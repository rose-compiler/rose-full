/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
// tps : need to include sage3basic.h -- took it out from the header file because precompiled headers cannot be included in header files
#include "sage3basic.h" // file_IO
#include "rosedefs.h"
#include "Cxx_GrammarMemoryPoolSupport.h"
#include <fstream>
#include "AST_FILE_IO.h"
#include "StorageClasses.h"
#include <sstream>
#include <string>

using namespace std;

AstData*
AST_FILE_IO :: actualRebuildAst;

std::vector<AstData*>
AST_FILE_IO :: vectorOfASTs;

unsigned long 
AST_FILE_IO :: listOfMemoryPoolSizes [ totalNumberOfIRNodes + 1] ;

bool 
AST_FILE_IO :: freepointersOfCurrentAstAreSetToGlobalIndices;

std::map<std::string, AST_FILE_IO::CONSTRUCTOR > 
AST_FILE_IO::registeredAttributes;


/* JH (10/25/2005): Static method that computes the memory pool sizes and stores them incrementally
   in listOfAccumulatedPoolSizes at position [ V_$CLASSNAME + 1 ]. Reason for this strange issue; no global
   index must be 0, since we want to store NULL pointers as 0 ( means, we will not manipulate them ).
   Therefore, we introduce 'listOfAccumulatedPoolSizes [ 0 ] =  1', in order to calculate the index of an
   node by computing the index in its memory pool and then adding the getAccumulated sizes of the previous
   memory pools, already stored in listOfAccumulatedPoolSizes [ V_$CLASSNAME ].
*/

#define DEBUG_AstFileIO_startUp 0

void 
AST_FILE_IO :: startUp( SgProject* root )
   {
#if DEBUG_AstFileIO_startUp
      std::cout << "AST_FILE_IO::startUp" << std::endl;
#endif
   /* Our array containing the total memory pool sizes starts at startingIndex. This is the first multiple of 100
      that is greater than the indices used internally. We sort the the memory pool size at
      position [ V_$CLASSNAME + 1 ]. Concurrently, we allocate the appropriate STORAGE_class_list arrays.
      If the corresponding memory pool is empty, we set the pointer to NULL!
  */
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::startUp():");
 
     assert ( vectorOfASTs.empty() == true );
     assert ( root != NULL );

#if FILE_IO_EXTRA_CHECK
     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::startUp() FILE_IO_EXTRA_CHECK:");

     if ( SgProject::get_verbose() > 0 )
          std::cout << "Starting check, that all IRNodes are in the memory pools ... " << std::flush;
#if FILE_IO_MEMORY_POOL_CHECK
  // AST_FileIO::MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     memoryCheckingTraversal.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << "  done ! " << std::endl;
     }
#endif

  // JH: the global index counting starts at index 1, because we want to store NULL pointers as 0!
     unsigned long globalIndexCounter = 1;

          listOfMemoryPoolSizes [ 0 ] =  globalIndexCounter;
     listOfMemoryPoolSizes [ 1 ] =  globalIndexCounter; 
     globalIndexCounter = SgAccessModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 2 ] =  globalIndexCounter; 
     globalIndexCounter = SgActualArgumentExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 3 ] =  globalIndexCounter; 
     globalIndexCounter = SgAbsOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 4 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaAccessType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 5 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaAcceptStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 6 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaDelayStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 7 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaEntryDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 8 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaExitStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 9 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaDiscreteType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 10 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaFloatVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 11 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaLoopStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 12 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaPackageBody::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 13 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaPackageBodyDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 14 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaPackageSpec::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 15 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaPackageSpecDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 16 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaPackageSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 17 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaRangeConstraint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 18 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaRenamingDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 19 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaSubtype::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 20 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTaskBody::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 21 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTaskBodyDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 22 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTaskSpec::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 23 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTaskSpecDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 24 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTaskSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 25 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTaskRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 26 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTaskType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 27 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTaskTypeDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 28 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTypeConstraint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 29 ] =  globalIndexCounter; 
     globalIndexCounter = SgAddOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 30 ] =  globalIndexCounter; 
     globalIndexCounter = SgAddressOfOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 31 ] =  globalIndexCounter; 
     globalIndexCounter = SgAggregateInitializer::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 32 ] =  globalIndexCounter; 
     globalIndexCounter = SgAliasSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 33 ] =  globalIndexCounter; 
     globalIndexCounter = SgAllocateStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 34 ] =  globalIndexCounter; 
     globalIndexCounter = SgAndAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 35 ] =  globalIndexCounter; 
     globalIndexCounter = SgAndOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 36 ] =  globalIndexCounter; 
     globalIndexCounter = SgArithmeticIfStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 37 ] =  globalIndexCounter; 
     globalIndexCounter = SgArrayType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 38 ] =  globalIndexCounter; 
     globalIndexCounter = SgArrowExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 39 ] =  globalIndexCounter; 
     globalIndexCounter = SgArrowStarOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 40 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 41 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 42 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 43 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 44 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 45 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 46 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBasicString::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 47 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryAdd::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 48 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 49 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 50 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryAsr::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 51 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryDivide::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 52 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 53 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryLsl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 54 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryLsr::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 55 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryMod::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 56 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryMsl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 57 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryMultiply::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 58 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryRor::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 59 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinarySubtract::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 60 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 61 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 62 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBlock::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 63 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCoffStrtab::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 64 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCoffSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 65 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCoffSymbolList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 66 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCoffSymbolTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 67 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCommonSubExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 68 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmControlFlagsExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 69 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmConstantExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 70 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDOSExtendedHeader::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 71 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDOSFileHeader::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 72 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmSynthesizedDataStructureDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 73 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmSynthesizedDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 74 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDirectRegisterExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 75 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfAccessDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 76 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfArrayType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 77 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfBaseType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 78 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCatchBlock::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 79 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfClassTemplate::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 80 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfClassType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 81 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCommonBlock::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 82 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCommonInclusion::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 83 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCompilationUnit::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 84 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCompilationUnitList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 85 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCondition::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 86 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfConstType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 87 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfConstant::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 88 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfConstruct::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 89 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfConstructList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 90 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfDwarfProcedure::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 91 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfEntryPoint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 92 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfEnumerationType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 93 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfEnumerator::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 94 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFileType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 95 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFormalParameter::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 96 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFormatLabel::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 97 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFriend::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 98 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFunctionTemplate::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 99 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfImportedDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 100 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfImportedModule::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 101 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfImportedUnit::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 102 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfInformation::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 103 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfInheritance::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 104 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfInlinedSubroutine::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 105 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfInterfaceType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 106 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfLabel::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 107 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfLexicalBlock::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 108 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfLine::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 109 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfLineList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 110 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfMacro::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 111 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfMacroList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 112 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfMember::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 113 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfModule::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 114 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfMutableType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 115 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfNamelist::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 116 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfNamelistItem::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 117 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfNamespace::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 118 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfPackedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 119 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfPartialUnit::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 120 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfPointerType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 121 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfPtrToMemberType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 122 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfReferenceType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 123 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfRestrictType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 124 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSetType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 125 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSharedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 126 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfStringType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 127 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfStructureType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 128 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSubprogram::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 129 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSubrangeType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 130 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSubroutineType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 131 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfTemplateTypeParameter::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 132 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfTemplateValueParameter::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 133 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfThrownType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 134 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfTryBlock::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 135 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfTypedef::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 136 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUnionType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 137 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUnknownConstruct::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 138 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUnspecifiedParameters::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 139 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUnspecifiedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 140 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUpcRelaxedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 141 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUpcSharedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 142 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUpcStrictType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 143 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfVariable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 144 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfVariant::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 145 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfVariantPart::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 146 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfVolatileType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 147 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfWithStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 148 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfDynamicEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 149 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfDynamicEntryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 150 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfDynamicSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 151 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameEntryCI::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 152 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameEntryCIList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 153 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameEntryFD::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 154 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameEntryFDList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 155 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 156 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfFileHeader::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 157 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfNoteEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 158 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfNoteEntryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 159 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfNoteSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 160 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfRelocEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 161 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfRelocEntryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 162 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfRelocSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 163 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 164 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSectionTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 165 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSectionTableEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 166 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSegmentTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 167 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSegmentTableEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 168 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSegmentTableEntryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 169 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfStringSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 170 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfStrtab::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 171 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 172 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymbolList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 173 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymbolSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 174 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedAux::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 175 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedAuxList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 176 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 177 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedEntryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 178 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 179 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 180 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverEntryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 181 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededAux::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 182 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededAuxList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 183 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 184 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededEntryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 185 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 186 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 187 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmExecutableFileFormat::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 188 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmExprListExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 189 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 190 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmSynthesizedFieldDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 191 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmFloatType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 192 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmFloatValueExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 193 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmFunction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 194 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericDLL::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 195 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericDLLList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 196 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericFile::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 197 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericFileList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 198 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericFormat::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 199 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericHeader::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 200 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericHeaderList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 201 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 202 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericSectionList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 203 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericString::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 204 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericStrtab::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 205 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 206 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericSymbolList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 207 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmIndirectRegisterExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 208 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmInstruction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 209 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmIntegerValueExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 210 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmIntegerType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 211 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmInterpretation::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 212 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmInterpretationList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 213 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmAttribute::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 214 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmCodeAttribute::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 215 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmMethod::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 216 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmConstantPool::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 217 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmConstantPoolEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 218 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmConstantValue::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 219 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmInstruction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 220 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmFileHeader::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 221 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmNode::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 222 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmSignature::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 223 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmSourceFile::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 224 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEEntryPoint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 225 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEEntryTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 226 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEFileHeader::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 227 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLENameTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 228 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEPageTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 229 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEPageTableEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 230 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLERelocTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 231 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLESection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 232 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLESectionTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 233 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLESectionTableEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 234 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmM68kInstruction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 235 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmMemoryReferenceExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 236 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmMipsInstruction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 237 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEEntryPoint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 238 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEEntryTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 239 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEFileHeader::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 240 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEModuleTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 241 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNENameTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 242 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNERelocEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 243 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNERelocTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 244 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNESection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 245 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNESectionTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 246 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNESectionTableEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 247 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEStringTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 248 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNode::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 249 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 250 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmOperandList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 251 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEExportDirectory::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 252 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEExportEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 253 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEExportEntryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 254 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEExportSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 255 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEFileHeader::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 256 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportDirectory::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 257 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportDirectoryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 258 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportItem::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 259 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportItemList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 260 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 261 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPERVASizePair::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 262 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPERVASizePairList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 263 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPESection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 264 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPESectionTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 265 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPESectionTableEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 266 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEStringSection::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 267 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPowerpcInstruction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 268 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmRegisterNames::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 269 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmRegisterReferenceExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 270 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmRiscOperation::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 271 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmScalarType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 272 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 273 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStaticData::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 274 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 275 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStoredString::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 276 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStringStorage::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 277 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 278 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 279 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryMinus::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 280 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryPlus::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 281 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryRrx::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 282 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnarySignedExtend::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 283 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryUnsignedExtend::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 284 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryTruncate::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 285 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmValueExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 286 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmVectorType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 287 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmX86Instruction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 288 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryAddressSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 289 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryDataSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 290 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssertStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 291 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssignInitializer::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 292 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 293 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssignStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 294 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssignedGotoStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 295 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssociateStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 296 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsteriskShapeExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 297 ] =  globalIndexCounter; 
     globalIndexCounter = SgAtOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 298 ] =  globalIndexCounter; 
     globalIndexCounter = SgAttribute::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 299 ] =  globalIndexCounter; 
     globalIndexCounter = SgAttributeSpecificationStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 300 ] =  globalIndexCounter; 
     globalIndexCounter = SgAutoType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 301 ] =  globalIndexCounter; 
     globalIndexCounter = SgAwaitExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 302 ] =  globalIndexCounter; 
     globalIndexCounter = SgBackspaceStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 303 ] =  globalIndexCounter; 
     globalIndexCounter = SgBaseClass::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 304 ] =  globalIndexCounter; 
     globalIndexCounter = SgExpBaseClass::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 305 ] =  globalIndexCounter; 
     globalIndexCounter = SgBaseClassModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 306 ] =  globalIndexCounter; 
     globalIndexCounter = SgBasicBlock::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 307 ] =  globalIndexCounter; 
     globalIndexCounter = SgBidirectionalGraph::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 308 ] =  globalIndexCounter; 
     globalIndexCounter = SgBinaryComposite::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 309 ] =  globalIndexCounter; 
     globalIndexCounter = SgBinaryOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 310 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitAndOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 311 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitAttribute::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 312 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitComplementOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 313 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitEqvOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 314 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitOrOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 315 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitXorOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 316 ] =  globalIndexCounter; 
     globalIndexCounter = SgBlockDataStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 317 ] =  globalIndexCounter; 
     globalIndexCounter = SgBoolValExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 318 ] =  globalIndexCounter; 
     globalIndexCounter = SgBreakStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 319 ] =  globalIndexCounter; 
     globalIndexCounter = SgBracedInitializer::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 320 ] =  globalIndexCounter; 
     globalIndexCounter = SgC_PreprocessorDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 321 ] =  globalIndexCounter; 
     globalIndexCounter = SgCaseOptionStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 322 ] =  globalIndexCounter; 
     globalIndexCounter = SgCastExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 323 ] =  globalIndexCounter; 
     globalIndexCounter = SgCatchOptionStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 324 ] =  globalIndexCounter; 
     globalIndexCounter = SgCatchStatementSeq::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 325 ] =  globalIndexCounter; 
     globalIndexCounter = SgCharVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 326 ] =  globalIndexCounter; 
     globalIndexCounter = SgChar16Val::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 327 ] =  globalIndexCounter; 
     globalIndexCounter = SgChar32Val::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 328 ] =  globalIndexCounter; 
     globalIndexCounter = SgChooseExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 329 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassDecl_attr::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 330 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 331 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassDefinition::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 332 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassNameRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 333 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 334 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 335 ] =  globalIndexCounter; 
     globalIndexCounter = SgClinkageDeclarationStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 336 ] =  globalIndexCounter; 
     globalIndexCounter = SgClinkageEndStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 337 ] =  globalIndexCounter; 
     globalIndexCounter = SgClinkageStartStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 338 ] =  globalIndexCounter; 
     globalIndexCounter = SgCloseStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 339 ] =  globalIndexCounter; 
     globalIndexCounter = SgColonShapeExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 340 ] =  globalIndexCounter; 
     globalIndexCounter = SgCommaOpExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 341 ] =  globalIndexCounter; 
     globalIndexCounter = SgCommonBlock::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 342 ] =  globalIndexCounter; 
     globalIndexCounter = SgCommonBlockObject::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 343 ] =  globalIndexCounter; 
     globalIndexCounter = SgCommonSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 344 ] =  globalIndexCounter; 
     globalIndexCounter = SgComplexVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 345 ] =  globalIndexCounter; 
     globalIndexCounter = SgComprehension::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 346 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 347 ] =  globalIndexCounter; 
     globalIndexCounter = SgCompoundAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 348 ] =  globalIndexCounter; 
     globalIndexCounter = SgCompoundInitializer::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 349 ] =  globalIndexCounter; 
     globalIndexCounter = SgCompoundLiteralExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 350 ] =  globalIndexCounter; 
     globalIndexCounter = SgComputedGotoStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 351 ] =  globalIndexCounter; 
     globalIndexCounter = SgConcatenationOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 352 ] =  globalIndexCounter; 
     globalIndexCounter = SgConditionalExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 353 ] =  globalIndexCounter; 
     globalIndexCounter = SgConjugateOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 354 ] =  globalIndexCounter; 
     globalIndexCounter = SgConstVolatileModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 355 ] =  globalIndexCounter; 
     globalIndexCounter = SgConstructorInitializer::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 356 ] =  globalIndexCounter; 
     globalIndexCounter = SgContainsStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 357 ] =  globalIndexCounter; 
     globalIndexCounter = SgContinueStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 358 ] =  globalIndexCounter; 
     globalIndexCounter = SgCtorInitializerList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 359 ] =  globalIndexCounter; 
     globalIndexCounter = SgDataStatementGroup::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 360 ] =  globalIndexCounter; 
     globalIndexCounter = SgDataStatementObject::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 361 ] =  globalIndexCounter; 
     globalIndexCounter = SgDataStatementValue::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 362 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeadIfDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 363 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeallocateStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 364 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeclarationModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 365 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeclarationScope::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 366 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeclarationStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 367 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeclType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 368 ] =  globalIndexCounter; 
     globalIndexCounter = SgDefaultOptionStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 369 ] =  globalIndexCounter; 
     globalIndexCounter = SgDefaultSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 370 ] =  globalIndexCounter; 
     globalIndexCounter = SgDefineDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 371 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeleteExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 372 ] =  globalIndexCounter; 
     globalIndexCounter = SgDerivedTypeStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 373 ] =  globalIndexCounter; 
     globalIndexCounter = SgDesignatedInitializer::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 374 ] =  globalIndexCounter; 
     globalIndexCounter = SgDictionaryComprehension::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 375 ] =  globalIndexCounter; 
     globalIndexCounter = SgDictionaryExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 376 ] =  globalIndexCounter; 
     globalIndexCounter = SgDimensionObject::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 377 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 378 ] =  globalIndexCounter; 
     globalIndexCounter = SgDirectedGraphEdge::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 379 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 380 ] =  globalIndexCounter; 
     globalIndexCounter = SgDirectory::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 381 ] =  globalIndexCounter; 
     globalIndexCounter = SgDirectoryList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 382 ] =  globalIndexCounter; 
     globalIndexCounter = SgDivAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 383 ] =  globalIndexCounter; 
     globalIndexCounter = SgDivideOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 384 ] =  globalIndexCounter; 
     globalIndexCounter = SgDoWhileStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 385 ] =  globalIndexCounter; 
     globalIndexCounter = SgDotExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 386 ] =  globalIndexCounter; 
     globalIndexCounter = SgDotStarOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 387 ] =  globalIndexCounter; 
     globalIndexCounter = SgDoubleVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 388 ] =  globalIndexCounter; 
     globalIndexCounter = SgElaboratedTypeModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 389 ] =  globalIndexCounter; 
     globalIndexCounter = SgElementwiseOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 390 ] =  globalIndexCounter; 
     globalIndexCounter = SgElementwiseAddOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 391 ] =  globalIndexCounter; 
     globalIndexCounter = SgElementwiseDivideOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 392 ] =  globalIndexCounter; 
     globalIndexCounter = SgElementwiseLeftDivideOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 393 ] =  globalIndexCounter; 
     globalIndexCounter = SgElementwiseMultiplyOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 394 ] =  globalIndexCounter; 
     globalIndexCounter = SgElementwisePowerOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 395 ] =  globalIndexCounter; 
     globalIndexCounter = SgElementwiseSubtractOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 396 ] =  globalIndexCounter; 
     globalIndexCounter = SgElseDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 397 ] =  globalIndexCounter; 
     globalIndexCounter = SgElseWhereStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 398 ] =  globalIndexCounter; 
     globalIndexCounter = SgElseifDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 399 ] =  globalIndexCounter; 
     globalIndexCounter = SgEmptyDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 400 ] =  globalIndexCounter; 
     globalIndexCounter = SgEmptyDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 401 ] =  globalIndexCounter; 
     globalIndexCounter = SgEndfileStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 402 ] =  globalIndexCounter; 
     globalIndexCounter = SgEndifDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 403 ] =  globalIndexCounter; 
     globalIndexCounter = SgEntryStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 404 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 405 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumFieldSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 406 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 407 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 408 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 409 ] =  globalIndexCounter; 
     globalIndexCounter = SgEqualityOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 410 ] =  globalIndexCounter; 
     globalIndexCounter = SgEquivalenceStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 411 ] =  globalIndexCounter; 
     globalIndexCounter = SgErrorDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 412 ] =  globalIndexCounter; 
     globalIndexCounter = SgExecStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 413 ] =  globalIndexCounter; 
     globalIndexCounter = SgExponentiationOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 414 ] =  globalIndexCounter; 
     globalIndexCounter = SgExponentiationAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 415 ] =  globalIndexCounter; 
     globalIndexCounter = SgExprListExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 416 ] =  globalIndexCounter; 
     globalIndexCounter = SgExprStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 417 ] =  globalIndexCounter; 
     globalIndexCounter = SgExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 418 ] =  globalIndexCounter; 
     globalIndexCounter = SgExpressionRoot::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 419 ] =  globalIndexCounter; 
     globalIndexCounter = SgFile::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 420 ] =  globalIndexCounter; 
     globalIndexCounter = SgFileList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 421 ] =  globalIndexCounter; 
     globalIndexCounter = SgFloatVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 422 ] =  globalIndexCounter; 
     globalIndexCounter = SgFloat128Val::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 423 ] =  globalIndexCounter; 
     globalIndexCounter = SgFloat80Val::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 424 ] =  globalIndexCounter; 
     globalIndexCounter = SgFoldExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 425 ] =  globalIndexCounter; 
     globalIndexCounter = SgFlushStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 426 ] =  globalIndexCounter; 
     globalIndexCounter = SgForAllStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 427 ] =  globalIndexCounter; 
     globalIndexCounter = SgForInitStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 428 ] =  globalIndexCounter; 
     globalIndexCounter = SgForStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 429 ] =  globalIndexCounter; 
     globalIndexCounter = SgFormatItem::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 430 ] =  globalIndexCounter; 
     globalIndexCounter = SgFormatItemList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 431 ] =  globalIndexCounter; 
     globalIndexCounter = SgFormatStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 432 ] =  globalIndexCounter; 
     globalIndexCounter = SgFortranDo::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 433 ] =  globalIndexCounter; 
     globalIndexCounter = SgFortranIncludeLine::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 434 ] =  globalIndexCounter; 
     globalIndexCounter = SgFortranNonblockedDo::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 435 ] =  globalIndexCounter; 
     globalIndexCounter = SgFuncDecl_attr::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 436 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionCallExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 437 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 438 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionDefinition::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 439 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionParameterScope::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 440 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 441 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionParameterList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 442 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionParameterRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 443 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionParameterTypeList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 444 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 445 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 446 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 447 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionTypeSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 448 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionTypeTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 449 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 450 ] =  globalIndexCounter; 
     globalIndexCounter = SgGlobal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 451 ] =  globalIndexCounter; 
     globalIndexCounter = SgGotoStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 452 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraph::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 453 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraphEdge::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 454 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraphEdgeList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 455 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraphNode::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 456 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraphNodeList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 457 ] =  globalIndexCounter; 
     globalIndexCounter = SgGreaterOrEqualOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 458 ] =  globalIndexCounter; 
     globalIndexCounter = SgGreaterThanOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 459 ] =  globalIndexCounter; 
     globalIndexCounter = SgIOItemExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 460 ] =  globalIndexCounter; 
     globalIndexCounter = SgIOStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 461 ] =  globalIndexCounter; 
     globalIndexCounter = SgIdentDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 462 ] =  globalIndexCounter; 
     globalIndexCounter = SgIfDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 463 ] =  globalIndexCounter; 
     globalIndexCounter = SgIfStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 464 ] =  globalIndexCounter; 
     globalIndexCounter = SgIfdefDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 465 ] =  globalIndexCounter; 
     globalIndexCounter = SgIfndefDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 466 ] =  globalIndexCounter; 
     globalIndexCounter = SgImageControlStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 467 ] =  globalIndexCounter; 
     globalIndexCounter = SgImagPartOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 468 ] =  globalIndexCounter; 
     globalIndexCounter = SgImplicitStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 469 ] =  globalIndexCounter; 
     globalIndexCounter = SgImpliedDo::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 470 ] =  globalIndexCounter; 
     globalIndexCounter = SgImportStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 471 ] =  globalIndexCounter; 
     globalIndexCounter = SgIncidenceDirectedGraph::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 472 ] =  globalIndexCounter; 
     globalIndexCounter = SgIncidenceUndirectedGraph::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 473 ] =  globalIndexCounter; 
     globalIndexCounter = SgIncludeDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 474 ] =  globalIndexCounter; 
     globalIndexCounter = SgIncludeFile::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 475 ] =  globalIndexCounter; 
     globalIndexCounter = SgIncludeNextDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 476 ] =  globalIndexCounter; 
     globalIndexCounter = SgInitializedName::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 477 ] =  globalIndexCounter; 
     globalIndexCounter = SgInitializer::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 478 ] =  globalIndexCounter; 
     globalIndexCounter = SgInquireStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 479 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntKeyedBidirectionalGraph::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 480 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 481 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntegerDivideOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 482 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntegerDivideAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 483 ] =  globalIndexCounter; 
     globalIndexCounter = SgInterfaceBody::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 484 ] =  globalIndexCounter; 
     globalIndexCounter = SgHeaderFileBody::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 485 ] =  globalIndexCounter; 
     globalIndexCounter = SgHeaderFileReport::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 486 ] =  globalIndexCounter; 
     globalIndexCounter = SgInterfaceStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 487 ] =  globalIndexCounter; 
     globalIndexCounter = SgInterfaceSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 488 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntrinsicSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 489 ] =  globalIndexCounter; 
     globalIndexCounter = SgIsOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 490 ] =  globalIndexCounter; 
     globalIndexCounter = SgIsNotOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 491 ] =  globalIndexCounter; 
     globalIndexCounter = SgIorAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 492 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialBitType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 493 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialBitVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 494 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialTableType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 495 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialCompoolStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 496 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialForThenStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 497 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialDefineDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 498 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 499 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialOverlayDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 500 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialPresetPositionExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 501 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialTablePresetExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 502 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialTableStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 503 ] =  globalIndexCounter; 
     globalIndexCounter = SgKeyDatumPair::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 504 ] =  globalIndexCounter; 
     globalIndexCounter = SgCudaKernelExecConfig::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 505 ] =  globalIndexCounter; 
     globalIndexCounter = SgCudaKernelCallExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 506 ] =  globalIndexCounter; 
     globalIndexCounter = SgLabelRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 507 ] =  globalIndexCounter; 
     globalIndexCounter = SgLabelStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 508 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaLabelStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 509 ] =  globalIndexCounter; 
     globalIndexCounter = SgLabelSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 510 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaLabelSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 511 ] =  globalIndexCounter; 
     globalIndexCounter = SgLambdaCapture::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 512 ] =  globalIndexCounter; 
     globalIndexCounter = SgLambdaCaptureList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 513 ] =  globalIndexCounter; 
     globalIndexCounter = SgLambdaExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 514 ] =  globalIndexCounter; 
     globalIndexCounter = SgLambdaRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 515 ] =  globalIndexCounter; 
     globalIndexCounter = SgLeftDivideOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 516 ] =  globalIndexCounter; 
     globalIndexCounter = SgLessOrEqualOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 517 ] =  globalIndexCounter; 
     globalIndexCounter = SgLessThanOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 518 ] =  globalIndexCounter; 
     globalIndexCounter = SgLineDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 519 ] =  globalIndexCounter; 
     globalIndexCounter = SgLinemarkerDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 520 ] =  globalIndexCounter; 
     globalIndexCounter = SgLinkageModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 521 ] =  globalIndexCounter; 
     globalIndexCounter = SgListComprehension::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 522 ] =  globalIndexCounter; 
     globalIndexCounter = SgListExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 523 ] =  globalIndexCounter; 
     globalIndexCounter = SgLocatedNode::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 524 ] =  globalIndexCounter; 
     globalIndexCounter = SgLocatedNodeSupport::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 525 ] =  globalIndexCounter; 
     globalIndexCounter = SgLongDoubleVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 526 ] =  globalIndexCounter; 
     globalIndexCounter = SgLongIntVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 527 ] =  globalIndexCounter; 
     globalIndexCounter = SgLongLongIntVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 528 ] =  globalIndexCounter; 
     globalIndexCounter = SgLshiftAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 529 ] =  globalIndexCounter; 
     globalIndexCounter = SgLshiftOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 530 ] =  globalIndexCounter; 
     globalIndexCounter = SgMagicColonExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 531 ] =  globalIndexCounter; 
     globalIndexCounter = SgMatrixExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 532 ] =  globalIndexCounter; 
     globalIndexCounter = SgMatrixTransposeOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 533 ] =  globalIndexCounter; 
     globalIndexCounter = SgMatlabForStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 534 ] =  globalIndexCounter; 
     globalIndexCounter = SgMemberFunctionDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 535 ] =  globalIndexCounter; 
     globalIndexCounter = SgMemberFunctionRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 536 ] =  globalIndexCounter; 
     globalIndexCounter = SgMemberFunctionSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 537 ] =  globalIndexCounter; 
     globalIndexCounter = SgMemberFunctionType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 538 ] =  globalIndexCounter; 
     globalIndexCounter = SgMembershipOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 539 ] =  globalIndexCounter; 
     globalIndexCounter = SgMicrosoftAttributeDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 540 ] =  globalIndexCounter; 
     globalIndexCounter = SgMinusAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 541 ] =  globalIndexCounter; 
     globalIndexCounter = SgMinusMinusOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 542 ] =  globalIndexCounter; 
     globalIndexCounter = SgMinusOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 543 ] =  globalIndexCounter; 
     globalIndexCounter = SgModAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 544 ] =  globalIndexCounter; 
     globalIndexCounter = SgModOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 545 ] =  globalIndexCounter; 
     globalIndexCounter = SgModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 546 ] =  globalIndexCounter; 
     globalIndexCounter = SgModifierNodes::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 547 ] =  globalIndexCounter; 
     globalIndexCounter = SgModifierType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 548 ] =  globalIndexCounter; 
     globalIndexCounter = SgModuleStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 549 ] =  globalIndexCounter; 
     globalIndexCounter = SgModuleSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 550 ] =  globalIndexCounter; 
     globalIndexCounter = SgMultAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 551 ] =  globalIndexCounter; 
     globalIndexCounter = SgMultiplyOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 552 ] =  globalIndexCounter; 
     globalIndexCounter = SgName::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 553 ] =  globalIndexCounter; 
     globalIndexCounter = SgNameGroup::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 554 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 555 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamelistStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 556 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamespaceAliasDeclarationStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 557 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamespaceDeclarationStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 558 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamespaceDefinitionStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 559 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamespaceSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 560 ] =  globalIndexCounter; 
     globalIndexCounter = SgNaryOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 561 ] =  globalIndexCounter; 
     globalIndexCounter = SgNaryBooleanOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 562 ] =  globalIndexCounter; 
     globalIndexCounter = SgNaryComparisonOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 563 ] =  globalIndexCounter; 
     globalIndexCounter = SgNewExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 564 ] =  globalIndexCounter; 
     globalIndexCounter = SgNode::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 565 ] =  globalIndexCounter; 
     globalIndexCounter = SgNoexceptOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 566 ] =  globalIndexCounter; 
     globalIndexCounter = SgNotEqualOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 567 ] =  globalIndexCounter; 
     globalIndexCounter = SgNotOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 568 ] =  globalIndexCounter; 
     globalIndexCounter = SgNonMembershipOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 569 ] =  globalIndexCounter; 
     globalIndexCounter = SgNonrealDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 570 ] =  globalIndexCounter; 
     globalIndexCounter = SgNonrealRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 571 ] =  globalIndexCounter; 
     globalIndexCounter = SgNonrealSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 572 ] =  globalIndexCounter; 
     globalIndexCounter = SgNonrealType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 573 ] =  globalIndexCounter; 
     globalIndexCounter = SgNonrealBaseClass::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 574 ] =  globalIndexCounter; 
     globalIndexCounter = SgNullExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 575 ] =  globalIndexCounter; 
     globalIndexCounter = SgNullptrValExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 576 ] =  globalIndexCounter; 
     globalIndexCounter = SgNullStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 577 ] =  globalIndexCounter; 
     globalIndexCounter = SgNullifyStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 578 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpAtomicStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 579 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpBarrierStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 580 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpCriticalStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 581 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpClauseBodyStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 582 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpBodyStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 583 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpDoStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 584 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpFlushStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 585 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpDeclareSimdStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 586 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpForStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 587 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpForSimdStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 588 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpMasterStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 589 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpOrderedStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 590 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpParallelStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 591 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSectionStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 592 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSectionsStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 593 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSingleStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 594 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpTaskStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 595 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpTaskwaitStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 596 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpThreadprivateStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 597 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpWorkshareStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 598 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpTargetStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 599 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpTargetDataStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 600 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSimdStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 601 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 602 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpBeginClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 603 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpCollapseClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 604 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpCopyinClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 605 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpCopyprivateClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 606 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpDefaultClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 607 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpEndClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 608 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpExpressionClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 609 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpFirstprivateClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 610 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpIfClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 611 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpFinalClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 612 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpPriorityClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 613 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpDeviceClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 614 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpLastprivateClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 615 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpNowaitClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 616 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpNumThreadsClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 617 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpOrderedClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 618 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpPrivateClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 619 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpReductionClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 620 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpScheduleClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 621 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSharedClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 622 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpUntiedClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 623 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpMergeableClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 624 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpVariablesClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 625 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpMapClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 626 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSafelenClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 627 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSimdlenClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 628 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpLinearClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 629 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpUniformClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 630 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpAlignedClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 631 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpProcBindClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 632 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpAtomicClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 633 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpInbranchClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 634 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpNotinbranchClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 635 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpDependClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 636 ] =  globalIndexCounter; 
     globalIndexCounter = SgOpenclAccessModeModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 637 ] =  globalIndexCounter; 
     globalIndexCounter = SgOpenStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 638 ] =  globalIndexCounter; 
     globalIndexCounter = SgOptions::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 639 ] =  globalIndexCounter; 
     globalIndexCounter = SgOrOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 640 ] =  globalIndexCounter; 
     globalIndexCounter = SgParameterStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 641 ] =  globalIndexCounter; 
     globalIndexCounter = SgPartialFunctionModifierType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 642 ] =  globalIndexCounter; 
     globalIndexCounter = SgPartialFunctionType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 643 ] =  globalIndexCounter; 
     globalIndexCounter = SgPassStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 644 ] =  globalIndexCounter; 
     globalIndexCounter = SgPlusAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 645 ] =  globalIndexCounter; 
     globalIndexCounter = SgPlusPlusOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 646 ] =  globalIndexCounter; 
     globalIndexCounter = SgPntrArrRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 647 ] =  globalIndexCounter; 
     globalIndexCounter = SgPointerAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 648 ] =  globalIndexCounter; 
     globalIndexCounter = SgPointerDerefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 649 ] =  globalIndexCounter; 
     globalIndexCounter = SgPointerMemberType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 650 ] =  globalIndexCounter; 
     globalIndexCounter = SgPointerType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 651 ] =  globalIndexCounter; 
     globalIndexCounter = SgPowerOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 652 ] =  globalIndexCounter; 
     globalIndexCounter = SgPragma::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 653 ] =  globalIndexCounter; 
     globalIndexCounter = SgPragmaDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 654 ] =  globalIndexCounter; 
     globalIndexCounter = SgPrintStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 655 ] =  globalIndexCounter; 
     globalIndexCounter = SgProcedureHeaderStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 656 ] =  globalIndexCounter; 
     globalIndexCounter = SgProgramHeaderStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 657 ] =  globalIndexCounter; 
     globalIndexCounter = SgProject::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 658 ] =  globalIndexCounter; 
     globalIndexCounter = SgPseudoDestructorRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 659 ] =  globalIndexCounter; 
     globalIndexCounter = SgPythonGlobalStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 660 ] =  globalIndexCounter; 
     globalIndexCounter = SgPythonPrintStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 661 ] =  globalIndexCounter; 
     globalIndexCounter = SgQualifiedName::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 662 ] =  globalIndexCounter; 
     globalIndexCounter = SgQualifiedNameType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 663 ] =  globalIndexCounter; 
     globalIndexCounter = SgRangeExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 664 ] =  globalIndexCounter; 
     globalIndexCounter = SgRangeBasedForStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 665 ] =  globalIndexCounter; 
     globalIndexCounter = SgReadStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 666 ] =  globalIndexCounter; 
     globalIndexCounter = SgRealPartOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 667 ] =  globalIndexCounter; 
     globalIndexCounter = SgRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 668 ] =  globalIndexCounter; 
     globalIndexCounter = SgReferenceType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 669 ] =  globalIndexCounter; 
     globalIndexCounter = SgRemOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 670 ] =  globalIndexCounter; 
     globalIndexCounter = SgRenamePair::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 671 ] =  globalIndexCounter; 
     globalIndexCounter = SgRenameSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 672 ] =  globalIndexCounter; 
     globalIndexCounter = SgReplicationOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 673 ] =  globalIndexCounter; 
     globalIndexCounter = SgReturnStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 674 ] =  globalIndexCounter; 
     globalIndexCounter = SgRewindStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 675 ] =  globalIndexCounter; 
     globalIndexCounter = SgRshiftAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 676 ] =  globalIndexCounter; 
     globalIndexCounter = SgRshiftOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 677 ] =  globalIndexCounter; 
     globalIndexCounter = SgRvalueReferenceType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 678 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaUnsignedRshiftAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 679 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaUnsignedRshiftOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 680 ] =  globalIndexCounter; 
     globalIndexCounter = SgScopeOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 681 ] =  globalIndexCounter; 
     globalIndexCounter = SgScopeStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 682 ] =  globalIndexCounter; 
     globalIndexCounter = SgSequenceStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 683 ] =  globalIndexCounter; 
     globalIndexCounter = SgSetComprehension::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 684 ] =  globalIndexCounter; 
     globalIndexCounter = SgShortVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 685 ] =  globalIndexCounter; 
     globalIndexCounter = SgSizeOfOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 686 ] =  globalIndexCounter; 
     globalIndexCounter = SgAlignOfOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 687 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaInstanceOfOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 688 ] =  globalIndexCounter; 
     globalIndexCounter = SgSourceFile::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 689 ] =  globalIndexCounter; 
     globalIndexCounter = SgSpaceshipOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 690 ] =  globalIndexCounter; 
     globalIndexCounter = SgSpawnStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 691 ] =  globalIndexCounter; 
     globalIndexCounter = SgSyncAllStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 692 ] =  globalIndexCounter; 
     globalIndexCounter = SgSyncImagesStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 693 ] =  globalIndexCounter; 
     globalIndexCounter = SgSyncMemoryStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 694 ] =  globalIndexCounter; 
     globalIndexCounter = SgSyncTeamStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 695 ] =  globalIndexCounter; 
     globalIndexCounter = SgLockStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 696 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnlockStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 697 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaThrowStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 698 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaForEachStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 699 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaSynchronizedStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 700 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaParameterizedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 701 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaWildcardType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 702 ] =  globalIndexCounter; 
     globalIndexCounter = SgProcessControlStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 703 ] =  globalIndexCounter; 
     globalIndexCounter = SgSpecialFunctionModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 704 ] =  globalIndexCounter; 
     globalIndexCounter = SgStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 705 ] =  globalIndexCounter; 
     globalIndexCounter = SgStaticAssertionDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 706 ] =  globalIndexCounter; 
     globalIndexCounter = SgStmtDeclarationStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 707 ] =  globalIndexCounter; 
     globalIndexCounter = SgStatementExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 708 ] =  globalIndexCounter; 
     globalIndexCounter = SgStatementFunctionStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 709 ] =  globalIndexCounter; 
     globalIndexCounter = SgStorageModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 710 ] =  globalIndexCounter; 
     globalIndexCounter = SgStringConversion::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 711 ] =  globalIndexCounter; 
     globalIndexCounter = SgStringKeyedBidirectionalGraph::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 712 ] =  globalIndexCounter; 
     globalIndexCounter = SgStringVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 713 ] =  globalIndexCounter; 
     globalIndexCounter = SgStructureModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 714 ] =  globalIndexCounter; 
     globalIndexCounter = SgSubscriptExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 715 ] =  globalIndexCounter; 
     globalIndexCounter = SgSubtractOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 716 ] =  globalIndexCounter; 
     globalIndexCounter = SgSupport::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 717 ] =  globalIndexCounter; 
     globalIndexCounter = SgSwitchStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 718 ] =  globalIndexCounter; 
     globalIndexCounter = SgSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 719 ] =  globalIndexCounter; 
     globalIndexCounter = SgSymbolTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 720 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateArgument::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 721 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateArgumentList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 722 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 723 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateClassDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 724 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateClassSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 725 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateFunctionDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 726 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateFunctionRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 727 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateFunctionSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 728 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateMemberFunctionDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 729 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateMemberFunctionRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 730 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateMemberFunctionSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 731 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateTypedefDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 732 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateTypedefSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 733 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateVariableDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 734 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateVariableSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 735 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateClassDefinition::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 736 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateFunctionDefinition::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 737 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 738 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationDefn::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 739 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 740 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationFunctionDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 741 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationMemberFunctionDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 742 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationTypedefDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 743 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateParameter::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 744 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateParameterVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 745 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateParameterList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 746 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 747 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 748 ] =  globalIndexCounter; 
     globalIndexCounter = SgThisExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 749 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeTraitBuiltinOperator::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 750 ] =  globalIndexCounter; 
     globalIndexCounter = SgSuperExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 751 ] =  globalIndexCounter; 
     globalIndexCounter = SgThrowOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 752 ] =  globalIndexCounter; 
     globalIndexCounter = SgToken::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 753 ] =  globalIndexCounter; 
     globalIndexCounter = SgTryStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 754 ] =  globalIndexCounter; 
     globalIndexCounter = SgTupleExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 755 ] =  globalIndexCounter; 
     globalIndexCounter = SgType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 756 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeBool::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 757 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeChar::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 758 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeChar16::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 759 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeChar32::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 760 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeComplex::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 761 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeDefault::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 762 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 763 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeLabel::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 764 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeDouble::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 765 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeEllipse::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 766 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeFixed::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 767 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeFloat::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 768 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeFloat128::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 769 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeFloat80::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 770 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeGlobalVoid::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 771 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeIdOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 772 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeImaginary::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 773 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeInt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 774 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeLong::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 775 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeLongDouble::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 776 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeLongLong::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 777 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 778 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeMatrix::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 779 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeTuple::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 780 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeNullptr::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 781 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeOfType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 782 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeShort::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 783 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSigned128bitInteger::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 784 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedChar::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 785 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedInt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 786 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedLong::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 787 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedLongLong::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 788 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedShort::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 789 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeString::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 790 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnknown::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 791 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsigned128bitInteger::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 792 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedChar::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 793 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedInt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 794 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedLong::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 795 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedLongLong::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 796 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedShort::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 797 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeVoid::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 798 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeWchar::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 799 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypedefDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 800 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypedefSeq::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 801 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypedefSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 802 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypedefType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 803 ] =  globalIndexCounter; 
     globalIndexCounter = SgUPC_AccessModifier::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 804 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnaryAddOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 805 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnaryOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 806 ] =  globalIndexCounter; 
     globalIndexCounter = SgUndefDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 807 ] =  globalIndexCounter; 
     globalIndexCounter = SgUndirectedGraphEdge::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 808 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnknownArrayOrFunctionReference::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 809 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnknownFile::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 810 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 811 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnparse_Info::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 812 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedCharVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 813 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedIntVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 814 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedLongLongIntVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 815 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedLongVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 816 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedShortVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 817 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcBarrierStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 818 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcBlocksizeofExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 819 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcElemsizeofExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 820 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcFenceStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 821 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcForAllStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 822 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcLocalsizeofExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 823 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcMythread::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 824 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcNotifyStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 825 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcThreads::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 826 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcWaitStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 827 ] =  globalIndexCounter; 
     globalIndexCounter = SgUseStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 828 ] =  globalIndexCounter; 
     globalIndexCounter = SgUserDefinedBinaryOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 829 ] =  globalIndexCounter; 
     globalIndexCounter = SgUserDefinedUnaryOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 830 ] =  globalIndexCounter; 
     globalIndexCounter = SgUsingDeclarationStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 831 ] =  globalIndexCounter; 
     globalIndexCounter = SgUsingDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 832 ] =  globalIndexCounter; 
     globalIndexCounter = SgValueExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 833 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgCopyOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 834 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgEndOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 835 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 836 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgStartOneOperandOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 837 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgStartOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 838 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 839 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariableDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 840 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariableDefinition::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 841 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariableSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 842 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariantExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 843 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariantStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 844 ] =  globalIndexCounter; 
     globalIndexCounter = SgVoidVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 845 ] =  globalIndexCounter; 
     globalIndexCounter = SgWaitStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 846 ] =  globalIndexCounter; 
     globalIndexCounter = SgWarningDirectiveStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 847 ] =  globalIndexCounter; 
     globalIndexCounter = SgWithStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 848 ] =  globalIndexCounter; 
     globalIndexCounter = SgWcharVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 849 ] =  globalIndexCounter; 
     globalIndexCounter = SgWhereStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 850 ] =  globalIndexCounter; 
     globalIndexCounter = SgWhileStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 851 ] =  globalIndexCounter; 
     globalIndexCounter = SgWriteStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 852 ] =  globalIndexCounter; 
     globalIndexCounter = SgXorAssignOp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 853 ] =  globalIndexCounter; 
     globalIndexCounter = SgYieldExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 854 ] =  globalIndexCounter; 
     globalIndexCounter = Sg_File_Info::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 855 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeCAFTeam::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 856 ] =  globalIndexCounter; 
     globalIndexCounter = SgCAFWithTeamStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 857 ] =  globalIndexCounter; 
     globalIndexCounter = SgCAFCoExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 858 ] =  globalIndexCounter; 
     globalIndexCounter = SgCallExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 859 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeCrayPointer::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 860 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaImportStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 861 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaPackageDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 862 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaPackageStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 863 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaImportStatementList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 864 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaClassDeclarationList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 865 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaMemberValuePair::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 866 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaAnnotation::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 867 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaMarkerAnnotation::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 868 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaSingleMemberAnnotation::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 869 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaNormalAnnotation::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 870 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaTypeExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 871 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaQualifiedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 872 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 873 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaUnionType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 874 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaParameterType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 875 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsyncStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 876 ] =  globalIndexCounter; 
     globalIndexCounter = SgFinishStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 877 ] =  globalIndexCounter; 
     globalIndexCounter = SgAtStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 878 ] =  globalIndexCounter; 
     globalIndexCounter = SgAtomicStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 879 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 880 ] =  globalIndexCounter; 
     globalIndexCounter = SgWhenStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 881 ] =  globalIndexCounter; 
     globalIndexCounter = SgAtExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 882 ] =  globalIndexCounter; 
     globalIndexCounter = SgFinishExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 883 ] =  globalIndexCounter; 
     globalIndexCounter = SgHereExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 884 ] =  globalIndexCounter; 
     globalIndexCounter = SgDotDotExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 885 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNullInstruction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 886 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaComponentClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 887 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaIndexConstraint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 888 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaModularType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 889 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaRepresentationClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 890 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaFunctionRenamingDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 891 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaSelectStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 892 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaSelectAlternativeStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 893 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaTerminateStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 894 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 895 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmAarch32Coprocessor::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 896 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaAttributeClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 897 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryConcat::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 898 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmByteOrder::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 899 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaDerivedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 900 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaAttributeExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 901 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaEnumRepresentationClause::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 902 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryPreupdate::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 903 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryPostupdate::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 904 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaOthersExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 905 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaRenamingSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 906 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaRenamingRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 907 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaGenericDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 908 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaGenericDefn::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 909 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaFormalType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 910 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaGenericSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 911 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaFormalTypeDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 912 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaUnitRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 913 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaDiscriminatedTypeDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 914 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaDiscriminatedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 915 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaDiscriminantConstraint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 916 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaGenericInstanceDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 917 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaUnscopedBlock::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 918 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaInheritedFunctionSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 919 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaProtectedBody::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 920 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaProtectedBodyDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 921 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaProtectedSpec::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 922 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaProtectedSpecDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 923 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaProtectedSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 924 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaProtectedRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 925 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaProtectedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 926 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaProtectedTypeDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 927 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaDigitsConstraint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 928 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaAncestorInitializer::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 929 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaDeltaConstraint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 930 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaSubroutineType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 931 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaGenericInstanceSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 932 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaFormalPackageDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 933 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaFormalPackageSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 934 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmAttributeTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 935 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmMethodTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 936 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmField::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 937 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmFieldTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 938 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmExceptionHandler::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 939 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmExceptionTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 940 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmClass::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 941 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmLineNumberEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 942 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmLineNumberTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 943 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmInnerClassesEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 944 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmInnerClasses::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 945 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilInstruction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 946 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStackExpression::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 947 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmEnclosingMethod::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 948 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaNullConstraint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 949 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmModuleMainClass::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 950 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmInstructionList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 951 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilNode::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 952 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssembly::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 953 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyOS::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 954 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyProcessor::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 955 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyRef::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 956 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyRefOS::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 957 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyRefProcessor::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 958 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilClassLayout::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 959 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilConstant::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 960 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilCustomAttribute::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 961 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilDeclSecurity::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 962 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilEvent::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 963 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilEventMap::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 964 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilExportedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 965 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilField::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 966 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilFieldLayout::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 967 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilFieldMarshal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 968 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilFieldRVA::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 969 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilFile::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 970 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilGenericParam::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 971 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilGenericParamConstraint::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 972 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilImplMap::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 973 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilInterfaceImpl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 974 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilManifestResource::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 975 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMemberRef::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 976 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMethodDef::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 977 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMethodImpl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 978 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMethodSemantics::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 979 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMethodSpec::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 980 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilModule::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 981 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilModuleRef::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 982 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilNestedClass::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 983 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilParam::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 984 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilProperty::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 985 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilPropertyMap::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 986 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilStandAloneSig::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 987 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilTypeDef::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 988 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilTypeRef::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 989 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilTypeSpec::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 990 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaParameterList::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 991 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMetadata::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 992 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMetadataRoot::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 993 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilDataStream::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 994 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMetadataHeap::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 995 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilUint8Heap::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 996 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilUint32Heap::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 997 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCliHeader::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 998 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaVariantDecl::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 999 ] =  globalIndexCounter; 
     globalIndexCounter = SgAdaVariantWhenStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1000 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1001 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyOSTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1002 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyProcessorTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1003 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyRefTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1004 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyRefOSTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1005 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilAssemblyRefProcessorTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1006 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilClassLayoutTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1007 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilConstantTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1008 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilCustomAttributeTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1009 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilDeclSecurityTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1010 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilEventTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1011 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilEventMapTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1012 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilExportedTypeTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1013 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilFieldTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1014 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilFieldLayoutTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1015 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilFieldMarshalTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1016 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilFieldRVATable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1017 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilFileTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1018 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilGenericParamTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1019 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilGenericParamConstraintTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1020 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilImplMapTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1021 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilInterfaceImplTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1022 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilManifestResourceTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1023 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMemberRefTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1024 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMethodDefTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1025 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMethodImplTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1026 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMethodSemanticsTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1027 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMethodSpecTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1028 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilModuleTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1029 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilModuleRefTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1030 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilNestedClassTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1031 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilParamTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1032 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilPropertyTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1033 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilPropertyMapTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1034 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilStandAloneSigTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1035 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilTypeDefTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1036 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilTypeRefTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1037 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilTypeSpecTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1038 ] =  globalIndexCounter; 
     globalIndexCounter = SgJvmComposite::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1039 ] =  globalIndexCounter; 
     globalIndexCounter = SgFortranContinueStmt::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1040 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmStackMapTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1041 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmStackMapFrame::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1042 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmStackMapVerificationType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1043 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmBootstrapMethod::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1044 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmBootstrapMethods::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1045 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmExceptions::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1046 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmNestMembers::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1047 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmNestHost::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1048 ] =  globalIndexCounter; 
     globalIndexCounter = SgJovialLabelDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1049 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmLocalVariableEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1050 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmLocalVariableTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1051 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmLocalVariableTypeEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1052 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmLocalVariableTypeTable::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1053 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUserInstruction::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1054 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmMethodParameters::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1055 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmMethodParametersEntry::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1056 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmVoidType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1057 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPointerType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1058 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 1059 ] =  globalIndexCounter; 
     globalIndexCounter = SgRangeType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1060 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilExceptionData::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1061 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilMethodData::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1062 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateVariableInstantiation::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1063 ] =  globalIndexCounter; 
     globalIndexCounter = SgReferenceExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1064 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1065 ] =  globalIndexCounter; 
     globalIndexCounter = SgScopedRefExp::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1066 ] =  globalIndexCounter; 
     globalIndexCounter = SgScopedType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1067 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1068 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmSynthetic::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1069 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmJvmDeprecated::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1070 ] =  globalIndexCounter; 
     globalIndexCounter = SgSignedCharVal::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1071 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCilErrorHeap::getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 1072 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 1073 ] =  globalIndexCounter; 

/* #line 78 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

#if DEBUG_AstFileIO_startUp
      std::cout << "listOfMemoryPoolSizes [935] = " << std::dec << listOfMemoryPoolSizes [935] << std::endl;
#endif

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::startUp() Build contiguious storage:");

     actualRebuildAst = new AstData(root);
     vectorOfASTs.push_back( actualRebuildAst );

     actualRebuildAst->listOfAccumulatedPoolSizes[0] = listOfMemoryPoolSizes[0];
     for (int i = 0; i < totalNumberOfIRNodes ; ++i )
        {
          actualRebuildAst->listOfAccumulatedPoolSizes[i+1] = listOfMemoryPoolSizes[i+1];
          listOfMemoryPoolSizes[i] = actualRebuildAst->listOfAccumulatedPoolSizes[i+1] - actualRebuildAst->listOfAccumulatedPoolSizes[i];
        }
     
     freepointersOfCurrentAstAreSetToGlobalIndices = true;
    
     REGISTER_ATTRIBUTE_FOR_FILE_IO(AstAttribute) ;
     }

   }


unsigned long
AST_FILE_IO :: getSizeOfMemoryPool( const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      return listOfMemoryPoolSizes [ position ];
   }


unsigned long
AST_FILE_IO :: getSizeOfMemoryPoolUpToAst( AstData *astInPool, const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      unsigned long memoryPoolSize = 0;
      for (int i=0;i < astInPool->get_AstIndex(); ++i)
          {
            memoryPoolSize += vectorOfASTs[i]->getMemoryPoolSize(position);
          }
      return memoryPoolSize;
   }

unsigned long
AST_FILE_IO :: getAccumulatedPoolSizeOfNewAst( const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      return actualRebuildAst->getNumberOfAccumulatedNodes ( position ) ;
   }


unsigned long
AST_FILE_IO :: getAccumulatedPoolSizeOfAst( AstData *astInPool, const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      return astInPool->getNumberOfAccumulatedNodes ( position ) ;
   }


unsigned long
AST_FILE_IO :: getPoolSizeOfNewAst( const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      return actualRebuildAst->getMemoryPoolSize ( position ) ;
   }


unsigned long 
AST_FILE_IO :: getTotalNumberOfNodesOfAstInMemoryPool ( )
   {
   // JH (01/03/2006): returning the sum of all pool sizes; this is used for checking only ...
      return listOfMemoryPoolSizes [ totalNumberOfIRNodes ] ; 
   }


unsigned long 
AST_FILE_IO :: getTotalNumberOfNodesOfNewAst ( )
   {
   // JH (01/03/2006): returning the sum of all pool sizes; this is used for checking only ...
      assert (actualRebuildAst != NULL);
      return actualRebuildAst->getTotalNumberOfASTIRNodes();
   }



unsigned long 
AST_FILE_IO :: linearSearch( unsigned long globalIndex ) 
   {
   /* JH (01/03/2006): linearSearch. This easy implementation just looks at the first index, where the
      getAccumulated pool sizes exceed index.
   */
#if FILE_IO_EXTRA_CHECK 
      // assert ( 0 <= globalIndex ) ;
      assert ( globalIndex < actualRebuildAst->getTotalNumberOfASTIRNodes() ) ;
#endif
      unsigned int actualIRNodeType = 1;
      while ( actualIRNodeType  < actualRebuildAst->getTotalNumberOfASTIRNodes() )
         {
           if ( actualRebuildAst->getNumberOfAccumulatedNodes (actualIRNodeType) <= globalIndex && globalIndex < actualRebuildAst->getNumberOfAccumulatedNodes (actualIRNodeType + 1 ) ) 
              { 
                break ; 
              }
         } 
#if FILE_IO_EXTRA_CHECK
      assert ( 0 < actualIRNodeType ) ;
      assert ( actualIRNodeType < actualRebuildAst->getTotalNumberOfASTIRNodes() ) ;
#endif
      return actualIRNodeType;
   }

                                                                                                                                                                                                                          
                                                                                                                                                                                                                          
unsigned long 
AST_FILE_IO :: binarySearch( unsigned long globalIndex, int start , int end )
   {
   /* JH (01/03/2006): binarySearch: find the SgVariant that corresponds to the index contained in
      the pointer. Therefore, we use the accumulatedPoolSizesOfNewAst and check the ranges
   */
      if ( end - start <= 1 )
         {
           if ( actualRebuildAst->getNumberOfAccumulatedNodes (start) <= globalIndex && globalIndex < actualRebuildAst->getNumberOfAccumulatedNodes (end) ) 
              {
                return start; 
              }
           else
              {
                return end;
              }
         }
      int middle = ( end + start ) / 2 ;
      if (  actualRebuildAst->getNumberOfAccumulatedNodes (middle ) <= globalIndex )
         {
           return binarySearch ( globalIndex , middle , end ) ;
         }
      else
         {
           return binarySearch ( globalIndex, start , middle ) ;
         }
   }

void
AST_FILE_IO :: compressAstInMemoryPool ( ) 
   {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::compressAstInMemoryPool():");
 
     assert ( freepointersOfCurrentAstAreSetToGlobalIndices == true );
     assert ( 0 < getTotalNumberOfNodesOfAstInMemoryPool() );
   /* JH (01/03/2006): prepareMemoryPoolWise: method that traverses the storage pools.
      1. For each IRNodesStorageClass the pickOutIRNodeData is called
      2. The static data of the EasyStorage classes is arranged, in order that all static data (of a type) is
         contained in one memory block
      3. For each IRNodesStorageClass the rebuildIRNode is called
      4. The static data of the EasyStorage classes is deleted
   */

      unsigned long sizeOfActualPool = 0 ; 

     AstSpecificDataManagingClassStorageClass staticTemp; 
     staticTemp.pickOutIRNodeData(actualRebuildAst); 
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAccessModifier ) ; 
     std::cout << " SgAccessModifier has size " << sizeOfActualPool << std::endl;
     SgAccessModifierStorageClass* SgAccessModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAccessModifierStorageArray = new SgAccessModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAccessModifier::initializeStorageClassArray (SgAccessModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgActualArgumentExpression ) ; 
     std::cout << " SgActualArgumentExpression has size " << sizeOfActualPool << std::endl;
     SgActualArgumentExpressionStorageClass* SgActualArgumentExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgActualArgumentExpressionStorageArray = new SgActualArgumentExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgActualArgumentExpression::initializeStorageClassArray (SgActualArgumentExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAbsOp ) ; 
     std::cout << " SgAbsOp has size " << sizeOfActualPool << std::endl;
     SgAbsOpStorageClass* SgAbsOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAbsOpStorageArray = new SgAbsOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAbsOp::initializeStorageClassArray (SgAbsOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaAccessType ) ; 
     std::cout << " SgAdaAccessType has size " << sizeOfActualPool << std::endl;
     SgAdaAccessTypeStorageClass* SgAdaAccessTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAccessTypeStorageArray = new SgAdaAccessTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaAccessType::initializeStorageClassArray (SgAdaAccessTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaAcceptStmt ) ; 
     std::cout << " SgAdaAcceptStmt has size " << sizeOfActualPool << std::endl;
     SgAdaAcceptStmtStorageClass* SgAdaAcceptStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAcceptStmtStorageArray = new SgAdaAcceptStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaAcceptStmt::initializeStorageClassArray (SgAdaAcceptStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaDelayStmt ) ; 
     std::cout << " SgAdaDelayStmt has size " << sizeOfActualPool << std::endl;
     SgAdaDelayStmtStorageClass* SgAdaDelayStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDelayStmtStorageArray = new SgAdaDelayStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaDelayStmt::initializeStorageClassArray (SgAdaDelayStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaEntryDecl ) ; 
     std::cout << " SgAdaEntryDecl has size " << sizeOfActualPool << std::endl;
     SgAdaEntryDeclStorageClass* SgAdaEntryDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaEntryDeclStorageArray = new SgAdaEntryDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaEntryDecl::initializeStorageClassArray (SgAdaEntryDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaExitStmt ) ; 
     std::cout << " SgAdaExitStmt has size " << sizeOfActualPool << std::endl;
     SgAdaExitStmtStorageClass* SgAdaExitStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaExitStmtStorageArray = new SgAdaExitStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaExitStmt::initializeStorageClassArray (SgAdaExitStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaDiscreteType ) ; 
     std::cout << " SgAdaDiscreteType has size " << sizeOfActualPool << std::endl;
     SgAdaDiscreteTypeStorageClass* SgAdaDiscreteTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDiscreteTypeStorageArray = new SgAdaDiscreteTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaDiscreteType::initializeStorageClassArray (SgAdaDiscreteTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaFloatVal ) ; 
     std::cout << " SgAdaFloatVal has size " << sizeOfActualPool << std::endl;
     SgAdaFloatValStorageClass* SgAdaFloatValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFloatValStorageArray = new SgAdaFloatValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaFloatVal::initializeStorageClassArray (SgAdaFloatValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaLoopStmt ) ; 
     std::cout << " SgAdaLoopStmt has size " << sizeOfActualPool << std::endl;
     SgAdaLoopStmtStorageClass* SgAdaLoopStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaLoopStmtStorageArray = new SgAdaLoopStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaLoopStmt::initializeStorageClassArray (SgAdaLoopStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaPackageBody ) ; 
     std::cout << " SgAdaPackageBody has size " << sizeOfActualPool << std::endl;
     SgAdaPackageBodyStorageClass* SgAdaPackageBodyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageBodyStorageArray = new SgAdaPackageBodyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaPackageBody::initializeStorageClassArray (SgAdaPackageBodyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaPackageBodyDecl ) ; 
     std::cout << " SgAdaPackageBodyDecl has size " << sizeOfActualPool << std::endl;
     SgAdaPackageBodyDeclStorageClass* SgAdaPackageBodyDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageBodyDeclStorageArray = new SgAdaPackageBodyDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaPackageBodyDecl::initializeStorageClassArray (SgAdaPackageBodyDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaPackageSpec ) ; 
     std::cout << " SgAdaPackageSpec has size " << sizeOfActualPool << std::endl;
     SgAdaPackageSpecStorageClass* SgAdaPackageSpecStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageSpecStorageArray = new SgAdaPackageSpecStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaPackageSpec::initializeStorageClassArray (SgAdaPackageSpecStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaPackageSpecDecl ) ; 
     std::cout << " SgAdaPackageSpecDecl has size " << sizeOfActualPool << std::endl;
     SgAdaPackageSpecDeclStorageClass* SgAdaPackageSpecDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageSpecDeclStorageArray = new SgAdaPackageSpecDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaPackageSpecDecl::initializeStorageClassArray (SgAdaPackageSpecDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaPackageSymbol ) ; 
     std::cout << " SgAdaPackageSymbol has size " << sizeOfActualPool << std::endl;
     SgAdaPackageSymbolStorageClass* SgAdaPackageSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageSymbolStorageArray = new SgAdaPackageSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaPackageSymbol::initializeStorageClassArray (SgAdaPackageSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaRangeConstraint ) ; 
     std::cout << " SgAdaRangeConstraint has size " << sizeOfActualPool << std::endl;
     SgAdaRangeConstraintStorageClass* SgAdaRangeConstraintStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRangeConstraintStorageArray = new SgAdaRangeConstraintStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaRangeConstraint::initializeStorageClassArray (SgAdaRangeConstraintStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaRenamingDecl ) ; 
     std::cout << " SgAdaRenamingDecl has size " << sizeOfActualPool << std::endl;
     SgAdaRenamingDeclStorageClass* SgAdaRenamingDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRenamingDeclStorageArray = new SgAdaRenamingDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaRenamingDecl::initializeStorageClassArray (SgAdaRenamingDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaSubtype ) ; 
     std::cout << " SgAdaSubtype has size " << sizeOfActualPool << std::endl;
     SgAdaSubtypeStorageClass* SgAdaSubtypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaSubtypeStorageArray = new SgAdaSubtypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaSubtype::initializeStorageClassArray (SgAdaSubtypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTaskBody ) ; 
     std::cout << " SgAdaTaskBody has size " << sizeOfActualPool << std::endl;
     SgAdaTaskBodyStorageClass* SgAdaTaskBodyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskBodyStorageArray = new SgAdaTaskBodyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTaskBody::initializeStorageClassArray (SgAdaTaskBodyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTaskBodyDecl ) ; 
     std::cout << " SgAdaTaskBodyDecl has size " << sizeOfActualPool << std::endl;
     SgAdaTaskBodyDeclStorageClass* SgAdaTaskBodyDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskBodyDeclStorageArray = new SgAdaTaskBodyDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTaskBodyDecl::initializeStorageClassArray (SgAdaTaskBodyDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTaskSpec ) ; 
     std::cout << " SgAdaTaskSpec has size " << sizeOfActualPool << std::endl;
     SgAdaTaskSpecStorageClass* SgAdaTaskSpecStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskSpecStorageArray = new SgAdaTaskSpecStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTaskSpec::initializeStorageClassArray (SgAdaTaskSpecStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTaskSpecDecl ) ; 
     std::cout << " SgAdaTaskSpecDecl has size " << sizeOfActualPool << std::endl;
     SgAdaTaskSpecDeclStorageClass* SgAdaTaskSpecDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskSpecDeclStorageArray = new SgAdaTaskSpecDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTaskSpecDecl::initializeStorageClassArray (SgAdaTaskSpecDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTaskSymbol ) ; 
     std::cout << " SgAdaTaskSymbol has size " << sizeOfActualPool << std::endl;
     SgAdaTaskSymbolStorageClass* SgAdaTaskSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskSymbolStorageArray = new SgAdaTaskSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTaskSymbol::initializeStorageClassArray (SgAdaTaskSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTaskRefExp ) ; 
     std::cout << " SgAdaTaskRefExp has size " << sizeOfActualPool << std::endl;
     SgAdaTaskRefExpStorageClass* SgAdaTaskRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskRefExpStorageArray = new SgAdaTaskRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTaskRefExp::initializeStorageClassArray (SgAdaTaskRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTaskType ) ; 
     std::cout << " SgAdaTaskType has size " << sizeOfActualPool << std::endl;
     SgAdaTaskTypeStorageClass* SgAdaTaskTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskTypeStorageArray = new SgAdaTaskTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTaskType::initializeStorageClassArray (SgAdaTaskTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTaskTypeDecl ) ; 
     std::cout << " SgAdaTaskTypeDecl has size " << sizeOfActualPool << std::endl;
     SgAdaTaskTypeDeclStorageClass* SgAdaTaskTypeDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskTypeDeclStorageArray = new SgAdaTaskTypeDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTaskTypeDecl::initializeStorageClassArray (SgAdaTaskTypeDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTypeConstraint ) ; 
     std::cout << " SgAdaTypeConstraint has size " << sizeOfActualPool << std::endl;
     SgAdaTypeConstraintStorageClass* SgAdaTypeConstraintStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTypeConstraintStorageArray = new SgAdaTypeConstraintStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTypeConstraint::initializeStorageClassArray (SgAdaTypeConstraintStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAddOp ) ; 
     std::cout << " SgAddOp has size " << sizeOfActualPool << std::endl;
     SgAddOpStorageClass* SgAddOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAddOpStorageArray = new SgAddOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAddOp::initializeStorageClassArray (SgAddOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAddressOfOp ) ; 
     std::cout << " SgAddressOfOp has size " << sizeOfActualPool << std::endl;
     SgAddressOfOpStorageClass* SgAddressOfOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAddressOfOpStorageArray = new SgAddressOfOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAddressOfOp::initializeStorageClassArray (SgAddressOfOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAggregateInitializer ) ; 
     std::cout << " SgAggregateInitializer has size " << sizeOfActualPool << std::endl;
     SgAggregateInitializerStorageClass* SgAggregateInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAggregateInitializerStorageArray = new SgAggregateInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAggregateInitializer::initializeStorageClassArray (SgAggregateInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAliasSymbol ) ; 
     std::cout << " SgAliasSymbol has size " << sizeOfActualPool << std::endl;
     SgAliasSymbolStorageClass* SgAliasSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAliasSymbolStorageArray = new SgAliasSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAliasSymbol::initializeStorageClassArray (SgAliasSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAllocateStatement ) ; 
     std::cout << " SgAllocateStatement has size " << sizeOfActualPool << std::endl;
     SgAllocateStatementStorageClass* SgAllocateStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAllocateStatementStorageArray = new SgAllocateStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAllocateStatement::initializeStorageClassArray (SgAllocateStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAndAssignOp ) ; 
     std::cout << " SgAndAssignOp has size " << sizeOfActualPool << std::endl;
     SgAndAssignOpStorageClass* SgAndAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAndAssignOpStorageArray = new SgAndAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAndAssignOp::initializeStorageClassArray (SgAndAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAndOp ) ; 
     std::cout << " SgAndOp has size " << sizeOfActualPool << std::endl;
     SgAndOpStorageClass* SgAndOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAndOpStorageArray = new SgAndOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAndOp::initializeStorageClassArray (SgAndOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgArithmeticIfStatement ) ; 
     std::cout << " SgArithmeticIfStatement has size " << sizeOfActualPool << std::endl;
     SgArithmeticIfStatementStorageClass* SgArithmeticIfStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArithmeticIfStatementStorageArray = new SgArithmeticIfStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgArithmeticIfStatement::initializeStorageClassArray (SgArithmeticIfStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgArrayType ) ; 
     std::cout << " SgArrayType has size " << sizeOfActualPool << std::endl;
     SgArrayTypeStorageClass* SgArrayTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrayTypeStorageArray = new SgArrayTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgArrayType::initializeStorageClassArray (SgArrayTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgArrowExp ) ; 
     std::cout << " SgArrowExp has size " << sizeOfActualPool << std::endl;
     SgArrowExpStorageClass* SgArrowExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrowExpStorageArray = new SgArrowExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgArrowExp::initializeStorageClassArray (SgArrowExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgArrowStarOp ) ; 
     std::cout << " SgArrowStarOp has size " << sizeOfActualPool << std::endl;
     SgArrowStarOpStorageClass* SgArrowStarOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrowStarOpStorageArray = new SgArrowStarOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgArrowStarOp::initializeStorageClassArray (SgArrowStarOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBasicString ) ; 
     std::cout << " SgAsmBasicString has size " << sizeOfActualPool << std::endl;
     SgAsmBasicStringStorageClass* SgAsmBasicStringStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBasicStringStorageArray = new SgAsmBasicStringStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBasicString::initializeStorageClassArray (SgAsmBasicStringStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryAdd ) ; 
     std::cout << " SgAsmBinaryAdd has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryAddStorageClass* SgAsmBinaryAddStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddStorageArray = new SgAsmBinaryAddStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryAdd::initializeStorageClassArray (SgAsmBinaryAddStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryAsr ) ; 
     std::cout << " SgAsmBinaryAsr has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryAsrStorageClass* SgAsmBinaryAsrStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAsrStorageArray = new SgAsmBinaryAsrStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryAsr::initializeStorageClassArray (SgAsmBinaryAsrStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryDivide ) ; 
     std::cout << " SgAsmBinaryDivide has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryDivideStorageClass* SgAsmBinaryDivideStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryDivideStorageArray = new SgAsmBinaryDivideStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryDivide::initializeStorageClassArray (SgAsmBinaryDivideStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryExpression ) ; 
     std::cout << " SgAsmBinaryExpression has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryExpressionStorageClass* SgAsmBinaryExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryExpressionStorageArray = new SgAsmBinaryExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryExpression::initializeStorageClassArray (SgAsmBinaryExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryLsl ) ; 
     std::cout << " SgAsmBinaryLsl has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryLslStorageClass* SgAsmBinaryLslStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryLslStorageArray = new SgAsmBinaryLslStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryLsl::initializeStorageClassArray (SgAsmBinaryLslStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryLsr ) ; 
     std::cout << " SgAsmBinaryLsr has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryLsrStorageClass* SgAsmBinaryLsrStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryLsrStorageArray = new SgAsmBinaryLsrStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryLsr::initializeStorageClassArray (SgAsmBinaryLsrStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryMod ) ; 
     std::cout << " SgAsmBinaryMod has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryModStorageClass* SgAsmBinaryModStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryModStorageArray = new SgAsmBinaryModStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryMod::initializeStorageClassArray (SgAsmBinaryModStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryMsl ) ; 
     std::cout << " SgAsmBinaryMsl has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryMslStorageClass* SgAsmBinaryMslStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryMslStorageArray = new SgAsmBinaryMslStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryMsl::initializeStorageClassArray (SgAsmBinaryMslStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryMultiply ) ; 
     std::cout << " SgAsmBinaryMultiply has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryMultiplyStorageClass* SgAsmBinaryMultiplyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryMultiplyStorageArray = new SgAsmBinaryMultiplyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryMultiply::initializeStorageClassArray (SgAsmBinaryMultiplyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryRor ) ; 
     std::cout << " SgAsmBinaryRor has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryRorStorageClass* SgAsmBinaryRorStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryRorStorageArray = new SgAsmBinaryRorStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryRor::initializeStorageClassArray (SgAsmBinaryRorStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinarySubtract ) ; 
     std::cout << " SgAsmBinarySubtract has size " << sizeOfActualPool << std::endl;
     SgAsmBinarySubtractStorageClass* SgAsmBinarySubtractStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinarySubtractStorageArray = new SgAsmBinarySubtractStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinarySubtract::initializeStorageClassArray (SgAsmBinarySubtractStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBlock ) ; 
     std::cout << " SgAsmBlock has size " << sizeOfActualPool << std::endl;
     SgAsmBlockStorageClass* SgAsmBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBlockStorageArray = new SgAsmBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBlock::initializeStorageClassArray (SgAsmBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCoffStrtab ) ; 
     std::cout << " SgAsmCoffStrtab has size " << sizeOfActualPool << std::endl;
     SgAsmCoffStrtabStorageClass* SgAsmCoffStrtabStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffStrtabStorageArray = new SgAsmCoffStrtabStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCoffStrtab::initializeStorageClassArray (SgAsmCoffStrtabStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCoffSymbol ) ; 
     std::cout << " SgAsmCoffSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmCoffSymbolStorageClass* SgAsmCoffSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolStorageArray = new SgAsmCoffSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCoffSymbol::initializeStorageClassArray (SgAsmCoffSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCoffSymbolList ) ; 
     std::cout << " SgAsmCoffSymbolList has size " << sizeOfActualPool << std::endl;
     SgAsmCoffSymbolListStorageClass* SgAsmCoffSymbolListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolListStorageArray = new SgAsmCoffSymbolListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCoffSymbolList::initializeStorageClassArray (SgAsmCoffSymbolListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCoffSymbolTable ) ; 
     std::cout << " SgAsmCoffSymbolTable has size " << sizeOfActualPool << std::endl;
     SgAsmCoffSymbolTableStorageClass* SgAsmCoffSymbolTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolTableStorageArray = new SgAsmCoffSymbolTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCoffSymbolTable::initializeStorageClassArray (SgAsmCoffSymbolTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCommonSubExpression ) ; 
     std::cout << " SgAsmCommonSubExpression has size " << sizeOfActualPool << std::endl;
     SgAsmCommonSubExpressionStorageClass* SgAsmCommonSubExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCommonSubExpressionStorageArray = new SgAsmCommonSubExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCommonSubExpression::initializeStorageClassArray (SgAsmCommonSubExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmControlFlagsExpression ) ; 
     std::cout << " SgAsmControlFlagsExpression has size " << sizeOfActualPool << std::endl;
     SgAsmControlFlagsExpressionStorageClass* SgAsmControlFlagsExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmControlFlagsExpressionStorageArray = new SgAsmControlFlagsExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmControlFlagsExpression::initializeStorageClassArray (SgAsmControlFlagsExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmConstantExpression ) ; 
     std::cout << " SgAsmConstantExpression has size " << sizeOfActualPool << std::endl;
     SgAsmConstantExpressionStorageClass* SgAsmConstantExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmConstantExpressionStorageArray = new SgAsmConstantExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmConstantExpression::initializeStorageClassArray (SgAsmConstantExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDOSExtendedHeader ) ; 
     std::cout << " SgAsmDOSExtendedHeader has size " << sizeOfActualPool << std::endl;
     SgAsmDOSExtendedHeaderStorageClass* SgAsmDOSExtendedHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDOSExtendedHeaderStorageArray = new SgAsmDOSExtendedHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDOSExtendedHeader::initializeStorageClassArray (SgAsmDOSExtendedHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDOSFileHeader ) ; 
     std::cout << " SgAsmDOSFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmDOSFileHeaderStorageClass* SgAsmDOSFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDOSFileHeaderStorageArray = new SgAsmDOSFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDOSFileHeader::initializeStorageClassArray (SgAsmDOSFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmSynthesizedDataStructureDeclaration ) ; 
     std::cout << " SgAsmSynthesizedDataStructureDeclaration has size " << sizeOfActualPool << std::endl;
     SgAsmSynthesizedDataStructureDeclarationStorageClass* SgAsmSynthesizedDataStructureDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmSynthesizedDataStructureDeclarationStorageArray = new SgAsmSynthesizedDataStructureDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmSynthesizedDataStructureDeclaration::initializeStorageClassArray (SgAsmSynthesizedDataStructureDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmSynthesizedDeclaration ) ; 
     std::cout << " SgAsmSynthesizedDeclaration has size " << sizeOfActualPool << std::endl;
     SgAsmSynthesizedDeclarationStorageClass* SgAsmSynthesizedDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmSynthesizedDeclarationStorageArray = new SgAsmSynthesizedDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmSynthesizedDeclaration::initializeStorageClassArray (SgAsmSynthesizedDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDirectRegisterExpression ) ; 
     std::cout << " SgAsmDirectRegisterExpression has size " << sizeOfActualPool << std::endl;
     SgAsmDirectRegisterExpressionStorageClass* SgAsmDirectRegisterExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDirectRegisterExpressionStorageArray = new SgAsmDirectRegisterExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDirectRegisterExpression::initializeStorageClassArray (SgAsmDirectRegisterExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfAccessDeclaration ) ; 
     std::cout << " SgAsmDwarfAccessDeclaration has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfAccessDeclarationStorageClass* SgAsmDwarfAccessDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfAccessDeclarationStorageArray = new SgAsmDwarfAccessDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfAccessDeclaration::initializeStorageClassArray (SgAsmDwarfAccessDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfArrayType ) ; 
     std::cout << " SgAsmDwarfArrayType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfArrayTypeStorageClass* SgAsmDwarfArrayTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfArrayTypeStorageArray = new SgAsmDwarfArrayTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfArrayType::initializeStorageClassArray (SgAsmDwarfArrayTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfBaseType ) ; 
     std::cout << " SgAsmDwarfBaseType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfBaseTypeStorageClass* SgAsmDwarfBaseTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfBaseTypeStorageArray = new SgAsmDwarfBaseTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfBaseType::initializeStorageClassArray (SgAsmDwarfBaseTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCatchBlock ) ; 
     std::cout << " SgAsmDwarfCatchBlock has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCatchBlockStorageClass* SgAsmDwarfCatchBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCatchBlockStorageArray = new SgAsmDwarfCatchBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCatchBlock::initializeStorageClassArray (SgAsmDwarfCatchBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfClassTemplate ) ; 
     std::cout << " SgAsmDwarfClassTemplate has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfClassTemplateStorageClass* SgAsmDwarfClassTemplateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfClassTemplateStorageArray = new SgAsmDwarfClassTemplateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfClassTemplate::initializeStorageClassArray (SgAsmDwarfClassTemplateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfClassType ) ; 
     std::cout << " SgAsmDwarfClassType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfClassTypeStorageClass* SgAsmDwarfClassTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfClassTypeStorageArray = new SgAsmDwarfClassTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfClassType::initializeStorageClassArray (SgAsmDwarfClassTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCommonBlock ) ; 
     std::cout << " SgAsmDwarfCommonBlock has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCommonBlockStorageClass* SgAsmDwarfCommonBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCommonBlockStorageArray = new SgAsmDwarfCommonBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCommonBlock::initializeStorageClassArray (SgAsmDwarfCommonBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCommonInclusion ) ; 
     std::cout << " SgAsmDwarfCommonInclusion has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCommonInclusionStorageClass* SgAsmDwarfCommonInclusionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCommonInclusionStorageArray = new SgAsmDwarfCommonInclusionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCommonInclusion::initializeStorageClassArray (SgAsmDwarfCommonInclusionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCompilationUnit ) ; 
     std::cout << " SgAsmDwarfCompilationUnit has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCompilationUnitStorageClass* SgAsmDwarfCompilationUnitStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCompilationUnitStorageArray = new SgAsmDwarfCompilationUnitStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCompilationUnit::initializeStorageClassArray (SgAsmDwarfCompilationUnitStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCompilationUnitList ) ; 
     std::cout << " SgAsmDwarfCompilationUnitList has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCompilationUnitListStorageClass* SgAsmDwarfCompilationUnitListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCompilationUnitListStorageArray = new SgAsmDwarfCompilationUnitListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCompilationUnitList::initializeStorageClassArray (SgAsmDwarfCompilationUnitListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCondition ) ; 
     std::cout << " SgAsmDwarfCondition has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConditionStorageClass* SgAsmDwarfConditionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConditionStorageArray = new SgAsmDwarfConditionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCondition::initializeStorageClassArray (SgAsmDwarfConditionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfConstType ) ; 
     std::cout << " SgAsmDwarfConstType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConstTypeStorageClass* SgAsmDwarfConstTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstTypeStorageArray = new SgAsmDwarfConstTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfConstType::initializeStorageClassArray (SgAsmDwarfConstTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfConstant ) ; 
     std::cout << " SgAsmDwarfConstant has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConstantStorageClass* SgAsmDwarfConstantStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstantStorageArray = new SgAsmDwarfConstantStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfConstant::initializeStorageClassArray (SgAsmDwarfConstantStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfConstruct ) ; 
     std::cout << " SgAsmDwarfConstruct has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConstructStorageClass* SgAsmDwarfConstructStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstructStorageArray = new SgAsmDwarfConstructStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfConstruct::initializeStorageClassArray (SgAsmDwarfConstructStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfConstructList ) ; 
     std::cout << " SgAsmDwarfConstructList has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConstructListStorageClass* SgAsmDwarfConstructListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstructListStorageArray = new SgAsmDwarfConstructListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfConstructList::initializeStorageClassArray (SgAsmDwarfConstructListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfDwarfProcedure ) ; 
     std::cout << " SgAsmDwarfDwarfProcedure has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfDwarfProcedureStorageClass* SgAsmDwarfDwarfProcedureStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfDwarfProcedureStorageArray = new SgAsmDwarfDwarfProcedureStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfDwarfProcedure::initializeStorageClassArray (SgAsmDwarfDwarfProcedureStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfEntryPoint ) ; 
     std::cout << " SgAsmDwarfEntryPoint has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfEntryPointStorageClass* SgAsmDwarfEntryPointStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEntryPointStorageArray = new SgAsmDwarfEntryPointStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfEntryPoint::initializeStorageClassArray (SgAsmDwarfEntryPointStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfEnumerationType ) ; 
     std::cout << " SgAsmDwarfEnumerationType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfEnumerationTypeStorageClass* SgAsmDwarfEnumerationTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEnumerationTypeStorageArray = new SgAsmDwarfEnumerationTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfEnumerationType::initializeStorageClassArray (SgAsmDwarfEnumerationTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfEnumerator ) ; 
     std::cout << " SgAsmDwarfEnumerator has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfEnumeratorStorageClass* SgAsmDwarfEnumeratorStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEnumeratorStorageArray = new SgAsmDwarfEnumeratorStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfEnumerator::initializeStorageClassArray (SgAsmDwarfEnumeratorStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFileType ) ; 
     std::cout << " SgAsmDwarfFileType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFileTypeStorageClass* SgAsmDwarfFileTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFileTypeStorageArray = new SgAsmDwarfFileTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFileType::initializeStorageClassArray (SgAsmDwarfFileTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFormalParameter ) ; 
     std::cout << " SgAsmDwarfFormalParameter has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFormalParameterStorageClass* SgAsmDwarfFormalParameterStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFormalParameterStorageArray = new SgAsmDwarfFormalParameterStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFormalParameter::initializeStorageClassArray (SgAsmDwarfFormalParameterStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFormatLabel ) ; 
     std::cout << " SgAsmDwarfFormatLabel has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFormatLabelStorageClass* SgAsmDwarfFormatLabelStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFormatLabelStorageArray = new SgAsmDwarfFormatLabelStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFormatLabel::initializeStorageClassArray (SgAsmDwarfFormatLabelStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFriend ) ; 
     std::cout << " SgAsmDwarfFriend has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFriendStorageClass* SgAsmDwarfFriendStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFriendStorageArray = new SgAsmDwarfFriendStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFriend::initializeStorageClassArray (SgAsmDwarfFriendStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFunctionTemplate ) ; 
     std::cout << " SgAsmDwarfFunctionTemplate has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFunctionTemplateStorageClass* SgAsmDwarfFunctionTemplateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFunctionTemplateStorageArray = new SgAsmDwarfFunctionTemplateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFunctionTemplate::initializeStorageClassArray (SgAsmDwarfFunctionTemplateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfImportedDeclaration ) ; 
     std::cout << " SgAsmDwarfImportedDeclaration has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfImportedDeclarationStorageClass* SgAsmDwarfImportedDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedDeclarationStorageArray = new SgAsmDwarfImportedDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfImportedDeclaration::initializeStorageClassArray (SgAsmDwarfImportedDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfImportedModule ) ; 
     std::cout << " SgAsmDwarfImportedModule has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfImportedModuleStorageClass* SgAsmDwarfImportedModuleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedModuleStorageArray = new SgAsmDwarfImportedModuleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfImportedModule::initializeStorageClassArray (SgAsmDwarfImportedModuleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfImportedUnit ) ; 
     std::cout << " SgAsmDwarfImportedUnit has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfImportedUnitStorageClass* SgAsmDwarfImportedUnitStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedUnitStorageArray = new SgAsmDwarfImportedUnitStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfImportedUnit::initializeStorageClassArray (SgAsmDwarfImportedUnitStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfInformation ) ; 
     std::cout << " SgAsmDwarfInformation has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfInformationStorageClass* SgAsmDwarfInformationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInformationStorageArray = new SgAsmDwarfInformationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfInformation::initializeStorageClassArray (SgAsmDwarfInformationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfInheritance ) ; 
     std::cout << " SgAsmDwarfInheritance has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfInheritanceStorageClass* SgAsmDwarfInheritanceStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInheritanceStorageArray = new SgAsmDwarfInheritanceStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfInheritance::initializeStorageClassArray (SgAsmDwarfInheritanceStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfInlinedSubroutine ) ; 
     std::cout << " SgAsmDwarfInlinedSubroutine has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfInlinedSubroutineStorageClass* SgAsmDwarfInlinedSubroutineStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInlinedSubroutineStorageArray = new SgAsmDwarfInlinedSubroutineStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfInlinedSubroutine::initializeStorageClassArray (SgAsmDwarfInlinedSubroutineStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfInterfaceType ) ; 
     std::cout << " SgAsmDwarfInterfaceType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfInterfaceTypeStorageClass* SgAsmDwarfInterfaceTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInterfaceTypeStorageArray = new SgAsmDwarfInterfaceTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfInterfaceType::initializeStorageClassArray (SgAsmDwarfInterfaceTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfLabel ) ; 
     std::cout << " SgAsmDwarfLabel has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfLabelStorageClass* SgAsmDwarfLabelStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLabelStorageArray = new SgAsmDwarfLabelStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfLabel::initializeStorageClassArray (SgAsmDwarfLabelStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfLexicalBlock ) ; 
     std::cout << " SgAsmDwarfLexicalBlock has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfLexicalBlockStorageClass* SgAsmDwarfLexicalBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLexicalBlockStorageArray = new SgAsmDwarfLexicalBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfLexicalBlock::initializeStorageClassArray (SgAsmDwarfLexicalBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfLine ) ; 
     std::cout << " SgAsmDwarfLine has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfLineStorageClass* SgAsmDwarfLineStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLineStorageArray = new SgAsmDwarfLineStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfLine::initializeStorageClassArray (SgAsmDwarfLineStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfLineList ) ; 
     std::cout << " SgAsmDwarfLineList has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfLineListStorageClass* SgAsmDwarfLineListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLineListStorageArray = new SgAsmDwarfLineListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfLineList::initializeStorageClassArray (SgAsmDwarfLineListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfMacro ) ; 
     std::cout << " SgAsmDwarfMacro has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfMacroStorageClass* SgAsmDwarfMacroStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMacroStorageArray = new SgAsmDwarfMacroStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfMacro::initializeStorageClassArray (SgAsmDwarfMacroStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfMacroList ) ; 
     std::cout << " SgAsmDwarfMacroList has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfMacroListStorageClass* SgAsmDwarfMacroListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMacroListStorageArray = new SgAsmDwarfMacroListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfMacroList::initializeStorageClassArray (SgAsmDwarfMacroListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfMember ) ; 
     std::cout << " SgAsmDwarfMember has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfMemberStorageClass* SgAsmDwarfMemberStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMemberStorageArray = new SgAsmDwarfMemberStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfMember::initializeStorageClassArray (SgAsmDwarfMemberStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfModule ) ; 
     std::cout << " SgAsmDwarfModule has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfModuleStorageClass* SgAsmDwarfModuleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfModuleStorageArray = new SgAsmDwarfModuleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfModule::initializeStorageClassArray (SgAsmDwarfModuleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfMutableType ) ; 
     std::cout << " SgAsmDwarfMutableType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfMutableTypeStorageClass* SgAsmDwarfMutableTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMutableTypeStorageArray = new SgAsmDwarfMutableTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfMutableType::initializeStorageClassArray (SgAsmDwarfMutableTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfNamelist ) ; 
     std::cout << " SgAsmDwarfNamelist has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfNamelistStorageClass* SgAsmDwarfNamelistStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamelistStorageArray = new SgAsmDwarfNamelistStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfNamelist::initializeStorageClassArray (SgAsmDwarfNamelistStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfNamelistItem ) ; 
     std::cout << " SgAsmDwarfNamelistItem has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfNamelistItemStorageClass* SgAsmDwarfNamelistItemStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamelistItemStorageArray = new SgAsmDwarfNamelistItemStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfNamelistItem::initializeStorageClassArray (SgAsmDwarfNamelistItemStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfNamespace ) ; 
     std::cout << " SgAsmDwarfNamespace has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfNamespaceStorageClass* SgAsmDwarfNamespaceStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamespaceStorageArray = new SgAsmDwarfNamespaceStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfNamespace::initializeStorageClassArray (SgAsmDwarfNamespaceStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfPackedType ) ; 
     std::cout << " SgAsmDwarfPackedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfPackedTypeStorageClass* SgAsmDwarfPackedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPackedTypeStorageArray = new SgAsmDwarfPackedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfPackedType::initializeStorageClassArray (SgAsmDwarfPackedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfPartialUnit ) ; 
     std::cout << " SgAsmDwarfPartialUnit has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfPartialUnitStorageClass* SgAsmDwarfPartialUnitStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPartialUnitStorageArray = new SgAsmDwarfPartialUnitStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfPartialUnit::initializeStorageClassArray (SgAsmDwarfPartialUnitStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfPointerType ) ; 
     std::cout << " SgAsmDwarfPointerType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfPointerTypeStorageClass* SgAsmDwarfPointerTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPointerTypeStorageArray = new SgAsmDwarfPointerTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfPointerType::initializeStorageClassArray (SgAsmDwarfPointerTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfPtrToMemberType ) ; 
     std::cout << " SgAsmDwarfPtrToMemberType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfPtrToMemberTypeStorageClass* SgAsmDwarfPtrToMemberTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPtrToMemberTypeStorageArray = new SgAsmDwarfPtrToMemberTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfPtrToMemberType::initializeStorageClassArray (SgAsmDwarfPtrToMemberTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfReferenceType ) ; 
     std::cout << " SgAsmDwarfReferenceType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfReferenceTypeStorageClass* SgAsmDwarfReferenceTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfReferenceTypeStorageArray = new SgAsmDwarfReferenceTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfReferenceType::initializeStorageClassArray (SgAsmDwarfReferenceTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfRestrictType ) ; 
     std::cout << " SgAsmDwarfRestrictType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfRestrictTypeStorageClass* SgAsmDwarfRestrictTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfRestrictTypeStorageArray = new SgAsmDwarfRestrictTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfRestrictType::initializeStorageClassArray (SgAsmDwarfRestrictTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSetType ) ; 
     std::cout << " SgAsmDwarfSetType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSetTypeStorageClass* SgAsmDwarfSetTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSetTypeStorageArray = new SgAsmDwarfSetTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSetType::initializeStorageClassArray (SgAsmDwarfSetTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSharedType ) ; 
     std::cout << " SgAsmDwarfSharedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSharedTypeStorageClass* SgAsmDwarfSharedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSharedTypeStorageArray = new SgAsmDwarfSharedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSharedType::initializeStorageClassArray (SgAsmDwarfSharedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfStringType ) ; 
     std::cout << " SgAsmDwarfStringType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfStringTypeStorageClass* SgAsmDwarfStringTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfStringTypeStorageArray = new SgAsmDwarfStringTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfStringType::initializeStorageClassArray (SgAsmDwarfStringTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfStructureType ) ; 
     std::cout << " SgAsmDwarfStructureType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfStructureTypeStorageClass* SgAsmDwarfStructureTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfStructureTypeStorageArray = new SgAsmDwarfStructureTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfStructureType::initializeStorageClassArray (SgAsmDwarfStructureTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSubprogram ) ; 
     std::cout << " SgAsmDwarfSubprogram has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSubprogramStorageClass* SgAsmDwarfSubprogramStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubprogramStorageArray = new SgAsmDwarfSubprogramStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSubprogram::initializeStorageClassArray (SgAsmDwarfSubprogramStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSubrangeType ) ; 
     std::cout << " SgAsmDwarfSubrangeType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSubrangeTypeStorageClass* SgAsmDwarfSubrangeTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubrangeTypeStorageArray = new SgAsmDwarfSubrangeTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSubrangeType::initializeStorageClassArray (SgAsmDwarfSubrangeTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSubroutineType ) ; 
     std::cout << " SgAsmDwarfSubroutineType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSubroutineTypeStorageClass* SgAsmDwarfSubroutineTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubroutineTypeStorageArray = new SgAsmDwarfSubroutineTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSubroutineType::initializeStorageClassArray (SgAsmDwarfSubroutineTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfTemplateTypeParameter ) ; 
     std::cout << " SgAsmDwarfTemplateTypeParameter has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfTemplateTypeParameterStorageClass* SgAsmDwarfTemplateTypeParameterStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTemplateTypeParameterStorageArray = new SgAsmDwarfTemplateTypeParameterStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfTemplateTypeParameter::initializeStorageClassArray (SgAsmDwarfTemplateTypeParameterStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfTemplateValueParameter ) ; 
     std::cout << " SgAsmDwarfTemplateValueParameter has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfTemplateValueParameterStorageClass* SgAsmDwarfTemplateValueParameterStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTemplateValueParameterStorageArray = new SgAsmDwarfTemplateValueParameterStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfTemplateValueParameter::initializeStorageClassArray (SgAsmDwarfTemplateValueParameterStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfThrownType ) ; 
     std::cout << " SgAsmDwarfThrownType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfThrownTypeStorageClass* SgAsmDwarfThrownTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfThrownTypeStorageArray = new SgAsmDwarfThrownTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfThrownType::initializeStorageClassArray (SgAsmDwarfThrownTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfTryBlock ) ; 
     std::cout << " SgAsmDwarfTryBlock has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfTryBlockStorageClass* SgAsmDwarfTryBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTryBlockStorageArray = new SgAsmDwarfTryBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfTryBlock::initializeStorageClassArray (SgAsmDwarfTryBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfTypedef ) ; 
     std::cout << " SgAsmDwarfTypedef has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfTypedefStorageClass* SgAsmDwarfTypedefStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTypedefStorageArray = new SgAsmDwarfTypedefStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfTypedef::initializeStorageClassArray (SgAsmDwarfTypedefStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUnionType ) ; 
     std::cout << " SgAsmDwarfUnionType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUnionTypeStorageClass* SgAsmDwarfUnionTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnionTypeStorageArray = new SgAsmDwarfUnionTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUnionType::initializeStorageClassArray (SgAsmDwarfUnionTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUnknownConstruct ) ; 
     std::cout << " SgAsmDwarfUnknownConstruct has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUnknownConstructStorageClass* SgAsmDwarfUnknownConstructStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnknownConstructStorageArray = new SgAsmDwarfUnknownConstructStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUnknownConstruct::initializeStorageClassArray (SgAsmDwarfUnknownConstructStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUnspecifiedParameters ) ; 
     std::cout << " SgAsmDwarfUnspecifiedParameters has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUnspecifiedParametersStorageClass* SgAsmDwarfUnspecifiedParametersStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnspecifiedParametersStorageArray = new SgAsmDwarfUnspecifiedParametersStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUnspecifiedParameters::initializeStorageClassArray (SgAsmDwarfUnspecifiedParametersStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUnspecifiedType ) ; 
     std::cout << " SgAsmDwarfUnspecifiedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUnspecifiedTypeStorageClass* SgAsmDwarfUnspecifiedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnspecifiedTypeStorageArray = new SgAsmDwarfUnspecifiedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUnspecifiedType::initializeStorageClassArray (SgAsmDwarfUnspecifiedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUpcRelaxedType ) ; 
     std::cout << " SgAsmDwarfUpcRelaxedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUpcRelaxedTypeStorageClass* SgAsmDwarfUpcRelaxedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcRelaxedTypeStorageArray = new SgAsmDwarfUpcRelaxedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUpcRelaxedType::initializeStorageClassArray (SgAsmDwarfUpcRelaxedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUpcSharedType ) ; 
     std::cout << " SgAsmDwarfUpcSharedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUpcSharedTypeStorageClass* SgAsmDwarfUpcSharedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcSharedTypeStorageArray = new SgAsmDwarfUpcSharedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUpcSharedType::initializeStorageClassArray (SgAsmDwarfUpcSharedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUpcStrictType ) ; 
     std::cout << " SgAsmDwarfUpcStrictType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUpcStrictTypeStorageClass* SgAsmDwarfUpcStrictTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcStrictTypeStorageArray = new SgAsmDwarfUpcStrictTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUpcStrictType::initializeStorageClassArray (SgAsmDwarfUpcStrictTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfVariable ) ; 
     std::cout << " SgAsmDwarfVariable has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfVariableStorageClass* SgAsmDwarfVariableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariableStorageArray = new SgAsmDwarfVariableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfVariable::initializeStorageClassArray (SgAsmDwarfVariableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfVariant ) ; 
     std::cout << " SgAsmDwarfVariant has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfVariantStorageClass* SgAsmDwarfVariantStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariantStorageArray = new SgAsmDwarfVariantStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfVariant::initializeStorageClassArray (SgAsmDwarfVariantStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfVariantPart ) ; 
     std::cout << " SgAsmDwarfVariantPart has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfVariantPartStorageClass* SgAsmDwarfVariantPartStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariantPartStorageArray = new SgAsmDwarfVariantPartStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfVariantPart::initializeStorageClassArray (SgAsmDwarfVariantPartStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfVolatileType ) ; 
     std::cout << " SgAsmDwarfVolatileType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfVolatileTypeStorageClass* SgAsmDwarfVolatileTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVolatileTypeStorageArray = new SgAsmDwarfVolatileTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfVolatileType::initializeStorageClassArray (SgAsmDwarfVolatileTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfWithStmt ) ; 
     std::cout << " SgAsmDwarfWithStmt has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfWithStmtStorageClass* SgAsmDwarfWithStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfWithStmtStorageArray = new SgAsmDwarfWithStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfWithStmt::initializeStorageClassArray (SgAsmDwarfWithStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfDynamicEntry ) ; 
     std::cout << " SgAsmElfDynamicEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfDynamicEntryStorageClass* SgAsmElfDynamicEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicEntryStorageArray = new SgAsmElfDynamicEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfDynamicEntry::initializeStorageClassArray (SgAsmElfDynamicEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfDynamicEntryList ) ; 
     std::cout << " SgAsmElfDynamicEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfDynamicEntryListStorageClass* SgAsmElfDynamicEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicEntryListStorageArray = new SgAsmElfDynamicEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfDynamicEntryList::initializeStorageClassArray (SgAsmElfDynamicEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfDynamicSection ) ; 
     std::cout << " SgAsmElfDynamicSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfDynamicSectionStorageClass* SgAsmElfDynamicSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicSectionStorageArray = new SgAsmElfDynamicSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfDynamicSection::initializeStorageClassArray (SgAsmElfDynamicSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameEntryCI ) ; 
     std::cout << " SgAsmElfEHFrameEntryCI has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameEntryCIStorageClass* SgAsmElfEHFrameEntryCIStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryCIStorageArray = new SgAsmElfEHFrameEntryCIStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameEntryCI::initializeStorageClassArray (SgAsmElfEHFrameEntryCIStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameEntryCIList ) ; 
     std::cout << " SgAsmElfEHFrameEntryCIList has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameEntryCIListStorageClass* SgAsmElfEHFrameEntryCIListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryCIListStorageArray = new SgAsmElfEHFrameEntryCIListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameEntryCIList::initializeStorageClassArray (SgAsmElfEHFrameEntryCIListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameEntryFD ) ; 
     std::cout << " SgAsmElfEHFrameEntryFD has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameEntryFDStorageClass* SgAsmElfEHFrameEntryFDStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryFDStorageArray = new SgAsmElfEHFrameEntryFDStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameEntryFD::initializeStorageClassArray (SgAsmElfEHFrameEntryFDStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameEntryFDList ) ; 
     std::cout << " SgAsmElfEHFrameEntryFDList has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameEntryFDListStorageClass* SgAsmElfEHFrameEntryFDListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryFDListStorageArray = new SgAsmElfEHFrameEntryFDListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameEntryFDList::initializeStorageClassArray (SgAsmElfEHFrameEntryFDListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameSection ) ; 
     std::cout << " SgAsmElfEHFrameSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameSectionStorageClass* SgAsmElfEHFrameSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameSectionStorageArray = new SgAsmElfEHFrameSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameSection::initializeStorageClassArray (SgAsmElfEHFrameSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfFileHeader ) ; 
     std::cout << " SgAsmElfFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmElfFileHeaderStorageClass* SgAsmElfFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfFileHeaderStorageArray = new SgAsmElfFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfFileHeader::initializeStorageClassArray (SgAsmElfFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfNoteEntry ) ; 
     std::cout << " SgAsmElfNoteEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfNoteEntryStorageClass* SgAsmElfNoteEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteEntryStorageArray = new SgAsmElfNoteEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfNoteEntry::initializeStorageClassArray (SgAsmElfNoteEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfNoteEntryList ) ; 
     std::cout << " SgAsmElfNoteEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfNoteEntryListStorageClass* SgAsmElfNoteEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteEntryListStorageArray = new SgAsmElfNoteEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfNoteEntryList::initializeStorageClassArray (SgAsmElfNoteEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfNoteSection ) ; 
     std::cout << " SgAsmElfNoteSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfNoteSectionStorageClass* SgAsmElfNoteSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteSectionStorageArray = new SgAsmElfNoteSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfNoteSection::initializeStorageClassArray (SgAsmElfNoteSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfRelocEntry ) ; 
     std::cout << " SgAsmElfRelocEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfRelocEntryStorageClass* SgAsmElfRelocEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocEntryStorageArray = new SgAsmElfRelocEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfRelocEntry::initializeStorageClassArray (SgAsmElfRelocEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfRelocEntryList ) ; 
     std::cout << " SgAsmElfRelocEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfRelocEntryListStorageClass* SgAsmElfRelocEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocEntryListStorageArray = new SgAsmElfRelocEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfRelocEntryList::initializeStorageClassArray (SgAsmElfRelocEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfRelocSection ) ; 
     std::cout << " SgAsmElfRelocSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfRelocSectionStorageClass* SgAsmElfRelocSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocSectionStorageArray = new SgAsmElfRelocSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfRelocSection::initializeStorageClassArray (SgAsmElfRelocSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSection ) ; 
     std::cout << " SgAsmElfSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSectionStorageClass* SgAsmElfSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionStorageArray = new SgAsmElfSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSection::initializeStorageClassArray (SgAsmElfSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSectionTable ) ; 
     std::cout << " SgAsmElfSectionTable has size " << sizeOfActualPool << std::endl;
     SgAsmElfSectionTableStorageClass* SgAsmElfSectionTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionTableStorageArray = new SgAsmElfSectionTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSectionTable::initializeStorageClassArray (SgAsmElfSectionTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSectionTableEntry ) ; 
     std::cout << " SgAsmElfSectionTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSectionTableEntryStorageClass* SgAsmElfSectionTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionTableEntryStorageArray = new SgAsmElfSectionTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSectionTableEntry::initializeStorageClassArray (SgAsmElfSectionTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSegmentTable ) ; 
     std::cout << " SgAsmElfSegmentTable has size " << sizeOfActualPool << std::endl;
     SgAsmElfSegmentTableStorageClass* SgAsmElfSegmentTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableStorageArray = new SgAsmElfSegmentTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSegmentTable::initializeStorageClassArray (SgAsmElfSegmentTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSegmentTableEntry ) ; 
     std::cout << " SgAsmElfSegmentTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSegmentTableEntryStorageClass* SgAsmElfSegmentTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableEntryStorageArray = new SgAsmElfSegmentTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSegmentTableEntry::initializeStorageClassArray (SgAsmElfSegmentTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSegmentTableEntryList ) ; 
     std::cout << " SgAsmElfSegmentTableEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSegmentTableEntryListStorageClass* SgAsmElfSegmentTableEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableEntryListStorageArray = new SgAsmElfSegmentTableEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSegmentTableEntryList::initializeStorageClassArray (SgAsmElfSegmentTableEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfStringSection ) ; 
     std::cout << " SgAsmElfStringSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfStringSectionStorageClass* SgAsmElfStringSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfStringSectionStorageArray = new SgAsmElfStringSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfStringSection::initializeStorageClassArray (SgAsmElfStringSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfStrtab ) ; 
     std::cout << " SgAsmElfStrtab has size " << sizeOfActualPool << std::endl;
     SgAsmElfStrtabStorageClass* SgAsmElfStrtabStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfStrtabStorageArray = new SgAsmElfStrtabStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfStrtab::initializeStorageClassArray (SgAsmElfStrtabStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymbol ) ; 
     std::cout << " SgAsmElfSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymbolStorageClass* SgAsmElfSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolStorageArray = new SgAsmElfSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymbol::initializeStorageClassArray (SgAsmElfSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymbolList ) ; 
     std::cout << " SgAsmElfSymbolList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymbolListStorageClass* SgAsmElfSymbolListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolListStorageArray = new SgAsmElfSymbolListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymbolList::initializeStorageClassArray (SgAsmElfSymbolListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymbolSection ) ; 
     std::cout << " SgAsmElfSymbolSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymbolSectionStorageClass* SgAsmElfSymbolSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolSectionStorageArray = new SgAsmElfSymbolSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymbolSection::initializeStorageClassArray (SgAsmElfSymbolSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedAux ) ; 
     std::cout << " SgAsmElfSymverDefinedAux has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedAuxStorageClass* SgAsmElfSymverDefinedAuxStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedAuxStorageArray = new SgAsmElfSymverDefinedAuxStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedAux::initializeStorageClassArray (SgAsmElfSymverDefinedAuxStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedAuxList ) ; 
     std::cout << " SgAsmElfSymverDefinedAuxList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedAuxListStorageClass* SgAsmElfSymverDefinedAuxListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedAuxListStorageArray = new SgAsmElfSymverDefinedAuxListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedAuxList::initializeStorageClassArray (SgAsmElfSymverDefinedAuxListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedEntry ) ; 
     std::cout << " SgAsmElfSymverDefinedEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedEntryStorageClass* SgAsmElfSymverDefinedEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedEntryStorageArray = new SgAsmElfSymverDefinedEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedEntry::initializeStorageClassArray (SgAsmElfSymverDefinedEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedEntryList ) ; 
     std::cout << " SgAsmElfSymverDefinedEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedEntryListStorageClass* SgAsmElfSymverDefinedEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedEntryListStorageArray = new SgAsmElfSymverDefinedEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedEntryList::initializeStorageClassArray (SgAsmElfSymverDefinedEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedSection ) ; 
     std::cout << " SgAsmElfSymverDefinedSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedSectionStorageClass* SgAsmElfSymverDefinedSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedSectionStorageArray = new SgAsmElfSymverDefinedSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedSection::initializeStorageClassArray (SgAsmElfSymverDefinedSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverEntry ) ; 
     std::cout << " SgAsmElfSymverEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverEntryStorageClass* SgAsmElfSymverEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverEntryStorageArray = new SgAsmElfSymverEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverEntry::initializeStorageClassArray (SgAsmElfSymverEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverEntryList ) ; 
     std::cout << " SgAsmElfSymverEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverEntryListStorageClass* SgAsmElfSymverEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverEntryListStorageArray = new SgAsmElfSymverEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverEntryList::initializeStorageClassArray (SgAsmElfSymverEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededAux ) ; 
     std::cout << " SgAsmElfSymverNeededAux has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededAuxStorageClass* SgAsmElfSymverNeededAuxStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededAuxStorageArray = new SgAsmElfSymverNeededAuxStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededAux::initializeStorageClassArray (SgAsmElfSymverNeededAuxStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededAuxList ) ; 
     std::cout << " SgAsmElfSymverNeededAuxList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededAuxListStorageClass* SgAsmElfSymverNeededAuxListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededAuxListStorageArray = new SgAsmElfSymverNeededAuxListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededAuxList::initializeStorageClassArray (SgAsmElfSymverNeededAuxListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededEntry ) ; 
     std::cout << " SgAsmElfSymverNeededEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededEntryStorageClass* SgAsmElfSymverNeededEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededEntryStorageArray = new SgAsmElfSymverNeededEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededEntry::initializeStorageClassArray (SgAsmElfSymverNeededEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededEntryList ) ; 
     std::cout << " SgAsmElfSymverNeededEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededEntryListStorageClass* SgAsmElfSymverNeededEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededEntryListStorageArray = new SgAsmElfSymverNeededEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededEntryList::initializeStorageClassArray (SgAsmElfSymverNeededEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededSection ) ; 
     std::cout << " SgAsmElfSymverNeededSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededSectionStorageClass* SgAsmElfSymverNeededSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededSectionStorageArray = new SgAsmElfSymverNeededSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededSection::initializeStorageClassArray (SgAsmElfSymverNeededSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverSection ) ; 
     std::cout << " SgAsmElfSymverSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverSectionStorageClass* SgAsmElfSymverSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverSectionStorageArray = new SgAsmElfSymverSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverSection::initializeStorageClassArray (SgAsmElfSymverSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmExecutableFileFormat ) ; 
     std::cout << " SgAsmExecutableFileFormat has size " << sizeOfActualPool << std::endl;
     SgAsmExecutableFileFormatStorageClass* SgAsmExecutableFileFormatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExecutableFileFormatStorageArray = new SgAsmExecutableFileFormatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmExecutableFileFormat::initializeStorageClassArray (SgAsmExecutableFileFormatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmExprListExp ) ; 
     std::cout << " SgAsmExprListExp has size " << sizeOfActualPool << std::endl;
     SgAsmExprListExpStorageClass* SgAsmExprListExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExprListExpStorageArray = new SgAsmExprListExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmExprListExp::initializeStorageClassArray (SgAsmExprListExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmExpression ) ; 
     std::cout << " SgAsmExpression has size " << sizeOfActualPool << std::endl;
     SgAsmExpressionStorageClass* SgAsmExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExpressionStorageArray = new SgAsmExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmExpression::initializeStorageClassArray (SgAsmExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmSynthesizedFieldDeclaration ) ; 
     std::cout << " SgAsmSynthesizedFieldDeclaration has size " << sizeOfActualPool << std::endl;
     SgAsmSynthesizedFieldDeclarationStorageClass* SgAsmSynthesizedFieldDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmSynthesizedFieldDeclarationStorageArray = new SgAsmSynthesizedFieldDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmSynthesizedFieldDeclaration::initializeStorageClassArray (SgAsmSynthesizedFieldDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmFloatType ) ; 
     std::cout << " SgAsmFloatType has size " << sizeOfActualPool << std::endl;
     SgAsmFloatTypeStorageClass* SgAsmFloatTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmFloatTypeStorageArray = new SgAsmFloatTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmFloatType::initializeStorageClassArray (SgAsmFloatTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmFloatValueExpression ) ; 
     std::cout << " SgAsmFloatValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmFloatValueExpressionStorageClass* SgAsmFloatValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmFloatValueExpressionStorageArray = new SgAsmFloatValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmFloatValueExpression::initializeStorageClassArray (SgAsmFloatValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmFunction ) ; 
     std::cout << " SgAsmFunction has size " << sizeOfActualPool << std::endl;
     SgAsmFunctionStorageClass* SgAsmFunctionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmFunctionStorageArray = new SgAsmFunctionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmFunction::initializeStorageClassArray (SgAsmFunctionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericDLL ) ; 
     std::cout << " SgAsmGenericDLL has size " << sizeOfActualPool << std::endl;
     SgAsmGenericDLLStorageClass* SgAsmGenericDLLStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericDLLStorageArray = new SgAsmGenericDLLStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericDLL::initializeStorageClassArray (SgAsmGenericDLLStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericDLLList ) ; 
     std::cout << " SgAsmGenericDLLList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericDLLListStorageClass* SgAsmGenericDLLListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericDLLListStorageArray = new SgAsmGenericDLLListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericDLLList::initializeStorageClassArray (SgAsmGenericDLLListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericFile ) ; 
     std::cout << " SgAsmGenericFile has size " << sizeOfActualPool << std::endl;
     SgAsmGenericFileStorageClass* SgAsmGenericFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFileStorageArray = new SgAsmGenericFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericFile::initializeStorageClassArray (SgAsmGenericFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericFileList ) ; 
     std::cout << " SgAsmGenericFileList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericFileListStorageClass* SgAsmGenericFileListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFileListStorageArray = new SgAsmGenericFileListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericFileList::initializeStorageClassArray (SgAsmGenericFileListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericFormat ) ; 
     std::cout << " SgAsmGenericFormat has size " << sizeOfActualPool << std::endl;
     SgAsmGenericFormatStorageClass* SgAsmGenericFormatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFormatStorageArray = new SgAsmGenericFormatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericFormat::initializeStorageClassArray (SgAsmGenericFormatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericHeader ) ; 
     std::cout << " SgAsmGenericHeader has size " << sizeOfActualPool << std::endl;
     SgAsmGenericHeaderStorageClass* SgAsmGenericHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericHeaderStorageArray = new SgAsmGenericHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericHeader::initializeStorageClassArray (SgAsmGenericHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericHeaderList ) ; 
     std::cout << " SgAsmGenericHeaderList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericHeaderListStorageClass* SgAsmGenericHeaderListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericHeaderListStorageArray = new SgAsmGenericHeaderListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericHeaderList::initializeStorageClassArray (SgAsmGenericHeaderListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericSection ) ; 
     std::cout << " SgAsmGenericSection has size " << sizeOfActualPool << std::endl;
     SgAsmGenericSectionStorageClass* SgAsmGenericSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSectionStorageArray = new SgAsmGenericSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericSection::initializeStorageClassArray (SgAsmGenericSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericSectionList ) ; 
     std::cout << " SgAsmGenericSectionList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericSectionListStorageClass* SgAsmGenericSectionListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSectionListStorageArray = new SgAsmGenericSectionListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericSectionList::initializeStorageClassArray (SgAsmGenericSectionListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericString ) ; 
     std::cout << " SgAsmGenericString has size " << sizeOfActualPool << std::endl;
     SgAsmGenericStringStorageClass* SgAsmGenericStringStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericStringStorageArray = new SgAsmGenericStringStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericString::initializeStorageClassArray (SgAsmGenericStringStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericStrtab ) ; 
     std::cout << " SgAsmGenericStrtab has size " << sizeOfActualPool << std::endl;
     SgAsmGenericStrtabStorageClass* SgAsmGenericStrtabStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericStrtabStorageArray = new SgAsmGenericStrtabStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericStrtab::initializeStorageClassArray (SgAsmGenericStrtabStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericSymbol ) ; 
     std::cout << " SgAsmGenericSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmGenericSymbolStorageClass* SgAsmGenericSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSymbolStorageArray = new SgAsmGenericSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericSymbol::initializeStorageClassArray (SgAsmGenericSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericSymbolList ) ; 
     std::cout << " SgAsmGenericSymbolList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericSymbolListStorageClass* SgAsmGenericSymbolListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSymbolListStorageArray = new SgAsmGenericSymbolListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericSymbolList::initializeStorageClassArray (SgAsmGenericSymbolListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmIndirectRegisterExpression ) ; 
     std::cout << " SgAsmIndirectRegisterExpression has size " << sizeOfActualPool << std::endl;
     SgAsmIndirectRegisterExpressionStorageClass* SgAsmIndirectRegisterExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmIndirectRegisterExpressionStorageArray = new SgAsmIndirectRegisterExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmIndirectRegisterExpression::initializeStorageClassArray (SgAsmIndirectRegisterExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmInstruction ) ; 
     std::cout << " SgAsmInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmInstructionStorageClass* SgAsmInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInstructionStorageArray = new SgAsmInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmInstruction::initializeStorageClassArray (SgAsmInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmIntegerValueExpression ) ; 
     std::cout << " SgAsmIntegerValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmIntegerValueExpressionStorageClass* SgAsmIntegerValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmIntegerValueExpressionStorageArray = new SgAsmIntegerValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmIntegerValueExpression::initializeStorageClassArray (SgAsmIntegerValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmIntegerType ) ; 
     std::cout << " SgAsmIntegerType has size " << sizeOfActualPool << std::endl;
     SgAsmIntegerTypeStorageClass* SgAsmIntegerTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmIntegerTypeStorageArray = new SgAsmIntegerTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmIntegerType::initializeStorageClassArray (SgAsmIntegerTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmInterpretation ) ; 
     std::cout << " SgAsmInterpretation has size " << sizeOfActualPool << std::endl;
     SgAsmInterpretationStorageClass* SgAsmInterpretationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInterpretationStorageArray = new SgAsmInterpretationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmInterpretation::initializeStorageClassArray (SgAsmInterpretationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmInterpretationList ) ; 
     std::cout << " SgAsmInterpretationList has size " << sizeOfActualPool << std::endl;
     SgAsmInterpretationListStorageClass* SgAsmInterpretationListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInterpretationListStorageArray = new SgAsmInterpretationListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmInterpretationList::initializeStorageClassArray (SgAsmInterpretationListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmAttribute ) ; 
     std::cout << " SgAsmJvmAttribute has size " << sizeOfActualPool << std::endl;
     SgAsmJvmAttributeStorageClass* SgAsmJvmAttributeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmAttributeStorageArray = new SgAsmJvmAttributeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmAttribute::initializeStorageClassArray (SgAsmJvmAttributeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmCodeAttribute ) ; 
     std::cout << " SgAsmJvmCodeAttribute has size " << sizeOfActualPool << std::endl;
     SgAsmJvmCodeAttributeStorageClass* SgAsmJvmCodeAttributeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmCodeAttributeStorageArray = new SgAsmJvmCodeAttributeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmCodeAttribute::initializeStorageClassArray (SgAsmJvmCodeAttributeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmMethod ) ; 
     std::cout << " SgAsmJvmMethod has size " << sizeOfActualPool << std::endl;
     SgAsmJvmMethodStorageClass* SgAsmJvmMethodStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmMethodStorageArray = new SgAsmJvmMethodStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmMethod::initializeStorageClassArray (SgAsmJvmMethodStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmConstantPool ) ; 
     std::cout << " SgAsmJvmConstantPool has size " << sizeOfActualPool << std::endl;
     SgAsmJvmConstantPoolStorageClass* SgAsmJvmConstantPoolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmConstantPoolStorageArray = new SgAsmJvmConstantPoolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmConstantPool::initializeStorageClassArray (SgAsmJvmConstantPoolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmConstantPoolEntry ) ; 
     std::cout << " SgAsmJvmConstantPoolEntry has size " << sizeOfActualPool << std::endl;
     SgAsmJvmConstantPoolEntryStorageClass* SgAsmJvmConstantPoolEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmConstantPoolEntryStorageArray = new SgAsmJvmConstantPoolEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmConstantPoolEntry::initializeStorageClassArray (SgAsmJvmConstantPoolEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmConstantValue ) ; 
     std::cout << " SgAsmJvmConstantValue has size " << sizeOfActualPool << std::endl;
     SgAsmJvmConstantValueStorageClass* SgAsmJvmConstantValueStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmConstantValueStorageArray = new SgAsmJvmConstantValueStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmConstantValue::initializeStorageClassArray (SgAsmJvmConstantValueStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmInstruction ) ; 
     std::cout << " SgAsmJvmInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmJvmInstructionStorageClass* SgAsmJvmInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmInstructionStorageArray = new SgAsmJvmInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmInstruction::initializeStorageClassArray (SgAsmJvmInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmFileHeader ) ; 
     std::cout << " SgAsmJvmFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmJvmFileHeaderStorageClass* SgAsmJvmFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmFileHeaderStorageArray = new SgAsmJvmFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmFileHeader::initializeStorageClassArray (SgAsmJvmFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmNode ) ; 
     std::cout << " SgAsmJvmNode has size " << sizeOfActualPool << std::endl;
     SgAsmJvmNodeStorageClass* SgAsmJvmNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmNodeStorageArray = new SgAsmJvmNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmNode::initializeStorageClassArray (SgAsmJvmNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmSignature ) ; 
     std::cout << " SgAsmJvmSignature has size " << sizeOfActualPool << std::endl;
     SgAsmJvmSignatureStorageClass* SgAsmJvmSignatureStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmSignatureStorageArray = new SgAsmJvmSignatureStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmSignature::initializeStorageClassArray (SgAsmJvmSignatureStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmSourceFile ) ; 
     std::cout << " SgAsmJvmSourceFile has size " << sizeOfActualPool << std::endl;
     SgAsmJvmSourceFileStorageClass* SgAsmJvmSourceFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmSourceFileStorageArray = new SgAsmJvmSourceFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmSourceFile::initializeStorageClassArray (SgAsmJvmSourceFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEEntryPoint ) ; 
     std::cout << " SgAsmLEEntryPoint has size " << sizeOfActualPool << std::endl;
     SgAsmLEEntryPointStorageClass* SgAsmLEEntryPointStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEEntryPointStorageArray = new SgAsmLEEntryPointStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEEntryPoint::initializeStorageClassArray (SgAsmLEEntryPointStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEEntryTable ) ; 
     std::cout << " SgAsmLEEntryTable has size " << sizeOfActualPool << std::endl;
     SgAsmLEEntryTableStorageClass* SgAsmLEEntryTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEEntryTableStorageArray = new SgAsmLEEntryTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEEntryTable::initializeStorageClassArray (SgAsmLEEntryTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEFileHeader ) ; 
     std::cout << " SgAsmLEFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmLEFileHeaderStorageClass* SgAsmLEFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEFileHeaderStorageArray = new SgAsmLEFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEFileHeader::initializeStorageClassArray (SgAsmLEFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLENameTable ) ; 
     std::cout << " SgAsmLENameTable has size " << sizeOfActualPool << std::endl;
     SgAsmLENameTableStorageClass* SgAsmLENameTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLENameTableStorageArray = new SgAsmLENameTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLENameTable::initializeStorageClassArray (SgAsmLENameTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEPageTable ) ; 
     std::cout << " SgAsmLEPageTable has size " << sizeOfActualPool << std::endl;
     SgAsmLEPageTableStorageClass* SgAsmLEPageTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEPageTableStorageArray = new SgAsmLEPageTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEPageTable::initializeStorageClassArray (SgAsmLEPageTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEPageTableEntry ) ; 
     std::cout << " SgAsmLEPageTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmLEPageTableEntryStorageClass* SgAsmLEPageTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEPageTableEntryStorageArray = new SgAsmLEPageTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEPageTableEntry::initializeStorageClassArray (SgAsmLEPageTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLERelocTable ) ; 
     std::cout << " SgAsmLERelocTable has size " << sizeOfActualPool << std::endl;
     SgAsmLERelocTableStorageClass* SgAsmLERelocTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLERelocTableStorageArray = new SgAsmLERelocTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLERelocTable::initializeStorageClassArray (SgAsmLERelocTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLESection ) ; 
     std::cout << " SgAsmLESection has size " << sizeOfActualPool << std::endl;
     SgAsmLESectionStorageClass* SgAsmLESectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionStorageArray = new SgAsmLESectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLESection::initializeStorageClassArray (SgAsmLESectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLESectionTable ) ; 
     std::cout << " SgAsmLESectionTable has size " << sizeOfActualPool << std::endl;
     SgAsmLESectionTableStorageClass* SgAsmLESectionTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionTableStorageArray = new SgAsmLESectionTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLESectionTable::initializeStorageClassArray (SgAsmLESectionTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLESectionTableEntry ) ; 
     std::cout << " SgAsmLESectionTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmLESectionTableEntryStorageClass* SgAsmLESectionTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionTableEntryStorageArray = new SgAsmLESectionTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLESectionTableEntry::initializeStorageClassArray (SgAsmLESectionTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmM68kInstruction ) ; 
     std::cout << " SgAsmM68kInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmM68kInstructionStorageClass* SgAsmM68kInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmM68kInstructionStorageArray = new SgAsmM68kInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmM68kInstruction::initializeStorageClassArray (SgAsmM68kInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmMemoryReferenceExpression ) ; 
     std::cout << " SgAsmMemoryReferenceExpression has size " << sizeOfActualPool << std::endl;
     SgAsmMemoryReferenceExpressionStorageClass* SgAsmMemoryReferenceExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmMemoryReferenceExpressionStorageArray = new SgAsmMemoryReferenceExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmMemoryReferenceExpression::initializeStorageClassArray (SgAsmMemoryReferenceExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmMipsInstruction ) ; 
     std::cout << " SgAsmMipsInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmMipsInstructionStorageClass* SgAsmMipsInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmMipsInstructionStorageArray = new SgAsmMipsInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmMipsInstruction::initializeStorageClassArray (SgAsmMipsInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEEntryPoint ) ; 
     std::cout << " SgAsmNEEntryPoint has size " << sizeOfActualPool << std::endl;
     SgAsmNEEntryPointStorageClass* SgAsmNEEntryPointStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEEntryPointStorageArray = new SgAsmNEEntryPointStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEEntryPoint::initializeStorageClassArray (SgAsmNEEntryPointStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEEntryTable ) ; 
     std::cout << " SgAsmNEEntryTable has size " << sizeOfActualPool << std::endl;
     SgAsmNEEntryTableStorageClass* SgAsmNEEntryTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEEntryTableStorageArray = new SgAsmNEEntryTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEEntryTable::initializeStorageClassArray (SgAsmNEEntryTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEFileHeader ) ; 
     std::cout << " SgAsmNEFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmNEFileHeaderStorageClass* SgAsmNEFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEFileHeaderStorageArray = new SgAsmNEFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEFileHeader::initializeStorageClassArray (SgAsmNEFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEModuleTable ) ; 
     std::cout << " SgAsmNEModuleTable has size " << sizeOfActualPool << std::endl;
     SgAsmNEModuleTableStorageClass* SgAsmNEModuleTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEModuleTableStorageArray = new SgAsmNEModuleTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEModuleTable::initializeStorageClassArray (SgAsmNEModuleTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNENameTable ) ; 
     std::cout << " SgAsmNENameTable has size " << sizeOfActualPool << std::endl;
     SgAsmNENameTableStorageClass* SgAsmNENameTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNENameTableStorageArray = new SgAsmNENameTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNENameTable::initializeStorageClassArray (SgAsmNENameTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNERelocEntry ) ; 
     std::cout << " SgAsmNERelocEntry has size " << sizeOfActualPool << std::endl;
     SgAsmNERelocEntryStorageClass* SgAsmNERelocEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNERelocEntryStorageArray = new SgAsmNERelocEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNERelocEntry::initializeStorageClassArray (SgAsmNERelocEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNERelocTable ) ; 
     std::cout << " SgAsmNERelocTable has size " << sizeOfActualPool << std::endl;
     SgAsmNERelocTableStorageClass* SgAsmNERelocTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNERelocTableStorageArray = new SgAsmNERelocTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNERelocTable::initializeStorageClassArray (SgAsmNERelocTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNESection ) ; 
     std::cout << " SgAsmNESection has size " << sizeOfActualPool << std::endl;
     SgAsmNESectionStorageClass* SgAsmNESectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionStorageArray = new SgAsmNESectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNESection::initializeStorageClassArray (SgAsmNESectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNESectionTable ) ; 
     std::cout << " SgAsmNESectionTable has size " << sizeOfActualPool << std::endl;
     SgAsmNESectionTableStorageClass* SgAsmNESectionTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionTableStorageArray = new SgAsmNESectionTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNESectionTable::initializeStorageClassArray (SgAsmNESectionTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNESectionTableEntry ) ; 
     std::cout << " SgAsmNESectionTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmNESectionTableEntryStorageClass* SgAsmNESectionTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionTableEntryStorageArray = new SgAsmNESectionTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNESectionTableEntry::initializeStorageClassArray (SgAsmNESectionTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEStringTable ) ; 
     std::cout << " SgAsmNEStringTable has size " << sizeOfActualPool << std::endl;
     SgAsmNEStringTableStorageClass* SgAsmNEStringTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEStringTableStorageArray = new SgAsmNEStringTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEStringTable::initializeStorageClassArray (SgAsmNEStringTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNode ) ; 
     std::cout << " SgAsmNode has size " << sizeOfActualPool << std::endl;
     SgAsmNodeStorageClass* SgAsmNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNodeStorageArray = new SgAsmNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNode::initializeStorageClassArray (SgAsmNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmOp ) ; 
     std::cout << " SgAsmOp has size " << sizeOfActualPool << std::endl;
     SgAsmOpStorageClass* SgAsmOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmOpStorageArray = new SgAsmOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmOp::initializeStorageClassArray (SgAsmOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmOperandList ) ; 
     std::cout << " SgAsmOperandList has size " << sizeOfActualPool << std::endl;
     SgAsmOperandListStorageClass* SgAsmOperandListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmOperandListStorageArray = new SgAsmOperandListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmOperandList::initializeStorageClassArray (SgAsmOperandListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEExportDirectory ) ; 
     std::cout << " SgAsmPEExportDirectory has size " << sizeOfActualPool << std::endl;
     SgAsmPEExportDirectoryStorageClass* SgAsmPEExportDirectoryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportDirectoryStorageArray = new SgAsmPEExportDirectoryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEExportDirectory::initializeStorageClassArray (SgAsmPEExportDirectoryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEExportEntry ) ; 
     std::cout << " SgAsmPEExportEntry has size " << sizeOfActualPool << std::endl;
     SgAsmPEExportEntryStorageClass* SgAsmPEExportEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportEntryStorageArray = new SgAsmPEExportEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEExportEntry::initializeStorageClassArray (SgAsmPEExportEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEExportEntryList ) ; 
     std::cout << " SgAsmPEExportEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmPEExportEntryListStorageClass* SgAsmPEExportEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportEntryListStorageArray = new SgAsmPEExportEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEExportEntryList::initializeStorageClassArray (SgAsmPEExportEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEExportSection ) ; 
     std::cout << " SgAsmPEExportSection has size " << sizeOfActualPool << std::endl;
     SgAsmPEExportSectionStorageClass* SgAsmPEExportSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportSectionStorageArray = new SgAsmPEExportSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEExportSection::initializeStorageClassArray (SgAsmPEExportSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEFileHeader ) ; 
     std::cout << " SgAsmPEFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmPEFileHeaderStorageClass* SgAsmPEFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEFileHeaderStorageArray = new SgAsmPEFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEFileHeader::initializeStorageClassArray (SgAsmPEFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportDirectory ) ; 
     std::cout << " SgAsmPEImportDirectory has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportDirectoryStorageClass* SgAsmPEImportDirectoryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportDirectoryStorageArray = new SgAsmPEImportDirectoryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportDirectory::initializeStorageClassArray (SgAsmPEImportDirectoryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportDirectoryList ) ; 
     std::cout << " SgAsmPEImportDirectoryList has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportDirectoryListStorageClass* SgAsmPEImportDirectoryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportDirectoryListStorageArray = new SgAsmPEImportDirectoryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportDirectoryList::initializeStorageClassArray (SgAsmPEImportDirectoryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportItem ) ; 
     std::cout << " SgAsmPEImportItem has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportItemStorageClass* SgAsmPEImportItemStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportItemStorageArray = new SgAsmPEImportItemStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportItem::initializeStorageClassArray (SgAsmPEImportItemStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportItemList ) ; 
     std::cout << " SgAsmPEImportItemList has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportItemListStorageClass* SgAsmPEImportItemListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportItemListStorageArray = new SgAsmPEImportItemListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportItemList::initializeStorageClassArray (SgAsmPEImportItemListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportSection ) ; 
     std::cout << " SgAsmPEImportSection has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportSectionStorageClass* SgAsmPEImportSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportSectionStorageArray = new SgAsmPEImportSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportSection::initializeStorageClassArray (SgAsmPEImportSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPERVASizePair ) ; 
     std::cout << " SgAsmPERVASizePair has size " << sizeOfActualPool << std::endl;
     SgAsmPERVASizePairStorageClass* SgAsmPERVASizePairStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPERVASizePairStorageArray = new SgAsmPERVASizePairStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPERVASizePair::initializeStorageClassArray (SgAsmPERVASizePairStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPERVASizePairList ) ; 
     std::cout << " SgAsmPERVASizePairList has size " << sizeOfActualPool << std::endl;
     SgAsmPERVASizePairListStorageClass* SgAsmPERVASizePairListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPERVASizePairListStorageArray = new SgAsmPERVASizePairListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPERVASizePairList::initializeStorageClassArray (SgAsmPERVASizePairListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPESection ) ; 
     std::cout << " SgAsmPESection has size " << sizeOfActualPool << std::endl;
     SgAsmPESectionStorageClass* SgAsmPESectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionStorageArray = new SgAsmPESectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPESection::initializeStorageClassArray (SgAsmPESectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPESectionTable ) ; 
     std::cout << " SgAsmPESectionTable has size " << sizeOfActualPool << std::endl;
     SgAsmPESectionTableStorageClass* SgAsmPESectionTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionTableStorageArray = new SgAsmPESectionTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPESectionTable::initializeStorageClassArray (SgAsmPESectionTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPESectionTableEntry ) ; 
     std::cout << " SgAsmPESectionTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmPESectionTableEntryStorageClass* SgAsmPESectionTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionTableEntryStorageArray = new SgAsmPESectionTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPESectionTableEntry::initializeStorageClassArray (SgAsmPESectionTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEStringSection ) ; 
     std::cout << " SgAsmPEStringSection has size " << sizeOfActualPool << std::endl;
     SgAsmPEStringSectionStorageClass* SgAsmPEStringSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEStringSectionStorageArray = new SgAsmPEStringSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEStringSection::initializeStorageClassArray (SgAsmPEStringSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPowerpcInstruction ) ; 
     std::cout << " SgAsmPowerpcInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmPowerpcInstructionStorageClass* SgAsmPowerpcInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPowerpcInstructionStorageArray = new SgAsmPowerpcInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPowerpcInstruction::initializeStorageClassArray (SgAsmPowerpcInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmRegisterNames ) ; 
     std::cout << " SgAsmRegisterNames has size " << sizeOfActualPool << std::endl;
     SgAsmRegisterNamesStorageClass* SgAsmRegisterNamesStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmRegisterNamesStorageArray = new SgAsmRegisterNamesStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmRegisterNames::initializeStorageClassArray (SgAsmRegisterNamesStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmRegisterReferenceExpression ) ; 
     std::cout << " SgAsmRegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     SgAsmRegisterReferenceExpressionStorageClass* SgAsmRegisterReferenceExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmRegisterReferenceExpressionStorageArray = new SgAsmRegisterReferenceExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmRegisterReferenceExpression::initializeStorageClassArray (SgAsmRegisterReferenceExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmRiscOperation ) ; 
     std::cout << " SgAsmRiscOperation has size " << sizeOfActualPool << std::endl;
     SgAsmRiscOperationStorageClass* SgAsmRiscOperationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmRiscOperationStorageArray = new SgAsmRiscOperationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmRiscOperation::initializeStorageClassArray (SgAsmRiscOperationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmScalarType ) ; 
     std::cout << " SgAsmScalarType has size " << sizeOfActualPool << std::endl;
     SgAsmScalarTypeStorageClass* SgAsmScalarTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmScalarTypeStorageArray = new SgAsmScalarTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmScalarType::initializeStorageClassArray (SgAsmScalarTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStatement ) ; 
     std::cout << " SgAsmStatement has size " << sizeOfActualPool << std::endl;
     SgAsmStatementStorageClass* SgAsmStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStatementStorageArray = new SgAsmStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStatement::initializeStorageClassArray (SgAsmStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStaticData ) ; 
     std::cout << " SgAsmStaticData has size " << sizeOfActualPool << std::endl;
     SgAsmStaticDataStorageClass* SgAsmStaticDataStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStaticDataStorageArray = new SgAsmStaticDataStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStaticData::initializeStorageClassArray (SgAsmStaticDataStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStmt ) ; 
     std::cout << " SgAsmStmt has size " << sizeOfActualPool << std::endl;
     SgAsmStmtStorageClass* SgAsmStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStmtStorageArray = new SgAsmStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStmt::initializeStorageClassArray (SgAsmStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStoredString ) ; 
     std::cout << " SgAsmStoredString has size " << sizeOfActualPool << std::endl;
     SgAsmStoredStringStorageClass* SgAsmStoredStringStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStoredStringStorageArray = new SgAsmStoredStringStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStoredString::initializeStorageClassArray (SgAsmStoredStringStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStringStorage ) ; 
     std::cout << " SgAsmStringStorage has size " << sizeOfActualPool << std::endl;
     SgAsmStringStorageStorageClass* SgAsmStringStorageStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStringStorageStorageArray = new SgAsmStringStorageStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStringStorage::initializeStorageClassArray (SgAsmStringStorageStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmType ) ; 
     std::cout << " SgAsmType has size " << sizeOfActualPool << std::endl;
     SgAsmTypeStorageClass* SgAsmTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeStorageArray = new SgAsmTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmType::initializeStorageClassArray (SgAsmTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryExpression ) ; 
     std::cout << " SgAsmUnaryExpression has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryExpressionStorageClass* SgAsmUnaryExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryExpressionStorageArray = new SgAsmUnaryExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryExpression::initializeStorageClassArray (SgAsmUnaryExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryMinus ) ; 
     std::cout << " SgAsmUnaryMinus has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryMinusStorageClass* SgAsmUnaryMinusStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryMinusStorageArray = new SgAsmUnaryMinusStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryMinus::initializeStorageClassArray (SgAsmUnaryMinusStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryPlus ) ; 
     std::cout << " SgAsmUnaryPlus has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryPlusStorageClass* SgAsmUnaryPlusStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryPlusStorageArray = new SgAsmUnaryPlusStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryPlus::initializeStorageClassArray (SgAsmUnaryPlusStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryRrx ) ; 
     std::cout << " SgAsmUnaryRrx has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryRrxStorageClass* SgAsmUnaryRrxStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryRrxStorageArray = new SgAsmUnaryRrxStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryRrx::initializeStorageClassArray (SgAsmUnaryRrxStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnarySignedExtend ) ; 
     std::cout << " SgAsmUnarySignedExtend has size " << sizeOfActualPool << std::endl;
     SgAsmUnarySignedExtendStorageClass* SgAsmUnarySignedExtendStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnarySignedExtendStorageArray = new SgAsmUnarySignedExtendStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnarySignedExtend::initializeStorageClassArray (SgAsmUnarySignedExtendStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryUnsignedExtend ) ; 
     std::cout << " SgAsmUnaryUnsignedExtend has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryUnsignedExtendStorageClass* SgAsmUnaryUnsignedExtendStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryUnsignedExtendStorageArray = new SgAsmUnaryUnsignedExtendStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryUnsignedExtend::initializeStorageClassArray (SgAsmUnaryUnsignedExtendStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryTruncate ) ; 
     std::cout << " SgAsmUnaryTruncate has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryTruncateStorageClass* SgAsmUnaryTruncateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryTruncateStorageArray = new SgAsmUnaryTruncateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryTruncate::initializeStorageClassArray (SgAsmUnaryTruncateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmValueExpression ) ; 
     std::cout << " SgAsmValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmValueExpressionStorageClass* SgAsmValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmValueExpressionStorageArray = new SgAsmValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmValueExpression::initializeStorageClassArray (SgAsmValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmVectorType ) ; 
     std::cout << " SgAsmVectorType has size " << sizeOfActualPool << std::endl;
     SgAsmVectorTypeStorageClass* SgAsmVectorTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmVectorTypeStorageArray = new SgAsmVectorTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmVectorType::initializeStorageClassArray (SgAsmVectorTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmX86Instruction ) ; 
     std::cout << " SgAsmX86Instruction has size " << sizeOfActualPool << std::endl;
     SgAsmX86InstructionStorageClass* SgAsmX86InstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmX86InstructionStorageArray = new SgAsmX86InstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmX86Instruction::initializeStorageClassArray (SgAsmX86InstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryAddressSymbol ) ; 
     std::cout << " SgAsmBinaryAddressSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryAddressSymbolStorageClass* SgAsmBinaryAddressSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddressSymbolStorageArray = new SgAsmBinaryAddressSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryAddressSymbol::initializeStorageClassArray (SgAsmBinaryAddressSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryDataSymbol ) ; 
     std::cout << " SgAsmBinaryDataSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryDataSymbolStorageClass* SgAsmBinaryDataSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryDataSymbolStorageArray = new SgAsmBinaryDataSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryDataSymbol::initializeStorageClassArray (SgAsmBinaryDataSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssertStmt ) ; 
     std::cout << " SgAssertStmt has size " << sizeOfActualPool << std::endl;
     SgAssertStmtStorageClass* SgAssertStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssertStmtStorageArray = new SgAssertStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssertStmt::initializeStorageClassArray (SgAssertStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssignInitializer ) ; 
     std::cout << " SgAssignInitializer has size " << sizeOfActualPool << std::endl;
     SgAssignInitializerStorageClass* SgAssignInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignInitializerStorageArray = new SgAssignInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssignInitializer::initializeStorageClassArray (SgAssignInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssignOp ) ; 
     std::cout << " SgAssignOp has size " << sizeOfActualPool << std::endl;
     SgAssignOpStorageClass* SgAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignOpStorageArray = new SgAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssignOp::initializeStorageClassArray (SgAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssignStatement ) ; 
     std::cout << " SgAssignStatement has size " << sizeOfActualPool << std::endl;
     SgAssignStatementStorageClass* SgAssignStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignStatementStorageArray = new SgAssignStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssignStatement::initializeStorageClassArray (SgAssignStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssignedGotoStatement ) ; 
     std::cout << " SgAssignedGotoStatement has size " << sizeOfActualPool << std::endl;
     SgAssignedGotoStatementStorageClass* SgAssignedGotoStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignedGotoStatementStorageArray = new SgAssignedGotoStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssignedGotoStatement::initializeStorageClassArray (SgAssignedGotoStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssociateStatement ) ; 
     std::cout << " SgAssociateStatement has size " << sizeOfActualPool << std::endl;
     SgAssociateStatementStorageClass* SgAssociateStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssociateStatementStorageArray = new SgAssociateStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssociateStatement::initializeStorageClassArray (SgAssociateStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsteriskShapeExp ) ; 
     std::cout << " SgAsteriskShapeExp has size " << sizeOfActualPool << std::endl;
     SgAsteriskShapeExpStorageClass* SgAsteriskShapeExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsteriskShapeExpStorageArray = new SgAsteriskShapeExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsteriskShapeExp::initializeStorageClassArray (SgAsteriskShapeExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAtOp ) ; 
     std::cout << " SgAtOp has size " << sizeOfActualPool << std::endl;
     SgAtOpStorageClass* SgAtOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAtOpStorageArray = new SgAtOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAtOp::initializeStorageClassArray (SgAtOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAttribute ) ; 
     std::cout << " SgAttribute has size " << sizeOfActualPool << std::endl;
     SgAttributeStorageClass* SgAttributeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAttributeStorageArray = new SgAttributeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAttribute::initializeStorageClassArray (SgAttributeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAttributeSpecificationStatement ) ; 
     std::cout << " SgAttributeSpecificationStatement has size " << sizeOfActualPool << std::endl;
     SgAttributeSpecificationStatementStorageClass* SgAttributeSpecificationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAttributeSpecificationStatementStorageArray = new SgAttributeSpecificationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAttributeSpecificationStatement::initializeStorageClassArray (SgAttributeSpecificationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAutoType ) ; 
     std::cout << " SgAutoType has size " << sizeOfActualPool << std::endl;
     SgAutoTypeStorageClass* SgAutoTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAutoTypeStorageArray = new SgAutoTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAutoType::initializeStorageClassArray (SgAutoTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAwaitExpression ) ; 
     std::cout << " SgAwaitExpression has size " << sizeOfActualPool << std::endl;
     SgAwaitExpressionStorageClass* SgAwaitExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAwaitExpressionStorageArray = new SgAwaitExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAwaitExpression::initializeStorageClassArray (SgAwaitExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBackspaceStatement ) ; 
     std::cout << " SgBackspaceStatement has size " << sizeOfActualPool << std::endl;
     SgBackspaceStatementStorageClass* SgBackspaceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBackspaceStatementStorageArray = new SgBackspaceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBackspaceStatement::initializeStorageClassArray (SgBackspaceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBaseClass ) ; 
     std::cout << " SgBaseClass has size " << sizeOfActualPool << std::endl;
     SgBaseClassStorageClass* SgBaseClassStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBaseClassStorageArray = new SgBaseClassStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBaseClass::initializeStorageClassArray (SgBaseClassStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExpBaseClass ) ; 
     std::cout << " SgExpBaseClass has size " << sizeOfActualPool << std::endl;
     SgExpBaseClassStorageClass* SgExpBaseClassStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpBaseClassStorageArray = new SgExpBaseClassStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExpBaseClass::initializeStorageClassArray (SgExpBaseClassStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBaseClassModifier ) ; 
     std::cout << " SgBaseClassModifier has size " << sizeOfActualPool << std::endl;
     SgBaseClassModifierStorageClass* SgBaseClassModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBaseClassModifierStorageArray = new SgBaseClassModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBaseClassModifier::initializeStorageClassArray (SgBaseClassModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBasicBlock ) ; 
     std::cout << " SgBasicBlock has size " << sizeOfActualPool << std::endl;
     SgBasicBlockStorageClass* SgBasicBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBasicBlockStorageArray = new SgBasicBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBasicBlock::initializeStorageClassArray (SgBasicBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBidirectionalGraph ) ; 
     std::cout << " SgBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     SgBidirectionalGraphStorageClass* SgBidirectionalGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBidirectionalGraphStorageArray = new SgBidirectionalGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBidirectionalGraph::initializeStorageClassArray (SgBidirectionalGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBinaryComposite ) ; 
     std::cout << " SgBinaryComposite has size " << sizeOfActualPool << std::endl;
     SgBinaryCompositeStorageClass* SgBinaryCompositeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBinaryCompositeStorageArray = new SgBinaryCompositeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBinaryComposite::initializeStorageClassArray (SgBinaryCompositeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBinaryOp ) ; 
     std::cout << " SgBinaryOp has size " << sizeOfActualPool << std::endl;
     SgBinaryOpStorageClass* SgBinaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBinaryOpStorageArray = new SgBinaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBinaryOp::initializeStorageClassArray (SgBinaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitAndOp ) ; 
     std::cout << " SgBitAndOp has size " << sizeOfActualPool << std::endl;
     SgBitAndOpStorageClass* SgBitAndOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitAndOpStorageArray = new SgBitAndOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitAndOp::initializeStorageClassArray (SgBitAndOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitAttribute ) ; 
     std::cout << " SgBitAttribute has size " << sizeOfActualPool << std::endl;
     SgBitAttributeStorageClass* SgBitAttributeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitAttributeStorageArray = new SgBitAttributeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitAttribute::initializeStorageClassArray (SgBitAttributeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitComplementOp ) ; 
     std::cout << " SgBitComplementOp has size " << sizeOfActualPool << std::endl;
     SgBitComplementOpStorageClass* SgBitComplementOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitComplementOpStorageArray = new SgBitComplementOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitComplementOp::initializeStorageClassArray (SgBitComplementOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitEqvOp ) ; 
     std::cout << " SgBitEqvOp has size " << sizeOfActualPool << std::endl;
     SgBitEqvOpStorageClass* SgBitEqvOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitEqvOpStorageArray = new SgBitEqvOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitEqvOp::initializeStorageClassArray (SgBitEqvOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitOrOp ) ; 
     std::cout << " SgBitOrOp has size " << sizeOfActualPool << std::endl;
     SgBitOrOpStorageClass* SgBitOrOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitOrOpStorageArray = new SgBitOrOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitOrOp::initializeStorageClassArray (SgBitOrOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitXorOp ) ; 
     std::cout << " SgBitXorOp has size " << sizeOfActualPool << std::endl;
     SgBitXorOpStorageClass* SgBitXorOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitXorOpStorageArray = new SgBitXorOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitXorOp::initializeStorageClassArray (SgBitXorOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBlockDataStatement ) ; 
     std::cout << " SgBlockDataStatement has size " << sizeOfActualPool << std::endl;
     SgBlockDataStatementStorageClass* SgBlockDataStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBlockDataStatementStorageArray = new SgBlockDataStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBlockDataStatement::initializeStorageClassArray (SgBlockDataStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBoolValExp ) ; 
     std::cout << " SgBoolValExp has size " << sizeOfActualPool << std::endl;
     SgBoolValExpStorageClass* SgBoolValExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBoolValExpStorageArray = new SgBoolValExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBoolValExp::initializeStorageClassArray (SgBoolValExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBreakStmt ) ; 
     std::cout << " SgBreakStmt has size " << sizeOfActualPool << std::endl;
     SgBreakStmtStorageClass* SgBreakStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBreakStmtStorageArray = new SgBreakStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBreakStmt::initializeStorageClassArray (SgBreakStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBracedInitializer ) ; 
     std::cout << " SgBracedInitializer has size " << sizeOfActualPool << std::endl;
     SgBracedInitializerStorageClass* SgBracedInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBracedInitializerStorageArray = new SgBracedInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBracedInitializer::initializeStorageClassArray (SgBracedInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgC_PreprocessorDirectiveStatement ) ; 
     std::cout << " SgC_PreprocessorDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgC_PreprocessorDirectiveStatementStorageClass* SgC_PreprocessorDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgC_PreprocessorDirectiveStatementStorageArray = new SgC_PreprocessorDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgC_PreprocessorDirectiveStatement::initializeStorageClassArray (SgC_PreprocessorDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCaseOptionStmt ) ; 
     std::cout << " SgCaseOptionStmt has size " << sizeOfActualPool << std::endl;
     SgCaseOptionStmtStorageClass* SgCaseOptionStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCaseOptionStmtStorageArray = new SgCaseOptionStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCaseOptionStmt::initializeStorageClassArray (SgCaseOptionStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCastExp ) ; 
     std::cout << " SgCastExp has size " << sizeOfActualPool << std::endl;
     SgCastExpStorageClass* SgCastExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCastExpStorageArray = new SgCastExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCastExp::initializeStorageClassArray (SgCastExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCatchOptionStmt ) ; 
     std::cout << " SgCatchOptionStmt has size " << sizeOfActualPool << std::endl;
     SgCatchOptionStmtStorageClass* SgCatchOptionStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCatchOptionStmtStorageArray = new SgCatchOptionStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCatchOptionStmt::initializeStorageClassArray (SgCatchOptionStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCatchStatementSeq ) ; 
     std::cout << " SgCatchStatementSeq has size " << sizeOfActualPool << std::endl;
     SgCatchStatementSeqStorageClass* SgCatchStatementSeqStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCatchStatementSeqStorageArray = new SgCatchStatementSeqStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCatchStatementSeq::initializeStorageClassArray (SgCatchStatementSeqStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCharVal ) ; 
     std::cout << " SgCharVal has size " << sizeOfActualPool << std::endl;
     SgCharValStorageClass* SgCharValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCharValStorageArray = new SgCharValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCharVal::initializeStorageClassArray (SgCharValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgChar16Val ) ; 
     std::cout << " SgChar16Val has size " << sizeOfActualPool << std::endl;
     SgChar16ValStorageClass* SgChar16ValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgChar16ValStorageArray = new SgChar16ValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgChar16Val::initializeStorageClassArray (SgChar16ValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgChar32Val ) ; 
     std::cout << " SgChar32Val has size " << sizeOfActualPool << std::endl;
     SgChar32ValStorageClass* SgChar32ValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgChar32ValStorageArray = new SgChar32ValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgChar32Val::initializeStorageClassArray (SgChar32ValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgChooseExpression ) ; 
     std::cout << " SgChooseExpression has size " << sizeOfActualPool << std::endl;
     SgChooseExpressionStorageClass* SgChooseExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgChooseExpressionStorageArray = new SgChooseExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgChooseExpression::initializeStorageClassArray (SgChooseExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassDecl_attr ) ; 
     std::cout << " SgClassDecl_attr has size " << sizeOfActualPool << std::endl;
     SgClassDecl_attrStorageClass* SgClassDecl_attrStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDecl_attrStorageArray = new SgClassDecl_attrStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassDecl_attr::initializeStorageClassArray (SgClassDecl_attrStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassDeclaration ) ; 
     std::cout << " SgClassDeclaration has size " << sizeOfActualPool << std::endl;
     SgClassDeclarationStorageClass* SgClassDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDeclarationStorageArray = new SgClassDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassDeclaration::initializeStorageClassArray (SgClassDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassDefinition ) ; 
     std::cout << " SgClassDefinition has size " << sizeOfActualPool << std::endl;
     SgClassDefinitionStorageClass* SgClassDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDefinitionStorageArray = new SgClassDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassDefinition::initializeStorageClassArray (SgClassDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassNameRefExp ) ; 
     std::cout << " SgClassNameRefExp has size " << sizeOfActualPool << std::endl;
     SgClassNameRefExpStorageClass* SgClassNameRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassNameRefExpStorageArray = new SgClassNameRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassNameRefExp::initializeStorageClassArray (SgClassNameRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassSymbol ) ; 
     std::cout << " SgClassSymbol has size " << sizeOfActualPool << std::endl;
     SgClassSymbolStorageClass* SgClassSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassSymbolStorageArray = new SgClassSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassSymbol::initializeStorageClassArray (SgClassSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassType ) ; 
     std::cout << " SgClassType has size " << sizeOfActualPool << std::endl;
     SgClassTypeStorageClass* SgClassTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassTypeStorageArray = new SgClassTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassType::initializeStorageClassArray (SgClassTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClinkageDeclarationStatement ) ; 
     std::cout << " SgClinkageDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgClinkageDeclarationStatementStorageClass* SgClinkageDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageDeclarationStatementStorageArray = new SgClinkageDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClinkageDeclarationStatement::initializeStorageClassArray (SgClinkageDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClinkageEndStatement ) ; 
     std::cout << " SgClinkageEndStatement has size " << sizeOfActualPool << std::endl;
     SgClinkageEndStatementStorageClass* SgClinkageEndStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageEndStatementStorageArray = new SgClinkageEndStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClinkageEndStatement::initializeStorageClassArray (SgClinkageEndStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClinkageStartStatement ) ; 
     std::cout << " SgClinkageStartStatement has size " << sizeOfActualPool << std::endl;
     SgClinkageStartStatementStorageClass* SgClinkageStartStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageStartStatementStorageArray = new SgClinkageStartStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClinkageStartStatement::initializeStorageClassArray (SgClinkageStartStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCloseStatement ) ; 
     std::cout << " SgCloseStatement has size " << sizeOfActualPool << std::endl;
     SgCloseStatementStorageClass* SgCloseStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCloseStatementStorageArray = new SgCloseStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCloseStatement::initializeStorageClassArray (SgCloseStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgColonShapeExp ) ; 
     std::cout << " SgColonShapeExp has size " << sizeOfActualPool << std::endl;
     SgColonShapeExpStorageClass* SgColonShapeExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgColonShapeExpStorageArray = new SgColonShapeExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgColonShapeExp::initializeStorageClassArray (SgColonShapeExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCommaOpExp ) ; 
     std::cout << " SgCommaOpExp has size " << sizeOfActualPool << std::endl;
     SgCommaOpExpStorageClass* SgCommaOpExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommaOpExpStorageArray = new SgCommaOpExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCommaOpExp::initializeStorageClassArray (SgCommaOpExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCommonBlock ) ; 
     std::cout << " SgCommonBlock has size " << sizeOfActualPool << std::endl;
     SgCommonBlockStorageClass* SgCommonBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonBlockStorageArray = new SgCommonBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCommonBlock::initializeStorageClassArray (SgCommonBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCommonBlockObject ) ; 
     std::cout << " SgCommonBlockObject has size " << sizeOfActualPool << std::endl;
     SgCommonBlockObjectStorageClass* SgCommonBlockObjectStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonBlockObjectStorageArray = new SgCommonBlockObjectStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCommonBlockObject::initializeStorageClassArray (SgCommonBlockObjectStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCommonSymbol ) ; 
     std::cout << " SgCommonSymbol has size " << sizeOfActualPool << std::endl;
     SgCommonSymbolStorageClass* SgCommonSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonSymbolStorageArray = new SgCommonSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCommonSymbol::initializeStorageClassArray (SgCommonSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgComplexVal ) ; 
     std::cout << " SgComplexVal has size " << sizeOfActualPool << std::endl;
     SgComplexValStorageClass* SgComplexValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComplexValStorageArray = new SgComplexValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgComplexVal::initializeStorageClassArray (SgComplexValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgComprehension ) ; 
     std::cout << " SgComprehension has size " << sizeOfActualPool << std::endl;
     SgComprehensionStorageClass* SgComprehensionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComprehensionStorageArray = new SgComprehensionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgComprehension::initializeStorageClassArray (SgComprehensionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCompoundAssignOp ) ; 
     std::cout << " SgCompoundAssignOp has size " << sizeOfActualPool << std::endl;
     SgCompoundAssignOpStorageClass* SgCompoundAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundAssignOpStorageArray = new SgCompoundAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCompoundAssignOp::initializeStorageClassArray (SgCompoundAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCompoundInitializer ) ; 
     std::cout << " SgCompoundInitializer has size " << sizeOfActualPool << std::endl;
     SgCompoundInitializerStorageClass* SgCompoundInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundInitializerStorageArray = new SgCompoundInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCompoundInitializer::initializeStorageClassArray (SgCompoundInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCompoundLiteralExp ) ; 
     std::cout << " SgCompoundLiteralExp has size " << sizeOfActualPool << std::endl;
     SgCompoundLiteralExpStorageClass* SgCompoundLiteralExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundLiteralExpStorageArray = new SgCompoundLiteralExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCompoundLiteralExp::initializeStorageClassArray (SgCompoundLiteralExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgComputedGotoStatement ) ; 
     std::cout << " SgComputedGotoStatement has size " << sizeOfActualPool << std::endl;
     SgComputedGotoStatementStorageClass* SgComputedGotoStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComputedGotoStatementStorageArray = new SgComputedGotoStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgComputedGotoStatement::initializeStorageClassArray (SgComputedGotoStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConcatenationOp ) ; 
     std::cout << " SgConcatenationOp has size " << sizeOfActualPool << std::endl;
     SgConcatenationOpStorageClass* SgConcatenationOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConcatenationOpStorageArray = new SgConcatenationOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConcatenationOp::initializeStorageClassArray (SgConcatenationOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConditionalExp ) ; 
     std::cout << " SgConditionalExp has size " << sizeOfActualPool << std::endl;
     SgConditionalExpStorageClass* SgConditionalExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConditionalExpStorageArray = new SgConditionalExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConditionalExp::initializeStorageClassArray (SgConditionalExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConjugateOp ) ; 
     std::cout << " SgConjugateOp has size " << sizeOfActualPool << std::endl;
     SgConjugateOpStorageClass* SgConjugateOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConjugateOpStorageArray = new SgConjugateOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConjugateOp::initializeStorageClassArray (SgConjugateOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConstVolatileModifier ) ; 
     std::cout << " SgConstVolatileModifier has size " << sizeOfActualPool << std::endl;
     SgConstVolatileModifierStorageClass* SgConstVolatileModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConstVolatileModifierStorageArray = new SgConstVolatileModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConstVolatileModifier::initializeStorageClassArray (SgConstVolatileModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConstructorInitializer ) ; 
     std::cout << " SgConstructorInitializer has size " << sizeOfActualPool << std::endl;
     SgConstructorInitializerStorageClass* SgConstructorInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConstructorInitializerStorageArray = new SgConstructorInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConstructorInitializer::initializeStorageClassArray (SgConstructorInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgContainsStatement ) ; 
     std::cout << " SgContainsStatement has size " << sizeOfActualPool << std::endl;
     SgContainsStatementStorageClass* SgContainsStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgContainsStatementStorageArray = new SgContainsStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgContainsStatement::initializeStorageClassArray (SgContainsStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgContinueStmt ) ; 
     std::cout << " SgContinueStmt has size " << sizeOfActualPool << std::endl;
     SgContinueStmtStorageClass* SgContinueStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgContinueStmtStorageArray = new SgContinueStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgContinueStmt::initializeStorageClassArray (SgContinueStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCtorInitializerList ) ; 
     std::cout << " SgCtorInitializerList has size " << sizeOfActualPool << std::endl;
     SgCtorInitializerListStorageClass* SgCtorInitializerListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCtorInitializerListStorageArray = new SgCtorInitializerListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCtorInitializerList::initializeStorageClassArray (SgCtorInitializerListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDataStatementGroup ) ; 
     std::cout << " SgDataStatementGroup has size " << sizeOfActualPool << std::endl;
     SgDataStatementGroupStorageClass* SgDataStatementGroupStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementGroupStorageArray = new SgDataStatementGroupStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDataStatementGroup::initializeStorageClassArray (SgDataStatementGroupStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDataStatementObject ) ; 
     std::cout << " SgDataStatementObject has size " << sizeOfActualPool << std::endl;
     SgDataStatementObjectStorageClass* SgDataStatementObjectStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementObjectStorageArray = new SgDataStatementObjectStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDataStatementObject::initializeStorageClassArray (SgDataStatementObjectStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDataStatementValue ) ; 
     std::cout << " SgDataStatementValue has size " << sizeOfActualPool << std::endl;
     SgDataStatementValueStorageClass* SgDataStatementValueStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementValueStorageArray = new SgDataStatementValueStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDataStatementValue::initializeStorageClassArray (SgDataStatementValueStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeadIfDirectiveStatement ) ; 
     std::cout << " SgDeadIfDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgDeadIfDirectiveStatementStorageClass* SgDeadIfDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeadIfDirectiveStatementStorageArray = new SgDeadIfDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeadIfDirectiveStatement::initializeStorageClassArray (SgDeadIfDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeallocateStatement ) ; 
     std::cout << " SgDeallocateStatement has size " << sizeOfActualPool << std::endl;
     SgDeallocateStatementStorageClass* SgDeallocateStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeallocateStatementStorageArray = new SgDeallocateStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeallocateStatement::initializeStorageClassArray (SgDeallocateStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeclarationModifier ) ; 
     std::cout << " SgDeclarationModifier has size " << sizeOfActualPool << std::endl;
     SgDeclarationModifierStorageClass* SgDeclarationModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationModifierStorageArray = new SgDeclarationModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeclarationModifier::initializeStorageClassArray (SgDeclarationModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeclarationScope ) ; 
     std::cout << " SgDeclarationScope has size " << sizeOfActualPool << std::endl;
     SgDeclarationScopeStorageClass* SgDeclarationScopeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationScopeStorageArray = new SgDeclarationScopeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeclarationScope::initializeStorageClassArray (SgDeclarationScopeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeclarationStatement ) ; 
     std::cout << " SgDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgDeclarationStatementStorageClass* SgDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationStatementStorageArray = new SgDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeclarationStatement::initializeStorageClassArray (SgDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeclType ) ; 
     std::cout << " SgDeclType has size " << sizeOfActualPool << std::endl;
     SgDeclTypeStorageClass* SgDeclTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclTypeStorageArray = new SgDeclTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeclType::initializeStorageClassArray (SgDeclTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDefaultOptionStmt ) ; 
     std::cout << " SgDefaultOptionStmt has size " << sizeOfActualPool << std::endl;
     SgDefaultOptionStmtStorageClass* SgDefaultOptionStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefaultOptionStmtStorageArray = new SgDefaultOptionStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDefaultOptionStmt::initializeStorageClassArray (SgDefaultOptionStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDefaultSymbol ) ; 
     std::cout << " SgDefaultSymbol has size " << sizeOfActualPool << std::endl;
     SgDefaultSymbolStorageClass* SgDefaultSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefaultSymbolStorageArray = new SgDefaultSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDefaultSymbol::initializeStorageClassArray (SgDefaultSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDefineDirectiveStatement ) ; 
     std::cout << " SgDefineDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgDefineDirectiveStatementStorageClass* SgDefineDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefineDirectiveStatementStorageArray = new SgDefineDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDefineDirectiveStatement::initializeStorageClassArray (SgDefineDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeleteExp ) ; 
     std::cout << " SgDeleteExp has size " << sizeOfActualPool << std::endl;
     SgDeleteExpStorageClass* SgDeleteExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeleteExpStorageArray = new SgDeleteExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeleteExp::initializeStorageClassArray (SgDeleteExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDerivedTypeStatement ) ; 
     std::cout << " SgDerivedTypeStatement has size " << sizeOfActualPool << std::endl;
     SgDerivedTypeStatementStorageClass* SgDerivedTypeStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDerivedTypeStatementStorageArray = new SgDerivedTypeStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDerivedTypeStatement::initializeStorageClassArray (SgDerivedTypeStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDesignatedInitializer ) ; 
     std::cout << " SgDesignatedInitializer has size " << sizeOfActualPool << std::endl;
     SgDesignatedInitializerStorageClass* SgDesignatedInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDesignatedInitializerStorageArray = new SgDesignatedInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDesignatedInitializer::initializeStorageClassArray (SgDesignatedInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDictionaryComprehension ) ; 
     std::cout << " SgDictionaryComprehension has size " << sizeOfActualPool << std::endl;
     SgDictionaryComprehensionStorageClass* SgDictionaryComprehensionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDictionaryComprehensionStorageArray = new SgDictionaryComprehensionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDictionaryComprehension::initializeStorageClassArray (SgDictionaryComprehensionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDictionaryExp ) ; 
     std::cout << " SgDictionaryExp has size " << sizeOfActualPool << std::endl;
     SgDictionaryExpStorageClass* SgDictionaryExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDictionaryExpStorageArray = new SgDictionaryExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDictionaryExp::initializeStorageClassArray (SgDictionaryExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDimensionObject ) ; 
     std::cout << " SgDimensionObject has size " << sizeOfActualPool << std::endl;
     SgDimensionObjectStorageClass* SgDimensionObjectStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDimensionObjectStorageArray = new SgDimensionObjectStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDimensionObject::initializeStorageClassArray (SgDimensionObjectStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDirectedGraphEdge ) ; 
     std::cout << " SgDirectedGraphEdge has size " << sizeOfActualPool << std::endl;
     SgDirectedGraphEdgeStorageClass* SgDirectedGraphEdgeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectedGraphEdgeStorageArray = new SgDirectedGraphEdgeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDirectedGraphEdge::initializeStorageClassArray (SgDirectedGraphEdgeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDirectory ) ; 
     std::cout << " SgDirectory has size " << sizeOfActualPool << std::endl;
     SgDirectoryStorageClass* SgDirectoryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectoryStorageArray = new SgDirectoryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDirectory::initializeStorageClassArray (SgDirectoryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDirectoryList ) ; 
     std::cout << " SgDirectoryList has size " << sizeOfActualPool << std::endl;
     SgDirectoryListStorageClass* SgDirectoryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectoryListStorageArray = new SgDirectoryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDirectoryList::initializeStorageClassArray (SgDirectoryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDivAssignOp ) ; 
     std::cout << " SgDivAssignOp has size " << sizeOfActualPool << std::endl;
     SgDivAssignOpStorageClass* SgDivAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDivAssignOpStorageArray = new SgDivAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDivAssignOp::initializeStorageClassArray (SgDivAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDivideOp ) ; 
     std::cout << " SgDivideOp has size " << sizeOfActualPool << std::endl;
     SgDivideOpStorageClass* SgDivideOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDivideOpStorageArray = new SgDivideOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDivideOp::initializeStorageClassArray (SgDivideOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDoWhileStmt ) ; 
     std::cout << " SgDoWhileStmt has size " << sizeOfActualPool << std::endl;
     SgDoWhileStmtStorageClass* SgDoWhileStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDoWhileStmtStorageArray = new SgDoWhileStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDoWhileStmt::initializeStorageClassArray (SgDoWhileStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDotExp ) ; 
     std::cout << " SgDotExp has size " << sizeOfActualPool << std::endl;
     SgDotExpStorageClass* SgDotExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotExpStorageArray = new SgDotExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDotExp::initializeStorageClassArray (SgDotExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDotStarOp ) ; 
     std::cout << " SgDotStarOp has size " << sizeOfActualPool << std::endl;
     SgDotStarOpStorageClass* SgDotStarOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotStarOpStorageArray = new SgDotStarOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDotStarOp::initializeStorageClassArray (SgDotStarOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDoubleVal ) ; 
     std::cout << " SgDoubleVal has size " << sizeOfActualPool << std::endl;
     SgDoubleValStorageClass* SgDoubleValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDoubleValStorageArray = new SgDoubleValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDoubleVal::initializeStorageClassArray (SgDoubleValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElaboratedTypeModifier ) ; 
     std::cout << " SgElaboratedTypeModifier has size " << sizeOfActualPool << std::endl;
     SgElaboratedTypeModifierStorageClass* SgElaboratedTypeModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElaboratedTypeModifierStorageArray = new SgElaboratedTypeModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElaboratedTypeModifier::initializeStorageClassArray (SgElaboratedTypeModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElementwiseOp ) ; 
     std::cout << " SgElementwiseOp has size " << sizeOfActualPool << std::endl;
     SgElementwiseOpStorageClass* SgElementwiseOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseOpStorageArray = new SgElementwiseOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElementwiseOp::initializeStorageClassArray (SgElementwiseOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElementwiseAddOp ) ; 
     std::cout << " SgElementwiseAddOp has size " << sizeOfActualPool << std::endl;
     SgElementwiseAddOpStorageClass* SgElementwiseAddOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseAddOpStorageArray = new SgElementwiseAddOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElementwiseAddOp::initializeStorageClassArray (SgElementwiseAddOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElementwiseDivideOp ) ; 
     std::cout << " SgElementwiseDivideOp has size " << sizeOfActualPool << std::endl;
     SgElementwiseDivideOpStorageClass* SgElementwiseDivideOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseDivideOpStorageArray = new SgElementwiseDivideOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElementwiseDivideOp::initializeStorageClassArray (SgElementwiseDivideOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElementwiseLeftDivideOp ) ; 
     std::cout << " SgElementwiseLeftDivideOp has size " << sizeOfActualPool << std::endl;
     SgElementwiseLeftDivideOpStorageClass* SgElementwiseLeftDivideOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseLeftDivideOpStorageArray = new SgElementwiseLeftDivideOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElementwiseLeftDivideOp::initializeStorageClassArray (SgElementwiseLeftDivideOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElementwiseMultiplyOp ) ; 
     std::cout << " SgElementwiseMultiplyOp has size " << sizeOfActualPool << std::endl;
     SgElementwiseMultiplyOpStorageClass* SgElementwiseMultiplyOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseMultiplyOpStorageArray = new SgElementwiseMultiplyOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElementwiseMultiplyOp::initializeStorageClassArray (SgElementwiseMultiplyOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElementwisePowerOp ) ; 
     std::cout << " SgElementwisePowerOp has size " << sizeOfActualPool << std::endl;
     SgElementwisePowerOpStorageClass* SgElementwisePowerOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwisePowerOpStorageArray = new SgElementwisePowerOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElementwisePowerOp::initializeStorageClassArray (SgElementwisePowerOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElementwiseSubtractOp ) ; 
     std::cout << " SgElementwiseSubtractOp has size " << sizeOfActualPool << std::endl;
     SgElementwiseSubtractOpStorageClass* SgElementwiseSubtractOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseSubtractOpStorageArray = new SgElementwiseSubtractOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElementwiseSubtractOp::initializeStorageClassArray (SgElementwiseSubtractOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElseDirectiveStatement ) ; 
     std::cout << " SgElseDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgElseDirectiveStatementStorageClass* SgElseDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseDirectiveStatementStorageArray = new SgElseDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElseDirectiveStatement::initializeStorageClassArray (SgElseDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElseWhereStatement ) ; 
     std::cout << " SgElseWhereStatement has size " << sizeOfActualPool << std::endl;
     SgElseWhereStatementStorageClass* SgElseWhereStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseWhereStatementStorageArray = new SgElseWhereStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElseWhereStatement::initializeStorageClassArray (SgElseWhereStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElseifDirectiveStatement ) ; 
     std::cout << " SgElseifDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgElseifDirectiveStatementStorageClass* SgElseifDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseifDirectiveStatementStorageArray = new SgElseifDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElseifDirectiveStatement::initializeStorageClassArray (SgElseifDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEmptyDeclaration ) ; 
     std::cout << " SgEmptyDeclaration has size " << sizeOfActualPool << std::endl;
     SgEmptyDeclarationStorageClass* SgEmptyDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEmptyDeclarationStorageArray = new SgEmptyDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEmptyDeclaration::initializeStorageClassArray (SgEmptyDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEmptyDirectiveStatement ) ; 
     std::cout << " SgEmptyDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgEmptyDirectiveStatementStorageClass* SgEmptyDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEmptyDirectiveStatementStorageArray = new SgEmptyDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEmptyDirectiveStatement::initializeStorageClassArray (SgEmptyDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEndfileStatement ) ; 
     std::cout << " SgEndfileStatement has size " << sizeOfActualPool << std::endl;
     SgEndfileStatementStorageClass* SgEndfileStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEndfileStatementStorageArray = new SgEndfileStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEndfileStatement::initializeStorageClassArray (SgEndfileStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEndifDirectiveStatement ) ; 
     std::cout << " SgEndifDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgEndifDirectiveStatementStorageClass* SgEndifDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEndifDirectiveStatementStorageArray = new SgEndifDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEndifDirectiveStatement::initializeStorageClassArray (SgEndifDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEntryStatement ) ; 
     std::cout << " SgEntryStatement has size " << sizeOfActualPool << std::endl;
     SgEntryStatementStorageClass* SgEntryStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEntryStatementStorageArray = new SgEntryStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEntryStatement::initializeStorageClassArray (SgEntryStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumDeclaration ) ; 
     std::cout << " SgEnumDeclaration has size " << sizeOfActualPool << std::endl;
     SgEnumDeclarationStorageClass* SgEnumDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumDeclarationStorageArray = new SgEnumDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumDeclaration::initializeStorageClassArray (SgEnumDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumFieldSymbol ) ; 
     std::cout << " SgEnumFieldSymbol has size " << sizeOfActualPool << std::endl;
     SgEnumFieldSymbolStorageClass* SgEnumFieldSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumFieldSymbolStorageArray = new SgEnumFieldSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumFieldSymbol::initializeStorageClassArray (SgEnumFieldSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumSymbol ) ; 
     std::cout << " SgEnumSymbol has size " << sizeOfActualPool << std::endl;
     SgEnumSymbolStorageClass* SgEnumSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumSymbolStorageArray = new SgEnumSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumSymbol::initializeStorageClassArray (SgEnumSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumType ) ; 
     std::cout << " SgEnumType has size " << sizeOfActualPool << std::endl;
     SgEnumTypeStorageClass* SgEnumTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumTypeStorageArray = new SgEnumTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumType::initializeStorageClassArray (SgEnumTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumVal ) ; 
     std::cout << " SgEnumVal has size " << sizeOfActualPool << std::endl;
     SgEnumValStorageClass* SgEnumValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumValStorageArray = new SgEnumValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumVal::initializeStorageClassArray (SgEnumValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEqualityOp ) ; 
     std::cout << " SgEqualityOp has size " << sizeOfActualPool << std::endl;
     SgEqualityOpStorageClass* SgEqualityOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEqualityOpStorageArray = new SgEqualityOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEqualityOp::initializeStorageClassArray (SgEqualityOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEquivalenceStatement ) ; 
     std::cout << " SgEquivalenceStatement has size " << sizeOfActualPool << std::endl;
     SgEquivalenceStatementStorageClass* SgEquivalenceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEquivalenceStatementStorageArray = new SgEquivalenceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEquivalenceStatement::initializeStorageClassArray (SgEquivalenceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgErrorDirectiveStatement ) ; 
     std::cout << " SgErrorDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgErrorDirectiveStatementStorageClass* SgErrorDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgErrorDirectiveStatementStorageArray = new SgErrorDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgErrorDirectiveStatement::initializeStorageClassArray (SgErrorDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExecStatement ) ; 
     std::cout << " SgExecStatement has size " << sizeOfActualPool << std::endl;
     SgExecStatementStorageClass* SgExecStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExecStatementStorageArray = new SgExecStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExecStatement::initializeStorageClassArray (SgExecStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExponentiationOp ) ; 
     std::cout << " SgExponentiationOp has size " << sizeOfActualPool << std::endl;
     SgExponentiationOpStorageClass* SgExponentiationOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExponentiationOpStorageArray = new SgExponentiationOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExponentiationOp::initializeStorageClassArray (SgExponentiationOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExponentiationAssignOp ) ; 
     std::cout << " SgExponentiationAssignOp has size " << sizeOfActualPool << std::endl;
     SgExponentiationAssignOpStorageClass* SgExponentiationAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExponentiationAssignOpStorageArray = new SgExponentiationAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExponentiationAssignOp::initializeStorageClassArray (SgExponentiationAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExprListExp ) ; 
     std::cout << " SgExprListExp has size " << sizeOfActualPool << std::endl;
     SgExprListExpStorageClass* SgExprListExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExprListExpStorageArray = new SgExprListExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExprListExp::initializeStorageClassArray (SgExprListExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExprStatement ) ; 
     std::cout << " SgExprStatement has size " << sizeOfActualPool << std::endl;
     SgExprStatementStorageClass* SgExprStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExprStatementStorageArray = new SgExprStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExprStatement::initializeStorageClassArray (SgExprStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExpression ) ; 
     std::cout << " SgExpression has size " << sizeOfActualPool << std::endl;
     SgExpressionStorageClass* SgExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpressionStorageArray = new SgExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExpression::initializeStorageClassArray (SgExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExpressionRoot ) ; 
     std::cout << " SgExpressionRoot has size " << sizeOfActualPool << std::endl;
     SgExpressionRootStorageClass* SgExpressionRootStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpressionRootStorageArray = new SgExpressionRootStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExpressionRoot::initializeStorageClassArray (SgExpressionRootStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFile ) ; 
     std::cout << " SgFile has size " << sizeOfActualPool << std::endl;
     SgFileStorageClass* SgFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFileStorageArray = new SgFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFile::initializeStorageClassArray (SgFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFileList ) ; 
     std::cout << " SgFileList has size " << sizeOfActualPool << std::endl;
     SgFileListStorageClass* SgFileListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFileListStorageArray = new SgFileListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFileList::initializeStorageClassArray (SgFileListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFloatVal ) ; 
     std::cout << " SgFloatVal has size " << sizeOfActualPool << std::endl;
     SgFloatValStorageClass* SgFloatValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFloatValStorageArray = new SgFloatValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFloatVal::initializeStorageClassArray (SgFloatValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFloat128Val ) ; 
     std::cout << " SgFloat128Val has size " << sizeOfActualPool << std::endl;
     SgFloat128ValStorageClass* SgFloat128ValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFloat128ValStorageArray = new SgFloat128ValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFloat128Val::initializeStorageClassArray (SgFloat128ValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFloat80Val ) ; 
     std::cout << " SgFloat80Val has size " << sizeOfActualPool << std::endl;
     SgFloat80ValStorageClass* SgFloat80ValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFloat80ValStorageArray = new SgFloat80ValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFloat80Val::initializeStorageClassArray (SgFloat80ValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFoldExpression ) ; 
     std::cout << " SgFoldExpression has size " << sizeOfActualPool << std::endl;
     SgFoldExpressionStorageClass* SgFoldExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFoldExpressionStorageArray = new SgFoldExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFoldExpression::initializeStorageClassArray (SgFoldExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFlushStatement ) ; 
     std::cout << " SgFlushStatement has size " << sizeOfActualPool << std::endl;
     SgFlushStatementStorageClass* SgFlushStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFlushStatementStorageArray = new SgFlushStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFlushStatement::initializeStorageClassArray (SgFlushStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgForAllStatement ) ; 
     std::cout << " SgForAllStatement has size " << sizeOfActualPool << std::endl;
     SgForAllStatementStorageClass* SgForAllStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForAllStatementStorageArray = new SgForAllStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgForAllStatement::initializeStorageClassArray (SgForAllStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgForInitStatement ) ; 
     std::cout << " SgForInitStatement has size " << sizeOfActualPool << std::endl;
     SgForInitStatementStorageClass* SgForInitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForInitStatementStorageArray = new SgForInitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgForInitStatement::initializeStorageClassArray (SgForInitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgForStatement ) ; 
     std::cout << " SgForStatement has size " << sizeOfActualPool << std::endl;
     SgForStatementStorageClass* SgForStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForStatementStorageArray = new SgForStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgForStatement::initializeStorageClassArray (SgForStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFormatItem ) ; 
     std::cout << " SgFormatItem has size " << sizeOfActualPool << std::endl;
     SgFormatItemStorageClass* SgFormatItemStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatItemStorageArray = new SgFormatItemStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFormatItem::initializeStorageClassArray (SgFormatItemStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFormatItemList ) ; 
     std::cout << " SgFormatItemList has size " << sizeOfActualPool << std::endl;
     SgFormatItemListStorageClass* SgFormatItemListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatItemListStorageArray = new SgFormatItemListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFormatItemList::initializeStorageClassArray (SgFormatItemListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFormatStatement ) ; 
     std::cout << " SgFormatStatement has size " << sizeOfActualPool << std::endl;
     SgFormatStatementStorageClass* SgFormatStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatStatementStorageArray = new SgFormatStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFormatStatement::initializeStorageClassArray (SgFormatStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFortranDo ) ; 
     std::cout << " SgFortranDo has size " << sizeOfActualPool << std::endl;
     SgFortranDoStorageClass* SgFortranDoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranDoStorageArray = new SgFortranDoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFortranDo::initializeStorageClassArray (SgFortranDoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFortranIncludeLine ) ; 
     std::cout << " SgFortranIncludeLine has size " << sizeOfActualPool << std::endl;
     SgFortranIncludeLineStorageClass* SgFortranIncludeLineStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranIncludeLineStorageArray = new SgFortranIncludeLineStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFortranIncludeLine::initializeStorageClassArray (SgFortranIncludeLineStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFortranNonblockedDo ) ; 
     std::cout << " SgFortranNonblockedDo has size " << sizeOfActualPool << std::endl;
     SgFortranNonblockedDoStorageClass* SgFortranNonblockedDoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranNonblockedDoStorageArray = new SgFortranNonblockedDoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFortranNonblockedDo::initializeStorageClassArray (SgFortranNonblockedDoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFuncDecl_attr ) ; 
     std::cout << " SgFuncDecl_attr has size " << sizeOfActualPool << std::endl;
     SgFuncDecl_attrStorageClass* SgFuncDecl_attrStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFuncDecl_attrStorageArray = new SgFuncDecl_attrStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFuncDecl_attr::initializeStorageClassArray (SgFuncDecl_attrStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionCallExp ) ; 
     std::cout << " SgFunctionCallExp has size " << sizeOfActualPool << std::endl;
     SgFunctionCallExpStorageClass* SgFunctionCallExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionCallExpStorageArray = new SgFunctionCallExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionCallExp::initializeStorageClassArray (SgFunctionCallExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionDeclaration ) ; 
     std::cout << " SgFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     SgFunctionDeclarationStorageClass* SgFunctionDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionDeclarationStorageArray = new SgFunctionDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionDeclaration::initializeStorageClassArray (SgFunctionDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionDefinition ) ; 
     std::cout << " SgFunctionDefinition has size " << sizeOfActualPool << std::endl;
     SgFunctionDefinitionStorageClass* SgFunctionDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionDefinitionStorageArray = new SgFunctionDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionDefinition::initializeStorageClassArray (SgFunctionDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionParameterScope ) ; 
     std::cout << " SgFunctionParameterScope has size " << sizeOfActualPool << std::endl;
     SgFunctionParameterScopeStorageClass* SgFunctionParameterScopeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterScopeStorageArray = new SgFunctionParameterScopeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionParameterScope::initializeStorageClassArray (SgFunctionParameterScopeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionModifier ) ; 
     std::cout << " SgFunctionModifier has size " << sizeOfActualPool << std::endl;
     SgFunctionModifierStorageClass* SgFunctionModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionModifierStorageArray = new SgFunctionModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionModifier::initializeStorageClassArray (SgFunctionModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionParameterList ) ; 
     std::cout << " SgFunctionParameterList has size " << sizeOfActualPool << std::endl;
     SgFunctionParameterListStorageClass* SgFunctionParameterListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterListStorageArray = new SgFunctionParameterListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionParameterList::initializeStorageClassArray (SgFunctionParameterListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionParameterRefExp ) ; 
     std::cout << " SgFunctionParameterRefExp has size " << sizeOfActualPool << std::endl;
     SgFunctionParameterRefExpStorageClass* SgFunctionParameterRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterRefExpStorageArray = new SgFunctionParameterRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionParameterRefExp::initializeStorageClassArray (SgFunctionParameterRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionParameterTypeList ) ; 
     std::cout << " SgFunctionParameterTypeList has size " << sizeOfActualPool << std::endl;
     SgFunctionParameterTypeListStorageClass* SgFunctionParameterTypeListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterTypeListStorageArray = new SgFunctionParameterTypeListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionParameterTypeList::initializeStorageClassArray (SgFunctionParameterTypeListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionRefExp ) ; 
     std::cout << " SgFunctionRefExp has size " << sizeOfActualPool << std::endl;
     SgFunctionRefExpStorageClass* SgFunctionRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionRefExpStorageArray = new SgFunctionRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionRefExp::initializeStorageClassArray (SgFunctionRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionSymbol ) ; 
     std::cout << " SgFunctionSymbol has size " << sizeOfActualPool << std::endl;
     SgFunctionSymbolStorageClass* SgFunctionSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionSymbolStorageArray = new SgFunctionSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionSymbol::initializeStorageClassArray (SgFunctionSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionType ) ; 
     std::cout << " SgFunctionType has size " << sizeOfActualPool << std::endl;
     SgFunctionTypeStorageClass* SgFunctionTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeStorageArray = new SgFunctionTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionType::initializeStorageClassArray (SgFunctionTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionTypeSymbol ) ; 
     std::cout << " SgFunctionTypeSymbol has size " << sizeOfActualPool << std::endl;
     SgFunctionTypeSymbolStorageClass* SgFunctionTypeSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeSymbolStorageArray = new SgFunctionTypeSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionTypeSymbol::initializeStorageClassArray (SgFunctionTypeSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionTypeTable ) ; 
     std::cout << " SgFunctionTypeTable has size " << sizeOfActualPool << std::endl;
     SgFunctionTypeTableStorageClass* SgFunctionTypeTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeTableStorageArray = new SgFunctionTypeTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionTypeTable::initializeStorageClassArray (SgFunctionTypeTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeTable ) ; 
     std::cout << " SgTypeTable has size " << sizeOfActualPool << std::endl;
     SgTypeTableStorageClass* SgTypeTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeTableStorageArray = new SgTypeTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeTable::initializeStorageClassArray (SgTypeTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGlobal ) ; 
     std::cout << " SgGlobal has size " << sizeOfActualPool << std::endl;
     SgGlobalStorageClass* SgGlobalStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGlobalStorageArray = new SgGlobalStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGlobal::initializeStorageClassArray (SgGlobalStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGotoStatement ) ; 
     std::cout << " SgGotoStatement has size " << sizeOfActualPool << std::endl;
     SgGotoStatementStorageClass* SgGotoStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGotoStatementStorageArray = new SgGotoStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGotoStatement::initializeStorageClassArray (SgGotoStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraph ) ; 
     std::cout << " SgGraph has size " << sizeOfActualPool << std::endl;
     SgGraphStorageClass* SgGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphStorageArray = new SgGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraph::initializeStorageClassArray (SgGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraphEdge ) ; 
     std::cout << " SgGraphEdge has size " << sizeOfActualPool << std::endl;
     SgGraphEdgeStorageClass* SgGraphEdgeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphEdgeStorageArray = new SgGraphEdgeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraphEdge::initializeStorageClassArray (SgGraphEdgeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraphEdgeList ) ; 
     std::cout << " SgGraphEdgeList has size " << sizeOfActualPool << std::endl;
     SgGraphEdgeListStorageClass* SgGraphEdgeListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphEdgeListStorageArray = new SgGraphEdgeListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraphEdgeList::initializeStorageClassArray (SgGraphEdgeListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraphNode ) ; 
     std::cout << " SgGraphNode has size " << sizeOfActualPool << std::endl;
     SgGraphNodeStorageClass* SgGraphNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphNodeStorageArray = new SgGraphNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraphNode::initializeStorageClassArray (SgGraphNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraphNodeList ) ; 
     std::cout << " SgGraphNodeList has size " << sizeOfActualPool << std::endl;
     SgGraphNodeListStorageClass* SgGraphNodeListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphNodeListStorageArray = new SgGraphNodeListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraphNodeList::initializeStorageClassArray (SgGraphNodeListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGreaterOrEqualOp ) ; 
     std::cout << " SgGreaterOrEqualOp has size " << sizeOfActualPool << std::endl;
     SgGreaterOrEqualOpStorageClass* SgGreaterOrEqualOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGreaterOrEqualOpStorageArray = new SgGreaterOrEqualOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGreaterOrEqualOp::initializeStorageClassArray (SgGreaterOrEqualOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGreaterThanOp ) ; 
     std::cout << " SgGreaterThanOp has size " << sizeOfActualPool << std::endl;
     SgGreaterThanOpStorageClass* SgGreaterThanOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGreaterThanOpStorageArray = new SgGreaterThanOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGreaterThanOp::initializeStorageClassArray (SgGreaterThanOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIOItemExpression ) ; 
     std::cout << " SgIOItemExpression has size " << sizeOfActualPool << std::endl;
     SgIOItemExpressionStorageClass* SgIOItemExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIOItemExpressionStorageArray = new SgIOItemExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIOItemExpression::initializeStorageClassArray (SgIOItemExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIOStatement ) ; 
     std::cout << " SgIOStatement has size " << sizeOfActualPool << std::endl;
     SgIOStatementStorageClass* SgIOStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIOStatementStorageArray = new SgIOStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIOStatement::initializeStorageClassArray (SgIOStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIdentDirectiveStatement ) ; 
     std::cout << " SgIdentDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIdentDirectiveStatementStorageClass* SgIdentDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIdentDirectiveStatementStorageArray = new SgIdentDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIdentDirectiveStatement::initializeStorageClassArray (SgIdentDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIfDirectiveStatement ) ; 
     std::cout << " SgIfDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIfDirectiveStatementStorageClass* SgIfDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfDirectiveStatementStorageArray = new SgIfDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIfDirectiveStatement::initializeStorageClassArray (SgIfDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIfStmt ) ; 
     std::cout << " SgIfStmt has size " << sizeOfActualPool << std::endl;
     SgIfStmtStorageClass* SgIfStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfStmtStorageArray = new SgIfStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIfStmt::initializeStorageClassArray (SgIfStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIfdefDirectiveStatement ) ; 
     std::cout << " SgIfdefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIfdefDirectiveStatementStorageClass* SgIfdefDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfdefDirectiveStatementStorageArray = new SgIfdefDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIfdefDirectiveStatement::initializeStorageClassArray (SgIfdefDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIfndefDirectiveStatement ) ; 
     std::cout << " SgIfndefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIfndefDirectiveStatementStorageClass* SgIfndefDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfndefDirectiveStatementStorageArray = new SgIfndefDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIfndefDirectiveStatement::initializeStorageClassArray (SgIfndefDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgImageControlStatement ) ; 
     std::cout << " SgImageControlStatement has size " << sizeOfActualPool << std::endl;
     SgImageControlStatementStorageClass* SgImageControlStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImageControlStatementStorageArray = new SgImageControlStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgImageControlStatement::initializeStorageClassArray (SgImageControlStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgImagPartOp ) ; 
     std::cout << " SgImagPartOp has size " << sizeOfActualPool << std::endl;
     SgImagPartOpStorageClass* SgImagPartOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImagPartOpStorageArray = new SgImagPartOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgImagPartOp::initializeStorageClassArray (SgImagPartOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgImplicitStatement ) ; 
     std::cout << " SgImplicitStatement has size " << sizeOfActualPool << std::endl;
     SgImplicitStatementStorageClass* SgImplicitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImplicitStatementStorageArray = new SgImplicitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgImplicitStatement::initializeStorageClassArray (SgImplicitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgImpliedDo ) ; 
     std::cout << " SgImpliedDo has size " << sizeOfActualPool << std::endl;
     SgImpliedDoStorageClass* SgImpliedDoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImpliedDoStorageArray = new SgImpliedDoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgImpliedDo::initializeStorageClassArray (SgImpliedDoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgImportStatement ) ; 
     std::cout << " SgImportStatement has size " << sizeOfActualPool << std::endl;
     SgImportStatementStorageClass* SgImportStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImportStatementStorageArray = new SgImportStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgImportStatement::initializeStorageClassArray (SgImportStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIncidenceDirectedGraph ) ; 
     std::cout << " SgIncidenceDirectedGraph has size " << sizeOfActualPool << std::endl;
     SgIncidenceDirectedGraphStorageClass* SgIncidenceDirectedGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncidenceDirectedGraphStorageArray = new SgIncidenceDirectedGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIncidenceDirectedGraph::initializeStorageClassArray (SgIncidenceDirectedGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIncidenceUndirectedGraph ) ; 
     std::cout << " SgIncidenceUndirectedGraph has size " << sizeOfActualPool << std::endl;
     SgIncidenceUndirectedGraphStorageClass* SgIncidenceUndirectedGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncidenceUndirectedGraphStorageArray = new SgIncidenceUndirectedGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIncidenceUndirectedGraph::initializeStorageClassArray (SgIncidenceUndirectedGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIncludeDirectiveStatement ) ; 
     std::cout << " SgIncludeDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIncludeDirectiveStatementStorageClass* SgIncludeDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeDirectiveStatementStorageArray = new SgIncludeDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIncludeDirectiveStatement::initializeStorageClassArray (SgIncludeDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIncludeFile ) ; 
     std::cout << " SgIncludeFile has size " << sizeOfActualPool << std::endl;
     SgIncludeFileStorageClass* SgIncludeFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeFileStorageArray = new SgIncludeFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIncludeFile::initializeStorageClassArray (SgIncludeFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIncludeNextDirectiveStatement ) ; 
     std::cout << " SgIncludeNextDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIncludeNextDirectiveStatementStorageClass* SgIncludeNextDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeNextDirectiveStatementStorageArray = new SgIncludeNextDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIncludeNextDirectiveStatement::initializeStorageClassArray (SgIncludeNextDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInitializedName ) ; 
     std::cout << " SgInitializedName has size " << sizeOfActualPool << std::endl;
     SgInitializedNameStorageClass* SgInitializedNameStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInitializedNameStorageArray = new SgInitializedNameStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInitializedName::initializeStorageClassArray (SgInitializedNameStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInitializer ) ; 
     std::cout << " SgInitializer has size " << sizeOfActualPool << std::endl;
     SgInitializerStorageClass* SgInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInitializerStorageArray = new SgInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInitializer::initializeStorageClassArray (SgInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInquireStatement ) ; 
     std::cout << " SgInquireStatement has size " << sizeOfActualPool << std::endl;
     SgInquireStatementStorageClass* SgInquireStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInquireStatementStorageArray = new SgInquireStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInquireStatement::initializeStorageClassArray (SgInquireStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntKeyedBidirectionalGraph ) ; 
     std::cout << " SgIntKeyedBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     SgIntKeyedBidirectionalGraphStorageClass* SgIntKeyedBidirectionalGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntKeyedBidirectionalGraphStorageArray = new SgIntKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntKeyedBidirectionalGraph::initializeStorageClassArray (SgIntKeyedBidirectionalGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntVal ) ; 
     std::cout << " SgIntVal has size " << sizeOfActualPool << std::endl;
     SgIntValStorageClass* SgIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntValStorageArray = new SgIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntVal::initializeStorageClassArray (SgIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntegerDivideOp ) ; 
     std::cout << " SgIntegerDivideOp has size " << sizeOfActualPool << std::endl;
     SgIntegerDivideOpStorageClass* SgIntegerDivideOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntegerDivideOpStorageArray = new SgIntegerDivideOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntegerDivideOp::initializeStorageClassArray (SgIntegerDivideOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntegerDivideAssignOp ) ; 
     std::cout << " SgIntegerDivideAssignOp has size " << sizeOfActualPool << std::endl;
     SgIntegerDivideAssignOpStorageClass* SgIntegerDivideAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntegerDivideAssignOpStorageArray = new SgIntegerDivideAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntegerDivideAssignOp::initializeStorageClassArray (SgIntegerDivideAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInterfaceBody ) ; 
     std::cout << " SgInterfaceBody has size " << sizeOfActualPool << std::endl;
     SgInterfaceBodyStorageClass* SgInterfaceBodyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceBodyStorageArray = new SgInterfaceBodyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInterfaceBody::initializeStorageClassArray (SgInterfaceBodyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgHeaderFileBody ) ; 
     std::cout << " SgHeaderFileBody has size " << sizeOfActualPool << std::endl;
     SgHeaderFileBodyStorageClass* SgHeaderFileBodyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgHeaderFileBodyStorageArray = new SgHeaderFileBodyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgHeaderFileBody::initializeStorageClassArray (SgHeaderFileBodyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgHeaderFileReport ) ; 
     std::cout << " SgHeaderFileReport has size " << sizeOfActualPool << std::endl;
     SgHeaderFileReportStorageClass* SgHeaderFileReportStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgHeaderFileReportStorageArray = new SgHeaderFileReportStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgHeaderFileReport::initializeStorageClassArray (SgHeaderFileReportStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInterfaceStatement ) ; 
     std::cout << " SgInterfaceStatement has size " << sizeOfActualPool << std::endl;
     SgInterfaceStatementStorageClass* SgInterfaceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceStatementStorageArray = new SgInterfaceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInterfaceStatement::initializeStorageClassArray (SgInterfaceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInterfaceSymbol ) ; 
     std::cout << " SgInterfaceSymbol has size " << sizeOfActualPool << std::endl;
     SgInterfaceSymbolStorageClass* SgInterfaceSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceSymbolStorageArray = new SgInterfaceSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInterfaceSymbol::initializeStorageClassArray (SgInterfaceSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntrinsicSymbol ) ; 
     std::cout << " SgIntrinsicSymbol has size " << sizeOfActualPool << std::endl;
     SgIntrinsicSymbolStorageClass* SgIntrinsicSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntrinsicSymbolStorageArray = new SgIntrinsicSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntrinsicSymbol::initializeStorageClassArray (SgIntrinsicSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIsOp ) ; 
     std::cout << " SgIsOp has size " << sizeOfActualPool << std::endl;
     SgIsOpStorageClass* SgIsOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIsOpStorageArray = new SgIsOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIsOp::initializeStorageClassArray (SgIsOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIsNotOp ) ; 
     std::cout << " SgIsNotOp has size " << sizeOfActualPool << std::endl;
     SgIsNotOpStorageClass* SgIsNotOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIsNotOpStorageArray = new SgIsNotOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIsNotOp::initializeStorageClassArray (SgIsNotOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIorAssignOp ) ; 
     std::cout << " SgIorAssignOp has size " << sizeOfActualPool << std::endl;
     SgIorAssignOpStorageClass* SgIorAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIorAssignOpStorageArray = new SgIorAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIorAssignOp::initializeStorageClassArray (SgIorAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialBitType ) ; 
     std::cout << " SgJovialBitType has size " << sizeOfActualPool << std::endl;
     SgJovialBitTypeStorageClass* SgJovialBitTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialBitTypeStorageArray = new SgJovialBitTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialBitType::initializeStorageClassArray (SgJovialBitTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialBitVal ) ; 
     std::cout << " SgJovialBitVal has size " << sizeOfActualPool << std::endl;
     SgJovialBitValStorageClass* SgJovialBitValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialBitValStorageArray = new SgJovialBitValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialBitVal::initializeStorageClassArray (SgJovialBitValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialTableType ) ; 
     std::cout << " SgJovialTableType has size " << sizeOfActualPool << std::endl;
     SgJovialTableTypeStorageClass* SgJovialTableTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialTableTypeStorageArray = new SgJovialTableTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialTableType::initializeStorageClassArray (SgJovialTableTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialCompoolStatement ) ; 
     std::cout << " SgJovialCompoolStatement has size " << sizeOfActualPool << std::endl;
     SgJovialCompoolStatementStorageClass* SgJovialCompoolStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialCompoolStatementStorageArray = new SgJovialCompoolStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialCompoolStatement::initializeStorageClassArray (SgJovialCompoolStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialForThenStatement ) ; 
     std::cout << " SgJovialForThenStatement has size " << sizeOfActualPool << std::endl;
     SgJovialForThenStatementStorageClass* SgJovialForThenStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialForThenStatementStorageArray = new SgJovialForThenStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialForThenStatement::initializeStorageClassArray (SgJovialForThenStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialDefineDeclaration ) ; 
     std::cout << " SgJovialDefineDeclaration has size " << sizeOfActualPool << std::endl;
     SgJovialDefineDeclarationStorageClass* SgJovialDefineDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialDefineDeclarationStorageArray = new SgJovialDefineDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialDefineDeclaration::initializeStorageClassArray (SgJovialDefineDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialDirectiveStatement ) ; 
     std::cout << " SgJovialDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgJovialDirectiveStatementStorageClass* SgJovialDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialDirectiveStatementStorageArray = new SgJovialDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialDirectiveStatement::initializeStorageClassArray (SgJovialDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialOverlayDeclaration ) ; 
     std::cout << " SgJovialOverlayDeclaration has size " << sizeOfActualPool << std::endl;
     SgJovialOverlayDeclarationStorageClass* SgJovialOverlayDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialOverlayDeclarationStorageArray = new SgJovialOverlayDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialOverlayDeclaration::initializeStorageClassArray (SgJovialOverlayDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialPresetPositionExp ) ; 
     std::cout << " SgJovialPresetPositionExp has size " << sizeOfActualPool << std::endl;
     SgJovialPresetPositionExpStorageClass* SgJovialPresetPositionExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialPresetPositionExpStorageArray = new SgJovialPresetPositionExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialPresetPositionExp::initializeStorageClassArray (SgJovialPresetPositionExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialTablePresetExp ) ; 
     std::cout << " SgJovialTablePresetExp has size " << sizeOfActualPool << std::endl;
     SgJovialTablePresetExpStorageClass* SgJovialTablePresetExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialTablePresetExpStorageArray = new SgJovialTablePresetExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialTablePresetExp::initializeStorageClassArray (SgJovialTablePresetExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialTableStatement ) ; 
     std::cout << " SgJovialTableStatement has size " << sizeOfActualPool << std::endl;
     SgJovialTableStatementStorageClass* SgJovialTableStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialTableStatementStorageArray = new SgJovialTableStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialTableStatement::initializeStorageClassArray (SgJovialTableStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgKeyDatumPair ) ; 
     std::cout << " SgKeyDatumPair has size " << sizeOfActualPool << std::endl;
     SgKeyDatumPairStorageClass* SgKeyDatumPairStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgKeyDatumPairStorageArray = new SgKeyDatumPairStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgKeyDatumPair::initializeStorageClassArray (SgKeyDatumPairStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCudaKernelExecConfig ) ; 
     std::cout << " SgCudaKernelExecConfig has size " << sizeOfActualPool << std::endl;
     SgCudaKernelExecConfigStorageClass* SgCudaKernelExecConfigStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCudaKernelExecConfigStorageArray = new SgCudaKernelExecConfigStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCudaKernelExecConfig::initializeStorageClassArray (SgCudaKernelExecConfigStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCudaKernelCallExp ) ; 
     std::cout << " SgCudaKernelCallExp has size " << sizeOfActualPool << std::endl;
     SgCudaKernelCallExpStorageClass* SgCudaKernelCallExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCudaKernelCallExpStorageArray = new SgCudaKernelCallExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCudaKernelCallExp::initializeStorageClassArray (SgCudaKernelCallExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLabelRefExp ) ; 
     std::cout << " SgLabelRefExp has size " << sizeOfActualPool << std::endl;
     SgLabelRefExpStorageClass* SgLabelRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelRefExpStorageArray = new SgLabelRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLabelRefExp::initializeStorageClassArray (SgLabelRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLabelStatement ) ; 
     std::cout << " SgLabelStatement has size " << sizeOfActualPool << std::endl;
     SgLabelStatementStorageClass* SgLabelStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelStatementStorageArray = new SgLabelStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLabelStatement::initializeStorageClassArray (SgLabelStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaLabelStatement ) ; 
     std::cout << " SgJavaLabelStatement has size " << sizeOfActualPool << std::endl;
     SgJavaLabelStatementStorageClass* SgJavaLabelStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaLabelStatementStorageArray = new SgJavaLabelStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaLabelStatement::initializeStorageClassArray (SgJavaLabelStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLabelSymbol ) ; 
     std::cout << " SgLabelSymbol has size " << sizeOfActualPool << std::endl;
     SgLabelSymbolStorageClass* SgLabelSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelSymbolStorageArray = new SgLabelSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLabelSymbol::initializeStorageClassArray (SgLabelSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaLabelSymbol ) ; 
     std::cout << " SgJavaLabelSymbol has size " << sizeOfActualPool << std::endl;
     SgJavaLabelSymbolStorageClass* SgJavaLabelSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaLabelSymbolStorageArray = new SgJavaLabelSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaLabelSymbol::initializeStorageClassArray (SgJavaLabelSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLambdaCapture ) ; 
     std::cout << " SgLambdaCapture has size " << sizeOfActualPool << std::endl;
     SgLambdaCaptureStorageClass* SgLambdaCaptureStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaCaptureStorageArray = new SgLambdaCaptureStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLambdaCapture::initializeStorageClassArray (SgLambdaCaptureStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLambdaCaptureList ) ; 
     std::cout << " SgLambdaCaptureList has size " << sizeOfActualPool << std::endl;
     SgLambdaCaptureListStorageClass* SgLambdaCaptureListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaCaptureListStorageArray = new SgLambdaCaptureListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLambdaCaptureList::initializeStorageClassArray (SgLambdaCaptureListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLambdaExp ) ; 
     std::cout << " SgLambdaExp has size " << sizeOfActualPool << std::endl;
     SgLambdaExpStorageClass* SgLambdaExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaExpStorageArray = new SgLambdaExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLambdaExp::initializeStorageClassArray (SgLambdaExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLambdaRefExp ) ; 
     std::cout << " SgLambdaRefExp has size " << sizeOfActualPool << std::endl;
     SgLambdaRefExpStorageClass* SgLambdaRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaRefExpStorageArray = new SgLambdaRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLambdaRefExp::initializeStorageClassArray (SgLambdaRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLeftDivideOp ) ; 
     std::cout << " SgLeftDivideOp has size " << sizeOfActualPool << std::endl;
     SgLeftDivideOpStorageClass* SgLeftDivideOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLeftDivideOpStorageArray = new SgLeftDivideOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLeftDivideOp::initializeStorageClassArray (SgLeftDivideOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLessOrEqualOp ) ; 
     std::cout << " SgLessOrEqualOp has size " << sizeOfActualPool << std::endl;
     SgLessOrEqualOpStorageClass* SgLessOrEqualOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLessOrEqualOpStorageArray = new SgLessOrEqualOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLessOrEqualOp::initializeStorageClassArray (SgLessOrEqualOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLessThanOp ) ; 
     std::cout << " SgLessThanOp has size " << sizeOfActualPool << std::endl;
     SgLessThanOpStorageClass* SgLessThanOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLessThanOpStorageArray = new SgLessThanOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLessThanOp::initializeStorageClassArray (SgLessThanOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLineDirectiveStatement ) ; 
     std::cout << " SgLineDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgLineDirectiveStatementStorageClass* SgLineDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLineDirectiveStatementStorageArray = new SgLineDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLineDirectiveStatement::initializeStorageClassArray (SgLineDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLinemarkerDirectiveStatement ) ; 
     std::cout << " SgLinemarkerDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgLinemarkerDirectiveStatementStorageClass* SgLinemarkerDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLinemarkerDirectiveStatementStorageArray = new SgLinemarkerDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLinemarkerDirectiveStatement::initializeStorageClassArray (SgLinemarkerDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLinkageModifier ) ; 
     std::cout << " SgLinkageModifier has size " << sizeOfActualPool << std::endl;
     SgLinkageModifierStorageClass* SgLinkageModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLinkageModifierStorageArray = new SgLinkageModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLinkageModifier::initializeStorageClassArray (SgLinkageModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgListComprehension ) ; 
     std::cout << " SgListComprehension has size " << sizeOfActualPool << std::endl;
     SgListComprehensionStorageClass* SgListComprehensionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgListComprehensionStorageArray = new SgListComprehensionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgListComprehension::initializeStorageClassArray (SgListComprehensionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgListExp ) ; 
     std::cout << " SgListExp has size " << sizeOfActualPool << std::endl;
     SgListExpStorageClass* SgListExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgListExpStorageArray = new SgListExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgListExp::initializeStorageClassArray (SgListExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLocatedNode ) ; 
     std::cout << " SgLocatedNode has size " << sizeOfActualPool << std::endl;
     SgLocatedNodeStorageClass* SgLocatedNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLocatedNodeStorageArray = new SgLocatedNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLocatedNode::initializeStorageClassArray (SgLocatedNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLocatedNodeSupport ) ; 
     std::cout << " SgLocatedNodeSupport has size " << sizeOfActualPool << std::endl;
     SgLocatedNodeSupportStorageClass* SgLocatedNodeSupportStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLocatedNodeSupportStorageArray = new SgLocatedNodeSupportStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLocatedNodeSupport::initializeStorageClassArray (SgLocatedNodeSupportStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLongDoubleVal ) ; 
     std::cout << " SgLongDoubleVal has size " << sizeOfActualPool << std::endl;
     SgLongDoubleValStorageClass* SgLongDoubleValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongDoubleValStorageArray = new SgLongDoubleValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLongDoubleVal::initializeStorageClassArray (SgLongDoubleValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLongIntVal ) ; 
     std::cout << " SgLongIntVal has size " << sizeOfActualPool << std::endl;
     SgLongIntValStorageClass* SgLongIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongIntValStorageArray = new SgLongIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLongIntVal::initializeStorageClassArray (SgLongIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLongLongIntVal ) ; 
     std::cout << " SgLongLongIntVal has size " << sizeOfActualPool << std::endl;
     SgLongLongIntValStorageClass* SgLongLongIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongLongIntValStorageArray = new SgLongLongIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLongLongIntVal::initializeStorageClassArray (SgLongLongIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLshiftAssignOp ) ; 
     std::cout << " SgLshiftAssignOp has size " << sizeOfActualPool << std::endl;
     SgLshiftAssignOpStorageClass* SgLshiftAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLshiftAssignOpStorageArray = new SgLshiftAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLshiftAssignOp::initializeStorageClassArray (SgLshiftAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLshiftOp ) ; 
     std::cout << " SgLshiftOp has size " << sizeOfActualPool << std::endl;
     SgLshiftOpStorageClass* SgLshiftOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLshiftOpStorageArray = new SgLshiftOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLshiftOp::initializeStorageClassArray (SgLshiftOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMagicColonExp ) ; 
     std::cout << " SgMagicColonExp has size " << sizeOfActualPool << std::endl;
     SgMagicColonExpStorageClass* SgMagicColonExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMagicColonExpStorageArray = new SgMagicColonExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMagicColonExp::initializeStorageClassArray (SgMagicColonExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMatrixExp ) ; 
     std::cout << " SgMatrixExp has size " << sizeOfActualPool << std::endl;
     SgMatrixExpStorageClass* SgMatrixExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMatrixExpStorageArray = new SgMatrixExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMatrixExp::initializeStorageClassArray (SgMatrixExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMatrixTransposeOp ) ; 
     std::cout << " SgMatrixTransposeOp has size " << sizeOfActualPool << std::endl;
     SgMatrixTransposeOpStorageClass* SgMatrixTransposeOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMatrixTransposeOpStorageArray = new SgMatrixTransposeOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMatrixTransposeOp::initializeStorageClassArray (SgMatrixTransposeOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMatlabForStatement ) ; 
     std::cout << " SgMatlabForStatement has size " << sizeOfActualPool << std::endl;
     SgMatlabForStatementStorageClass* SgMatlabForStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMatlabForStatementStorageArray = new SgMatlabForStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMatlabForStatement::initializeStorageClassArray (SgMatlabForStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMemberFunctionDeclaration ) ; 
     std::cout << " SgMemberFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     SgMemberFunctionDeclarationStorageClass* SgMemberFunctionDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionDeclarationStorageArray = new SgMemberFunctionDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMemberFunctionDeclaration::initializeStorageClassArray (SgMemberFunctionDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMemberFunctionRefExp ) ; 
     std::cout << " SgMemberFunctionRefExp has size " << sizeOfActualPool << std::endl;
     SgMemberFunctionRefExpStorageClass* SgMemberFunctionRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionRefExpStorageArray = new SgMemberFunctionRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMemberFunctionRefExp::initializeStorageClassArray (SgMemberFunctionRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMemberFunctionSymbol ) ; 
     std::cout << " SgMemberFunctionSymbol has size " << sizeOfActualPool << std::endl;
     SgMemberFunctionSymbolStorageClass* SgMemberFunctionSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionSymbolStorageArray = new SgMemberFunctionSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMemberFunctionSymbol::initializeStorageClassArray (SgMemberFunctionSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMemberFunctionType ) ; 
     std::cout << " SgMemberFunctionType has size " << sizeOfActualPool << std::endl;
     SgMemberFunctionTypeStorageClass* SgMemberFunctionTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionTypeStorageArray = new SgMemberFunctionTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMemberFunctionType::initializeStorageClassArray (SgMemberFunctionTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMembershipOp ) ; 
     std::cout << " SgMembershipOp has size " << sizeOfActualPool << std::endl;
     SgMembershipOpStorageClass* SgMembershipOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMembershipOpStorageArray = new SgMembershipOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMembershipOp::initializeStorageClassArray (SgMembershipOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMicrosoftAttributeDeclaration ) ; 
     std::cout << " SgMicrosoftAttributeDeclaration has size " << sizeOfActualPool << std::endl;
     SgMicrosoftAttributeDeclarationStorageClass* SgMicrosoftAttributeDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMicrosoftAttributeDeclarationStorageArray = new SgMicrosoftAttributeDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMicrosoftAttributeDeclaration::initializeStorageClassArray (SgMicrosoftAttributeDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMinusAssignOp ) ; 
     std::cout << " SgMinusAssignOp has size " << sizeOfActualPool << std::endl;
     SgMinusAssignOpStorageClass* SgMinusAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusAssignOpStorageArray = new SgMinusAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMinusAssignOp::initializeStorageClassArray (SgMinusAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMinusMinusOp ) ; 
     std::cout << " SgMinusMinusOp has size " << sizeOfActualPool << std::endl;
     SgMinusMinusOpStorageClass* SgMinusMinusOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusMinusOpStorageArray = new SgMinusMinusOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMinusMinusOp::initializeStorageClassArray (SgMinusMinusOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMinusOp ) ; 
     std::cout << " SgMinusOp has size " << sizeOfActualPool << std::endl;
     SgMinusOpStorageClass* SgMinusOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusOpStorageArray = new SgMinusOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMinusOp::initializeStorageClassArray (SgMinusOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModAssignOp ) ; 
     std::cout << " SgModAssignOp has size " << sizeOfActualPool << std::endl;
     SgModAssignOpStorageClass* SgModAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModAssignOpStorageArray = new SgModAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModAssignOp::initializeStorageClassArray (SgModAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModOp ) ; 
     std::cout << " SgModOp has size " << sizeOfActualPool << std::endl;
     SgModOpStorageClass* SgModOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModOpStorageArray = new SgModOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModOp::initializeStorageClassArray (SgModOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModifier ) ; 
     std::cout << " SgModifier has size " << sizeOfActualPool << std::endl;
     SgModifierStorageClass* SgModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierStorageArray = new SgModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModifier::initializeStorageClassArray (SgModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModifierNodes ) ; 
     std::cout << " SgModifierNodes has size " << sizeOfActualPool << std::endl;
     SgModifierNodesStorageClass* SgModifierNodesStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierNodesStorageArray = new SgModifierNodesStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModifierNodes::initializeStorageClassArray (SgModifierNodesStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModifierType ) ; 
     std::cout << " SgModifierType has size " << sizeOfActualPool << std::endl;
     SgModifierTypeStorageClass* SgModifierTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierTypeStorageArray = new SgModifierTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModifierType::initializeStorageClassArray (SgModifierTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModuleStatement ) ; 
     std::cout << " SgModuleStatement has size " << sizeOfActualPool << std::endl;
     SgModuleStatementStorageClass* SgModuleStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModuleStatementStorageArray = new SgModuleStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModuleStatement::initializeStorageClassArray (SgModuleStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModuleSymbol ) ; 
     std::cout << " SgModuleSymbol has size " << sizeOfActualPool << std::endl;
     SgModuleSymbolStorageClass* SgModuleSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModuleSymbolStorageArray = new SgModuleSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModuleSymbol::initializeStorageClassArray (SgModuleSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMultAssignOp ) ; 
     std::cout << " SgMultAssignOp has size " << sizeOfActualPool << std::endl;
     SgMultAssignOpStorageClass* SgMultAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMultAssignOpStorageArray = new SgMultAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMultAssignOp::initializeStorageClassArray (SgMultAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMultiplyOp ) ; 
     std::cout << " SgMultiplyOp has size " << sizeOfActualPool << std::endl;
     SgMultiplyOpStorageClass* SgMultiplyOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMultiplyOpStorageArray = new SgMultiplyOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMultiplyOp::initializeStorageClassArray (SgMultiplyOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgName ) ; 
     std::cout << " SgName has size " << sizeOfActualPool << std::endl;
     SgNameStorageClass* SgNameStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNameStorageArray = new SgNameStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgName::initializeStorageClassArray (SgNameStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNameGroup ) ; 
     std::cout << " SgNameGroup has size " << sizeOfActualPool << std::endl;
     SgNameGroupStorageClass* SgNameGroupStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNameGroupStorageArray = new SgNameGroupStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNameGroup::initializeStorageClassArray (SgNameGroupStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamedType ) ; 
     std::cout << " SgNamedType has size " << sizeOfActualPool << std::endl;
     SgNamedTypeStorageClass* SgNamedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamedTypeStorageArray = new SgNamedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamedType::initializeStorageClassArray (SgNamedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamelistStatement ) ; 
     std::cout << " SgNamelistStatement has size " << sizeOfActualPool << std::endl;
     SgNamelistStatementStorageClass* SgNamelistStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamelistStatementStorageArray = new SgNamelistStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamelistStatement::initializeStorageClassArray (SgNamelistStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamespaceAliasDeclarationStatement ) ; 
     std::cout << " SgNamespaceAliasDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgNamespaceAliasDeclarationStatementStorageClass* SgNamespaceAliasDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceAliasDeclarationStatementStorageArray = new SgNamespaceAliasDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamespaceAliasDeclarationStatement::initializeStorageClassArray (SgNamespaceAliasDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamespaceDeclarationStatement ) ; 
     std::cout << " SgNamespaceDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgNamespaceDeclarationStatementStorageClass* SgNamespaceDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceDeclarationStatementStorageArray = new SgNamespaceDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamespaceDeclarationStatement::initializeStorageClassArray (SgNamespaceDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamespaceDefinitionStatement ) ; 
     std::cout << " SgNamespaceDefinitionStatement has size " << sizeOfActualPool << std::endl;
     SgNamespaceDefinitionStatementStorageClass* SgNamespaceDefinitionStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceDefinitionStatementStorageArray = new SgNamespaceDefinitionStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamespaceDefinitionStatement::initializeStorageClassArray (SgNamespaceDefinitionStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamespaceSymbol ) ; 
     std::cout << " SgNamespaceSymbol has size " << sizeOfActualPool << std::endl;
     SgNamespaceSymbolStorageClass* SgNamespaceSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceSymbolStorageArray = new SgNamespaceSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamespaceSymbol::initializeStorageClassArray (SgNamespaceSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNaryOp ) ; 
     std::cout << " SgNaryOp has size " << sizeOfActualPool << std::endl;
     SgNaryOpStorageClass* SgNaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryOpStorageArray = new SgNaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNaryOp::initializeStorageClassArray (SgNaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNaryBooleanOp ) ; 
     std::cout << " SgNaryBooleanOp has size " << sizeOfActualPool << std::endl;
     SgNaryBooleanOpStorageClass* SgNaryBooleanOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryBooleanOpStorageArray = new SgNaryBooleanOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNaryBooleanOp::initializeStorageClassArray (SgNaryBooleanOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNaryComparisonOp ) ; 
     std::cout << " SgNaryComparisonOp has size " << sizeOfActualPool << std::endl;
     SgNaryComparisonOpStorageClass* SgNaryComparisonOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryComparisonOpStorageArray = new SgNaryComparisonOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNaryComparisonOp::initializeStorageClassArray (SgNaryComparisonOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNewExp ) ; 
     std::cout << " SgNewExp has size " << sizeOfActualPool << std::endl;
     SgNewExpStorageClass* SgNewExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNewExpStorageArray = new SgNewExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNewExp::initializeStorageClassArray (SgNewExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNode ) ; 
     std::cout << " SgNode has size " << sizeOfActualPool << std::endl;
     SgNodeStorageClass* SgNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNodeStorageArray = new SgNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNode::initializeStorageClassArray (SgNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNoexceptOp ) ; 
     std::cout << " SgNoexceptOp has size " << sizeOfActualPool << std::endl;
     SgNoexceptOpStorageClass* SgNoexceptOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNoexceptOpStorageArray = new SgNoexceptOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNoexceptOp::initializeStorageClassArray (SgNoexceptOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNotEqualOp ) ; 
     std::cout << " SgNotEqualOp has size " << sizeOfActualPool << std::endl;
     SgNotEqualOpStorageClass* SgNotEqualOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNotEqualOpStorageArray = new SgNotEqualOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNotEqualOp::initializeStorageClassArray (SgNotEqualOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNotOp ) ; 
     std::cout << " SgNotOp has size " << sizeOfActualPool << std::endl;
     SgNotOpStorageClass* SgNotOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNotOpStorageArray = new SgNotOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNotOp::initializeStorageClassArray (SgNotOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNonMembershipOp ) ; 
     std::cout << " SgNonMembershipOp has size " << sizeOfActualPool << std::endl;
     SgNonMembershipOpStorageClass* SgNonMembershipOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonMembershipOpStorageArray = new SgNonMembershipOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNonMembershipOp::initializeStorageClassArray (SgNonMembershipOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNonrealDecl ) ; 
     std::cout << " SgNonrealDecl has size " << sizeOfActualPool << std::endl;
     SgNonrealDeclStorageClass* SgNonrealDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealDeclStorageArray = new SgNonrealDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNonrealDecl::initializeStorageClassArray (SgNonrealDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNonrealRefExp ) ; 
     std::cout << " SgNonrealRefExp has size " << sizeOfActualPool << std::endl;
     SgNonrealRefExpStorageClass* SgNonrealRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealRefExpStorageArray = new SgNonrealRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNonrealRefExp::initializeStorageClassArray (SgNonrealRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNonrealSymbol ) ; 
     std::cout << " SgNonrealSymbol has size " << sizeOfActualPool << std::endl;
     SgNonrealSymbolStorageClass* SgNonrealSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealSymbolStorageArray = new SgNonrealSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNonrealSymbol::initializeStorageClassArray (SgNonrealSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNonrealType ) ; 
     std::cout << " SgNonrealType has size " << sizeOfActualPool << std::endl;
     SgNonrealTypeStorageClass* SgNonrealTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealTypeStorageArray = new SgNonrealTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNonrealType::initializeStorageClassArray (SgNonrealTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNonrealBaseClass ) ; 
     std::cout << " SgNonrealBaseClass has size " << sizeOfActualPool << std::endl;
     SgNonrealBaseClassStorageClass* SgNonrealBaseClassStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealBaseClassStorageArray = new SgNonrealBaseClassStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNonrealBaseClass::initializeStorageClassArray (SgNonrealBaseClassStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNullExpression ) ; 
     std::cout << " SgNullExpression has size " << sizeOfActualPool << std::endl;
     SgNullExpressionStorageClass* SgNullExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullExpressionStorageArray = new SgNullExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNullExpression::initializeStorageClassArray (SgNullExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNullptrValExp ) ; 
     std::cout << " SgNullptrValExp has size " << sizeOfActualPool << std::endl;
     SgNullptrValExpStorageClass* SgNullptrValExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullptrValExpStorageArray = new SgNullptrValExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNullptrValExp::initializeStorageClassArray (SgNullptrValExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNullStatement ) ; 
     std::cout << " SgNullStatement has size " << sizeOfActualPool << std::endl;
     SgNullStatementStorageClass* SgNullStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullStatementStorageArray = new SgNullStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNullStatement::initializeStorageClassArray (SgNullStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNullifyStatement ) ; 
     std::cout << " SgNullifyStatement has size " << sizeOfActualPool << std::endl;
     SgNullifyStatementStorageClass* SgNullifyStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullifyStatementStorageArray = new SgNullifyStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNullifyStatement::initializeStorageClassArray (SgNullifyStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpAtomicStatement ) ; 
     std::cout << " SgOmpAtomicStatement has size " << sizeOfActualPool << std::endl;
     SgOmpAtomicStatementStorageClass* SgOmpAtomicStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpAtomicStatementStorageArray = new SgOmpAtomicStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpAtomicStatement::initializeStorageClassArray (SgOmpAtomicStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpBarrierStatement ) ; 
     std::cout << " SgOmpBarrierStatement has size " << sizeOfActualPool << std::endl;
     SgOmpBarrierStatementStorageClass* SgOmpBarrierStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBarrierStatementStorageArray = new SgOmpBarrierStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpBarrierStatement::initializeStorageClassArray (SgOmpBarrierStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpCriticalStatement ) ; 
     std::cout << " SgOmpCriticalStatement has size " << sizeOfActualPool << std::endl;
     SgOmpCriticalStatementStorageClass* SgOmpCriticalStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCriticalStatementStorageArray = new SgOmpCriticalStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpCriticalStatement::initializeStorageClassArray (SgOmpCriticalStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpClauseBodyStatement ) ; 
     std::cout << " SgOmpClauseBodyStatement has size " << sizeOfActualPool << std::endl;
     SgOmpClauseBodyStatementStorageClass* SgOmpClauseBodyStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpClauseBodyStatementStorageArray = new SgOmpClauseBodyStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpClauseBodyStatement::initializeStorageClassArray (SgOmpClauseBodyStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpBodyStatement ) ; 
     std::cout << " SgOmpBodyStatement has size " << sizeOfActualPool << std::endl;
     SgOmpBodyStatementStorageClass* SgOmpBodyStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBodyStatementStorageArray = new SgOmpBodyStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpBodyStatement::initializeStorageClassArray (SgOmpBodyStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpDoStatement ) ; 
     std::cout << " SgOmpDoStatement has size " << sizeOfActualPool << std::endl;
     SgOmpDoStatementStorageClass* SgOmpDoStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDoStatementStorageArray = new SgOmpDoStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpDoStatement::initializeStorageClassArray (SgOmpDoStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpFlushStatement ) ; 
     std::cout << " SgOmpFlushStatement has size " << sizeOfActualPool << std::endl;
     SgOmpFlushStatementStorageClass* SgOmpFlushStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFlushStatementStorageArray = new SgOmpFlushStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpFlushStatement::initializeStorageClassArray (SgOmpFlushStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpDeclareSimdStatement ) ; 
     std::cout << " SgOmpDeclareSimdStatement has size " << sizeOfActualPool << std::endl;
     SgOmpDeclareSimdStatementStorageClass* SgOmpDeclareSimdStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDeclareSimdStatementStorageArray = new SgOmpDeclareSimdStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpDeclareSimdStatement::initializeStorageClassArray (SgOmpDeclareSimdStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpForStatement ) ; 
     std::cout << " SgOmpForStatement has size " << sizeOfActualPool << std::endl;
     SgOmpForStatementStorageClass* SgOmpForStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpForStatementStorageArray = new SgOmpForStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpForStatement::initializeStorageClassArray (SgOmpForStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpForSimdStatement ) ; 
     std::cout << " SgOmpForSimdStatement has size " << sizeOfActualPool << std::endl;
     SgOmpForSimdStatementStorageClass* SgOmpForSimdStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpForSimdStatementStorageArray = new SgOmpForSimdStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpForSimdStatement::initializeStorageClassArray (SgOmpForSimdStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpMasterStatement ) ; 
     std::cout << " SgOmpMasterStatement has size " << sizeOfActualPool << std::endl;
     SgOmpMasterStatementStorageClass* SgOmpMasterStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpMasterStatementStorageArray = new SgOmpMasterStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpMasterStatement::initializeStorageClassArray (SgOmpMasterStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpOrderedStatement ) ; 
     std::cout << " SgOmpOrderedStatement has size " << sizeOfActualPool << std::endl;
     SgOmpOrderedStatementStorageClass* SgOmpOrderedStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpOrderedStatementStorageArray = new SgOmpOrderedStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpOrderedStatement::initializeStorageClassArray (SgOmpOrderedStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpParallelStatement ) ; 
     std::cout << " SgOmpParallelStatement has size " << sizeOfActualPool << std::endl;
     SgOmpParallelStatementStorageClass* SgOmpParallelStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpParallelStatementStorageArray = new SgOmpParallelStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpParallelStatement::initializeStorageClassArray (SgOmpParallelStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSectionStatement ) ; 
     std::cout << " SgOmpSectionStatement has size " << sizeOfActualPool << std::endl;
     SgOmpSectionStatementStorageClass* SgOmpSectionStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSectionStatementStorageArray = new SgOmpSectionStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSectionStatement::initializeStorageClassArray (SgOmpSectionStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSectionsStatement ) ; 
     std::cout << " SgOmpSectionsStatement has size " << sizeOfActualPool << std::endl;
     SgOmpSectionsStatementStorageClass* SgOmpSectionsStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSectionsStatementStorageArray = new SgOmpSectionsStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSectionsStatement::initializeStorageClassArray (SgOmpSectionsStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSingleStatement ) ; 
     std::cout << " SgOmpSingleStatement has size " << sizeOfActualPool << std::endl;
     SgOmpSingleStatementStorageClass* SgOmpSingleStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSingleStatementStorageArray = new SgOmpSingleStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSingleStatement::initializeStorageClassArray (SgOmpSingleStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpTaskStatement ) ; 
     std::cout << " SgOmpTaskStatement has size " << sizeOfActualPool << std::endl;
     SgOmpTaskStatementStorageClass* SgOmpTaskStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTaskStatementStorageArray = new SgOmpTaskStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpTaskStatement::initializeStorageClassArray (SgOmpTaskStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpTaskwaitStatement ) ; 
     std::cout << " SgOmpTaskwaitStatement has size " << sizeOfActualPool << std::endl;
     SgOmpTaskwaitStatementStorageClass* SgOmpTaskwaitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTaskwaitStatementStorageArray = new SgOmpTaskwaitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpTaskwaitStatement::initializeStorageClassArray (SgOmpTaskwaitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpThreadprivateStatement ) ; 
     std::cout << " SgOmpThreadprivateStatement has size " << sizeOfActualPool << std::endl;
     SgOmpThreadprivateStatementStorageClass* SgOmpThreadprivateStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpThreadprivateStatementStorageArray = new SgOmpThreadprivateStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpThreadprivateStatement::initializeStorageClassArray (SgOmpThreadprivateStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpWorkshareStatement ) ; 
     std::cout << " SgOmpWorkshareStatement has size " << sizeOfActualPool << std::endl;
     SgOmpWorkshareStatementStorageClass* SgOmpWorkshareStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpWorkshareStatementStorageArray = new SgOmpWorkshareStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpWorkshareStatement::initializeStorageClassArray (SgOmpWorkshareStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpTargetStatement ) ; 
     std::cout << " SgOmpTargetStatement has size " << sizeOfActualPool << std::endl;
     SgOmpTargetStatementStorageClass* SgOmpTargetStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTargetStatementStorageArray = new SgOmpTargetStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpTargetStatement::initializeStorageClassArray (SgOmpTargetStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpTargetDataStatement ) ; 
     std::cout << " SgOmpTargetDataStatement has size " << sizeOfActualPool << std::endl;
     SgOmpTargetDataStatementStorageClass* SgOmpTargetDataStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTargetDataStatementStorageArray = new SgOmpTargetDataStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpTargetDataStatement::initializeStorageClassArray (SgOmpTargetDataStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSimdStatement ) ; 
     std::cout << " SgOmpSimdStatement has size " << sizeOfActualPool << std::endl;
     SgOmpSimdStatementStorageClass* SgOmpSimdStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSimdStatementStorageArray = new SgOmpSimdStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSimdStatement::initializeStorageClassArray (SgOmpSimdStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpClause ) ; 
     std::cout << " SgOmpClause has size " << sizeOfActualPool << std::endl;
     SgOmpClauseStorageClass* SgOmpClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpClauseStorageArray = new SgOmpClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpClause::initializeStorageClassArray (SgOmpClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpBeginClause ) ; 
     std::cout << " SgOmpBeginClause has size " << sizeOfActualPool << std::endl;
     SgOmpBeginClauseStorageClass* SgOmpBeginClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBeginClauseStorageArray = new SgOmpBeginClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpBeginClause::initializeStorageClassArray (SgOmpBeginClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpCollapseClause ) ; 
     std::cout << " SgOmpCollapseClause has size " << sizeOfActualPool << std::endl;
     SgOmpCollapseClauseStorageClass* SgOmpCollapseClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCollapseClauseStorageArray = new SgOmpCollapseClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpCollapseClause::initializeStorageClassArray (SgOmpCollapseClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpCopyinClause ) ; 
     std::cout << " SgOmpCopyinClause has size " << sizeOfActualPool << std::endl;
     SgOmpCopyinClauseStorageClass* SgOmpCopyinClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCopyinClauseStorageArray = new SgOmpCopyinClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpCopyinClause::initializeStorageClassArray (SgOmpCopyinClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpCopyprivateClause ) ; 
     std::cout << " SgOmpCopyprivateClause has size " << sizeOfActualPool << std::endl;
     SgOmpCopyprivateClauseStorageClass* SgOmpCopyprivateClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCopyprivateClauseStorageArray = new SgOmpCopyprivateClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpCopyprivateClause::initializeStorageClassArray (SgOmpCopyprivateClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpDefaultClause ) ; 
     std::cout << " SgOmpDefaultClause has size " << sizeOfActualPool << std::endl;
     SgOmpDefaultClauseStorageClass* SgOmpDefaultClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDefaultClauseStorageArray = new SgOmpDefaultClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpDefaultClause::initializeStorageClassArray (SgOmpDefaultClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpEndClause ) ; 
     std::cout << " SgOmpEndClause has size " << sizeOfActualPool << std::endl;
     SgOmpEndClauseStorageClass* SgOmpEndClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpEndClauseStorageArray = new SgOmpEndClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpEndClause::initializeStorageClassArray (SgOmpEndClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpExpressionClause ) ; 
     std::cout << " SgOmpExpressionClause has size " << sizeOfActualPool << std::endl;
     SgOmpExpressionClauseStorageClass* SgOmpExpressionClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpExpressionClauseStorageArray = new SgOmpExpressionClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpExpressionClause::initializeStorageClassArray (SgOmpExpressionClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpFirstprivateClause ) ; 
     std::cout << " SgOmpFirstprivateClause has size " << sizeOfActualPool << std::endl;
     SgOmpFirstprivateClauseStorageClass* SgOmpFirstprivateClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFirstprivateClauseStorageArray = new SgOmpFirstprivateClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpFirstprivateClause::initializeStorageClassArray (SgOmpFirstprivateClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpIfClause ) ; 
     std::cout << " SgOmpIfClause has size " << sizeOfActualPool << std::endl;
     SgOmpIfClauseStorageClass* SgOmpIfClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpIfClauseStorageArray = new SgOmpIfClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpIfClause::initializeStorageClassArray (SgOmpIfClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpFinalClause ) ; 
     std::cout << " SgOmpFinalClause has size " << sizeOfActualPool << std::endl;
     SgOmpFinalClauseStorageClass* SgOmpFinalClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFinalClauseStorageArray = new SgOmpFinalClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpFinalClause::initializeStorageClassArray (SgOmpFinalClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpPriorityClause ) ; 
     std::cout << " SgOmpPriorityClause has size " << sizeOfActualPool << std::endl;
     SgOmpPriorityClauseStorageClass* SgOmpPriorityClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpPriorityClauseStorageArray = new SgOmpPriorityClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpPriorityClause::initializeStorageClassArray (SgOmpPriorityClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpDeviceClause ) ; 
     std::cout << " SgOmpDeviceClause has size " << sizeOfActualPool << std::endl;
     SgOmpDeviceClauseStorageClass* SgOmpDeviceClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDeviceClauseStorageArray = new SgOmpDeviceClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpDeviceClause::initializeStorageClassArray (SgOmpDeviceClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpLastprivateClause ) ; 
     std::cout << " SgOmpLastprivateClause has size " << sizeOfActualPool << std::endl;
     SgOmpLastprivateClauseStorageClass* SgOmpLastprivateClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpLastprivateClauseStorageArray = new SgOmpLastprivateClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpLastprivateClause::initializeStorageClassArray (SgOmpLastprivateClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpNowaitClause ) ; 
     std::cout << " SgOmpNowaitClause has size " << sizeOfActualPool << std::endl;
     SgOmpNowaitClauseStorageClass* SgOmpNowaitClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNowaitClauseStorageArray = new SgOmpNowaitClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpNowaitClause::initializeStorageClassArray (SgOmpNowaitClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpNumThreadsClause ) ; 
     std::cout << " SgOmpNumThreadsClause has size " << sizeOfActualPool << std::endl;
     SgOmpNumThreadsClauseStorageClass* SgOmpNumThreadsClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNumThreadsClauseStorageArray = new SgOmpNumThreadsClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpNumThreadsClause::initializeStorageClassArray (SgOmpNumThreadsClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpOrderedClause ) ; 
     std::cout << " SgOmpOrderedClause has size " << sizeOfActualPool << std::endl;
     SgOmpOrderedClauseStorageClass* SgOmpOrderedClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpOrderedClauseStorageArray = new SgOmpOrderedClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpOrderedClause::initializeStorageClassArray (SgOmpOrderedClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpPrivateClause ) ; 
     std::cout << " SgOmpPrivateClause has size " << sizeOfActualPool << std::endl;
     SgOmpPrivateClauseStorageClass* SgOmpPrivateClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpPrivateClauseStorageArray = new SgOmpPrivateClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpPrivateClause::initializeStorageClassArray (SgOmpPrivateClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpReductionClause ) ; 
     std::cout << " SgOmpReductionClause has size " << sizeOfActualPool << std::endl;
     SgOmpReductionClauseStorageClass* SgOmpReductionClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpReductionClauseStorageArray = new SgOmpReductionClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpReductionClause::initializeStorageClassArray (SgOmpReductionClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpScheduleClause ) ; 
     std::cout << " SgOmpScheduleClause has size " << sizeOfActualPool << std::endl;
     SgOmpScheduleClauseStorageClass* SgOmpScheduleClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpScheduleClauseStorageArray = new SgOmpScheduleClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpScheduleClause::initializeStorageClassArray (SgOmpScheduleClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSharedClause ) ; 
     std::cout << " SgOmpSharedClause has size " << sizeOfActualPool << std::endl;
     SgOmpSharedClauseStorageClass* SgOmpSharedClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSharedClauseStorageArray = new SgOmpSharedClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSharedClause::initializeStorageClassArray (SgOmpSharedClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpUntiedClause ) ; 
     std::cout << " SgOmpUntiedClause has size " << sizeOfActualPool << std::endl;
     SgOmpUntiedClauseStorageClass* SgOmpUntiedClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpUntiedClauseStorageArray = new SgOmpUntiedClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpUntiedClause::initializeStorageClassArray (SgOmpUntiedClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpMergeableClause ) ; 
     std::cout << " SgOmpMergeableClause has size " << sizeOfActualPool << std::endl;
     SgOmpMergeableClauseStorageClass* SgOmpMergeableClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpMergeableClauseStorageArray = new SgOmpMergeableClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpMergeableClause::initializeStorageClassArray (SgOmpMergeableClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpVariablesClause ) ; 
     std::cout << " SgOmpVariablesClause has size " << sizeOfActualPool << std::endl;
     SgOmpVariablesClauseStorageClass* SgOmpVariablesClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpVariablesClauseStorageArray = new SgOmpVariablesClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpVariablesClause::initializeStorageClassArray (SgOmpVariablesClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpMapClause ) ; 
     std::cout << " SgOmpMapClause has size " << sizeOfActualPool << std::endl;
     SgOmpMapClauseStorageClass* SgOmpMapClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpMapClauseStorageArray = new SgOmpMapClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpMapClause::initializeStorageClassArray (SgOmpMapClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSafelenClause ) ; 
     std::cout << " SgOmpSafelenClause has size " << sizeOfActualPool << std::endl;
     SgOmpSafelenClauseStorageClass* SgOmpSafelenClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSafelenClauseStorageArray = new SgOmpSafelenClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSafelenClause::initializeStorageClassArray (SgOmpSafelenClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSimdlenClause ) ; 
     std::cout << " SgOmpSimdlenClause has size " << sizeOfActualPool << std::endl;
     SgOmpSimdlenClauseStorageClass* SgOmpSimdlenClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSimdlenClauseStorageArray = new SgOmpSimdlenClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSimdlenClause::initializeStorageClassArray (SgOmpSimdlenClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpLinearClause ) ; 
     std::cout << " SgOmpLinearClause has size " << sizeOfActualPool << std::endl;
     SgOmpLinearClauseStorageClass* SgOmpLinearClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpLinearClauseStorageArray = new SgOmpLinearClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpLinearClause::initializeStorageClassArray (SgOmpLinearClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpUniformClause ) ; 
     std::cout << " SgOmpUniformClause has size " << sizeOfActualPool << std::endl;
     SgOmpUniformClauseStorageClass* SgOmpUniformClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpUniformClauseStorageArray = new SgOmpUniformClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpUniformClause::initializeStorageClassArray (SgOmpUniformClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpAlignedClause ) ; 
     std::cout << " SgOmpAlignedClause has size " << sizeOfActualPool << std::endl;
     SgOmpAlignedClauseStorageClass* SgOmpAlignedClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpAlignedClauseStorageArray = new SgOmpAlignedClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpAlignedClause::initializeStorageClassArray (SgOmpAlignedClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpProcBindClause ) ; 
     std::cout << " SgOmpProcBindClause has size " << sizeOfActualPool << std::endl;
     SgOmpProcBindClauseStorageClass* SgOmpProcBindClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpProcBindClauseStorageArray = new SgOmpProcBindClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpProcBindClause::initializeStorageClassArray (SgOmpProcBindClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpAtomicClause ) ; 
     std::cout << " SgOmpAtomicClause has size " << sizeOfActualPool << std::endl;
     SgOmpAtomicClauseStorageClass* SgOmpAtomicClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpAtomicClauseStorageArray = new SgOmpAtomicClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpAtomicClause::initializeStorageClassArray (SgOmpAtomicClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpInbranchClause ) ; 
     std::cout << " SgOmpInbranchClause has size " << sizeOfActualPool << std::endl;
     SgOmpInbranchClauseStorageClass* SgOmpInbranchClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpInbranchClauseStorageArray = new SgOmpInbranchClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpInbranchClause::initializeStorageClassArray (SgOmpInbranchClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpNotinbranchClause ) ; 
     std::cout << " SgOmpNotinbranchClause has size " << sizeOfActualPool << std::endl;
     SgOmpNotinbranchClauseStorageClass* SgOmpNotinbranchClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNotinbranchClauseStorageArray = new SgOmpNotinbranchClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpNotinbranchClause::initializeStorageClassArray (SgOmpNotinbranchClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpDependClause ) ; 
     std::cout << " SgOmpDependClause has size " << sizeOfActualPool << std::endl;
     SgOmpDependClauseStorageClass* SgOmpDependClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDependClauseStorageArray = new SgOmpDependClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpDependClause::initializeStorageClassArray (SgOmpDependClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOpenclAccessModeModifier ) ; 
     std::cout << " SgOpenclAccessModeModifier has size " << sizeOfActualPool << std::endl;
     SgOpenclAccessModeModifierStorageClass* SgOpenclAccessModeModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOpenclAccessModeModifierStorageArray = new SgOpenclAccessModeModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOpenclAccessModeModifier::initializeStorageClassArray (SgOpenclAccessModeModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOpenStatement ) ; 
     std::cout << " SgOpenStatement has size " << sizeOfActualPool << std::endl;
     SgOpenStatementStorageClass* SgOpenStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOpenStatementStorageArray = new SgOpenStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOpenStatement::initializeStorageClassArray (SgOpenStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOptions ) ; 
     std::cout << " SgOptions has size " << sizeOfActualPool << std::endl;
     SgOptionsStorageClass* SgOptionsStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOptionsStorageArray = new SgOptionsStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOptions::initializeStorageClassArray (SgOptionsStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOrOp ) ; 
     std::cout << " SgOrOp has size " << sizeOfActualPool << std::endl;
     SgOrOpStorageClass* SgOrOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOrOpStorageArray = new SgOrOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOrOp::initializeStorageClassArray (SgOrOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgParameterStatement ) ; 
     std::cout << " SgParameterStatement has size " << sizeOfActualPool << std::endl;
     SgParameterStatementStorageClass* SgParameterStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgParameterStatementStorageArray = new SgParameterStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgParameterStatement::initializeStorageClassArray (SgParameterStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPartialFunctionModifierType ) ; 
     std::cout << " SgPartialFunctionModifierType has size " << sizeOfActualPool << std::endl;
     SgPartialFunctionModifierTypeStorageClass* SgPartialFunctionModifierTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPartialFunctionModifierTypeStorageArray = new SgPartialFunctionModifierTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPartialFunctionModifierType::initializeStorageClassArray (SgPartialFunctionModifierTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPartialFunctionType ) ; 
     std::cout << " SgPartialFunctionType has size " << sizeOfActualPool << std::endl;
     SgPartialFunctionTypeStorageClass* SgPartialFunctionTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPartialFunctionTypeStorageArray = new SgPartialFunctionTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPartialFunctionType::initializeStorageClassArray (SgPartialFunctionTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPassStatement ) ; 
     std::cout << " SgPassStatement has size " << sizeOfActualPool << std::endl;
     SgPassStatementStorageClass* SgPassStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPassStatementStorageArray = new SgPassStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPassStatement::initializeStorageClassArray (SgPassStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPlusAssignOp ) ; 
     std::cout << " SgPlusAssignOp has size " << sizeOfActualPool << std::endl;
     SgPlusAssignOpStorageClass* SgPlusAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPlusAssignOpStorageArray = new SgPlusAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPlusAssignOp::initializeStorageClassArray (SgPlusAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPlusPlusOp ) ; 
     std::cout << " SgPlusPlusOp has size " << sizeOfActualPool << std::endl;
     SgPlusPlusOpStorageClass* SgPlusPlusOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPlusPlusOpStorageArray = new SgPlusPlusOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPlusPlusOp::initializeStorageClassArray (SgPlusPlusOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPntrArrRefExp ) ; 
     std::cout << " SgPntrArrRefExp has size " << sizeOfActualPool << std::endl;
     SgPntrArrRefExpStorageClass* SgPntrArrRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPntrArrRefExpStorageArray = new SgPntrArrRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPntrArrRefExp::initializeStorageClassArray (SgPntrArrRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPointerAssignOp ) ; 
     std::cout << " SgPointerAssignOp has size " << sizeOfActualPool << std::endl;
     SgPointerAssignOpStorageClass* SgPointerAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerAssignOpStorageArray = new SgPointerAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPointerAssignOp::initializeStorageClassArray (SgPointerAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPointerDerefExp ) ; 
     std::cout << " SgPointerDerefExp has size " << sizeOfActualPool << std::endl;
     SgPointerDerefExpStorageClass* SgPointerDerefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerDerefExpStorageArray = new SgPointerDerefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPointerDerefExp::initializeStorageClassArray (SgPointerDerefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPointerMemberType ) ; 
     std::cout << " SgPointerMemberType has size " << sizeOfActualPool << std::endl;
     SgPointerMemberTypeStorageClass* SgPointerMemberTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerMemberTypeStorageArray = new SgPointerMemberTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPointerMemberType::initializeStorageClassArray (SgPointerMemberTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPointerType ) ; 
     std::cout << " SgPointerType has size " << sizeOfActualPool << std::endl;
     SgPointerTypeStorageClass* SgPointerTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerTypeStorageArray = new SgPointerTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPointerType::initializeStorageClassArray (SgPointerTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPowerOp ) ; 
     std::cout << " SgPowerOp has size " << sizeOfActualPool << std::endl;
     SgPowerOpStorageClass* SgPowerOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPowerOpStorageArray = new SgPowerOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPowerOp::initializeStorageClassArray (SgPowerOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPragma ) ; 
     std::cout << " SgPragma has size " << sizeOfActualPool << std::endl;
     SgPragmaStorageClass* SgPragmaStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPragmaStorageArray = new SgPragmaStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPragma::initializeStorageClassArray (SgPragmaStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPragmaDeclaration ) ; 
     std::cout << " SgPragmaDeclaration has size " << sizeOfActualPool << std::endl;
     SgPragmaDeclarationStorageClass* SgPragmaDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPragmaDeclarationStorageArray = new SgPragmaDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPragmaDeclaration::initializeStorageClassArray (SgPragmaDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPrintStatement ) ; 
     std::cout << " SgPrintStatement has size " << sizeOfActualPool << std::endl;
     SgPrintStatementStorageClass* SgPrintStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPrintStatementStorageArray = new SgPrintStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPrintStatement::initializeStorageClassArray (SgPrintStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgProcedureHeaderStatement ) ; 
     std::cout << " SgProcedureHeaderStatement has size " << sizeOfActualPool << std::endl;
     SgProcedureHeaderStatementStorageClass* SgProcedureHeaderStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProcedureHeaderStatementStorageArray = new SgProcedureHeaderStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgProcedureHeaderStatement::initializeStorageClassArray (SgProcedureHeaderStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgProgramHeaderStatement ) ; 
     std::cout << " SgProgramHeaderStatement has size " << sizeOfActualPool << std::endl;
     SgProgramHeaderStatementStorageClass* SgProgramHeaderStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProgramHeaderStatementStorageArray = new SgProgramHeaderStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgProgramHeaderStatement::initializeStorageClassArray (SgProgramHeaderStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgProject ) ; 
     std::cout << " SgProject has size " << sizeOfActualPool << std::endl;
     SgProjectStorageClass* SgProjectStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProjectStorageArray = new SgProjectStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgProject::initializeStorageClassArray (SgProjectStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPseudoDestructorRefExp ) ; 
     std::cout << " SgPseudoDestructorRefExp has size " << sizeOfActualPool << std::endl;
     SgPseudoDestructorRefExpStorageClass* SgPseudoDestructorRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPseudoDestructorRefExpStorageArray = new SgPseudoDestructorRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPseudoDestructorRefExp::initializeStorageClassArray (SgPseudoDestructorRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPythonGlobalStmt ) ; 
     std::cout << " SgPythonGlobalStmt has size " << sizeOfActualPool << std::endl;
     SgPythonGlobalStmtStorageClass* SgPythonGlobalStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPythonGlobalStmtStorageArray = new SgPythonGlobalStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPythonGlobalStmt::initializeStorageClassArray (SgPythonGlobalStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPythonPrintStmt ) ; 
     std::cout << " SgPythonPrintStmt has size " << sizeOfActualPool << std::endl;
     SgPythonPrintStmtStorageClass* SgPythonPrintStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPythonPrintStmtStorageArray = new SgPythonPrintStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPythonPrintStmt::initializeStorageClassArray (SgPythonPrintStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgQualifiedName ) ; 
     std::cout << " SgQualifiedName has size " << sizeOfActualPool << std::endl;
     SgQualifiedNameStorageClass* SgQualifiedNameStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgQualifiedNameStorageArray = new SgQualifiedNameStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgQualifiedName::initializeStorageClassArray (SgQualifiedNameStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgQualifiedNameType ) ; 
     std::cout << " SgQualifiedNameType has size " << sizeOfActualPool << std::endl;
     SgQualifiedNameTypeStorageClass* SgQualifiedNameTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgQualifiedNameTypeStorageArray = new SgQualifiedNameTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgQualifiedNameType::initializeStorageClassArray (SgQualifiedNameTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRangeExp ) ; 
     std::cout << " SgRangeExp has size " << sizeOfActualPool << std::endl;
     SgRangeExpStorageClass* SgRangeExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRangeExpStorageArray = new SgRangeExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRangeExp::initializeStorageClassArray (SgRangeExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRangeBasedForStatement ) ; 
     std::cout << " SgRangeBasedForStatement has size " << sizeOfActualPool << std::endl;
     SgRangeBasedForStatementStorageClass* SgRangeBasedForStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRangeBasedForStatementStorageArray = new SgRangeBasedForStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRangeBasedForStatement::initializeStorageClassArray (SgRangeBasedForStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgReadStatement ) ; 
     std::cout << " SgReadStatement has size " << sizeOfActualPool << std::endl;
     SgReadStatementStorageClass* SgReadStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReadStatementStorageArray = new SgReadStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgReadStatement::initializeStorageClassArray (SgReadStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRealPartOp ) ; 
     std::cout << " SgRealPartOp has size " << sizeOfActualPool << std::endl;
     SgRealPartOpStorageClass* SgRealPartOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRealPartOpStorageArray = new SgRealPartOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRealPartOp::initializeStorageClassArray (SgRealPartOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRefExp ) ; 
     std::cout << " SgRefExp has size " << sizeOfActualPool << std::endl;
     SgRefExpStorageClass* SgRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRefExpStorageArray = new SgRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRefExp::initializeStorageClassArray (SgRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgReferenceType ) ; 
     std::cout << " SgReferenceType has size " << sizeOfActualPool << std::endl;
     SgReferenceTypeStorageClass* SgReferenceTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReferenceTypeStorageArray = new SgReferenceTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgReferenceType::initializeStorageClassArray (SgReferenceTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRemOp ) ; 
     std::cout << " SgRemOp has size " << sizeOfActualPool << std::endl;
     SgRemOpStorageClass* SgRemOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRemOpStorageArray = new SgRemOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRemOp::initializeStorageClassArray (SgRemOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRenamePair ) ; 
     std::cout << " SgRenamePair has size " << sizeOfActualPool << std::endl;
     SgRenamePairStorageClass* SgRenamePairStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRenamePairStorageArray = new SgRenamePairStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRenamePair::initializeStorageClassArray (SgRenamePairStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRenameSymbol ) ; 
     std::cout << " SgRenameSymbol has size " << sizeOfActualPool << std::endl;
     SgRenameSymbolStorageClass* SgRenameSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRenameSymbolStorageArray = new SgRenameSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRenameSymbol::initializeStorageClassArray (SgRenameSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgReplicationOp ) ; 
     std::cout << " SgReplicationOp has size " << sizeOfActualPool << std::endl;
     SgReplicationOpStorageClass* SgReplicationOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReplicationOpStorageArray = new SgReplicationOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgReplicationOp::initializeStorageClassArray (SgReplicationOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgReturnStmt ) ; 
     std::cout << " SgReturnStmt has size " << sizeOfActualPool << std::endl;
     SgReturnStmtStorageClass* SgReturnStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReturnStmtStorageArray = new SgReturnStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgReturnStmt::initializeStorageClassArray (SgReturnStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRewindStatement ) ; 
     std::cout << " SgRewindStatement has size " << sizeOfActualPool << std::endl;
     SgRewindStatementStorageClass* SgRewindStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRewindStatementStorageArray = new SgRewindStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRewindStatement::initializeStorageClassArray (SgRewindStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRshiftAssignOp ) ; 
     std::cout << " SgRshiftAssignOp has size " << sizeOfActualPool << std::endl;
     SgRshiftAssignOpStorageClass* SgRshiftAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRshiftAssignOpStorageArray = new SgRshiftAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRshiftAssignOp::initializeStorageClassArray (SgRshiftAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRshiftOp ) ; 
     std::cout << " SgRshiftOp has size " << sizeOfActualPool << std::endl;
     SgRshiftOpStorageClass* SgRshiftOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRshiftOpStorageArray = new SgRshiftOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRshiftOp::initializeStorageClassArray (SgRshiftOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRvalueReferenceType ) ; 
     std::cout << " SgRvalueReferenceType has size " << sizeOfActualPool << std::endl;
     SgRvalueReferenceTypeStorageClass* SgRvalueReferenceTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRvalueReferenceTypeStorageArray = new SgRvalueReferenceTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRvalueReferenceType::initializeStorageClassArray (SgRvalueReferenceTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaUnsignedRshiftAssignOp ) ; 
     std::cout << " SgJavaUnsignedRshiftAssignOp has size " << sizeOfActualPool << std::endl;
     SgJavaUnsignedRshiftAssignOpStorageClass* SgJavaUnsignedRshiftAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnsignedRshiftAssignOpStorageArray = new SgJavaUnsignedRshiftAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaUnsignedRshiftAssignOp::initializeStorageClassArray (SgJavaUnsignedRshiftAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaUnsignedRshiftOp ) ; 
     std::cout << " SgJavaUnsignedRshiftOp has size " << sizeOfActualPool << std::endl;
     SgJavaUnsignedRshiftOpStorageClass* SgJavaUnsignedRshiftOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnsignedRshiftOpStorageArray = new SgJavaUnsignedRshiftOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaUnsignedRshiftOp::initializeStorageClassArray (SgJavaUnsignedRshiftOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgScopeOp ) ; 
     std::cout << " SgScopeOp has size " << sizeOfActualPool << std::endl;
     SgScopeOpStorageClass* SgScopeOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopeOpStorageArray = new SgScopeOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgScopeOp::initializeStorageClassArray (SgScopeOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgScopeStatement ) ; 
     std::cout << " SgScopeStatement has size " << sizeOfActualPool << std::endl;
     SgScopeStatementStorageClass* SgScopeStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopeStatementStorageArray = new SgScopeStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgScopeStatement::initializeStorageClassArray (SgScopeStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSequenceStatement ) ; 
     std::cout << " SgSequenceStatement has size " << sizeOfActualPool << std::endl;
     SgSequenceStatementStorageClass* SgSequenceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSequenceStatementStorageArray = new SgSequenceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSequenceStatement::initializeStorageClassArray (SgSequenceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSetComprehension ) ; 
     std::cout << " SgSetComprehension has size " << sizeOfActualPool << std::endl;
     SgSetComprehensionStorageClass* SgSetComprehensionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSetComprehensionStorageArray = new SgSetComprehensionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSetComprehension::initializeStorageClassArray (SgSetComprehensionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgShortVal ) ; 
     std::cout << " SgShortVal has size " << sizeOfActualPool << std::endl;
     SgShortValStorageClass* SgShortValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgShortValStorageArray = new SgShortValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgShortVal::initializeStorageClassArray (SgShortValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSizeOfOp ) ; 
     std::cout << " SgSizeOfOp has size " << sizeOfActualPool << std::endl;
     SgSizeOfOpStorageClass* SgSizeOfOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSizeOfOpStorageArray = new SgSizeOfOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSizeOfOp::initializeStorageClassArray (SgSizeOfOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAlignOfOp ) ; 
     std::cout << " SgAlignOfOp has size " << sizeOfActualPool << std::endl;
     SgAlignOfOpStorageClass* SgAlignOfOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAlignOfOpStorageArray = new SgAlignOfOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAlignOfOp::initializeStorageClassArray (SgAlignOfOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaInstanceOfOp ) ; 
     std::cout << " SgJavaInstanceOfOp has size " << sizeOfActualPool << std::endl;
     SgJavaInstanceOfOpStorageClass* SgJavaInstanceOfOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaInstanceOfOpStorageArray = new SgJavaInstanceOfOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaInstanceOfOp::initializeStorageClassArray (SgJavaInstanceOfOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSourceFile ) ; 
     std::cout << " SgSourceFile has size " << sizeOfActualPool << std::endl;
     SgSourceFileStorageClass* SgSourceFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSourceFileStorageArray = new SgSourceFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSourceFile::initializeStorageClassArray (SgSourceFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSpaceshipOp ) ; 
     std::cout << " SgSpaceshipOp has size " << sizeOfActualPool << std::endl;
     SgSpaceshipOpStorageClass* SgSpaceshipOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpaceshipOpStorageArray = new SgSpaceshipOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSpaceshipOp::initializeStorageClassArray (SgSpaceshipOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSpawnStmt ) ; 
     std::cout << " SgSpawnStmt has size " << sizeOfActualPool << std::endl;
     SgSpawnStmtStorageClass* SgSpawnStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpawnStmtStorageArray = new SgSpawnStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSpawnStmt::initializeStorageClassArray (SgSpawnStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSyncAllStatement ) ; 
     std::cout << " SgSyncAllStatement has size " << sizeOfActualPool << std::endl;
     SgSyncAllStatementStorageClass* SgSyncAllStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSyncAllStatementStorageArray = new SgSyncAllStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSyncAllStatement::initializeStorageClassArray (SgSyncAllStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSyncImagesStatement ) ; 
     std::cout << " SgSyncImagesStatement has size " << sizeOfActualPool << std::endl;
     SgSyncImagesStatementStorageClass* SgSyncImagesStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSyncImagesStatementStorageArray = new SgSyncImagesStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSyncImagesStatement::initializeStorageClassArray (SgSyncImagesStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSyncMemoryStatement ) ; 
     std::cout << " SgSyncMemoryStatement has size " << sizeOfActualPool << std::endl;
     SgSyncMemoryStatementStorageClass* SgSyncMemoryStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSyncMemoryStatementStorageArray = new SgSyncMemoryStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSyncMemoryStatement::initializeStorageClassArray (SgSyncMemoryStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSyncTeamStatement ) ; 
     std::cout << " SgSyncTeamStatement has size " << sizeOfActualPool << std::endl;
     SgSyncTeamStatementStorageClass* SgSyncTeamStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSyncTeamStatementStorageArray = new SgSyncTeamStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSyncTeamStatement::initializeStorageClassArray (SgSyncTeamStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLockStatement ) ; 
     std::cout << " SgLockStatement has size " << sizeOfActualPool << std::endl;
     SgLockStatementStorageClass* SgLockStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLockStatementStorageArray = new SgLockStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLockStatement::initializeStorageClassArray (SgLockStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnlockStatement ) ; 
     std::cout << " SgUnlockStatement has size " << sizeOfActualPool << std::endl;
     SgUnlockStatementStorageClass* SgUnlockStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnlockStatementStorageArray = new SgUnlockStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnlockStatement::initializeStorageClassArray (SgUnlockStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaThrowStatement ) ; 
     std::cout << " SgJavaThrowStatement has size " << sizeOfActualPool << std::endl;
     SgJavaThrowStatementStorageClass* SgJavaThrowStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaThrowStatementStorageArray = new SgJavaThrowStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaThrowStatement::initializeStorageClassArray (SgJavaThrowStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaForEachStatement ) ; 
     std::cout << " SgJavaForEachStatement has size " << sizeOfActualPool << std::endl;
     SgJavaForEachStatementStorageClass* SgJavaForEachStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaForEachStatementStorageArray = new SgJavaForEachStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaForEachStatement::initializeStorageClassArray (SgJavaForEachStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaSynchronizedStatement ) ; 
     std::cout << " SgJavaSynchronizedStatement has size " << sizeOfActualPool << std::endl;
     SgJavaSynchronizedStatementStorageClass* SgJavaSynchronizedStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaSynchronizedStatementStorageArray = new SgJavaSynchronizedStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaSynchronizedStatement::initializeStorageClassArray (SgJavaSynchronizedStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaParameterizedType ) ; 
     std::cout << " SgJavaParameterizedType has size " << sizeOfActualPool << std::endl;
     SgJavaParameterizedTypeStorageClass* SgJavaParameterizedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaParameterizedTypeStorageArray = new SgJavaParameterizedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaParameterizedType::initializeStorageClassArray (SgJavaParameterizedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaWildcardType ) ; 
     std::cout << " SgJavaWildcardType has size " << sizeOfActualPool << std::endl;
     SgJavaWildcardTypeStorageClass* SgJavaWildcardTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaWildcardTypeStorageArray = new SgJavaWildcardTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaWildcardType::initializeStorageClassArray (SgJavaWildcardTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgProcessControlStatement ) ; 
     std::cout << " SgProcessControlStatement has size " << sizeOfActualPool << std::endl;
     SgProcessControlStatementStorageClass* SgProcessControlStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProcessControlStatementStorageArray = new SgProcessControlStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgProcessControlStatement::initializeStorageClassArray (SgProcessControlStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSpecialFunctionModifier ) ; 
     std::cout << " SgSpecialFunctionModifier has size " << sizeOfActualPool << std::endl;
     SgSpecialFunctionModifierStorageClass* SgSpecialFunctionModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpecialFunctionModifierStorageArray = new SgSpecialFunctionModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSpecialFunctionModifier::initializeStorageClassArray (SgSpecialFunctionModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStatement ) ; 
     std::cout << " SgStatement has size " << sizeOfActualPool << std::endl;
     SgStatementStorageClass* SgStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementStorageArray = new SgStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStatement::initializeStorageClassArray (SgStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStaticAssertionDeclaration ) ; 
     std::cout << " SgStaticAssertionDeclaration has size " << sizeOfActualPool << std::endl;
     SgStaticAssertionDeclarationStorageClass* SgStaticAssertionDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStaticAssertionDeclarationStorageArray = new SgStaticAssertionDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStaticAssertionDeclaration::initializeStorageClassArray (SgStaticAssertionDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStmtDeclarationStatement ) ; 
     std::cout << " SgStmtDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgStmtDeclarationStatementStorageClass* SgStmtDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStmtDeclarationStatementStorageArray = new SgStmtDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStmtDeclarationStatement::initializeStorageClassArray (SgStmtDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStatementExpression ) ; 
     std::cout << " SgStatementExpression has size " << sizeOfActualPool << std::endl;
     SgStatementExpressionStorageClass* SgStatementExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementExpressionStorageArray = new SgStatementExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStatementExpression::initializeStorageClassArray (SgStatementExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStatementFunctionStatement ) ; 
     std::cout << " SgStatementFunctionStatement has size " << sizeOfActualPool << std::endl;
     SgStatementFunctionStatementStorageClass* SgStatementFunctionStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementFunctionStatementStorageArray = new SgStatementFunctionStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStatementFunctionStatement::initializeStorageClassArray (SgStatementFunctionStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStorageModifier ) ; 
     std::cout << " SgStorageModifier has size " << sizeOfActualPool << std::endl;
     SgStorageModifierStorageClass* SgStorageModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStorageModifierStorageArray = new SgStorageModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStorageModifier::initializeStorageClassArray (SgStorageModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStringConversion ) ; 
     std::cout << " SgStringConversion has size " << sizeOfActualPool << std::endl;
     SgStringConversionStorageClass* SgStringConversionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringConversionStorageArray = new SgStringConversionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStringConversion::initializeStorageClassArray (SgStringConversionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStringKeyedBidirectionalGraph ) ; 
     std::cout << " SgStringKeyedBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     SgStringKeyedBidirectionalGraphStorageClass* SgStringKeyedBidirectionalGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringKeyedBidirectionalGraphStorageArray = new SgStringKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStringKeyedBidirectionalGraph::initializeStorageClassArray (SgStringKeyedBidirectionalGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStringVal ) ; 
     std::cout << " SgStringVal has size " << sizeOfActualPool << std::endl;
     SgStringValStorageClass* SgStringValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringValStorageArray = new SgStringValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStringVal::initializeStorageClassArray (SgStringValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStructureModifier ) ; 
     std::cout << " SgStructureModifier has size " << sizeOfActualPool << std::endl;
     SgStructureModifierStorageClass* SgStructureModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStructureModifierStorageArray = new SgStructureModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStructureModifier::initializeStorageClassArray (SgStructureModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSubscriptExpression ) ; 
     std::cout << " SgSubscriptExpression has size " << sizeOfActualPool << std::endl;
     SgSubscriptExpressionStorageClass* SgSubscriptExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSubscriptExpressionStorageArray = new SgSubscriptExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSubscriptExpression::initializeStorageClassArray (SgSubscriptExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSubtractOp ) ; 
     std::cout << " SgSubtractOp has size " << sizeOfActualPool << std::endl;
     SgSubtractOpStorageClass* SgSubtractOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSubtractOpStorageArray = new SgSubtractOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSubtractOp::initializeStorageClassArray (SgSubtractOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSupport ) ; 
     std::cout << " SgSupport has size " << sizeOfActualPool << std::endl;
     SgSupportStorageClass* SgSupportStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSupportStorageArray = new SgSupportStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSupport::initializeStorageClassArray (SgSupportStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSwitchStatement ) ; 
     std::cout << " SgSwitchStatement has size " << sizeOfActualPool << std::endl;
     SgSwitchStatementStorageClass* SgSwitchStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSwitchStatementStorageArray = new SgSwitchStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSwitchStatement::initializeStorageClassArray (SgSwitchStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSymbolTable ) ; 
     std::cout << " SgSymbolTable has size " << sizeOfActualPool << std::endl;
     SgSymbolTableStorageClass* SgSymbolTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSymbolTableStorageArray = new SgSymbolTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSymbolTable::initializeStorageClassArray (SgSymbolTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateArgument ) ; 
     std::cout << " SgTemplateArgument has size " << sizeOfActualPool << std::endl;
     SgTemplateArgumentStorageClass* SgTemplateArgumentStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateArgumentStorageArray = new SgTemplateArgumentStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateArgument::initializeStorageClassArray (SgTemplateArgumentStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateArgumentList ) ; 
     std::cout << " SgTemplateArgumentList has size " << sizeOfActualPool << std::endl;
     SgTemplateArgumentListStorageClass* SgTemplateArgumentListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateArgumentListStorageArray = new SgTemplateArgumentListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateArgumentList::initializeStorageClassArray (SgTemplateArgumentListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateDeclaration ) ; 
     std::cout << " SgTemplateDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateDeclarationStorageClass* SgTemplateDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateDeclarationStorageArray = new SgTemplateDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateDeclaration::initializeStorageClassArray (SgTemplateDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateClassDeclaration ) ; 
     std::cout << " SgTemplateClassDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateClassDeclarationStorageClass* SgTemplateClassDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassDeclarationStorageArray = new SgTemplateClassDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateClassDeclaration::initializeStorageClassArray (SgTemplateClassDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateClassSymbol ) ; 
     std::cout << " SgTemplateClassSymbol has size " << sizeOfActualPool << std::endl;
     SgTemplateClassSymbolStorageClass* SgTemplateClassSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassSymbolStorageArray = new SgTemplateClassSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateClassSymbol::initializeStorageClassArray (SgTemplateClassSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateFunctionDeclaration ) ; 
     std::cout << " SgTemplateFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateFunctionDeclarationStorageClass* SgTemplateFunctionDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionDeclarationStorageArray = new SgTemplateFunctionDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateFunctionDeclaration::initializeStorageClassArray (SgTemplateFunctionDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateFunctionRefExp ) ; 
     std::cout << " SgTemplateFunctionRefExp has size " << sizeOfActualPool << std::endl;
     SgTemplateFunctionRefExpStorageClass* SgTemplateFunctionRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionRefExpStorageArray = new SgTemplateFunctionRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateFunctionRefExp::initializeStorageClassArray (SgTemplateFunctionRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateFunctionSymbol ) ; 
     std::cout << " SgTemplateFunctionSymbol has size " << sizeOfActualPool << std::endl;
     SgTemplateFunctionSymbolStorageClass* SgTemplateFunctionSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionSymbolStorageArray = new SgTemplateFunctionSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateFunctionSymbol::initializeStorageClassArray (SgTemplateFunctionSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateMemberFunctionDeclaration ) ; 
     std::cout << " SgTemplateMemberFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateMemberFunctionDeclarationStorageClass* SgTemplateMemberFunctionDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateMemberFunctionDeclarationStorageArray = new SgTemplateMemberFunctionDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateMemberFunctionDeclaration::initializeStorageClassArray (SgTemplateMemberFunctionDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateMemberFunctionRefExp ) ; 
     std::cout << " SgTemplateMemberFunctionRefExp has size " << sizeOfActualPool << std::endl;
     SgTemplateMemberFunctionRefExpStorageClass* SgTemplateMemberFunctionRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateMemberFunctionRefExpStorageArray = new SgTemplateMemberFunctionRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateMemberFunctionRefExp::initializeStorageClassArray (SgTemplateMemberFunctionRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateMemberFunctionSymbol ) ; 
     std::cout << " SgTemplateMemberFunctionSymbol has size " << sizeOfActualPool << std::endl;
     SgTemplateMemberFunctionSymbolStorageClass* SgTemplateMemberFunctionSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateMemberFunctionSymbolStorageArray = new SgTemplateMemberFunctionSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateMemberFunctionSymbol::initializeStorageClassArray (SgTemplateMemberFunctionSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateTypedefDeclaration ) ; 
     std::cout << " SgTemplateTypedefDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateTypedefDeclarationStorageClass* SgTemplateTypedefDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateTypedefDeclarationStorageArray = new SgTemplateTypedefDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateTypedefDeclaration::initializeStorageClassArray (SgTemplateTypedefDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateTypedefSymbol ) ; 
     std::cout << " SgTemplateTypedefSymbol has size " << sizeOfActualPool << std::endl;
     SgTemplateTypedefSymbolStorageClass* SgTemplateTypedefSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateTypedefSymbolStorageArray = new SgTemplateTypedefSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateTypedefSymbol::initializeStorageClassArray (SgTemplateTypedefSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateVariableDeclaration ) ; 
     std::cout << " SgTemplateVariableDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateVariableDeclarationStorageClass* SgTemplateVariableDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateVariableDeclarationStorageArray = new SgTemplateVariableDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateVariableDeclaration::initializeStorageClassArray (SgTemplateVariableDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateVariableSymbol ) ; 
     std::cout << " SgTemplateVariableSymbol has size " << sizeOfActualPool << std::endl;
     SgTemplateVariableSymbolStorageClass* SgTemplateVariableSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateVariableSymbolStorageArray = new SgTemplateVariableSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateVariableSymbol::initializeStorageClassArray (SgTemplateVariableSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateClassDefinition ) ; 
     std::cout << " SgTemplateClassDefinition has size " << sizeOfActualPool << std::endl;
     SgTemplateClassDefinitionStorageClass* SgTemplateClassDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassDefinitionStorageArray = new SgTemplateClassDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateClassDefinition::initializeStorageClassArray (SgTemplateClassDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateFunctionDefinition ) ; 
     std::cout << " SgTemplateFunctionDefinition has size " << sizeOfActualPool << std::endl;
     SgTemplateFunctionDefinitionStorageClass* SgTemplateFunctionDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionDefinitionStorageArray = new SgTemplateFunctionDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateFunctionDefinition::initializeStorageClassArray (SgTemplateFunctionDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationDecl ) ; 
     std::cout << " SgTemplateInstantiationDecl has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationDeclStorageClass* SgTemplateInstantiationDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDeclStorageArray = new SgTemplateInstantiationDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationDecl::initializeStorageClassArray (SgTemplateInstantiationDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationDefn ) ; 
     std::cout << " SgTemplateInstantiationDefn has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationDefnStorageClass* SgTemplateInstantiationDefnStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDefnStorageArray = new SgTemplateInstantiationDefnStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationDefn::initializeStorageClassArray (SgTemplateInstantiationDefnStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationDirectiveStatement ) ; 
     std::cout << " SgTemplateInstantiationDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationDirectiveStatementStorageClass* SgTemplateInstantiationDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDirectiveStatementStorageArray = new SgTemplateInstantiationDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationDirectiveStatement::initializeStorageClassArray (SgTemplateInstantiationDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationFunctionDecl ) ; 
     std::cout << " SgTemplateInstantiationFunctionDecl has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationFunctionDeclStorageClass* SgTemplateInstantiationFunctionDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationFunctionDeclStorageArray = new SgTemplateInstantiationFunctionDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationFunctionDecl::initializeStorageClassArray (SgTemplateInstantiationFunctionDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationMemberFunctionDecl ) ; 
     std::cout << " SgTemplateInstantiationMemberFunctionDecl has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationMemberFunctionDeclStorageClass* SgTemplateInstantiationMemberFunctionDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationMemberFunctionDeclStorageArray = new SgTemplateInstantiationMemberFunctionDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationMemberFunctionDecl::initializeStorageClassArray (SgTemplateInstantiationMemberFunctionDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationTypedefDeclaration ) ; 
     std::cout << " SgTemplateInstantiationTypedefDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationTypedefDeclarationStorageClass* SgTemplateInstantiationTypedefDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationTypedefDeclarationStorageArray = new SgTemplateInstantiationTypedefDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationTypedefDeclaration::initializeStorageClassArray (SgTemplateInstantiationTypedefDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateParameter ) ; 
     std::cout << " SgTemplateParameter has size " << sizeOfActualPool << std::endl;
     SgTemplateParameterStorageClass* SgTemplateParameterStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterStorageArray = new SgTemplateParameterStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateParameter::initializeStorageClassArray (SgTemplateParameterStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateParameterVal ) ; 
     std::cout << " SgTemplateParameterVal has size " << sizeOfActualPool << std::endl;
     SgTemplateParameterValStorageClass* SgTemplateParameterValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterValStorageArray = new SgTemplateParameterValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateParameterVal::initializeStorageClassArray (SgTemplateParameterValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateParameterList ) ; 
     std::cout << " SgTemplateParameterList has size " << sizeOfActualPool << std::endl;
     SgTemplateParameterListStorageClass* SgTemplateParameterListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterListStorageArray = new SgTemplateParameterListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateParameterList::initializeStorageClassArray (SgTemplateParameterListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateSymbol ) ; 
     std::cout << " SgTemplateSymbol has size " << sizeOfActualPool << std::endl;
     SgTemplateSymbolStorageClass* SgTemplateSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateSymbolStorageArray = new SgTemplateSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateSymbol::initializeStorageClassArray (SgTemplateSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateType ) ; 
     std::cout << " SgTemplateType has size " << sizeOfActualPool << std::endl;
     SgTemplateTypeStorageClass* SgTemplateTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateTypeStorageArray = new SgTemplateTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateType::initializeStorageClassArray (SgTemplateTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgThisExp ) ; 
     std::cout << " SgThisExp has size " << sizeOfActualPool << std::endl;
     SgThisExpStorageClass* SgThisExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgThisExpStorageArray = new SgThisExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgThisExp::initializeStorageClassArray (SgThisExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeTraitBuiltinOperator ) ; 
     std::cout << " SgTypeTraitBuiltinOperator has size " << sizeOfActualPool << std::endl;
     SgTypeTraitBuiltinOperatorStorageClass* SgTypeTraitBuiltinOperatorStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeTraitBuiltinOperatorStorageArray = new SgTypeTraitBuiltinOperatorStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeTraitBuiltinOperator::initializeStorageClassArray (SgTypeTraitBuiltinOperatorStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSuperExp ) ; 
     std::cout << " SgSuperExp has size " << sizeOfActualPool << std::endl;
     SgSuperExpStorageClass* SgSuperExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSuperExpStorageArray = new SgSuperExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSuperExp::initializeStorageClassArray (SgSuperExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgThrowOp ) ; 
     std::cout << " SgThrowOp has size " << sizeOfActualPool << std::endl;
     SgThrowOpStorageClass* SgThrowOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgThrowOpStorageArray = new SgThrowOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgThrowOp::initializeStorageClassArray (SgThrowOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgToken ) ; 
     std::cout << " SgToken has size " << sizeOfActualPool << std::endl;
     SgTokenStorageClass* SgTokenStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTokenStorageArray = new SgTokenStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgToken::initializeStorageClassArray (SgTokenStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTryStmt ) ; 
     std::cout << " SgTryStmt has size " << sizeOfActualPool << std::endl;
     SgTryStmtStorageClass* SgTryStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTryStmtStorageArray = new SgTryStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTryStmt::initializeStorageClassArray (SgTryStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTupleExp ) ; 
     std::cout << " SgTupleExp has size " << sizeOfActualPool << std::endl;
     SgTupleExpStorageClass* SgTupleExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTupleExpStorageArray = new SgTupleExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTupleExp::initializeStorageClassArray (SgTupleExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgType ) ; 
     std::cout << " SgType has size " << sizeOfActualPool << std::endl;
     SgTypeStorageClass* SgTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeStorageArray = new SgTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgType::initializeStorageClassArray (SgTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeBool ) ; 
     std::cout << " SgTypeBool has size " << sizeOfActualPool << std::endl;
     SgTypeBoolStorageClass* SgTypeBoolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeBoolStorageArray = new SgTypeBoolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeBool::initializeStorageClassArray (SgTypeBoolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeChar ) ; 
     std::cout << " SgTypeChar has size " << sizeOfActualPool << std::endl;
     SgTypeCharStorageClass* SgTypeCharStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCharStorageArray = new SgTypeCharStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeChar::initializeStorageClassArray (SgTypeCharStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeChar16 ) ; 
     std::cout << " SgTypeChar16 has size " << sizeOfActualPool << std::endl;
     SgTypeChar16StorageClass* SgTypeChar16StorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeChar16StorageArray = new SgTypeChar16StorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeChar16::initializeStorageClassArray (SgTypeChar16StorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeChar32 ) ; 
     std::cout << " SgTypeChar32 has size " << sizeOfActualPool << std::endl;
     SgTypeChar32StorageClass* SgTypeChar32StorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeChar32StorageArray = new SgTypeChar32StorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeChar32::initializeStorageClassArray (SgTypeChar32StorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeComplex ) ; 
     std::cout << " SgTypeComplex has size " << sizeOfActualPool << std::endl;
     SgTypeComplexStorageClass* SgTypeComplexStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeComplexStorageArray = new SgTypeComplexStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeComplex::initializeStorageClassArray (SgTypeComplexStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeDefault ) ; 
     std::cout << " SgTypeDefault has size " << sizeOfActualPool << std::endl;
     SgTypeDefaultStorageClass* SgTypeDefaultStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeDefaultStorageArray = new SgTypeDefaultStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeDefault::initializeStorageClassArray (SgTypeDefaultStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeExpression ) ; 
     std::cout << " SgTypeExpression has size " << sizeOfActualPool << std::endl;
     SgTypeExpressionStorageClass* SgTypeExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeExpressionStorageArray = new SgTypeExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeExpression::initializeStorageClassArray (SgTypeExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeLabel ) ; 
     std::cout << " SgTypeLabel has size " << sizeOfActualPool << std::endl;
     SgTypeLabelStorageClass* SgTypeLabelStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLabelStorageArray = new SgTypeLabelStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeLabel::initializeStorageClassArray (SgTypeLabelStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeDouble ) ; 
     std::cout << " SgTypeDouble has size " << sizeOfActualPool << std::endl;
     SgTypeDoubleStorageClass* SgTypeDoubleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeDoubleStorageArray = new SgTypeDoubleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeDouble::initializeStorageClassArray (SgTypeDoubleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeEllipse ) ; 
     std::cout << " SgTypeEllipse has size " << sizeOfActualPool << std::endl;
     SgTypeEllipseStorageClass* SgTypeEllipseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeEllipseStorageArray = new SgTypeEllipseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeEllipse::initializeStorageClassArray (SgTypeEllipseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeFixed ) ; 
     std::cout << " SgTypeFixed has size " << sizeOfActualPool << std::endl;
     SgTypeFixedStorageClass* SgTypeFixedStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFixedStorageArray = new SgTypeFixedStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeFixed::initializeStorageClassArray (SgTypeFixedStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeFloat ) ; 
     std::cout << " SgTypeFloat has size " << sizeOfActualPool << std::endl;
     SgTypeFloatStorageClass* SgTypeFloatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFloatStorageArray = new SgTypeFloatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeFloat::initializeStorageClassArray (SgTypeFloatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeFloat128 ) ; 
     std::cout << " SgTypeFloat128 has size " << sizeOfActualPool << std::endl;
     SgTypeFloat128StorageClass* SgTypeFloat128StorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFloat128StorageArray = new SgTypeFloat128StorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeFloat128::initializeStorageClassArray (SgTypeFloat128StorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeFloat80 ) ; 
     std::cout << " SgTypeFloat80 has size " << sizeOfActualPool << std::endl;
     SgTypeFloat80StorageClass* SgTypeFloat80StorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFloat80StorageArray = new SgTypeFloat80StorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeFloat80::initializeStorageClassArray (SgTypeFloat80StorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeGlobalVoid ) ; 
     std::cout << " SgTypeGlobalVoid has size " << sizeOfActualPool << std::endl;
     SgTypeGlobalVoidStorageClass* SgTypeGlobalVoidStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeGlobalVoidStorageArray = new SgTypeGlobalVoidStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeGlobalVoid::initializeStorageClassArray (SgTypeGlobalVoidStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeIdOp ) ; 
     std::cout << " SgTypeIdOp has size " << sizeOfActualPool << std::endl;
     SgTypeIdOpStorageClass* SgTypeIdOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeIdOpStorageArray = new SgTypeIdOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeIdOp::initializeStorageClassArray (SgTypeIdOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeImaginary ) ; 
     std::cout << " SgTypeImaginary has size " << sizeOfActualPool << std::endl;
     SgTypeImaginaryStorageClass* SgTypeImaginaryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeImaginaryStorageArray = new SgTypeImaginaryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeImaginary::initializeStorageClassArray (SgTypeImaginaryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeInt ) ; 
     std::cout << " SgTypeInt has size " << sizeOfActualPool << std::endl;
     SgTypeIntStorageClass* SgTypeIntStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeIntStorageArray = new SgTypeIntStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeInt::initializeStorageClassArray (SgTypeIntStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeLong ) ; 
     std::cout << " SgTypeLong has size " << sizeOfActualPool << std::endl;
     SgTypeLongStorageClass* SgTypeLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongStorageArray = new SgTypeLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeLong::initializeStorageClassArray (SgTypeLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeLongDouble ) ; 
     std::cout << " SgTypeLongDouble has size " << sizeOfActualPool << std::endl;
     SgTypeLongDoubleStorageClass* SgTypeLongDoubleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongDoubleStorageArray = new SgTypeLongDoubleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeLongDouble::initializeStorageClassArray (SgTypeLongDoubleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeLongLong ) ; 
     std::cout << " SgTypeLongLong has size " << sizeOfActualPool << std::endl;
     SgTypeLongLongStorageClass* SgTypeLongLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongLongStorageArray = new SgTypeLongLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeLongLong::initializeStorageClassArray (SgTypeLongLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeModifier ) ; 
     std::cout << " SgTypeModifier has size " << sizeOfActualPool << std::endl;
     SgTypeModifierStorageClass* SgTypeModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeModifierStorageArray = new SgTypeModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeModifier::initializeStorageClassArray (SgTypeModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeMatrix ) ; 
     std::cout << " SgTypeMatrix has size " << sizeOfActualPool << std::endl;
     SgTypeMatrixStorageClass* SgTypeMatrixStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeMatrixStorageArray = new SgTypeMatrixStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeMatrix::initializeStorageClassArray (SgTypeMatrixStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeTuple ) ; 
     std::cout << " SgTypeTuple has size " << sizeOfActualPool << std::endl;
     SgTypeTupleStorageClass* SgTypeTupleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeTupleStorageArray = new SgTypeTupleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeTuple::initializeStorageClassArray (SgTypeTupleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeNullptr ) ; 
     std::cout << " SgTypeNullptr has size " << sizeOfActualPool << std::endl;
     SgTypeNullptrStorageClass* SgTypeNullptrStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeNullptrStorageArray = new SgTypeNullptrStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeNullptr::initializeStorageClassArray (SgTypeNullptrStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeOfType ) ; 
     std::cout << " SgTypeOfType has size " << sizeOfActualPool << std::endl;
     SgTypeOfTypeStorageClass* SgTypeOfTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeOfTypeStorageArray = new SgTypeOfTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeOfType::initializeStorageClassArray (SgTypeOfTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeShort ) ; 
     std::cout << " SgTypeShort has size " << sizeOfActualPool << std::endl;
     SgTypeShortStorageClass* SgTypeShortStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeShortStorageArray = new SgTypeShortStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeShort::initializeStorageClassArray (SgTypeShortStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSigned128bitInteger ) ; 
     std::cout << " SgTypeSigned128bitInteger has size " << sizeOfActualPool << std::endl;
     SgTypeSigned128bitIntegerStorageClass* SgTypeSigned128bitIntegerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSigned128bitIntegerStorageArray = new SgTypeSigned128bitIntegerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSigned128bitInteger::initializeStorageClassArray (SgTypeSigned128bitIntegerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedChar ) ; 
     std::cout << " SgTypeSignedChar has size " << sizeOfActualPool << std::endl;
     SgTypeSignedCharStorageClass* SgTypeSignedCharStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedCharStorageArray = new SgTypeSignedCharStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedChar::initializeStorageClassArray (SgTypeSignedCharStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedInt ) ; 
     std::cout << " SgTypeSignedInt has size " << sizeOfActualPool << std::endl;
     SgTypeSignedIntStorageClass* SgTypeSignedIntStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedIntStorageArray = new SgTypeSignedIntStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedInt::initializeStorageClassArray (SgTypeSignedIntStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedLong ) ; 
     std::cout << " SgTypeSignedLong has size " << sizeOfActualPool << std::endl;
     SgTypeSignedLongStorageClass* SgTypeSignedLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedLongStorageArray = new SgTypeSignedLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedLong::initializeStorageClassArray (SgTypeSignedLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedLongLong ) ; 
     std::cout << " SgTypeSignedLongLong has size " << sizeOfActualPool << std::endl;
     SgTypeSignedLongLongStorageClass* SgTypeSignedLongLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedLongLongStorageArray = new SgTypeSignedLongLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedLongLong::initializeStorageClassArray (SgTypeSignedLongLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedShort ) ; 
     std::cout << " SgTypeSignedShort has size " << sizeOfActualPool << std::endl;
     SgTypeSignedShortStorageClass* SgTypeSignedShortStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedShortStorageArray = new SgTypeSignedShortStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedShort::initializeStorageClassArray (SgTypeSignedShortStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeString ) ; 
     std::cout << " SgTypeString has size " << sizeOfActualPool << std::endl;
     SgTypeStringStorageClass* SgTypeStringStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeStringStorageArray = new SgTypeStringStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeString::initializeStorageClassArray (SgTypeStringStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnknown ) ; 
     std::cout << " SgTypeUnknown has size " << sizeOfActualPool << std::endl;
     SgTypeUnknownStorageClass* SgTypeUnknownStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnknownStorageArray = new SgTypeUnknownStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnknown::initializeStorageClassArray (SgTypeUnknownStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsigned128bitInteger ) ; 
     std::cout << " SgTypeUnsigned128bitInteger has size " << sizeOfActualPool << std::endl;
     SgTypeUnsigned128bitIntegerStorageClass* SgTypeUnsigned128bitIntegerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsigned128bitIntegerStorageArray = new SgTypeUnsigned128bitIntegerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsigned128bitInteger::initializeStorageClassArray (SgTypeUnsigned128bitIntegerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedChar ) ; 
     std::cout << " SgTypeUnsignedChar has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedCharStorageClass* SgTypeUnsignedCharStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedCharStorageArray = new SgTypeUnsignedCharStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedChar::initializeStorageClassArray (SgTypeUnsignedCharStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedInt ) ; 
     std::cout << " SgTypeUnsignedInt has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedIntStorageClass* SgTypeUnsignedIntStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedIntStorageArray = new SgTypeUnsignedIntStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedInt::initializeStorageClassArray (SgTypeUnsignedIntStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedLong ) ; 
     std::cout << " SgTypeUnsignedLong has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedLongStorageClass* SgTypeUnsignedLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedLongStorageArray = new SgTypeUnsignedLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedLong::initializeStorageClassArray (SgTypeUnsignedLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedLongLong ) ; 
     std::cout << " SgTypeUnsignedLongLong has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedLongLongStorageClass* SgTypeUnsignedLongLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedLongLongStorageArray = new SgTypeUnsignedLongLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedLongLong::initializeStorageClassArray (SgTypeUnsignedLongLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedShort ) ; 
     std::cout << " SgTypeUnsignedShort has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedShortStorageClass* SgTypeUnsignedShortStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedShortStorageArray = new SgTypeUnsignedShortStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedShort::initializeStorageClassArray (SgTypeUnsignedShortStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeVoid ) ; 
     std::cout << " SgTypeVoid has size " << sizeOfActualPool << std::endl;
     SgTypeVoidStorageClass* SgTypeVoidStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeVoidStorageArray = new SgTypeVoidStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeVoid::initializeStorageClassArray (SgTypeVoidStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeWchar ) ; 
     std::cout << " SgTypeWchar has size " << sizeOfActualPool << std::endl;
     SgTypeWcharStorageClass* SgTypeWcharStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeWcharStorageArray = new SgTypeWcharStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeWchar::initializeStorageClassArray (SgTypeWcharStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypedefDeclaration ) ; 
     std::cout << " SgTypedefDeclaration has size " << sizeOfActualPool << std::endl;
     SgTypedefDeclarationStorageClass* SgTypedefDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefDeclarationStorageArray = new SgTypedefDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypedefDeclaration::initializeStorageClassArray (SgTypedefDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypedefSeq ) ; 
     std::cout << " SgTypedefSeq has size " << sizeOfActualPool << std::endl;
     SgTypedefSeqStorageClass* SgTypedefSeqStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefSeqStorageArray = new SgTypedefSeqStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypedefSeq::initializeStorageClassArray (SgTypedefSeqStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypedefSymbol ) ; 
     std::cout << " SgTypedefSymbol has size " << sizeOfActualPool << std::endl;
     SgTypedefSymbolStorageClass* SgTypedefSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefSymbolStorageArray = new SgTypedefSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypedefSymbol::initializeStorageClassArray (SgTypedefSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypedefType ) ; 
     std::cout << " SgTypedefType has size " << sizeOfActualPool << std::endl;
     SgTypedefTypeStorageClass* SgTypedefTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefTypeStorageArray = new SgTypedefTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypedefType::initializeStorageClassArray (SgTypedefTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUPC_AccessModifier ) ; 
     std::cout << " SgUPC_AccessModifier has size " << sizeOfActualPool << std::endl;
     SgUPC_AccessModifierStorageClass* SgUPC_AccessModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUPC_AccessModifierStorageArray = new SgUPC_AccessModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUPC_AccessModifier::initializeStorageClassArray (SgUPC_AccessModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnaryAddOp ) ; 
     std::cout << " SgUnaryAddOp has size " << sizeOfActualPool << std::endl;
     SgUnaryAddOpStorageClass* SgUnaryAddOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnaryAddOpStorageArray = new SgUnaryAddOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnaryAddOp::initializeStorageClassArray (SgUnaryAddOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnaryOp ) ; 
     std::cout << " SgUnaryOp has size " << sizeOfActualPool << std::endl;
     SgUnaryOpStorageClass* SgUnaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnaryOpStorageArray = new SgUnaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnaryOp::initializeStorageClassArray (SgUnaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUndefDirectiveStatement ) ; 
     std::cout << " SgUndefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgUndefDirectiveStatementStorageClass* SgUndefDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUndefDirectiveStatementStorageArray = new SgUndefDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUndefDirectiveStatement::initializeStorageClassArray (SgUndefDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUndirectedGraphEdge ) ; 
     std::cout << " SgUndirectedGraphEdge has size " << sizeOfActualPool << std::endl;
     SgUndirectedGraphEdgeStorageClass* SgUndirectedGraphEdgeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUndirectedGraphEdgeStorageArray = new SgUndirectedGraphEdgeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUndirectedGraphEdge::initializeStorageClassArray (SgUndirectedGraphEdgeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnknownArrayOrFunctionReference ) ; 
     std::cout << " SgUnknownArrayOrFunctionReference has size " << sizeOfActualPool << std::endl;
     SgUnknownArrayOrFunctionReferenceStorageClass* SgUnknownArrayOrFunctionReferenceStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnknownArrayOrFunctionReferenceStorageArray = new SgUnknownArrayOrFunctionReferenceStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnknownArrayOrFunctionReference::initializeStorageClassArray (SgUnknownArrayOrFunctionReferenceStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnknownFile ) ; 
     std::cout << " SgUnknownFile has size " << sizeOfActualPool << std::endl;
     SgUnknownFileStorageClass* SgUnknownFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnknownFileStorageArray = new SgUnknownFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnknownFile::initializeStorageClassArray (SgUnknownFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnparse_Info ) ; 
     std::cout << " SgUnparse_Info has size " << sizeOfActualPool << std::endl;
     SgUnparse_InfoStorageClass* SgUnparse_InfoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnparse_InfoStorageArray = new SgUnparse_InfoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnparse_Info::initializeStorageClassArray (SgUnparse_InfoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedCharVal ) ; 
     std::cout << " SgUnsignedCharVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedCharValStorageClass* SgUnsignedCharValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedCharValStorageArray = new SgUnsignedCharValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedCharVal::initializeStorageClassArray (SgUnsignedCharValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedIntVal ) ; 
     std::cout << " SgUnsignedIntVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedIntValStorageClass* SgUnsignedIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedIntValStorageArray = new SgUnsignedIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedIntVal::initializeStorageClassArray (SgUnsignedIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedLongLongIntVal ) ; 
     std::cout << " SgUnsignedLongLongIntVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedLongLongIntValStorageClass* SgUnsignedLongLongIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedLongLongIntValStorageArray = new SgUnsignedLongLongIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedLongLongIntVal::initializeStorageClassArray (SgUnsignedLongLongIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedLongVal ) ; 
     std::cout << " SgUnsignedLongVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedLongValStorageClass* SgUnsignedLongValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedLongValStorageArray = new SgUnsignedLongValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedLongVal::initializeStorageClassArray (SgUnsignedLongValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedShortVal ) ; 
     std::cout << " SgUnsignedShortVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedShortValStorageClass* SgUnsignedShortValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedShortValStorageArray = new SgUnsignedShortValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedShortVal::initializeStorageClassArray (SgUnsignedShortValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcBarrierStatement ) ; 
     std::cout << " SgUpcBarrierStatement has size " << sizeOfActualPool << std::endl;
     SgUpcBarrierStatementStorageClass* SgUpcBarrierStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcBarrierStatementStorageArray = new SgUpcBarrierStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcBarrierStatement::initializeStorageClassArray (SgUpcBarrierStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcBlocksizeofExpression ) ; 
     std::cout << " SgUpcBlocksizeofExpression has size " << sizeOfActualPool << std::endl;
     SgUpcBlocksizeofExpressionStorageClass* SgUpcBlocksizeofExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcBlocksizeofExpressionStorageArray = new SgUpcBlocksizeofExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcBlocksizeofExpression::initializeStorageClassArray (SgUpcBlocksizeofExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcElemsizeofExpression ) ; 
     std::cout << " SgUpcElemsizeofExpression has size " << sizeOfActualPool << std::endl;
     SgUpcElemsizeofExpressionStorageClass* SgUpcElemsizeofExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcElemsizeofExpressionStorageArray = new SgUpcElemsizeofExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcElemsizeofExpression::initializeStorageClassArray (SgUpcElemsizeofExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcFenceStatement ) ; 
     std::cout << " SgUpcFenceStatement has size " << sizeOfActualPool << std::endl;
     SgUpcFenceStatementStorageClass* SgUpcFenceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcFenceStatementStorageArray = new SgUpcFenceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcFenceStatement::initializeStorageClassArray (SgUpcFenceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcForAllStatement ) ; 
     std::cout << " SgUpcForAllStatement has size " << sizeOfActualPool << std::endl;
     SgUpcForAllStatementStorageClass* SgUpcForAllStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcForAllStatementStorageArray = new SgUpcForAllStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcForAllStatement::initializeStorageClassArray (SgUpcForAllStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcLocalsizeofExpression ) ; 
     std::cout << " SgUpcLocalsizeofExpression has size " << sizeOfActualPool << std::endl;
     SgUpcLocalsizeofExpressionStorageClass* SgUpcLocalsizeofExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcLocalsizeofExpressionStorageArray = new SgUpcLocalsizeofExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcLocalsizeofExpression::initializeStorageClassArray (SgUpcLocalsizeofExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcMythread ) ; 
     std::cout << " SgUpcMythread has size " << sizeOfActualPool << std::endl;
     SgUpcMythreadStorageClass* SgUpcMythreadStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcMythreadStorageArray = new SgUpcMythreadStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcMythread::initializeStorageClassArray (SgUpcMythreadStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcNotifyStatement ) ; 
     std::cout << " SgUpcNotifyStatement has size " << sizeOfActualPool << std::endl;
     SgUpcNotifyStatementStorageClass* SgUpcNotifyStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcNotifyStatementStorageArray = new SgUpcNotifyStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcNotifyStatement::initializeStorageClassArray (SgUpcNotifyStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcThreads ) ; 
     std::cout << " SgUpcThreads has size " << sizeOfActualPool << std::endl;
     SgUpcThreadsStorageClass* SgUpcThreadsStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcThreadsStorageArray = new SgUpcThreadsStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcThreads::initializeStorageClassArray (SgUpcThreadsStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcWaitStatement ) ; 
     std::cout << " SgUpcWaitStatement has size " << sizeOfActualPool << std::endl;
     SgUpcWaitStatementStorageClass* SgUpcWaitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcWaitStatementStorageArray = new SgUpcWaitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcWaitStatement::initializeStorageClassArray (SgUpcWaitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUseStatement ) ; 
     std::cout << " SgUseStatement has size " << sizeOfActualPool << std::endl;
     SgUseStatementStorageClass* SgUseStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUseStatementStorageArray = new SgUseStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUseStatement::initializeStorageClassArray (SgUseStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUserDefinedBinaryOp ) ; 
     std::cout << " SgUserDefinedBinaryOp has size " << sizeOfActualPool << std::endl;
     SgUserDefinedBinaryOpStorageClass* SgUserDefinedBinaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUserDefinedBinaryOpStorageArray = new SgUserDefinedBinaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUserDefinedBinaryOp::initializeStorageClassArray (SgUserDefinedBinaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUserDefinedUnaryOp ) ; 
     std::cout << " SgUserDefinedUnaryOp has size " << sizeOfActualPool << std::endl;
     SgUserDefinedUnaryOpStorageClass* SgUserDefinedUnaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUserDefinedUnaryOpStorageArray = new SgUserDefinedUnaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUserDefinedUnaryOp::initializeStorageClassArray (SgUserDefinedUnaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUsingDeclarationStatement ) ; 
     std::cout << " SgUsingDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgUsingDeclarationStatementStorageClass* SgUsingDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUsingDeclarationStatementStorageArray = new SgUsingDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUsingDeclarationStatement::initializeStorageClassArray (SgUsingDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUsingDirectiveStatement ) ; 
     std::cout << " SgUsingDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgUsingDirectiveStatementStorageClass* SgUsingDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUsingDirectiveStatementStorageArray = new SgUsingDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUsingDirectiveStatement::initializeStorageClassArray (SgUsingDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgValueExp ) ; 
     std::cout << " SgValueExp has size " << sizeOfActualPool << std::endl;
     SgValueExpStorageClass* SgValueExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgValueExpStorageArray = new SgValueExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgValueExp::initializeStorageClassArray (SgValueExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgCopyOp ) ; 
     std::cout << " SgVarArgCopyOp has size " << sizeOfActualPool << std::endl;
     SgVarArgCopyOpStorageClass* SgVarArgCopyOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgCopyOpStorageArray = new SgVarArgCopyOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgCopyOp::initializeStorageClassArray (SgVarArgCopyOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgEndOp ) ; 
     std::cout << " SgVarArgEndOp has size " << sizeOfActualPool << std::endl;
     SgVarArgEndOpStorageClass* SgVarArgEndOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgEndOpStorageArray = new SgVarArgEndOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgEndOp::initializeStorageClassArray (SgVarArgEndOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgOp ) ; 
     std::cout << " SgVarArgOp has size " << sizeOfActualPool << std::endl;
     SgVarArgOpStorageClass* SgVarArgOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgOpStorageArray = new SgVarArgOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgOp::initializeStorageClassArray (SgVarArgOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgStartOneOperandOp ) ; 
     std::cout << " SgVarArgStartOneOperandOp has size " << sizeOfActualPool << std::endl;
     SgVarArgStartOneOperandOpStorageClass* SgVarArgStartOneOperandOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgStartOneOperandOpStorageArray = new SgVarArgStartOneOperandOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgStartOneOperandOp::initializeStorageClassArray (SgVarArgStartOneOperandOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgStartOp ) ; 
     std::cout << " SgVarArgStartOp has size " << sizeOfActualPool << std::endl;
     SgVarArgStartOpStorageClass* SgVarArgStartOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgStartOpStorageArray = new SgVarArgStartOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgStartOp::initializeStorageClassArray (SgVarArgStartOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarRefExp ) ; 
     std::cout << " SgVarRefExp has size " << sizeOfActualPool << std::endl;
     SgVarRefExpStorageClass* SgVarRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarRefExpStorageArray = new SgVarRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarRefExp::initializeStorageClassArray (SgVarRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariableDeclaration ) ; 
     std::cout << " SgVariableDeclaration has size " << sizeOfActualPool << std::endl;
     SgVariableDeclarationStorageClass* SgVariableDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableDeclarationStorageArray = new SgVariableDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariableDeclaration::initializeStorageClassArray (SgVariableDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariableDefinition ) ; 
     std::cout << " SgVariableDefinition has size " << sizeOfActualPool << std::endl;
     SgVariableDefinitionStorageClass* SgVariableDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableDefinitionStorageArray = new SgVariableDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariableDefinition::initializeStorageClassArray (SgVariableDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariableSymbol ) ; 
     std::cout << " SgVariableSymbol has size " << sizeOfActualPool << std::endl;
     SgVariableSymbolStorageClass* SgVariableSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableSymbolStorageArray = new SgVariableSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariableSymbol::initializeStorageClassArray (SgVariableSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariantExpression ) ; 
     std::cout << " SgVariantExpression has size " << sizeOfActualPool << std::endl;
     SgVariantExpressionStorageClass* SgVariantExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariantExpressionStorageArray = new SgVariantExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariantExpression::initializeStorageClassArray (SgVariantExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariantStatement ) ; 
     std::cout << " SgVariantStatement has size " << sizeOfActualPool << std::endl;
     SgVariantStatementStorageClass* SgVariantStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariantStatementStorageArray = new SgVariantStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariantStatement::initializeStorageClassArray (SgVariantStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVoidVal ) ; 
     std::cout << " SgVoidVal has size " << sizeOfActualPool << std::endl;
     SgVoidValStorageClass* SgVoidValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVoidValStorageArray = new SgVoidValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVoidVal::initializeStorageClassArray (SgVoidValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWaitStatement ) ; 
     std::cout << " SgWaitStatement has size " << sizeOfActualPool << std::endl;
     SgWaitStatementStorageClass* SgWaitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWaitStatementStorageArray = new SgWaitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWaitStatement::initializeStorageClassArray (SgWaitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWarningDirectiveStatement ) ; 
     std::cout << " SgWarningDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgWarningDirectiveStatementStorageClass* SgWarningDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWarningDirectiveStatementStorageArray = new SgWarningDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWarningDirectiveStatement::initializeStorageClassArray (SgWarningDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWithStatement ) ; 
     std::cout << " SgWithStatement has size " << sizeOfActualPool << std::endl;
     SgWithStatementStorageClass* SgWithStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWithStatementStorageArray = new SgWithStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWithStatement::initializeStorageClassArray (SgWithStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWcharVal ) ; 
     std::cout << " SgWcharVal has size " << sizeOfActualPool << std::endl;
     SgWcharValStorageClass* SgWcharValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWcharValStorageArray = new SgWcharValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWcharVal::initializeStorageClassArray (SgWcharValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWhereStatement ) ; 
     std::cout << " SgWhereStatement has size " << sizeOfActualPool << std::endl;
     SgWhereStatementStorageClass* SgWhereStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhereStatementStorageArray = new SgWhereStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWhereStatement::initializeStorageClassArray (SgWhereStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWhileStmt ) ; 
     std::cout << " SgWhileStmt has size " << sizeOfActualPool << std::endl;
     SgWhileStmtStorageClass* SgWhileStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhileStmtStorageArray = new SgWhileStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWhileStmt::initializeStorageClassArray (SgWhileStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWriteStatement ) ; 
     std::cout << " SgWriteStatement has size " << sizeOfActualPool << std::endl;
     SgWriteStatementStorageClass* SgWriteStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWriteStatementStorageArray = new SgWriteStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWriteStatement::initializeStorageClassArray (SgWriteStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgXorAssignOp ) ; 
     std::cout << " SgXorAssignOp has size " << sizeOfActualPool << std::endl;
     SgXorAssignOpStorageClass* SgXorAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgXorAssignOpStorageArray = new SgXorAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgXorAssignOp::initializeStorageClassArray (SgXorAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgYieldExpression ) ; 
     std::cout << " SgYieldExpression has size " << sizeOfActualPool << std::endl;
     SgYieldExpressionStorageClass* SgYieldExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgYieldExpressionStorageArray = new SgYieldExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgYieldExpression::initializeStorageClassArray (SgYieldExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_Sg_File_Info ) ; 
     std::cout << " Sg_File_Info has size " << sizeOfActualPool << std::endl;
     Sg_File_InfoStorageClass* Sg_File_InfoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          Sg_File_InfoStorageArray = new Sg_File_InfoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = Sg_File_Info::initializeStorageClassArray (Sg_File_InfoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeCAFTeam ) ; 
     std::cout << " SgTypeCAFTeam has size " << sizeOfActualPool << std::endl;
     SgTypeCAFTeamStorageClass* SgTypeCAFTeamStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCAFTeamStorageArray = new SgTypeCAFTeamStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeCAFTeam::initializeStorageClassArray (SgTypeCAFTeamStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCAFWithTeamStatement ) ; 
     std::cout << " SgCAFWithTeamStatement has size " << sizeOfActualPool << std::endl;
     SgCAFWithTeamStatementStorageClass* SgCAFWithTeamStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCAFWithTeamStatementStorageArray = new SgCAFWithTeamStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCAFWithTeamStatement::initializeStorageClassArray (SgCAFWithTeamStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCAFCoExpression ) ; 
     std::cout << " SgCAFCoExpression has size " << sizeOfActualPool << std::endl;
     SgCAFCoExpressionStorageClass* SgCAFCoExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCAFCoExpressionStorageArray = new SgCAFCoExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCAFCoExpression::initializeStorageClassArray (SgCAFCoExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCallExpression ) ; 
     std::cout << " SgCallExpression has size " << sizeOfActualPool << std::endl;
     SgCallExpressionStorageClass* SgCallExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCallExpressionStorageArray = new SgCallExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCallExpression::initializeStorageClassArray (SgCallExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeCrayPointer ) ; 
     std::cout << " SgTypeCrayPointer has size " << sizeOfActualPool << std::endl;
     SgTypeCrayPointerStorageClass* SgTypeCrayPointerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCrayPointerStorageArray = new SgTypeCrayPointerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeCrayPointer::initializeStorageClassArray (SgTypeCrayPointerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaImportStatement ) ; 
     std::cout << " SgJavaImportStatement has size " << sizeOfActualPool << std::endl;
     SgJavaImportStatementStorageClass* SgJavaImportStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaImportStatementStorageArray = new SgJavaImportStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaImportStatement::initializeStorageClassArray (SgJavaImportStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaPackageDeclaration ) ; 
     std::cout << " SgJavaPackageDeclaration has size " << sizeOfActualPool << std::endl;
     SgJavaPackageDeclarationStorageClass* SgJavaPackageDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaPackageDeclarationStorageArray = new SgJavaPackageDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaPackageDeclaration::initializeStorageClassArray (SgJavaPackageDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaPackageStatement ) ; 
     std::cout << " SgJavaPackageStatement has size " << sizeOfActualPool << std::endl;
     SgJavaPackageStatementStorageClass* SgJavaPackageStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaPackageStatementStorageArray = new SgJavaPackageStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaPackageStatement::initializeStorageClassArray (SgJavaPackageStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaImportStatementList ) ; 
     std::cout << " SgJavaImportStatementList has size " << sizeOfActualPool << std::endl;
     SgJavaImportStatementListStorageClass* SgJavaImportStatementListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaImportStatementListStorageArray = new SgJavaImportStatementListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaImportStatementList::initializeStorageClassArray (SgJavaImportStatementListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaClassDeclarationList ) ; 
     std::cout << " SgJavaClassDeclarationList has size " << sizeOfActualPool << std::endl;
     SgJavaClassDeclarationListStorageClass* SgJavaClassDeclarationListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaClassDeclarationListStorageArray = new SgJavaClassDeclarationListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaClassDeclarationList::initializeStorageClassArray (SgJavaClassDeclarationListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaMemberValuePair ) ; 
     std::cout << " SgJavaMemberValuePair has size " << sizeOfActualPool << std::endl;
     SgJavaMemberValuePairStorageClass* SgJavaMemberValuePairStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaMemberValuePairStorageArray = new SgJavaMemberValuePairStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaMemberValuePair::initializeStorageClassArray (SgJavaMemberValuePairStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaAnnotation ) ; 
     std::cout << " SgJavaAnnotation has size " << sizeOfActualPool << std::endl;
     SgJavaAnnotationStorageClass* SgJavaAnnotationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaAnnotationStorageArray = new SgJavaAnnotationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaAnnotation::initializeStorageClassArray (SgJavaAnnotationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaMarkerAnnotation ) ; 
     std::cout << " SgJavaMarkerAnnotation has size " << sizeOfActualPool << std::endl;
     SgJavaMarkerAnnotationStorageClass* SgJavaMarkerAnnotationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaMarkerAnnotationStorageArray = new SgJavaMarkerAnnotationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaMarkerAnnotation::initializeStorageClassArray (SgJavaMarkerAnnotationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaSingleMemberAnnotation ) ; 
     std::cout << " SgJavaSingleMemberAnnotation has size " << sizeOfActualPool << std::endl;
     SgJavaSingleMemberAnnotationStorageClass* SgJavaSingleMemberAnnotationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaSingleMemberAnnotationStorageArray = new SgJavaSingleMemberAnnotationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaSingleMemberAnnotation::initializeStorageClassArray (SgJavaSingleMemberAnnotationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaNormalAnnotation ) ; 
     std::cout << " SgJavaNormalAnnotation has size " << sizeOfActualPool << std::endl;
     SgJavaNormalAnnotationStorageClass* SgJavaNormalAnnotationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaNormalAnnotationStorageArray = new SgJavaNormalAnnotationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaNormalAnnotation::initializeStorageClassArray (SgJavaNormalAnnotationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaTypeExpression ) ; 
     std::cout << " SgJavaTypeExpression has size " << sizeOfActualPool << std::endl;
     SgJavaTypeExpressionStorageClass* SgJavaTypeExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaTypeExpressionStorageArray = new SgJavaTypeExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaTypeExpression::initializeStorageClassArray (SgJavaTypeExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaQualifiedType ) ; 
     std::cout << " SgJavaQualifiedType has size " << sizeOfActualPool << std::endl;
     SgJavaQualifiedTypeStorageClass* SgJavaQualifiedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaQualifiedTypeStorageArray = new SgJavaQualifiedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaQualifiedType::initializeStorageClassArray (SgJavaQualifiedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassExp ) ; 
     std::cout << " SgClassExp has size " << sizeOfActualPool << std::endl;
     SgClassExpStorageClass* SgClassExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassExpStorageArray = new SgClassExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassExp::initializeStorageClassArray (SgClassExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaUnionType ) ; 
     std::cout << " SgJavaUnionType has size " << sizeOfActualPool << std::endl;
     SgJavaUnionTypeStorageClass* SgJavaUnionTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnionTypeStorageArray = new SgJavaUnionTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaUnionType::initializeStorageClassArray (SgJavaUnionTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaParameterType ) ; 
     std::cout << " SgJavaParameterType has size " << sizeOfActualPool << std::endl;
     SgJavaParameterTypeStorageClass* SgJavaParameterTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaParameterTypeStorageArray = new SgJavaParameterTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaParameterType::initializeStorageClassArray (SgJavaParameterTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsyncStmt ) ; 
     std::cout << " SgAsyncStmt has size " << sizeOfActualPool << std::endl;
     SgAsyncStmtStorageClass* SgAsyncStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsyncStmtStorageArray = new SgAsyncStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsyncStmt::initializeStorageClassArray (SgAsyncStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFinishStmt ) ; 
     std::cout << " SgFinishStmt has size " << sizeOfActualPool << std::endl;
     SgFinishStmtStorageClass* SgFinishStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFinishStmtStorageArray = new SgFinishStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFinishStmt::initializeStorageClassArray (SgFinishStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAtStmt ) ; 
     std::cout << " SgAtStmt has size " << sizeOfActualPool << std::endl;
     SgAtStmtStorageClass* SgAtStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAtStmtStorageArray = new SgAtStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAtStmt::initializeStorageClassArray (SgAtStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAtomicStmt ) ; 
     std::cout << " SgAtomicStmt has size " << sizeOfActualPool << std::endl;
     SgAtomicStmtStorageClass* SgAtomicStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAtomicStmtStorageArray = new SgAtomicStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAtomicStmt::initializeStorageClassArray (SgAtomicStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWhenStmt ) ; 
     std::cout << " SgWhenStmt has size " << sizeOfActualPool << std::endl;
     SgWhenStmtStorageClass* SgWhenStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhenStmtStorageArray = new SgWhenStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWhenStmt::initializeStorageClassArray (SgWhenStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAtExp ) ; 
     std::cout << " SgAtExp has size " << sizeOfActualPool << std::endl;
     SgAtExpStorageClass* SgAtExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAtExpStorageArray = new SgAtExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAtExp::initializeStorageClassArray (SgAtExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFinishExp ) ; 
     std::cout << " SgFinishExp has size " << sizeOfActualPool << std::endl;
     SgFinishExpStorageClass* SgFinishExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFinishExpStorageArray = new SgFinishExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFinishExp::initializeStorageClassArray (SgFinishExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgHereExp ) ; 
     std::cout << " SgHereExp has size " << sizeOfActualPool << std::endl;
     SgHereExpStorageClass* SgHereExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgHereExpStorageArray = new SgHereExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgHereExp::initializeStorageClassArray (SgHereExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDotDotExp ) ; 
     std::cout << " SgDotDotExp has size " << sizeOfActualPool << std::endl;
     SgDotDotExpStorageClass* SgDotDotExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotDotExpStorageArray = new SgDotDotExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDotDotExp::initializeStorageClassArray (SgDotDotExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNullInstruction ) ; 
     std::cout << " SgAsmNullInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmNullInstructionStorageClass* SgAsmNullInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNullInstructionStorageArray = new SgAsmNullInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNullInstruction::initializeStorageClassArray (SgAsmNullInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaComponentClause ) ; 
     std::cout << " SgAdaComponentClause has size " << sizeOfActualPool << std::endl;
     SgAdaComponentClauseStorageClass* SgAdaComponentClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaComponentClauseStorageArray = new SgAdaComponentClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaComponentClause::initializeStorageClassArray (SgAdaComponentClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaIndexConstraint ) ; 
     std::cout << " SgAdaIndexConstraint has size " << sizeOfActualPool << std::endl;
     SgAdaIndexConstraintStorageClass* SgAdaIndexConstraintStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaIndexConstraintStorageArray = new SgAdaIndexConstraintStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaIndexConstraint::initializeStorageClassArray (SgAdaIndexConstraintStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaModularType ) ; 
     std::cout << " SgAdaModularType has size " << sizeOfActualPool << std::endl;
     SgAdaModularTypeStorageClass* SgAdaModularTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaModularTypeStorageArray = new SgAdaModularTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaModularType::initializeStorageClassArray (SgAdaModularTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaRepresentationClause ) ; 
     std::cout << " SgAdaRepresentationClause has size " << sizeOfActualPool << std::endl;
     SgAdaRepresentationClauseStorageClass* SgAdaRepresentationClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRepresentationClauseStorageArray = new SgAdaRepresentationClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaRepresentationClause::initializeStorageClassArray (SgAdaRepresentationClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaFunctionRenamingDecl ) ; 
     std::cout << " SgAdaFunctionRenamingDecl has size " << sizeOfActualPool << std::endl;
     SgAdaFunctionRenamingDeclStorageClass* SgAdaFunctionRenamingDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFunctionRenamingDeclStorageArray = new SgAdaFunctionRenamingDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaFunctionRenamingDecl::initializeStorageClassArray (SgAdaFunctionRenamingDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaSelectStmt ) ; 
     std::cout << " SgAdaSelectStmt has size " << sizeOfActualPool << std::endl;
     SgAdaSelectStmtStorageClass* SgAdaSelectStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaSelectStmtStorageArray = new SgAdaSelectStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaSelectStmt::initializeStorageClassArray (SgAdaSelectStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaSelectAlternativeStmt ) ; 
     std::cout << " SgAdaSelectAlternativeStmt has size " << sizeOfActualPool << std::endl;
     SgAdaSelectAlternativeStmtStorageClass* SgAdaSelectAlternativeStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaSelectAlternativeStmtStorageArray = new SgAdaSelectAlternativeStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaSelectAlternativeStmt::initializeStorageClassArray (SgAdaSelectAlternativeStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaTerminateStmt ) ; 
     std::cout << " SgAdaTerminateStmt has size " << sizeOfActualPool << std::endl;
     SgAdaTerminateStmtStorageClass* SgAdaTerminateStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTerminateStmtStorageArray = new SgAdaTerminateStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaTerminateStmt::initializeStorageClassArray (SgAdaTerminateStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmAarch32Coprocessor ) ; 
     std::cout << " SgAsmAarch32Coprocessor has size " << sizeOfActualPool << std::endl;
     SgAsmAarch32CoprocessorStorageClass* SgAsmAarch32CoprocessorStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmAarch32CoprocessorStorageArray = new SgAsmAarch32CoprocessorStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmAarch32Coprocessor::initializeStorageClassArray (SgAsmAarch32CoprocessorStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaAttributeClause ) ; 
     std::cout << " SgAdaAttributeClause has size " << sizeOfActualPool << std::endl;
     SgAdaAttributeClauseStorageClass* SgAdaAttributeClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAttributeClauseStorageArray = new SgAdaAttributeClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaAttributeClause::initializeStorageClassArray (SgAdaAttributeClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryConcat ) ; 
     std::cout << " SgAsmBinaryConcat has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryConcatStorageClass* SgAsmBinaryConcatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryConcatStorageArray = new SgAsmBinaryConcatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryConcat::initializeStorageClassArray (SgAsmBinaryConcatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmByteOrder ) ; 
     std::cout << " SgAsmByteOrder has size " << sizeOfActualPool << std::endl;
     SgAsmByteOrderStorageClass* SgAsmByteOrderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmByteOrderStorageArray = new SgAsmByteOrderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmByteOrder::initializeStorageClassArray (SgAsmByteOrderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaDerivedType ) ; 
     std::cout << " SgAdaDerivedType has size " << sizeOfActualPool << std::endl;
     SgAdaDerivedTypeStorageClass* SgAdaDerivedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDerivedTypeStorageArray = new SgAdaDerivedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaDerivedType::initializeStorageClassArray (SgAdaDerivedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaAttributeExp ) ; 
     std::cout << " SgAdaAttributeExp has size " << sizeOfActualPool << std::endl;
     SgAdaAttributeExpStorageClass* SgAdaAttributeExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAttributeExpStorageArray = new SgAdaAttributeExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaAttributeExp::initializeStorageClassArray (SgAdaAttributeExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaEnumRepresentationClause ) ; 
     std::cout << " SgAdaEnumRepresentationClause has size " << sizeOfActualPool << std::endl;
     SgAdaEnumRepresentationClauseStorageClass* SgAdaEnumRepresentationClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaEnumRepresentationClauseStorageArray = new SgAdaEnumRepresentationClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaEnumRepresentationClause::initializeStorageClassArray (SgAdaEnumRepresentationClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryPreupdate ) ; 
     std::cout << " SgAsmBinaryPreupdate has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryPreupdateStorageClass* SgAsmBinaryPreupdateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryPreupdateStorageArray = new SgAsmBinaryPreupdateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryPreupdate::initializeStorageClassArray (SgAsmBinaryPreupdateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryPostupdate ) ; 
     std::cout << " SgAsmBinaryPostupdate has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryPostupdateStorageClass* SgAsmBinaryPostupdateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryPostupdateStorageArray = new SgAsmBinaryPostupdateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryPostupdate::initializeStorageClassArray (SgAsmBinaryPostupdateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaOthersExp ) ; 
     std::cout << " SgAdaOthersExp has size " << sizeOfActualPool << std::endl;
     SgAdaOthersExpStorageClass* SgAdaOthersExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaOthersExpStorageArray = new SgAdaOthersExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaOthersExp::initializeStorageClassArray (SgAdaOthersExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaRenamingSymbol ) ; 
     std::cout << " SgAdaRenamingSymbol has size " << sizeOfActualPool << std::endl;
     SgAdaRenamingSymbolStorageClass* SgAdaRenamingSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRenamingSymbolStorageArray = new SgAdaRenamingSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaRenamingSymbol::initializeStorageClassArray (SgAdaRenamingSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaRenamingRefExp ) ; 
     std::cout << " SgAdaRenamingRefExp has size " << sizeOfActualPool << std::endl;
     SgAdaRenamingRefExpStorageClass* SgAdaRenamingRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRenamingRefExpStorageArray = new SgAdaRenamingRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaRenamingRefExp::initializeStorageClassArray (SgAdaRenamingRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaGenericDecl ) ; 
     std::cout << " SgAdaGenericDecl has size " << sizeOfActualPool << std::endl;
     SgAdaGenericDeclStorageClass* SgAdaGenericDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericDeclStorageArray = new SgAdaGenericDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaGenericDecl::initializeStorageClassArray (SgAdaGenericDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaGenericDefn ) ; 
     std::cout << " SgAdaGenericDefn has size " << sizeOfActualPool << std::endl;
     SgAdaGenericDefnStorageClass* SgAdaGenericDefnStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericDefnStorageArray = new SgAdaGenericDefnStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaGenericDefn::initializeStorageClassArray (SgAdaGenericDefnStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaFormalType ) ; 
     std::cout << " SgAdaFormalType has size " << sizeOfActualPool << std::endl;
     SgAdaFormalTypeStorageClass* SgAdaFormalTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFormalTypeStorageArray = new SgAdaFormalTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaFormalType::initializeStorageClassArray (SgAdaFormalTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaGenericSymbol ) ; 
     std::cout << " SgAdaGenericSymbol has size " << sizeOfActualPool << std::endl;
     SgAdaGenericSymbolStorageClass* SgAdaGenericSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericSymbolStorageArray = new SgAdaGenericSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaGenericSymbol::initializeStorageClassArray (SgAdaGenericSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaFormalTypeDecl ) ; 
     std::cout << " SgAdaFormalTypeDecl has size " << sizeOfActualPool << std::endl;
     SgAdaFormalTypeDeclStorageClass* SgAdaFormalTypeDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFormalTypeDeclStorageArray = new SgAdaFormalTypeDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaFormalTypeDecl::initializeStorageClassArray (SgAdaFormalTypeDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaUnitRefExp ) ; 
     std::cout << " SgAdaUnitRefExp has size " << sizeOfActualPool << std::endl;
     SgAdaUnitRefExpStorageClass* SgAdaUnitRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaUnitRefExpStorageArray = new SgAdaUnitRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaUnitRefExp::initializeStorageClassArray (SgAdaUnitRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaDiscriminatedTypeDecl ) ; 
     std::cout << " SgAdaDiscriminatedTypeDecl has size " << sizeOfActualPool << std::endl;
     SgAdaDiscriminatedTypeDeclStorageClass* SgAdaDiscriminatedTypeDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDiscriminatedTypeDeclStorageArray = new SgAdaDiscriminatedTypeDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaDiscriminatedTypeDecl::initializeStorageClassArray (SgAdaDiscriminatedTypeDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaDiscriminatedType ) ; 
     std::cout << " SgAdaDiscriminatedType has size " << sizeOfActualPool << std::endl;
     SgAdaDiscriminatedTypeStorageClass* SgAdaDiscriminatedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDiscriminatedTypeStorageArray = new SgAdaDiscriminatedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaDiscriminatedType::initializeStorageClassArray (SgAdaDiscriminatedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaDiscriminantConstraint ) ; 
     std::cout << " SgAdaDiscriminantConstraint has size " << sizeOfActualPool << std::endl;
     SgAdaDiscriminantConstraintStorageClass* SgAdaDiscriminantConstraintStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDiscriminantConstraintStorageArray = new SgAdaDiscriminantConstraintStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaDiscriminantConstraint::initializeStorageClassArray (SgAdaDiscriminantConstraintStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaGenericInstanceDecl ) ; 
     std::cout << " SgAdaGenericInstanceDecl has size " << sizeOfActualPool << std::endl;
     SgAdaGenericInstanceDeclStorageClass* SgAdaGenericInstanceDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericInstanceDeclStorageArray = new SgAdaGenericInstanceDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaGenericInstanceDecl::initializeStorageClassArray (SgAdaGenericInstanceDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaUnscopedBlock ) ; 
     std::cout << " SgAdaUnscopedBlock has size " << sizeOfActualPool << std::endl;
     SgAdaUnscopedBlockStorageClass* SgAdaUnscopedBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaUnscopedBlockStorageArray = new SgAdaUnscopedBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaUnscopedBlock::initializeStorageClassArray (SgAdaUnscopedBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaInheritedFunctionSymbol ) ; 
     std::cout << " SgAdaInheritedFunctionSymbol has size " << sizeOfActualPool << std::endl;
     SgAdaInheritedFunctionSymbolStorageClass* SgAdaInheritedFunctionSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaInheritedFunctionSymbolStorageArray = new SgAdaInheritedFunctionSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaInheritedFunctionSymbol::initializeStorageClassArray (SgAdaInheritedFunctionSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaProtectedBody ) ; 
     std::cout << " SgAdaProtectedBody has size " << sizeOfActualPool << std::endl;
     SgAdaProtectedBodyStorageClass* SgAdaProtectedBodyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedBodyStorageArray = new SgAdaProtectedBodyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaProtectedBody::initializeStorageClassArray (SgAdaProtectedBodyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaProtectedBodyDecl ) ; 
     std::cout << " SgAdaProtectedBodyDecl has size " << sizeOfActualPool << std::endl;
     SgAdaProtectedBodyDeclStorageClass* SgAdaProtectedBodyDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedBodyDeclStorageArray = new SgAdaProtectedBodyDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaProtectedBodyDecl::initializeStorageClassArray (SgAdaProtectedBodyDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaProtectedSpec ) ; 
     std::cout << " SgAdaProtectedSpec has size " << sizeOfActualPool << std::endl;
     SgAdaProtectedSpecStorageClass* SgAdaProtectedSpecStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedSpecStorageArray = new SgAdaProtectedSpecStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaProtectedSpec::initializeStorageClassArray (SgAdaProtectedSpecStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaProtectedSpecDecl ) ; 
     std::cout << " SgAdaProtectedSpecDecl has size " << sizeOfActualPool << std::endl;
     SgAdaProtectedSpecDeclStorageClass* SgAdaProtectedSpecDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedSpecDeclStorageArray = new SgAdaProtectedSpecDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaProtectedSpecDecl::initializeStorageClassArray (SgAdaProtectedSpecDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaProtectedSymbol ) ; 
     std::cout << " SgAdaProtectedSymbol has size " << sizeOfActualPool << std::endl;
     SgAdaProtectedSymbolStorageClass* SgAdaProtectedSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedSymbolStorageArray = new SgAdaProtectedSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaProtectedSymbol::initializeStorageClassArray (SgAdaProtectedSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaProtectedRefExp ) ; 
     std::cout << " SgAdaProtectedRefExp has size " << sizeOfActualPool << std::endl;
     SgAdaProtectedRefExpStorageClass* SgAdaProtectedRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedRefExpStorageArray = new SgAdaProtectedRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaProtectedRefExp::initializeStorageClassArray (SgAdaProtectedRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaProtectedType ) ; 
     std::cout << " SgAdaProtectedType has size " << sizeOfActualPool << std::endl;
     SgAdaProtectedTypeStorageClass* SgAdaProtectedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedTypeStorageArray = new SgAdaProtectedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaProtectedType::initializeStorageClassArray (SgAdaProtectedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaProtectedTypeDecl ) ; 
     std::cout << " SgAdaProtectedTypeDecl has size " << sizeOfActualPool << std::endl;
     SgAdaProtectedTypeDeclStorageClass* SgAdaProtectedTypeDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedTypeDeclStorageArray = new SgAdaProtectedTypeDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaProtectedTypeDecl::initializeStorageClassArray (SgAdaProtectedTypeDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaDigitsConstraint ) ; 
     std::cout << " SgAdaDigitsConstraint has size " << sizeOfActualPool << std::endl;
     SgAdaDigitsConstraintStorageClass* SgAdaDigitsConstraintStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDigitsConstraintStorageArray = new SgAdaDigitsConstraintStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaDigitsConstraint::initializeStorageClassArray (SgAdaDigitsConstraintStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaAncestorInitializer ) ; 
     std::cout << " SgAdaAncestorInitializer has size " << sizeOfActualPool << std::endl;
     SgAdaAncestorInitializerStorageClass* SgAdaAncestorInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAncestorInitializerStorageArray = new SgAdaAncestorInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaAncestorInitializer::initializeStorageClassArray (SgAdaAncestorInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaDeltaConstraint ) ; 
     std::cout << " SgAdaDeltaConstraint has size " << sizeOfActualPool << std::endl;
     SgAdaDeltaConstraintStorageClass* SgAdaDeltaConstraintStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDeltaConstraintStorageArray = new SgAdaDeltaConstraintStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaDeltaConstraint::initializeStorageClassArray (SgAdaDeltaConstraintStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaSubroutineType ) ; 
     std::cout << " SgAdaSubroutineType has size " << sizeOfActualPool << std::endl;
     SgAdaSubroutineTypeStorageClass* SgAdaSubroutineTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaSubroutineTypeStorageArray = new SgAdaSubroutineTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaSubroutineType::initializeStorageClassArray (SgAdaSubroutineTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaGenericInstanceSymbol ) ; 
     std::cout << " SgAdaGenericInstanceSymbol has size " << sizeOfActualPool << std::endl;
     SgAdaGenericInstanceSymbolStorageClass* SgAdaGenericInstanceSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericInstanceSymbolStorageArray = new SgAdaGenericInstanceSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaGenericInstanceSymbol::initializeStorageClassArray (SgAdaGenericInstanceSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaFormalPackageDecl ) ; 
     std::cout << " SgAdaFormalPackageDecl has size " << sizeOfActualPool << std::endl;
     SgAdaFormalPackageDeclStorageClass* SgAdaFormalPackageDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFormalPackageDeclStorageArray = new SgAdaFormalPackageDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaFormalPackageDecl::initializeStorageClassArray (SgAdaFormalPackageDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaFormalPackageSymbol ) ; 
     std::cout << " SgAdaFormalPackageSymbol has size " << sizeOfActualPool << std::endl;
     SgAdaFormalPackageSymbolStorageClass* SgAdaFormalPackageSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFormalPackageSymbolStorageArray = new SgAdaFormalPackageSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaFormalPackageSymbol::initializeStorageClassArray (SgAdaFormalPackageSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmAttributeTable ) ; 
     std::cout << " SgAsmJvmAttributeTable has size " << sizeOfActualPool << std::endl;
     SgAsmJvmAttributeTableStorageClass* SgAsmJvmAttributeTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmAttributeTableStorageArray = new SgAsmJvmAttributeTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmAttributeTable::initializeStorageClassArray (SgAsmJvmAttributeTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmMethodTable ) ; 
     std::cout << " SgAsmJvmMethodTable has size " << sizeOfActualPool << std::endl;
     SgAsmJvmMethodTableStorageClass* SgAsmJvmMethodTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmMethodTableStorageArray = new SgAsmJvmMethodTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmMethodTable::initializeStorageClassArray (SgAsmJvmMethodTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmField ) ; 
     std::cout << " SgAsmJvmField has size " << sizeOfActualPool << std::endl;
     SgAsmJvmFieldStorageClass* SgAsmJvmFieldStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmFieldStorageArray = new SgAsmJvmFieldStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmField::initializeStorageClassArray (SgAsmJvmFieldStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmFieldTable ) ; 
     std::cout << " SgAsmJvmFieldTable has size " << sizeOfActualPool << std::endl;
     SgAsmJvmFieldTableStorageClass* SgAsmJvmFieldTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmFieldTableStorageArray = new SgAsmJvmFieldTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmFieldTable::initializeStorageClassArray (SgAsmJvmFieldTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmExceptionHandler ) ; 
     std::cout << " SgAsmJvmExceptionHandler has size " << sizeOfActualPool << std::endl;
     SgAsmJvmExceptionHandlerStorageClass* SgAsmJvmExceptionHandlerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmExceptionHandlerStorageArray = new SgAsmJvmExceptionHandlerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmExceptionHandler::initializeStorageClassArray (SgAsmJvmExceptionHandlerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmExceptionTable ) ; 
     std::cout << " SgAsmJvmExceptionTable has size " << sizeOfActualPool << std::endl;
     SgAsmJvmExceptionTableStorageClass* SgAsmJvmExceptionTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmExceptionTableStorageArray = new SgAsmJvmExceptionTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmExceptionTable::initializeStorageClassArray (SgAsmJvmExceptionTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmClass ) ; 
     std::cout << " SgAsmJvmClass has size " << sizeOfActualPool << std::endl;
     SgAsmJvmClassStorageClass* SgAsmJvmClassStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmClassStorageArray = new SgAsmJvmClassStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmClass::initializeStorageClassArray (SgAsmJvmClassStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmLineNumberEntry ) ; 
     std::cout << " SgAsmJvmLineNumberEntry has size " << sizeOfActualPool << std::endl;
     SgAsmJvmLineNumberEntryStorageClass* SgAsmJvmLineNumberEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLineNumberEntryStorageArray = new SgAsmJvmLineNumberEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmLineNumberEntry::initializeStorageClassArray (SgAsmJvmLineNumberEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmLineNumberTable ) ; 
     std::cout << " SgAsmJvmLineNumberTable has size " << sizeOfActualPool << std::endl;
     SgAsmJvmLineNumberTableStorageClass* SgAsmJvmLineNumberTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLineNumberTableStorageArray = new SgAsmJvmLineNumberTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmLineNumberTable::initializeStorageClassArray (SgAsmJvmLineNumberTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmInnerClassesEntry ) ; 
     std::cout << " SgAsmJvmInnerClassesEntry has size " << sizeOfActualPool << std::endl;
     SgAsmJvmInnerClassesEntryStorageClass* SgAsmJvmInnerClassesEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmInnerClassesEntryStorageArray = new SgAsmJvmInnerClassesEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmInnerClassesEntry::initializeStorageClassArray (SgAsmJvmInnerClassesEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmInnerClasses ) ; 
     std::cout << " SgAsmJvmInnerClasses has size " << sizeOfActualPool << std::endl;
     SgAsmJvmInnerClassesStorageClass* SgAsmJvmInnerClassesStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmInnerClassesStorageArray = new SgAsmJvmInnerClassesStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmInnerClasses::initializeStorageClassArray (SgAsmJvmInnerClassesStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilInstruction ) ; 
     std::cout << " SgAsmCilInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmCilInstructionStorageClass* SgAsmCilInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilInstructionStorageArray = new SgAsmCilInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilInstruction::initializeStorageClassArray (SgAsmCilInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStackExpression ) ; 
     std::cout << " SgAsmStackExpression has size " << sizeOfActualPool << std::endl;
     SgAsmStackExpressionStorageClass* SgAsmStackExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStackExpressionStorageArray = new SgAsmStackExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStackExpression::initializeStorageClassArray (SgAsmStackExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmEnclosingMethod ) ; 
     std::cout << " SgAsmJvmEnclosingMethod has size " << sizeOfActualPool << std::endl;
     SgAsmJvmEnclosingMethodStorageClass* SgAsmJvmEnclosingMethodStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmEnclosingMethodStorageArray = new SgAsmJvmEnclosingMethodStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmEnclosingMethod::initializeStorageClassArray (SgAsmJvmEnclosingMethodStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaNullConstraint ) ; 
     std::cout << " SgAdaNullConstraint has size " << sizeOfActualPool << std::endl;
     SgAdaNullConstraintStorageClass* SgAdaNullConstraintStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaNullConstraintStorageArray = new SgAdaNullConstraintStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaNullConstraint::initializeStorageClassArray (SgAdaNullConstraintStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmModuleMainClass ) ; 
     std::cout << " SgAsmJvmModuleMainClass has size " << sizeOfActualPool << std::endl;
     SgAsmJvmModuleMainClassStorageClass* SgAsmJvmModuleMainClassStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmModuleMainClassStorageArray = new SgAsmJvmModuleMainClassStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmModuleMainClass::initializeStorageClassArray (SgAsmJvmModuleMainClassStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmInstructionList ) ; 
     std::cout << " SgAsmInstructionList has size " << sizeOfActualPool << std::endl;
     SgAsmInstructionListStorageClass* SgAsmInstructionListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInstructionListStorageArray = new SgAsmInstructionListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmInstructionList::initializeStorageClassArray (SgAsmInstructionListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilNode ) ; 
     std::cout << " SgAsmCilNode has size " << sizeOfActualPool << std::endl;
     SgAsmCilNodeStorageClass* SgAsmCilNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilNodeStorageArray = new SgAsmCilNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilNode::initializeStorageClassArray (SgAsmCilNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssembly ) ; 
     std::cout << " SgAsmCilAssembly has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyStorageClass* SgAsmCilAssemblyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyStorageArray = new SgAsmCilAssemblyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssembly::initializeStorageClassArray (SgAsmCilAssemblyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyOS ) ; 
     std::cout << " SgAsmCilAssemblyOS has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyOSStorageClass* SgAsmCilAssemblyOSStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyOSStorageArray = new SgAsmCilAssemblyOSStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyOS::initializeStorageClassArray (SgAsmCilAssemblyOSStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyProcessor ) ; 
     std::cout << " SgAsmCilAssemblyProcessor has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyProcessorStorageClass* SgAsmCilAssemblyProcessorStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyProcessorStorageArray = new SgAsmCilAssemblyProcessorStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyProcessor::initializeStorageClassArray (SgAsmCilAssemblyProcessorStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyRef ) ; 
     std::cout << " SgAsmCilAssemblyRef has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyRefStorageClass* SgAsmCilAssemblyRefStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefStorageArray = new SgAsmCilAssemblyRefStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyRef::initializeStorageClassArray (SgAsmCilAssemblyRefStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyRefOS ) ; 
     std::cout << " SgAsmCilAssemblyRefOS has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyRefOSStorageClass* SgAsmCilAssemblyRefOSStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefOSStorageArray = new SgAsmCilAssemblyRefOSStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyRefOS::initializeStorageClassArray (SgAsmCilAssemblyRefOSStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyRefProcessor ) ; 
     std::cout << " SgAsmCilAssemblyRefProcessor has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyRefProcessorStorageClass* SgAsmCilAssemblyRefProcessorStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefProcessorStorageArray = new SgAsmCilAssemblyRefProcessorStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyRefProcessor::initializeStorageClassArray (SgAsmCilAssemblyRefProcessorStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilClassLayout ) ; 
     std::cout << " SgAsmCilClassLayout has size " << sizeOfActualPool << std::endl;
     SgAsmCilClassLayoutStorageClass* SgAsmCilClassLayoutStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilClassLayoutStorageArray = new SgAsmCilClassLayoutStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilClassLayout::initializeStorageClassArray (SgAsmCilClassLayoutStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilConstant ) ; 
     std::cout << " SgAsmCilConstant has size " << sizeOfActualPool << std::endl;
     SgAsmCilConstantStorageClass* SgAsmCilConstantStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilConstantStorageArray = new SgAsmCilConstantStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilConstant::initializeStorageClassArray (SgAsmCilConstantStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilCustomAttribute ) ; 
     std::cout << " SgAsmCilCustomAttribute has size " << sizeOfActualPool << std::endl;
     SgAsmCilCustomAttributeStorageClass* SgAsmCilCustomAttributeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilCustomAttributeStorageArray = new SgAsmCilCustomAttributeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilCustomAttribute::initializeStorageClassArray (SgAsmCilCustomAttributeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilDeclSecurity ) ; 
     std::cout << " SgAsmCilDeclSecurity has size " << sizeOfActualPool << std::endl;
     SgAsmCilDeclSecurityStorageClass* SgAsmCilDeclSecurityStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilDeclSecurityStorageArray = new SgAsmCilDeclSecurityStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilDeclSecurity::initializeStorageClassArray (SgAsmCilDeclSecurityStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilEvent ) ; 
     std::cout << " SgAsmCilEvent has size " << sizeOfActualPool << std::endl;
     SgAsmCilEventStorageClass* SgAsmCilEventStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilEventStorageArray = new SgAsmCilEventStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilEvent::initializeStorageClassArray (SgAsmCilEventStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilEventMap ) ; 
     std::cout << " SgAsmCilEventMap has size " << sizeOfActualPool << std::endl;
     SgAsmCilEventMapStorageClass* SgAsmCilEventMapStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilEventMapStorageArray = new SgAsmCilEventMapStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilEventMap::initializeStorageClassArray (SgAsmCilEventMapStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilExportedType ) ; 
     std::cout << " SgAsmCilExportedType has size " << sizeOfActualPool << std::endl;
     SgAsmCilExportedTypeStorageClass* SgAsmCilExportedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilExportedTypeStorageArray = new SgAsmCilExportedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilExportedType::initializeStorageClassArray (SgAsmCilExportedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilField ) ; 
     std::cout << " SgAsmCilField has size " << sizeOfActualPool << std::endl;
     SgAsmCilFieldStorageClass* SgAsmCilFieldStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldStorageArray = new SgAsmCilFieldStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilField::initializeStorageClassArray (SgAsmCilFieldStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilFieldLayout ) ; 
     std::cout << " SgAsmCilFieldLayout has size " << sizeOfActualPool << std::endl;
     SgAsmCilFieldLayoutStorageClass* SgAsmCilFieldLayoutStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldLayoutStorageArray = new SgAsmCilFieldLayoutStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilFieldLayout::initializeStorageClassArray (SgAsmCilFieldLayoutStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilFieldMarshal ) ; 
     std::cout << " SgAsmCilFieldMarshal has size " << sizeOfActualPool << std::endl;
     SgAsmCilFieldMarshalStorageClass* SgAsmCilFieldMarshalStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldMarshalStorageArray = new SgAsmCilFieldMarshalStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilFieldMarshal::initializeStorageClassArray (SgAsmCilFieldMarshalStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilFieldRVA ) ; 
     std::cout << " SgAsmCilFieldRVA has size " << sizeOfActualPool << std::endl;
     SgAsmCilFieldRVAStorageClass* SgAsmCilFieldRVAStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldRVAStorageArray = new SgAsmCilFieldRVAStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilFieldRVA::initializeStorageClassArray (SgAsmCilFieldRVAStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilFile ) ; 
     std::cout << " SgAsmCilFile has size " << sizeOfActualPool << std::endl;
     SgAsmCilFileStorageClass* SgAsmCilFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFileStorageArray = new SgAsmCilFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilFile::initializeStorageClassArray (SgAsmCilFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilGenericParam ) ; 
     std::cout << " SgAsmCilGenericParam has size " << sizeOfActualPool << std::endl;
     SgAsmCilGenericParamStorageClass* SgAsmCilGenericParamStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilGenericParamStorageArray = new SgAsmCilGenericParamStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilGenericParam::initializeStorageClassArray (SgAsmCilGenericParamStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilGenericParamConstraint ) ; 
     std::cout << " SgAsmCilGenericParamConstraint has size " << sizeOfActualPool << std::endl;
     SgAsmCilGenericParamConstraintStorageClass* SgAsmCilGenericParamConstraintStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilGenericParamConstraintStorageArray = new SgAsmCilGenericParamConstraintStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilGenericParamConstraint::initializeStorageClassArray (SgAsmCilGenericParamConstraintStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilImplMap ) ; 
     std::cout << " SgAsmCilImplMap has size " << sizeOfActualPool << std::endl;
     SgAsmCilImplMapStorageClass* SgAsmCilImplMapStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilImplMapStorageArray = new SgAsmCilImplMapStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilImplMap::initializeStorageClassArray (SgAsmCilImplMapStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilInterfaceImpl ) ; 
     std::cout << " SgAsmCilInterfaceImpl has size " << sizeOfActualPool << std::endl;
     SgAsmCilInterfaceImplStorageClass* SgAsmCilInterfaceImplStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilInterfaceImplStorageArray = new SgAsmCilInterfaceImplStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilInterfaceImpl::initializeStorageClassArray (SgAsmCilInterfaceImplStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilManifestResource ) ; 
     std::cout << " SgAsmCilManifestResource has size " << sizeOfActualPool << std::endl;
     SgAsmCilManifestResourceStorageClass* SgAsmCilManifestResourceStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilManifestResourceStorageArray = new SgAsmCilManifestResourceStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilManifestResource::initializeStorageClassArray (SgAsmCilManifestResourceStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMemberRef ) ; 
     std::cout << " SgAsmCilMemberRef has size " << sizeOfActualPool << std::endl;
     SgAsmCilMemberRefStorageClass* SgAsmCilMemberRefStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMemberRefStorageArray = new SgAsmCilMemberRefStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMemberRef::initializeStorageClassArray (SgAsmCilMemberRefStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMethodDef ) ; 
     std::cout << " SgAsmCilMethodDef has size " << sizeOfActualPool << std::endl;
     SgAsmCilMethodDefStorageClass* SgAsmCilMethodDefStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodDefStorageArray = new SgAsmCilMethodDefStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMethodDef::initializeStorageClassArray (SgAsmCilMethodDefStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMethodImpl ) ; 
     std::cout << " SgAsmCilMethodImpl has size " << sizeOfActualPool << std::endl;
     SgAsmCilMethodImplStorageClass* SgAsmCilMethodImplStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodImplStorageArray = new SgAsmCilMethodImplStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMethodImpl::initializeStorageClassArray (SgAsmCilMethodImplStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMethodSemantics ) ; 
     std::cout << " SgAsmCilMethodSemantics has size " << sizeOfActualPool << std::endl;
     SgAsmCilMethodSemanticsStorageClass* SgAsmCilMethodSemanticsStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodSemanticsStorageArray = new SgAsmCilMethodSemanticsStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMethodSemantics::initializeStorageClassArray (SgAsmCilMethodSemanticsStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMethodSpec ) ; 
     std::cout << " SgAsmCilMethodSpec has size " << sizeOfActualPool << std::endl;
     SgAsmCilMethodSpecStorageClass* SgAsmCilMethodSpecStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodSpecStorageArray = new SgAsmCilMethodSpecStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMethodSpec::initializeStorageClassArray (SgAsmCilMethodSpecStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilModule ) ; 
     std::cout << " SgAsmCilModule has size " << sizeOfActualPool << std::endl;
     SgAsmCilModuleStorageClass* SgAsmCilModuleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilModuleStorageArray = new SgAsmCilModuleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilModule::initializeStorageClassArray (SgAsmCilModuleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilModuleRef ) ; 
     std::cout << " SgAsmCilModuleRef has size " << sizeOfActualPool << std::endl;
     SgAsmCilModuleRefStorageClass* SgAsmCilModuleRefStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilModuleRefStorageArray = new SgAsmCilModuleRefStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilModuleRef::initializeStorageClassArray (SgAsmCilModuleRefStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilNestedClass ) ; 
     std::cout << " SgAsmCilNestedClass has size " << sizeOfActualPool << std::endl;
     SgAsmCilNestedClassStorageClass* SgAsmCilNestedClassStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilNestedClassStorageArray = new SgAsmCilNestedClassStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilNestedClass::initializeStorageClassArray (SgAsmCilNestedClassStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilParam ) ; 
     std::cout << " SgAsmCilParam has size " << sizeOfActualPool << std::endl;
     SgAsmCilParamStorageClass* SgAsmCilParamStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilParamStorageArray = new SgAsmCilParamStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilParam::initializeStorageClassArray (SgAsmCilParamStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilProperty ) ; 
     std::cout << " SgAsmCilProperty has size " << sizeOfActualPool << std::endl;
     SgAsmCilPropertyStorageClass* SgAsmCilPropertyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilPropertyStorageArray = new SgAsmCilPropertyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilProperty::initializeStorageClassArray (SgAsmCilPropertyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilPropertyMap ) ; 
     std::cout << " SgAsmCilPropertyMap has size " << sizeOfActualPool << std::endl;
     SgAsmCilPropertyMapStorageClass* SgAsmCilPropertyMapStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilPropertyMapStorageArray = new SgAsmCilPropertyMapStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilPropertyMap::initializeStorageClassArray (SgAsmCilPropertyMapStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilStandAloneSig ) ; 
     std::cout << " SgAsmCilStandAloneSig has size " << sizeOfActualPool << std::endl;
     SgAsmCilStandAloneSigStorageClass* SgAsmCilStandAloneSigStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilStandAloneSigStorageArray = new SgAsmCilStandAloneSigStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilStandAloneSig::initializeStorageClassArray (SgAsmCilStandAloneSigStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilTypeDef ) ; 
     std::cout << " SgAsmCilTypeDef has size " << sizeOfActualPool << std::endl;
     SgAsmCilTypeDefStorageClass* SgAsmCilTypeDefStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeDefStorageArray = new SgAsmCilTypeDefStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilTypeDef::initializeStorageClassArray (SgAsmCilTypeDefStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilTypeRef ) ; 
     std::cout << " SgAsmCilTypeRef has size " << sizeOfActualPool << std::endl;
     SgAsmCilTypeRefStorageClass* SgAsmCilTypeRefStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeRefStorageArray = new SgAsmCilTypeRefStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilTypeRef::initializeStorageClassArray (SgAsmCilTypeRefStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilTypeSpec ) ; 
     std::cout << " SgAsmCilTypeSpec has size " << sizeOfActualPool << std::endl;
     SgAsmCilTypeSpecStorageClass* SgAsmCilTypeSpecStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeSpecStorageArray = new SgAsmCilTypeSpecStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilTypeSpec::initializeStorageClassArray (SgAsmCilTypeSpecStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaParameterList ) ; 
     std::cout << " SgAdaParameterList has size " << sizeOfActualPool << std::endl;
     SgAdaParameterListStorageClass* SgAdaParameterListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaParameterListStorageArray = new SgAdaParameterListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaParameterList::initializeStorageClassArray (SgAdaParameterListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMetadata ) ; 
     std::cout << " SgAsmCilMetadata has size " << sizeOfActualPool << std::endl;
     SgAsmCilMetadataStorageClass* SgAsmCilMetadataStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMetadataStorageArray = new SgAsmCilMetadataStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMetadata::initializeStorageClassArray (SgAsmCilMetadataStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMetadataRoot ) ; 
     std::cout << " SgAsmCilMetadataRoot has size " << sizeOfActualPool << std::endl;
     SgAsmCilMetadataRootStorageClass* SgAsmCilMetadataRootStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMetadataRootStorageArray = new SgAsmCilMetadataRootStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMetadataRoot::initializeStorageClassArray (SgAsmCilMetadataRootStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilDataStream ) ; 
     std::cout << " SgAsmCilDataStream has size " << sizeOfActualPool << std::endl;
     SgAsmCilDataStreamStorageClass* SgAsmCilDataStreamStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilDataStreamStorageArray = new SgAsmCilDataStreamStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilDataStream::initializeStorageClassArray (SgAsmCilDataStreamStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMetadataHeap ) ; 
     std::cout << " SgAsmCilMetadataHeap has size " << sizeOfActualPool << std::endl;
     SgAsmCilMetadataHeapStorageClass* SgAsmCilMetadataHeapStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMetadataHeapStorageArray = new SgAsmCilMetadataHeapStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMetadataHeap::initializeStorageClassArray (SgAsmCilMetadataHeapStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilUint8Heap ) ; 
     std::cout << " SgAsmCilUint8Heap has size " << sizeOfActualPool << std::endl;
     SgAsmCilUint8HeapStorageClass* SgAsmCilUint8HeapStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilUint8HeapStorageArray = new SgAsmCilUint8HeapStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilUint8Heap::initializeStorageClassArray (SgAsmCilUint8HeapStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilUint32Heap ) ; 
     std::cout << " SgAsmCilUint32Heap has size " << sizeOfActualPool << std::endl;
     SgAsmCilUint32HeapStorageClass* SgAsmCilUint32HeapStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilUint32HeapStorageArray = new SgAsmCilUint32HeapStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilUint32Heap::initializeStorageClassArray (SgAsmCilUint32HeapStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCliHeader ) ; 
     std::cout << " SgAsmCliHeader has size " << sizeOfActualPool << std::endl;
     SgAsmCliHeaderStorageClass* SgAsmCliHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCliHeaderStorageArray = new SgAsmCliHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCliHeader::initializeStorageClassArray (SgAsmCliHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaVariantDecl ) ; 
     std::cout << " SgAdaVariantDecl has size " << sizeOfActualPool << std::endl;
     SgAdaVariantDeclStorageClass* SgAdaVariantDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaVariantDeclStorageArray = new SgAdaVariantDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaVariantDecl::initializeStorageClassArray (SgAdaVariantDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAdaVariantWhenStmt ) ; 
     std::cout << " SgAdaVariantWhenStmt has size " << sizeOfActualPool << std::endl;
     SgAdaVariantWhenStmtStorageClass* SgAdaVariantWhenStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaVariantWhenStmtStorageArray = new SgAdaVariantWhenStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAdaVariantWhenStmt::initializeStorageClassArray (SgAdaVariantWhenStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyTable ) ; 
     std::cout << " SgAsmCilAssemblyTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyTableStorageClass* SgAsmCilAssemblyTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyTableStorageArray = new SgAsmCilAssemblyTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyTable::initializeStorageClassArray (SgAsmCilAssemblyTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyOSTable ) ; 
     std::cout << " SgAsmCilAssemblyOSTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyOSTableStorageClass* SgAsmCilAssemblyOSTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyOSTableStorageArray = new SgAsmCilAssemblyOSTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyOSTable::initializeStorageClassArray (SgAsmCilAssemblyOSTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyProcessorTable ) ; 
     std::cout << " SgAsmCilAssemblyProcessorTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyProcessorTableStorageClass* SgAsmCilAssemblyProcessorTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyProcessorTableStorageArray = new SgAsmCilAssemblyProcessorTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyProcessorTable::initializeStorageClassArray (SgAsmCilAssemblyProcessorTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyRefTable ) ; 
     std::cout << " SgAsmCilAssemblyRefTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyRefTableStorageClass* SgAsmCilAssemblyRefTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefTableStorageArray = new SgAsmCilAssemblyRefTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyRefTable::initializeStorageClassArray (SgAsmCilAssemblyRefTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyRefOSTable ) ; 
     std::cout << " SgAsmCilAssemblyRefOSTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyRefOSTableStorageClass* SgAsmCilAssemblyRefOSTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefOSTableStorageArray = new SgAsmCilAssemblyRefOSTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyRefOSTable::initializeStorageClassArray (SgAsmCilAssemblyRefOSTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilAssemblyRefProcessorTable ) ; 
     std::cout << " SgAsmCilAssemblyRefProcessorTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilAssemblyRefProcessorTableStorageClass* SgAsmCilAssemblyRefProcessorTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefProcessorTableStorageArray = new SgAsmCilAssemblyRefProcessorTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilAssemblyRefProcessorTable::initializeStorageClassArray (SgAsmCilAssemblyRefProcessorTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilClassLayoutTable ) ; 
     std::cout << " SgAsmCilClassLayoutTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilClassLayoutTableStorageClass* SgAsmCilClassLayoutTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilClassLayoutTableStorageArray = new SgAsmCilClassLayoutTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilClassLayoutTable::initializeStorageClassArray (SgAsmCilClassLayoutTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilConstantTable ) ; 
     std::cout << " SgAsmCilConstantTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilConstantTableStorageClass* SgAsmCilConstantTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilConstantTableStorageArray = new SgAsmCilConstantTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilConstantTable::initializeStorageClassArray (SgAsmCilConstantTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilCustomAttributeTable ) ; 
     std::cout << " SgAsmCilCustomAttributeTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilCustomAttributeTableStorageClass* SgAsmCilCustomAttributeTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilCustomAttributeTableStorageArray = new SgAsmCilCustomAttributeTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilCustomAttributeTable::initializeStorageClassArray (SgAsmCilCustomAttributeTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilDeclSecurityTable ) ; 
     std::cout << " SgAsmCilDeclSecurityTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilDeclSecurityTableStorageClass* SgAsmCilDeclSecurityTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilDeclSecurityTableStorageArray = new SgAsmCilDeclSecurityTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilDeclSecurityTable::initializeStorageClassArray (SgAsmCilDeclSecurityTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilEventTable ) ; 
     std::cout << " SgAsmCilEventTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilEventTableStorageClass* SgAsmCilEventTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilEventTableStorageArray = new SgAsmCilEventTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilEventTable::initializeStorageClassArray (SgAsmCilEventTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilEventMapTable ) ; 
     std::cout << " SgAsmCilEventMapTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilEventMapTableStorageClass* SgAsmCilEventMapTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilEventMapTableStorageArray = new SgAsmCilEventMapTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilEventMapTable::initializeStorageClassArray (SgAsmCilEventMapTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilExportedTypeTable ) ; 
     std::cout << " SgAsmCilExportedTypeTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilExportedTypeTableStorageClass* SgAsmCilExportedTypeTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilExportedTypeTableStorageArray = new SgAsmCilExportedTypeTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilExportedTypeTable::initializeStorageClassArray (SgAsmCilExportedTypeTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilFieldTable ) ; 
     std::cout << " SgAsmCilFieldTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilFieldTableStorageClass* SgAsmCilFieldTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldTableStorageArray = new SgAsmCilFieldTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilFieldTable::initializeStorageClassArray (SgAsmCilFieldTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilFieldLayoutTable ) ; 
     std::cout << " SgAsmCilFieldLayoutTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilFieldLayoutTableStorageClass* SgAsmCilFieldLayoutTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldLayoutTableStorageArray = new SgAsmCilFieldLayoutTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilFieldLayoutTable::initializeStorageClassArray (SgAsmCilFieldLayoutTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilFieldMarshalTable ) ; 
     std::cout << " SgAsmCilFieldMarshalTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilFieldMarshalTableStorageClass* SgAsmCilFieldMarshalTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldMarshalTableStorageArray = new SgAsmCilFieldMarshalTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilFieldMarshalTable::initializeStorageClassArray (SgAsmCilFieldMarshalTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilFieldRVATable ) ; 
     std::cout << " SgAsmCilFieldRVATable has size " << sizeOfActualPool << std::endl;
     SgAsmCilFieldRVATableStorageClass* SgAsmCilFieldRVATableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldRVATableStorageArray = new SgAsmCilFieldRVATableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilFieldRVATable::initializeStorageClassArray (SgAsmCilFieldRVATableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilFileTable ) ; 
     std::cout << " SgAsmCilFileTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilFileTableStorageClass* SgAsmCilFileTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFileTableStorageArray = new SgAsmCilFileTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilFileTable::initializeStorageClassArray (SgAsmCilFileTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilGenericParamTable ) ; 
     std::cout << " SgAsmCilGenericParamTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilGenericParamTableStorageClass* SgAsmCilGenericParamTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilGenericParamTableStorageArray = new SgAsmCilGenericParamTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilGenericParamTable::initializeStorageClassArray (SgAsmCilGenericParamTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilGenericParamConstraintTable ) ; 
     std::cout << " SgAsmCilGenericParamConstraintTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilGenericParamConstraintTableStorageClass* SgAsmCilGenericParamConstraintTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilGenericParamConstraintTableStorageArray = new SgAsmCilGenericParamConstraintTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilGenericParamConstraintTable::initializeStorageClassArray (SgAsmCilGenericParamConstraintTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilImplMapTable ) ; 
     std::cout << " SgAsmCilImplMapTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilImplMapTableStorageClass* SgAsmCilImplMapTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilImplMapTableStorageArray = new SgAsmCilImplMapTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilImplMapTable::initializeStorageClassArray (SgAsmCilImplMapTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilInterfaceImplTable ) ; 
     std::cout << " SgAsmCilInterfaceImplTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilInterfaceImplTableStorageClass* SgAsmCilInterfaceImplTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilInterfaceImplTableStorageArray = new SgAsmCilInterfaceImplTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilInterfaceImplTable::initializeStorageClassArray (SgAsmCilInterfaceImplTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilManifestResourceTable ) ; 
     std::cout << " SgAsmCilManifestResourceTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilManifestResourceTableStorageClass* SgAsmCilManifestResourceTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilManifestResourceTableStorageArray = new SgAsmCilManifestResourceTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilManifestResourceTable::initializeStorageClassArray (SgAsmCilManifestResourceTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMemberRefTable ) ; 
     std::cout << " SgAsmCilMemberRefTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilMemberRefTableStorageClass* SgAsmCilMemberRefTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMemberRefTableStorageArray = new SgAsmCilMemberRefTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMemberRefTable::initializeStorageClassArray (SgAsmCilMemberRefTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMethodDefTable ) ; 
     std::cout << " SgAsmCilMethodDefTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilMethodDefTableStorageClass* SgAsmCilMethodDefTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodDefTableStorageArray = new SgAsmCilMethodDefTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMethodDefTable::initializeStorageClassArray (SgAsmCilMethodDefTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMethodImplTable ) ; 
     std::cout << " SgAsmCilMethodImplTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilMethodImplTableStorageClass* SgAsmCilMethodImplTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodImplTableStorageArray = new SgAsmCilMethodImplTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMethodImplTable::initializeStorageClassArray (SgAsmCilMethodImplTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMethodSemanticsTable ) ; 
     std::cout << " SgAsmCilMethodSemanticsTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilMethodSemanticsTableStorageClass* SgAsmCilMethodSemanticsTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodSemanticsTableStorageArray = new SgAsmCilMethodSemanticsTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMethodSemanticsTable::initializeStorageClassArray (SgAsmCilMethodSemanticsTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMethodSpecTable ) ; 
     std::cout << " SgAsmCilMethodSpecTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilMethodSpecTableStorageClass* SgAsmCilMethodSpecTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodSpecTableStorageArray = new SgAsmCilMethodSpecTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMethodSpecTable::initializeStorageClassArray (SgAsmCilMethodSpecTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilModuleTable ) ; 
     std::cout << " SgAsmCilModuleTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilModuleTableStorageClass* SgAsmCilModuleTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilModuleTableStorageArray = new SgAsmCilModuleTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilModuleTable::initializeStorageClassArray (SgAsmCilModuleTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilModuleRefTable ) ; 
     std::cout << " SgAsmCilModuleRefTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilModuleRefTableStorageClass* SgAsmCilModuleRefTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilModuleRefTableStorageArray = new SgAsmCilModuleRefTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilModuleRefTable::initializeStorageClassArray (SgAsmCilModuleRefTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilNestedClassTable ) ; 
     std::cout << " SgAsmCilNestedClassTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilNestedClassTableStorageClass* SgAsmCilNestedClassTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilNestedClassTableStorageArray = new SgAsmCilNestedClassTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilNestedClassTable::initializeStorageClassArray (SgAsmCilNestedClassTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilParamTable ) ; 
     std::cout << " SgAsmCilParamTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilParamTableStorageClass* SgAsmCilParamTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilParamTableStorageArray = new SgAsmCilParamTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilParamTable::initializeStorageClassArray (SgAsmCilParamTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilPropertyTable ) ; 
     std::cout << " SgAsmCilPropertyTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilPropertyTableStorageClass* SgAsmCilPropertyTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilPropertyTableStorageArray = new SgAsmCilPropertyTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilPropertyTable::initializeStorageClassArray (SgAsmCilPropertyTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilPropertyMapTable ) ; 
     std::cout << " SgAsmCilPropertyMapTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilPropertyMapTableStorageClass* SgAsmCilPropertyMapTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilPropertyMapTableStorageArray = new SgAsmCilPropertyMapTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilPropertyMapTable::initializeStorageClassArray (SgAsmCilPropertyMapTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilStandAloneSigTable ) ; 
     std::cout << " SgAsmCilStandAloneSigTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilStandAloneSigTableStorageClass* SgAsmCilStandAloneSigTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilStandAloneSigTableStorageArray = new SgAsmCilStandAloneSigTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilStandAloneSigTable::initializeStorageClassArray (SgAsmCilStandAloneSigTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilTypeDefTable ) ; 
     std::cout << " SgAsmCilTypeDefTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilTypeDefTableStorageClass* SgAsmCilTypeDefTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeDefTableStorageArray = new SgAsmCilTypeDefTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilTypeDefTable::initializeStorageClassArray (SgAsmCilTypeDefTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilTypeRefTable ) ; 
     std::cout << " SgAsmCilTypeRefTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilTypeRefTableStorageClass* SgAsmCilTypeRefTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeRefTableStorageArray = new SgAsmCilTypeRefTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilTypeRefTable::initializeStorageClassArray (SgAsmCilTypeRefTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilTypeSpecTable ) ; 
     std::cout << " SgAsmCilTypeSpecTable has size " << sizeOfActualPool << std::endl;
     SgAsmCilTypeSpecTableStorageClass* SgAsmCilTypeSpecTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeSpecTableStorageArray = new SgAsmCilTypeSpecTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilTypeSpecTable::initializeStorageClassArray (SgAsmCilTypeSpecTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJvmComposite ) ; 
     std::cout << " SgJvmComposite has size " << sizeOfActualPool << std::endl;
     SgJvmCompositeStorageClass* SgJvmCompositeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJvmCompositeStorageArray = new SgJvmCompositeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJvmComposite::initializeStorageClassArray (SgJvmCompositeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFortranContinueStmt ) ; 
     std::cout << " SgFortranContinueStmt has size " << sizeOfActualPool << std::endl;
     SgFortranContinueStmtStorageClass* SgFortranContinueStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranContinueStmtStorageArray = new SgFortranContinueStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFortranContinueStmt::initializeStorageClassArray (SgFortranContinueStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmStackMapTable ) ; 
     std::cout << " SgAsmJvmStackMapTable has size " << sizeOfActualPool << std::endl;
     SgAsmJvmStackMapTableStorageClass* SgAsmJvmStackMapTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmStackMapTableStorageArray = new SgAsmJvmStackMapTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmStackMapTable::initializeStorageClassArray (SgAsmJvmStackMapTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmStackMapFrame ) ; 
     std::cout << " SgAsmJvmStackMapFrame has size " << sizeOfActualPool << std::endl;
     SgAsmJvmStackMapFrameStorageClass* SgAsmJvmStackMapFrameStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmStackMapFrameStorageArray = new SgAsmJvmStackMapFrameStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmStackMapFrame::initializeStorageClassArray (SgAsmJvmStackMapFrameStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmStackMapVerificationType ) ; 
     std::cout << " SgAsmJvmStackMapVerificationType has size " << sizeOfActualPool << std::endl;
     SgAsmJvmStackMapVerificationTypeStorageClass* SgAsmJvmStackMapVerificationTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmStackMapVerificationTypeStorageArray = new SgAsmJvmStackMapVerificationTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmStackMapVerificationType::initializeStorageClassArray (SgAsmJvmStackMapVerificationTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmBootstrapMethod ) ; 
     std::cout << " SgAsmJvmBootstrapMethod has size " << sizeOfActualPool << std::endl;
     SgAsmJvmBootstrapMethodStorageClass* SgAsmJvmBootstrapMethodStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmBootstrapMethodStorageArray = new SgAsmJvmBootstrapMethodStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmBootstrapMethod::initializeStorageClassArray (SgAsmJvmBootstrapMethodStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmBootstrapMethods ) ; 
     std::cout << " SgAsmJvmBootstrapMethods has size " << sizeOfActualPool << std::endl;
     SgAsmJvmBootstrapMethodsStorageClass* SgAsmJvmBootstrapMethodsStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmBootstrapMethodsStorageArray = new SgAsmJvmBootstrapMethodsStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmBootstrapMethods::initializeStorageClassArray (SgAsmJvmBootstrapMethodsStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmExceptions ) ; 
     std::cout << " SgAsmJvmExceptions has size " << sizeOfActualPool << std::endl;
     SgAsmJvmExceptionsStorageClass* SgAsmJvmExceptionsStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmExceptionsStorageArray = new SgAsmJvmExceptionsStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmExceptions::initializeStorageClassArray (SgAsmJvmExceptionsStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmNestMembers ) ; 
     std::cout << " SgAsmJvmNestMembers has size " << sizeOfActualPool << std::endl;
     SgAsmJvmNestMembersStorageClass* SgAsmJvmNestMembersStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmNestMembersStorageArray = new SgAsmJvmNestMembersStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmNestMembers::initializeStorageClassArray (SgAsmJvmNestMembersStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmNestHost ) ; 
     std::cout << " SgAsmJvmNestHost has size " << sizeOfActualPool << std::endl;
     SgAsmJvmNestHostStorageClass* SgAsmJvmNestHostStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmNestHostStorageArray = new SgAsmJvmNestHostStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmNestHost::initializeStorageClassArray (SgAsmJvmNestHostStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJovialLabelDeclaration ) ; 
     std::cout << " SgJovialLabelDeclaration has size " << sizeOfActualPool << std::endl;
     SgJovialLabelDeclarationStorageClass* SgJovialLabelDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialLabelDeclarationStorageArray = new SgJovialLabelDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJovialLabelDeclaration::initializeStorageClassArray (SgJovialLabelDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmLocalVariableEntry ) ; 
     std::cout << " SgAsmJvmLocalVariableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmJvmLocalVariableEntryStorageClass* SgAsmJvmLocalVariableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLocalVariableEntryStorageArray = new SgAsmJvmLocalVariableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmLocalVariableEntry::initializeStorageClassArray (SgAsmJvmLocalVariableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmLocalVariableTable ) ; 
     std::cout << " SgAsmJvmLocalVariableTable has size " << sizeOfActualPool << std::endl;
     SgAsmJvmLocalVariableTableStorageClass* SgAsmJvmLocalVariableTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLocalVariableTableStorageArray = new SgAsmJvmLocalVariableTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmLocalVariableTable::initializeStorageClassArray (SgAsmJvmLocalVariableTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmLocalVariableTypeEntry ) ; 
     std::cout << " SgAsmJvmLocalVariableTypeEntry has size " << sizeOfActualPool << std::endl;
     SgAsmJvmLocalVariableTypeEntryStorageClass* SgAsmJvmLocalVariableTypeEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLocalVariableTypeEntryStorageArray = new SgAsmJvmLocalVariableTypeEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmLocalVariableTypeEntry::initializeStorageClassArray (SgAsmJvmLocalVariableTypeEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmLocalVariableTypeTable ) ; 
     std::cout << " SgAsmJvmLocalVariableTypeTable has size " << sizeOfActualPool << std::endl;
     SgAsmJvmLocalVariableTypeTableStorageClass* SgAsmJvmLocalVariableTypeTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLocalVariableTypeTableStorageArray = new SgAsmJvmLocalVariableTypeTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmLocalVariableTypeTable::initializeStorageClassArray (SgAsmJvmLocalVariableTypeTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUserInstruction ) ; 
     std::cout << " SgAsmUserInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmUserInstructionStorageClass* SgAsmUserInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUserInstructionStorageArray = new SgAsmUserInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUserInstruction::initializeStorageClassArray (SgAsmUserInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmMethodParameters ) ; 
     std::cout << " SgAsmJvmMethodParameters has size " << sizeOfActualPool << std::endl;
     SgAsmJvmMethodParametersStorageClass* SgAsmJvmMethodParametersStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmMethodParametersStorageArray = new SgAsmJvmMethodParametersStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmMethodParameters::initializeStorageClassArray (SgAsmJvmMethodParametersStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmMethodParametersEntry ) ; 
     std::cout << " SgAsmJvmMethodParametersEntry has size " << sizeOfActualPool << std::endl;
     SgAsmJvmMethodParametersEntryStorageClass* SgAsmJvmMethodParametersEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmMethodParametersEntryStorageArray = new SgAsmJvmMethodParametersEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmMethodParametersEntry::initializeStorageClassArray (SgAsmJvmMethodParametersEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmVoidType ) ; 
     std::cout << " SgAsmVoidType has size " << sizeOfActualPool << std::endl;
     SgAsmVoidTypeStorageClass* SgAsmVoidTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmVoidTypeStorageArray = new SgAsmVoidTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmVoidType::initializeStorageClassArray (SgAsmVoidTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPointerType ) ; 
     std::cout << " SgAsmPointerType has size " << sizeOfActualPool << std::endl;
     SgAsmPointerTypeStorageClass* SgAsmPointerTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPointerTypeStorageArray = new SgAsmPointerTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPointerType::initializeStorageClassArray (SgAsmPointerTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRangeType ) ; 
     std::cout << " SgRangeType has size " << sizeOfActualPool << std::endl;
     SgRangeTypeStorageClass* SgRangeTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRangeTypeStorageArray = new SgRangeTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRangeType::initializeStorageClassArray (SgRangeTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilExceptionData ) ; 
     std::cout << " SgAsmCilExceptionData has size " << sizeOfActualPool << std::endl;
     SgAsmCilExceptionDataStorageClass* SgAsmCilExceptionDataStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilExceptionDataStorageArray = new SgAsmCilExceptionDataStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilExceptionData::initializeStorageClassArray (SgAsmCilExceptionDataStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilMethodData ) ; 
     std::cout << " SgAsmCilMethodData has size " << sizeOfActualPool << std::endl;
     SgAsmCilMethodDataStorageClass* SgAsmCilMethodDataStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodDataStorageArray = new SgAsmCilMethodDataStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilMethodData::initializeStorageClassArray (SgAsmCilMethodDataStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateVariableInstantiation ) ; 
     std::cout << " SgTemplateVariableInstantiation has size " << sizeOfActualPool << std::endl;
     SgTemplateVariableInstantiationStorageClass* SgTemplateVariableInstantiationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateVariableInstantiationStorageArray = new SgTemplateVariableInstantiationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateVariableInstantiation::initializeStorageClassArray (SgTemplateVariableInstantiationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgReferenceExp ) ; 
     std::cout << " SgReferenceExp has size " << sizeOfActualPool << std::endl;
     SgReferenceExpStorageClass* SgReferenceExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReferenceExpStorageArray = new SgReferenceExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgReferenceExp::initializeStorageClassArray (SgReferenceExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeRefExp ) ; 
     std::cout << " SgTypeRefExp has size " << sizeOfActualPool << std::endl;
     SgTypeRefExpStorageClass* SgTypeRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeRefExpStorageArray = new SgTypeRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeRefExp::initializeStorageClassArray (SgTypeRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgScopedRefExp ) ; 
     std::cout << " SgScopedRefExp has size " << sizeOfActualPool << std::endl;
     SgScopedRefExpStorageClass* SgScopedRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopedRefExpStorageArray = new SgScopedRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgScopedRefExp::initializeStorageClassArray (SgScopedRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgScopedType ) ; 
     std::cout << " SgScopedType has size " << sizeOfActualPool << std::endl;
     SgScopedTypeStorageClass* SgScopedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopedTypeStorageArray = new SgScopedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgScopedType::initializeStorageClassArray (SgScopedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSymbol ) ; 
     std::cout << " SgTypeSymbol has size " << sizeOfActualPool << std::endl;
     SgTypeSymbolStorageClass* SgTypeSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSymbolStorageArray = new SgTypeSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSymbol::initializeStorageClassArray (SgTypeSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmSynthetic ) ; 
     std::cout << " SgAsmJvmSynthetic has size " << sizeOfActualPool << std::endl;
     SgAsmJvmSyntheticStorageClass* SgAsmJvmSyntheticStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmSyntheticStorageArray = new SgAsmJvmSyntheticStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmSynthetic::initializeStorageClassArray (SgAsmJvmSyntheticStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmJvmDeprecated ) ; 
     std::cout << " SgAsmJvmDeprecated has size " << sizeOfActualPool << std::endl;
     SgAsmJvmDeprecatedStorageClass* SgAsmJvmDeprecatedStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmDeprecatedStorageArray = new SgAsmJvmDeprecatedStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmJvmDeprecated::initializeStorageClassArray (SgAsmJvmDeprecatedStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSignedCharVal ) ; 
     std::cout << " SgSignedCharVal has size " << sizeOfActualPool << std::endl;
     SgSignedCharValStorageClass* SgSignedCharValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSignedCharValStorageArray = new SgSignedCharValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSignedCharVal::initializeStorageClassArray (SgSignedCharValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCilErrorHeap ) ; 
     std::cout << " SgAsmCilErrorHeap has size " << sizeOfActualPool << std::endl;
     SgAsmCilErrorHeapStorageClass* SgAsmCilErrorHeapStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilErrorHeapStorageArray = new SgAsmCilErrorHeapStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCilErrorHeap::initializeStorageClassArray (SgAsmCilErrorHeapStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     clearAllMemoryPools();
     AstSpecificDataManagingClassStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock (); 
     actualRebuildAst = new AstSpecificDataManagingClass(staticTemp); 
     actualRebuildAst->setStaticDataMembersOfIRNodes(); 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAccessModifier ) ;
     std::cout << " SgAccessModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAccessModifier ( SgAccessModifierStorageArray[i] ) ; 
              }
          delete [] SgAccessModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgActualArgumentExpression ) ;
     std::cout << " SgActualArgumentExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgActualArgumentExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgActualArgumentExpression ( SgActualArgumentExpressionStorageArray[i] ) ; 
              }
          delete [] SgActualArgumentExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAbsOp ) ;
     std::cout << " SgAbsOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAbsOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAbsOp ( SgAbsOpStorageArray[i] ) ; 
              }
          delete [] SgAbsOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaAccessType ) ;
     std::cout << " SgAdaAccessType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaAccessTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaAccessType ( SgAdaAccessTypeStorageArray[i] ) ; 
              }
          delete [] SgAdaAccessTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaAcceptStmt ) ;
     std::cout << " SgAdaAcceptStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaAcceptStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaAcceptStmt ( SgAdaAcceptStmtStorageArray[i] ) ; 
              }
          delete [] SgAdaAcceptStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaDelayStmt ) ;
     std::cout << " SgAdaDelayStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaDelayStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaDelayStmt ( SgAdaDelayStmtStorageArray[i] ) ; 
              }
          delete [] SgAdaDelayStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaEntryDecl ) ;
     std::cout << " SgAdaEntryDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaEntryDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaEntryDecl ( SgAdaEntryDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaEntryDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaExitStmt ) ;
     std::cout << " SgAdaExitStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaExitStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaExitStmt ( SgAdaExitStmtStorageArray[i] ) ; 
              }
          delete [] SgAdaExitStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaDiscreteType ) ;
     std::cout << " SgAdaDiscreteType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaDiscreteTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaDiscreteType ( SgAdaDiscreteTypeStorageArray[i] ) ; 
              }
          delete [] SgAdaDiscreteTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaFloatVal ) ;
     std::cout << " SgAdaFloatVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaFloatValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaFloatVal ( SgAdaFloatValStorageArray[i] ) ; 
              }
          delete [] SgAdaFloatValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaLoopStmt ) ;
     std::cout << " SgAdaLoopStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaLoopStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaLoopStmt ( SgAdaLoopStmtStorageArray[i] ) ; 
              }
          delete [] SgAdaLoopStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaPackageBody ) ;
     std::cout << " SgAdaPackageBody has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaPackageBodyStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaPackageBody ( SgAdaPackageBodyStorageArray[i] ) ; 
              }
          delete [] SgAdaPackageBodyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaPackageBodyDecl ) ;
     std::cout << " SgAdaPackageBodyDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaPackageBodyDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaPackageBodyDecl ( SgAdaPackageBodyDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaPackageBodyDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaPackageSpec ) ;
     std::cout << " SgAdaPackageSpec has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaPackageSpecStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaPackageSpec ( SgAdaPackageSpecStorageArray[i] ) ; 
              }
          delete [] SgAdaPackageSpecStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaPackageSpecDecl ) ;
     std::cout << " SgAdaPackageSpecDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaPackageSpecDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaPackageSpecDecl ( SgAdaPackageSpecDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaPackageSpecDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaPackageSymbol ) ;
     std::cout << " SgAdaPackageSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaPackageSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaPackageSymbol ( SgAdaPackageSymbolStorageArray[i] ) ; 
              }
          delete [] SgAdaPackageSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaRangeConstraint ) ;
     std::cout << " SgAdaRangeConstraint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaRangeConstraintStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaRangeConstraint ( SgAdaRangeConstraintStorageArray[i] ) ; 
              }
          delete [] SgAdaRangeConstraintStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaRenamingDecl ) ;
     std::cout << " SgAdaRenamingDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaRenamingDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaRenamingDecl ( SgAdaRenamingDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaRenamingDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaSubtype ) ;
     std::cout << " SgAdaSubtype has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaSubtypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaSubtype ( SgAdaSubtypeStorageArray[i] ) ; 
              }
          delete [] SgAdaSubtypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTaskBody ) ;
     std::cout << " SgAdaTaskBody has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTaskBodyStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTaskBody ( SgAdaTaskBodyStorageArray[i] ) ; 
              }
          delete [] SgAdaTaskBodyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTaskBodyDecl ) ;
     std::cout << " SgAdaTaskBodyDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTaskBodyDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTaskBodyDecl ( SgAdaTaskBodyDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaTaskBodyDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTaskSpec ) ;
     std::cout << " SgAdaTaskSpec has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTaskSpecStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTaskSpec ( SgAdaTaskSpecStorageArray[i] ) ; 
              }
          delete [] SgAdaTaskSpecStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTaskSpecDecl ) ;
     std::cout << " SgAdaTaskSpecDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTaskSpecDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTaskSpecDecl ( SgAdaTaskSpecDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaTaskSpecDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTaskSymbol ) ;
     std::cout << " SgAdaTaskSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTaskSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTaskSymbol ( SgAdaTaskSymbolStorageArray[i] ) ; 
              }
          delete [] SgAdaTaskSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTaskRefExp ) ;
     std::cout << " SgAdaTaskRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTaskRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTaskRefExp ( SgAdaTaskRefExpStorageArray[i] ) ; 
              }
          delete [] SgAdaTaskRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTaskType ) ;
     std::cout << " SgAdaTaskType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTaskTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTaskType ( SgAdaTaskTypeStorageArray[i] ) ; 
              }
          delete [] SgAdaTaskTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTaskTypeDecl ) ;
     std::cout << " SgAdaTaskTypeDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTaskTypeDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTaskTypeDecl ( SgAdaTaskTypeDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaTaskTypeDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTypeConstraint ) ;
     std::cout << " SgAdaTypeConstraint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTypeConstraintStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTypeConstraint ( SgAdaTypeConstraintStorageArray[i] ) ; 
              }
          delete [] SgAdaTypeConstraintStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAddOp ) ;
     std::cout << " SgAddOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAddOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAddOp ( SgAddOpStorageArray[i] ) ; 
              }
          delete [] SgAddOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAddressOfOp ) ;
     std::cout << " SgAddressOfOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAddressOfOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAddressOfOp ( SgAddressOfOpStorageArray[i] ) ; 
              }
          delete [] SgAddressOfOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAggregateInitializer ) ;
     std::cout << " SgAggregateInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAggregateInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAggregateInitializer ( SgAggregateInitializerStorageArray[i] ) ; 
              }
          delete [] SgAggregateInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAliasSymbol ) ;
     std::cout << " SgAliasSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAliasSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAliasSymbol ( SgAliasSymbolStorageArray[i] ) ; 
              }
          delete [] SgAliasSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAllocateStatement ) ;
     std::cout << " SgAllocateStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAllocateStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAllocateStatement ( SgAllocateStatementStorageArray[i] ) ; 
              }
          delete [] SgAllocateStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAndAssignOp ) ;
     std::cout << " SgAndAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAndAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAndAssignOp ( SgAndAssignOpStorageArray[i] ) ; 
              }
          delete [] SgAndAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAndOp ) ;
     std::cout << " SgAndOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAndOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAndOp ( SgAndOpStorageArray[i] ) ; 
              }
          delete [] SgAndOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgArithmeticIfStatement ) ;
     std::cout << " SgArithmeticIfStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgArithmeticIfStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgArithmeticIfStatement ( SgArithmeticIfStatementStorageArray[i] ) ; 
              }
          delete [] SgArithmeticIfStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgArrayType ) ;
     std::cout << " SgArrayType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgArrayTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgArrayType ( SgArrayTypeStorageArray[i] ) ; 
              }
          delete [] SgArrayTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgArrowExp ) ;
     std::cout << " SgArrowExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgArrowExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgArrowExp ( SgArrowExpStorageArray[i] ) ; 
              }
          delete [] SgArrowExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgArrowStarOp ) ;
     std::cout << " SgArrowStarOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgArrowStarOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgArrowStarOp ( SgArrowStarOpStorageArray[i] ) ; 
              }
          delete [] SgArrowStarOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBasicString ) ;
     std::cout << " SgAsmBasicString has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBasicStringStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBasicString ( SgAsmBasicStringStorageArray[i] ) ; 
              }
          delete [] SgAsmBasicStringStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryAdd ) ;
     std::cout << " SgAsmBinaryAdd has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryAddStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryAdd ( SgAsmBinaryAddStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryAddStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryAsr ) ;
     std::cout << " SgAsmBinaryAsr has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryAsrStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryAsr ( SgAsmBinaryAsrStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryAsrStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryDivide ) ;
     std::cout << " SgAsmBinaryDivide has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryDivideStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryDivide ( SgAsmBinaryDivideStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryDivideStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryExpression ) ;
     std::cout << " SgAsmBinaryExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryExpression ( SgAsmBinaryExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryLsl ) ;
     std::cout << " SgAsmBinaryLsl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryLslStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryLsl ( SgAsmBinaryLslStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryLslStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryLsr ) ;
     std::cout << " SgAsmBinaryLsr has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryLsrStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryLsr ( SgAsmBinaryLsrStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryLsrStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryMod ) ;
     std::cout << " SgAsmBinaryMod has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryModStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryMod ( SgAsmBinaryModStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryModStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryMsl ) ;
     std::cout << " SgAsmBinaryMsl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryMslStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryMsl ( SgAsmBinaryMslStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryMslStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryMultiply ) ;
     std::cout << " SgAsmBinaryMultiply has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryMultiplyStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryMultiply ( SgAsmBinaryMultiplyStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryMultiplyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryRor ) ;
     std::cout << " SgAsmBinaryRor has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryRorStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryRor ( SgAsmBinaryRorStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryRorStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinarySubtract ) ;
     std::cout << " SgAsmBinarySubtract has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinarySubtractStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinarySubtract ( SgAsmBinarySubtractStorageArray[i] ) ; 
              }
          delete [] SgAsmBinarySubtractStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBlock ) ;
     std::cout << " SgAsmBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBlock ( SgAsmBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCoffStrtab ) ;
     std::cout << " SgAsmCoffStrtab has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCoffStrtabStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCoffStrtab ( SgAsmCoffStrtabStorageArray[i] ) ; 
              }
          delete [] SgAsmCoffStrtabStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCoffSymbol ) ;
     std::cout << " SgAsmCoffSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCoffSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCoffSymbol ( SgAsmCoffSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmCoffSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCoffSymbolList ) ;
     std::cout << " SgAsmCoffSymbolList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCoffSymbolListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCoffSymbolList ( SgAsmCoffSymbolListStorageArray[i] ) ; 
              }
          delete [] SgAsmCoffSymbolListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCoffSymbolTable ) ;
     std::cout << " SgAsmCoffSymbolTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCoffSymbolTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCoffSymbolTable ( SgAsmCoffSymbolTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCoffSymbolTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCommonSubExpression ) ;
     std::cout << " SgAsmCommonSubExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCommonSubExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCommonSubExpression ( SgAsmCommonSubExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmCommonSubExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmControlFlagsExpression ) ;
     std::cout << " SgAsmControlFlagsExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmControlFlagsExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmControlFlagsExpression ( SgAsmControlFlagsExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmControlFlagsExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmConstantExpression ) ;
     std::cout << " SgAsmConstantExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmConstantExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmConstantExpression ( SgAsmConstantExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmConstantExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDOSExtendedHeader ) ;
     std::cout << " SgAsmDOSExtendedHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDOSExtendedHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDOSExtendedHeader ( SgAsmDOSExtendedHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmDOSExtendedHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDOSFileHeader ) ;
     std::cout << " SgAsmDOSFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDOSFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDOSFileHeader ( SgAsmDOSFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmDOSFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmSynthesizedDataStructureDeclaration ) ;
     std::cout << " SgAsmSynthesizedDataStructureDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmSynthesizedDataStructureDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmSynthesizedDataStructureDeclaration ( SgAsmSynthesizedDataStructureDeclarationStorageArray[i] ) ; 
              }
          delete [] SgAsmSynthesizedDataStructureDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmSynthesizedDeclaration ) ;
     std::cout << " SgAsmSynthesizedDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmSynthesizedDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmSynthesizedDeclaration ( SgAsmSynthesizedDeclarationStorageArray[i] ) ; 
              }
          delete [] SgAsmSynthesizedDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDirectRegisterExpression ) ;
     std::cout << " SgAsmDirectRegisterExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDirectRegisterExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDirectRegisterExpression ( SgAsmDirectRegisterExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmDirectRegisterExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfAccessDeclaration ) ;
     std::cout << " SgAsmDwarfAccessDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfAccessDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfAccessDeclaration ( SgAsmDwarfAccessDeclarationStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfAccessDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfArrayType ) ;
     std::cout << " SgAsmDwarfArrayType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfArrayTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfArrayType ( SgAsmDwarfArrayTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfArrayTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfBaseType ) ;
     std::cout << " SgAsmDwarfBaseType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfBaseTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfBaseType ( SgAsmDwarfBaseTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfBaseTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCatchBlock ) ;
     std::cout << " SgAsmDwarfCatchBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCatchBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCatchBlock ( SgAsmDwarfCatchBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCatchBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfClassTemplate ) ;
     std::cout << " SgAsmDwarfClassTemplate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfClassTemplateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfClassTemplate ( SgAsmDwarfClassTemplateStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfClassTemplateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfClassType ) ;
     std::cout << " SgAsmDwarfClassType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfClassTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfClassType ( SgAsmDwarfClassTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfClassTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCommonBlock ) ;
     std::cout << " SgAsmDwarfCommonBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCommonBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCommonBlock ( SgAsmDwarfCommonBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCommonBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCommonInclusion ) ;
     std::cout << " SgAsmDwarfCommonInclusion has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCommonInclusionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCommonInclusion ( SgAsmDwarfCommonInclusionStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCommonInclusionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCompilationUnit ) ;
     std::cout << " SgAsmDwarfCompilationUnit has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCompilationUnitStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCompilationUnit ( SgAsmDwarfCompilationUnitStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCompilationUnitStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCompilationUnitList ) ;
     std::cout << " SgAsmDwarfCompilationUnitList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCompilationUnitListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCompilationUnitList ( SgAsmDwarfCompilationUnitListStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCompilationUnitListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCondition ) ;
     std::cout << " SgAsmDwarfCondition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConditionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCondition ( SgAsmDwarfConditionStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConditionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfConstType ) ;
     std::cout << " SgAsmDwarfConstType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConstTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfConstType ( SgAsmDwarfConstTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConstTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfConstant ) ;
     std::cout << " SgAsmDwarfConstant has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConstantStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfConstant ( SgAsmDwarfConstantStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConstantStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfConstruct ) ;
     std::cout << " SgAsmDwarfConstruct has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConstructStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfConstruct ( SgAsmDwarfConstructStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConstructStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfConstructList ) ;
     std::cout << " SgAsmDwarfConstructList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConstructListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfConstructList ( SgAsmDwarfConstructListStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConstructListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfDwarfProcedure ) ;
     std::cout << " SgAsmDwarfDwarfProcedure has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfDwarfProcedureStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfDwarfProcedure ( SgAsmDwarfDwarfProcedureStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfDwarfProcedureStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfEntryPoint ) ;
     std::cout << " SgAsmDwarfEntryPoint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfEntryPointStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfEntryPoint ( SgAsmDwarfEntryPointStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfEntryPointStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfEnumerationType ) ;
     std::cout << " SgAsmDwarfEnumerationType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfEnumerationTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfEnumerationType ( SgAsmDwarfEnumerationTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfEnumerationTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfEnumerator ) ;
     std::cout << " SgAsmDwarfEnumerator has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfEnumeratorStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfEnumerator ( SgAsmDwarfEnumeratorStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfEnumeratorStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFileType ) ;
     std::cout << " SgAsmDwarfFileType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFileTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFileType ( SgAsmDwarfFileTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFileTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFormalParameter ) ;
     std::cout << " SgAsmDwarfFormalParameter has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFormalParameterStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFormalParameter ( SgAsmDwarfFormalParameterStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFormalParameterStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFormatLabel ) ;
     std::cout << " SgAsmDwarfFormatLabel has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFormatLabelStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFormatLabel ( SgAsmDwarfFormatLabelStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFormatLabelStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFriend ) ;
     std::cout << " SgAsmDwarfFriend has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFriendStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFriend ( SgAsmDwarfFriendStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFriendStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFunctionTemplate ) ;
     std::cout << " SgAsmDwarfFunctionTemplate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFunctionTemplateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFunctionTemplate ( SgAsmDwarfFunctionTemplateStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFunctionTemplateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfImportedDeclaration ) ;
     std::cout << " SgAsmDwarfImportedDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfImportedDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfImportedDeclaration ( SgAsmDwarfImportedDeclarationStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfImportedDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfImportedModule ) ;
     std::cout << " SgAsmDwarfImportedModule has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfImportedModuleStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfImportedModule ( SgAsmDwarfImportedModuleStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfImportedModuleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfImportedUnit ) ;
     std::cout << " SgAsmDwarfImportedUnit has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfImportedUnitStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfImportedUnit ( SgAsmDwarfImportedUnitStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfImportedUnitStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfInformation ) ;
     std::cout << " SgAsmDwarfInformation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfInformation ( SgAsmDwarfInformationStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfInformationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfInheritance ) ;
     std::cout << " SgAsmDwarfInheritance has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfInheritanceStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfInheritance ( SgAsmDwarfInheritanceStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfInheritanceStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfInlinedSubroutine ) ;
     std::cout << " SgAsmDwarfInlinedSubroutine has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfInlinedSubroutineStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfInlinedSubroutine ( SgAsmDwarfInlinedSubroutineStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfInlinedSubroutineStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfInterfaceType ) ;
     std::cout << " SgAsmDwarfInterfaceType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfInterfaceTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfInterfaceType ( SgAsmDwarfInterfaceTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfInterfaceTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfLabel ) ;
     std::cout << " SgAsmDwarfLabel has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfLabelStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfLabel ( SgAsmDwarfLabelStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfLabelStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfLexicalBlock ) ;
     std::cout << " SgAsmDwarfLexicalBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfLexicalBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfLexicalBlock ( SgAsmDwarfLexicalBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfLexicalBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfLine ) ;
     std::cout << " SgAsmDwarfLine has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfLine ( SgAsmDwarfLineStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfLineStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfLineList ) ;
     std::cout << " SgAsmDwarfLineList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfLineListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfLineList ( SgAsmDwarfLineListStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfLineListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfMacro ) ;
     std::cout << " SgAsmDwarfMacro has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfMacroStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfMacro ( SgAsmDwarfMacroStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfMacroStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfMacroList ) ;
     std::cout << " SgAsmDwarfMacroList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfMacroListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfMacroList ( SgAsmDwarfMacroListStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfMacroListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfMember ) ;
     std::cout << " SgAsmDwarfMember has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfMemberStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfMember ( SgAsmDwarfMemberStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfMemberStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfModule ) ;
     std::cout << " SgAsmDwarfModule has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfModuleStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfModule ( SgAsmDwarfModuleStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfModuleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfMutableType ) ;
     std::cout << " SgAsmDwarfMutableType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfMutableTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfMutableType ( SgAsmDwarfMutableTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfMutableTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfNamelist ) ;
     std::cout << " SgAsmDwarfNamelist has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfNamelistStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfNamelist ( SgAsmDwarfNamelistStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfNamelistStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfNamelistItem ) ;
     std::cout << " SgAsmDwarfNamelistItem has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfNamelistItemStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfNamelistItem ( SgAsmDwarfNamelistItemStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfNamelistItemStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfNamespace ) ;
     std::cout << " SgAsmDwarfNamespace has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfNamespaceStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfNamespace ( SgAsmDwarfNamespaceStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfNamespaceStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfPackedType ) ;
     std::cout << " SgAsmDwarfPackedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfPackedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfPackedType ( SgAsmDwarfPackedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfPackedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfPartialUnit ) ;
     std::cout << " SgAsmDwarfPartialUnit has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfPartialUnitStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfPartialUnit ( SgAsmDwarfPartialUnitStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfPartialUnitStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfPointerType ) ;
     std::cout << " SgAsmDwarfPointerType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfPointerTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfPointerType ( SgAsmDwarfPointerTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfPointerTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfPtrToMemberType ) ;
     std::cout << " SgAsmDwarfPtrToMemberType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfPtrToMemberTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfPtrToMemberType ( SgAsmDwarfPtrToMemberTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfPtrToMemberTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfReferenceType ) ;
     std::cout << " SgAsmDwarfReferenceType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfReferenceTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfReferenceType ( SgAsmDwarfReferenceTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfReferenceTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfRestrictType ) ;
     std::cout << " SgAsmDwarfRestrictType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfRestrictTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfRestrictType ( SgAsmDwarfRestrictTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfRestrictTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSetType ) ;
     std::cout << " SgAsmDwarfSetType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSetTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSetType ( SgAsmDwarfSetTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSetTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSharedType ) ;
     std::cout << " SgAsmDwarfSharedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSharedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSharedType ( SgAsmDwarfSharedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSharedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfStringType ) ;
     std::cout << " SgAsmDwarfStringType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfStringTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfStringType ( SgAsmDwarfStringTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfStringTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfStructureType ) ;
     std::cout << " SgAsmDwarfStructureType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfStructureTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfStructureType ( SgAsmDwarfStructureTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfStructureTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSubprogram ) ;
     std::cout << " SgAsmDwarfSubprogram has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSubprogramStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSubprogram ( SgAsmDwarfSubprogramStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSubprogramStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSubrangeType ) ;
     std::cout << " SgAsmDwarfSubrangeType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSubrangeTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSubrangeType ( SgAsmDwarfSubrangeTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSubrangeTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSubroutineType ) ;
     std::cout << " SgAsmDwarfSubroutineType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSubroutineTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSubroutineType ( SgAsmDwarfSubroutineTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSubroutineTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfTemplateTypeParameter ) ;
     std::cout << " SgAsmDwarfTemplateTypeParameter has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfTemplateTypeParameterStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfTemplateTypeParameter ( SgAsmDwarfTemplateTypeParameterStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfTemplateTypeParameterStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfTemplateValueParameter ) ;
     std::cout << " SgAsmDwarfTemplateValueParameter has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfTemplateValueParameterStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfTemplateValueParameter ( SgAsmDwarfTemplateValueParameterStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfTemplateValueParameterStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfThrownType ) ;
     std::cout << " SgAsmDwarfThrownType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfThrownTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfThrownType ( SgAsmDwarfThrownTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfThrownTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfTryBlock ) ;
     std::cout << " SgAsmDwarfTryBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfTryBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfTryBlock ( SgAsmDwarfTryBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfTryBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfTypedef ) ;
     std::cout << " SgAsmDwarfTypedef has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfTypedefStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfTypedef ( SgAsmDwarfTypedefStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfTypedefStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUnionType ) ;
     std::cout << " SgAsmDwarfUnionType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUnionTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUnionType ( SgAsmDwarfUnionTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUnionTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUnknownConstruct ) ;
     std::cout << " SgAsmDwarfUnknownConstruct has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUnknownConstructStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUnknownConstruct ( SgAsmDwarfUnknownConstructStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUnknownConstructStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUnspecifiedParameters ) ;
     std::cout << " SgAsmDwarfUnspecifiedParameters has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUnspecifiedParametersStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUnspecifiedParameters ( SgAsmDwarfUnspecifiedParametersStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUnspecifiedParametersStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUnspecifiedType ) ;
     std::cout << " SgAsmDwarfUnspecifiedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUnspecifiedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUnspecifiedType ( SgAsmDwarfUnspecifiedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUnspecifiedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUpcRelaxedType ) ;
     std::cout << " SgAsmDwarfUpcRelaxedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUpcRelaxedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUpcRelaxedType ( SgAsmDwarfUpcRelaxedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUpcRelaxedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUpcSharedType ) ;
     std::cout << " SgAsmDwarfUpcSharedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUpcSharedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUpcSharedType ( SgAsmDwarfUpcSharedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUpcSharedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUpcStrictType ) ;
     std::cout << " SgAsmDwarfUpcStrictType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUpcStrictTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUpcStrictType ( SgAsmDwarfUpcStrictTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUpcStrictTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfVariable ) ;
     std::cout << " SgAsmDwarfVariable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfVariableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfVariable ( SgAsmDwarfVariableStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfVariableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfVariant ) ;
     std::cout << " SgAsmDwarfVariant has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfVariantStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfVariant ( SgAsmDwarfVariantStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfVariantStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfVariantPart ) ;
     std::cout << " SgAsmDwarfVariantPart has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfVariantPartStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfVariantPart ( SgAsmDwarfVariantPartStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfVariantPartStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfVolatileType ) ;
     std::cout << " SgAsmDwarfVolatileType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfVolatileTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfVolatileType ( SgAsmDwarfVolatileTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfVolatileTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfWithStmt ) ;
     std::cout << " SgAsmDwarfWithStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfWithStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfWithStmt ( SgAsmDwarfWithStmtStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfWithStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfDynamicEntry ) ;
     std::cout << " SgAsmElfDynamicEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfDynamicEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfDynamicEntry ( SgAsmElfDynamicEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfDynamicEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfDynamicEntryList ) ;
     std::cout << " SgAsmElfDynamicEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfDynamicEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfDynamicEntryList ( SgAsmElfDynamicEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfDynamicEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfDynamicSection ) ;
     std::cout << " SgAsmElfDynamicSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfDynamicSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfDynamicSection ( SgAsmElfDynamicSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfDynamicSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameEntryCI ) ;
     std::cout << " SgAsmElfEHFrameEntryCI has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameEntryCIStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameEntryCI ( SgAsmElfEHFrameEntryCIStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameEntryCIStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameEntryCIList ) ;
     std::cout << " SgAsmElfEHFrameEntryCIList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameEntryCIListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameEntryCIList ( SgAsmElfEHFrameEntryCIListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameEntryCIListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameEntryFD ) ;
     std::cout << " SgAsmElfEHFrameEntryFD has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameEntryFDStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameEntryFD ( SgAsmElfEHFrameEntryFDStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameEntryFDStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameEntryFDList ) ;
     std::cout << " SgAsmElfEHFrameEntryFDList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameEntryFDListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameEntryFDList ( SgAsmElfEHFrameEntryFDListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameEntryFDListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameSection ) ;
     std::cout << " SgAsmElfEHFrameSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameSection ( SgAsmElfEHFrameSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfFileHeader ) ;
     std::cout << " SgAsmElfFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfFileHeader ( SgAsmElfFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmElfFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfNoteEntry ) ;
     std::cout << " SgAsmElfNoteEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfNoteEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfNoteEntry ( SgAsmElfNoteEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfNoteEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfNoteEntryList ) ;
     std::cout << " SgAsmElfNoteEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfNoteEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfNoteEntryList ( SgAsmElfNoteEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfNoteEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfNoteSection ) ;
     std::cout << " SgAsmElfNoteSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfNoteSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfNoteSection ( SgAsmElfNoteSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfNoteSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfRelocEntry ) ;
     std::cout << " SgAsmElfRelocEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfRelocEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfRelocEntry ( SgAsmElfRelocEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfRelocEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfRelocEntryList ) ;
     std::cout << " SgAsmElfRelocEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfRelocEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfRelocEntryList ( SgAsmElfRelocEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfRelocEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfRelocSection ) ;
     std::cout << " SgAsmElfRelocSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfRelocSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfRelocSection ( SgAsmElfRelocSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfRelocSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSection ) ;
     std::cout << " SgAsmElfSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSection ( SgAsmElfSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSectionTable ) ;
     std::cout << " SgAsmElfSectionTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSectionTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSectionTable ( SgAsmElfSectionTableStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSectionTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSectionTableEntry ) ;
     std::cout << " SgAsmElfSectionTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSectionTableEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSectionTableEntry ( SgAsmElfSectionTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSectionTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSegmentTable ) ;
     std::cout << " SgAsmElfSegmentTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSegmentTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSegmentTable ( SgAsmElfSegmentTableStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSegmentTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSegmentTableEntry ) ;
     std::cout << " SgAsmElfSegmentTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSegmentTableEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSegmentTableEntry ( SgAsmElfSegmentTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSegmentTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSegmentTableEntryList ) ;
     std::cout << " SgAsmElfSegmentTableEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSegmentTableEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSegmentTableEntryList ( SgAsmElfSegmentTableEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSegmentTableEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfStringSection ) ;
     std::cout << " SgAsmElfStringSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfStringSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfStringSection ( SgAsmElfStringSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfStringSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfStrtab ) ;
     std::cout << " SgAsmElfStrtab has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfStrtabStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfStrtab ( SgAsmElfStrtabStorageArray[i] ) ; 
              }
          delete [] SgAsmElfStrtabStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymbol ) ;
     std::cout << " SgAsmElfSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymbol ( SgAsmElfSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymbolList ) ;
     std::cout << " SgAsmElfSymbolList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymbolListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymbolList ( SgAsmElfSymbolListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymbolListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymbolSection ) ;
     std::cout << " SgAsmElfSymbolSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymbolSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymbolSection ( SgAsmElfSymbolSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymbolSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedAux ) ;
     std::cout << " SgAsmElfSymverDefinedAux has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedAux ( SgAsmElfSymverDefinedAuxStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedAuxStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedAuxList ) ;
     std::cout << " SgAsmElfSymverDefinedAuxList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverDefinedAuxListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedAuxList ( SgAsmElfSymverDefinedAuxListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedAuxListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedEntry ) ;
     std::cout << " SgAsmElfSymverDefinedEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedEntry ( SgAsmElfSymverDefinedEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedEntryList ) ;
     std::cout << " SgAsmElfSymverDefinedEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverDefinedEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedEntryList ( SgAsmElfSymverDefinedEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedSection ) ;
     std::cout << " SgAsmElfSymverDefinedSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverDefinedSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedSection ( SgAsmElfSymverDefinedSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverEntry ) ;
     std::cout << " SgAsmElfSymverEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverEntry ( SgAsmElfSymverEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverEntryList ) ;
     std::cout << " SgAsmElfSymverEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverEntryList ( SgAsmElfSymverEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededAux ) ;
     std::cout << " SgAsmElfSymverNeededAux has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededAux ( SgAsmElfSymverNeededAuxStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededAuxStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededAuxList ) ;
     std::cout << " SgAsmElfSymverNeededAuxList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverNeededAuxListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededAuxList ( SgAsmElfSymverNeededAuxListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededAuxListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededEntry ) ;
     std::cout << " SgAsmElfSymverNeededEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededEntry ( SgAsmElfSymverNeededEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededEntryList ) ;
     std::cout << " SgAsmElfSymverNeededEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverNeededEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededEntryList ( SgAsmElfSymverNeededEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededSection ) ;
     std::cout << " SgAsmElfSymverNeededSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverNeededSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededSection ( SgAsmElfSymverNeededSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverSection ) ;
     std::cout << " SgAsmElfSymverSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverSection ( SgAsmElfSymverSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmExecutableFileFormat ) ;
     std::cout << " SgAsmExecutableFileFormat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmExecutableFileFormat ( SgAsmExecutableFileFormatStorageArray[i] ) ; 
              }
          delete [] SgAsmExecutableFileFormatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmExprListExp ) ;
     std::cout << " SgAsmExprListExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmExprListExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmExprListExp ( SgAsmExprListExpStorageArray[i] ) ; 
              }
          delete [] SgAsmExprListExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmExpression ) ;
     std::cout << " SgAsmExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmExpression ( SgAsmExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmSynthesizedFieldDeclaration ) ;
     std::cout << " SgAsmSynthesizedFieldDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmSynthesizedFieldDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmSynthesizedFieldDeclaration ( SgAsmSynthesizedFieldDeclarationStorageArray[i] ) ; 
              }
          delete [] SgAsmSynthesizedFieldDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmFloatType ) ;
     std::cout << " SgAsmFloatType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmFloatType ( SgAsmFloatTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmFloatTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmFloatValueExpression ) ;
     std::cout << " SgAsmFloatValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmFloatValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmFloatValueExpression ( SgAsmFloatValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmFloatValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmFunction ) ;
     std::cout << " SgAsmFunction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmFunctionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmFunction ( SgAsmFunctionStorageArray[i] ) ; 
              }
          delete [] SgAsmFunctionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericDLL ) ;
     std::cout << " SgAsmGenericDLL has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericDLLStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericDLL ( SgAsmGenericDLLStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericDLLStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericDLLList ) ;
     std::cout << " SgAsmGenericDLLList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericDLLListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericDLLList ( SgAsmGenericDLLListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericDLLListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericFile ) ;
     std::cout << " SgAsmGenericFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericFileStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericFile ( SgAsmGenericFileStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericFileList ) ;
     std::cout << " SgAsmGenericFileList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericFileListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericFileList ( SgAsmGenericFileListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericFileListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericFormat ) ;
     std::cout << " SgAsmGenericFormat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericFormat ( SgAsmGenericFormatStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericFormatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericHeader ) ;
     std::cout << " SgAsmGenericHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericHeader ( SgAsmGenericHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericHeaderList ) ;
     std::cout << " SgAsmGenericHeaderList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericHeaderListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericHeaderList ( SgAsmGenericHeaderListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericHeaderListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericSection ) ;
     std::cout << " SgAsmGenericSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericSection ( SgAsmGenericSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericSectionList ) ;
     std::cout << " SgAsmGenericSectionList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericSectionListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericSectionList ( SgAsmGenericSectionListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericSectionListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericString ) ;
     std::cout << " SgAsmGenericString has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericString ( SgAsmGenericStringStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericStringStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericStrtab ) ;
     std::cout << " SgAsmGenericStrtab has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericStrtabStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericStrtab ( SgAsmGenericStrtabStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericStrtabStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericSymbol ) ;
     std::cout << " SgAsmGenericSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericSymbol ( SgAsmGenericSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericSymbolList ) ;
     std::cout << " SgAsmGenericSymbolList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericSymbolListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericSymbolList ( SgAsmGenericSymbolListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericSymbolListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmIndirectRegisterExpression ) ;
     std::cout << " SgAsmIndirectRegisterExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmIndirectRegisterExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmIndirectRegisterExpression ( SgAsmIndirectRegisterExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmIndirectRegisterExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmInstruction ) ;
     std::cout << " SgAsmInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmInstruction ( SgAsmInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmIntegerValueExpression ) ;
     std::cout << " SgAsmIntegerValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmIntegerValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmIntegerValueExpression ( SgAsmIntegerValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmIntegerValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmIntegerType ) ;
     std::cout << " SgAsmIntegerType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmIntegerType ( SgAsmIntegerTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmIntegerTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmInterpretation ) ;
     std::cout << " SgAsmInterpretation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmInterpretation ( SgAsmInterpretationStorageArray[i] ) ; 
              }
          delete [] SgAsmInterpretationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmInterpretationList ) ;
     std::cout << " SgAsmInterpretationList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmInterpretationListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmInterpretationList ( SgAsmInterpretationListStorageArray[i] ) ; 
              }
          delete [] SgAsmInterpretationListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmAttribute ) ;
     std::cout << " SgAsmJvmAttribute has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmAttribute ( SgAsmJvmAttributeStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmAttributeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmCodeAttribute ) ;
     std::cout << " SgAsmJvmCodeAttribute has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmCodeAttributeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmCodeAttribute ( SgAsmJvmCodeAttributeStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmCodeAttributeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmMethod ) ;
     std::cout << " SgAsmJvmMethod has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmMethod ( SgAsmJvmMethodStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmMethodStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmConstantPool ) ;
     std::cout << " SgAsmJvmConstantPool has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmConstantPoolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmConstantPool ( SgAsmJvmConstantPoolStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmConstantPoolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmConstantPoolEntry ) ;
     std::cout << " SgAsmJvmConstantPoolEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmConstantPoolEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmConstantPoolEntry ( SgAsmJvmConstantPoolEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmConstantPoolEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmConstantValue ) ;
     std::cout << " SgAsmJvmConstantValue has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmConstantValue ( SgAsmJvmConstantValueStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmConstantValueStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmInstruction ) ;
     std::cout << " SgAsmJvmInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmInstruction ( SgAsmJvmInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmFileHeader ) ;
     std::cout << " SgAsmJvmFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmFileHeader ( SgAsmJvmFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmNode ) ;
     std::cout << " SgAsmJvmNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmNode ( SgAsmJvmNodeStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmSignature ) ;
     std::cout << " SgAsmJvmSignature has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmSignature ( SgAsmJvmSignatureStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmSignatureStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmSourceFile ) ;
     std::cout << " SgAsmJvmSourceFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmSourceFile ( SgAsmJvmSourceFileStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmSourceFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEEntryPoint ) ;
     std::cout << " SgAsmLEEntryPoint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLEEntryPointStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEEntryPoint ( SgAsmLEEntryPointStorageArray[i] ) ; 
              }
          delete [] SgAsmLEEntryPointStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEEntryTable ) ;
     std::cout << " SgAsmLEEntryTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLEEntryTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEEntryTable ( SgAsmLEEntryTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLEEntryTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEFileHeader ) ;
     std::cout << " SgAsmLEFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLEFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEFileHeader ( SgAsmLEFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmLEFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLENameTable ) ;
     std::cout << " SgAsmLENameTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLENameTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLENameTable ( SgAsmLENameTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLENameTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEPageTable ) ;
     std::cout << " SgAsmLEPageTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLEPageTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEPageTable ( SgAsmLEPageTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLEPageTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEPageTableEntry ) ;
     std::cout << " SgAsmLEPageTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEPageTableEntry ( SgAsmLEPageTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmLEPageTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLERelocTable ) ;
     std::cout << " SgAsmLERelocTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLERelocTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLERelocTable ( SgAsmLERelocTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLERelocTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLESection ) ;
     std::cout << " SgAsmLESection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLESectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLESection ( SgAsmLESectionStorageArray[i] ) ; 
              }
          delete [] SgAsmLESectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLESectionTable ) ;
     std::cout << " SgAsmLESectionTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLESectionTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLESectionTable ( SgAsmLESectionTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLESectionTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLESectionTableEntry ) ;
     std::cout << " SgAsmLESectionTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLESectionTableEntry ( SgAsmLESectionTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmLESectionTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmM68kInstruction ) ;
     std::cout << " SgAsmM68kInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmM68kInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmM68kInstruction ( SgAsmM68kInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmM68kInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmMemoryReferenceExpression ) ;
     std::cout << " SgAsmMemoryReferenceExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmMemoryReferenceExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmMemoryReferenceExpression ( SgAsmMemoryReferenceExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmMemoryReferenceExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmMipsInstruction ) ;
     std::cout << " SgAsmMipsInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmMipsInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmMipsInstruction ( SgAsmMipsInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmMipsInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEEntryPoint ) ;
     std::cout << " SgAsmNEEntryPoint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEEntryPoint ( SgAsmNEEntryPointStorageArray[i] ) ; 
              }
          delete [] SgAsmNEEntryPointStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEEntryTable ) ;
     std::cout << " SgAsmNEEntryTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNEEntryTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEEntryTable ( SgAsmNEEntryTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNEEntryTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEFileHeader ) ;
     std::cout << " SgAsmNEFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNEFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEFileHeader ( SgAsmNEFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmNEFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEModuleTable ) ;
     std::cout << " SgAsmNEModuleTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNEModuleTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEModuleTable ( SgAsmNEModuleTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNEModuleTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNENameTable ) ;
     std::cout << " SgAsmNENameTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNENameTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNENameTable ( SgAsmNENameTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNENameTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNERelocEntry ) ;
     std::cout << " SgAsmNERelocEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNERelocEntry ( SgAsmNERelocEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmNERelocEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNERelocTable ) ;
     std::cout << " SgAsmNERelocTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNERelocTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNERelocTable ( SgAsmNERelocTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNERelocTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNESection ) ;
     std::cout << " SgAsmNESection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNESectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNESection ( SgAsmNESectionStorageArray[i] ) ; 
              }
          delete [] SgAsmNESectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNESectionTable ) ;
     std::cout << " SgAsmNESectionTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNESectionTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNESectionTable ( SgAsmNESectionTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNESectionTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNESectionTableEntry ) ;
     std::cout << " SgAsmNESectionTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNESectionTableEntry ( SgAsmNESectionTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmNESectionTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEStringTable ) ;
     std::cout << " SgAsmNEStringTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNEStringTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEStringTable ( SgAsmNEStringTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNEStringTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNode ) ;
     std::cout << " SgAsmNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNode ( SgAsmNodeStorageArray[i] ) ; 
              }
          delete [] SgAsmNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmOp ) ;
     std::cout << " SgAsmOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmOp ( SgAsmOpStorageArray[i] ) ; 
              }
          delete [] SgAsmOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmOperandList ) ;
     std::cout << " SgAsmOperandList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmOperandListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmOperandList ( SgAsmOperandListStorageArray[i] ) ; 
              }
          delete [] SgAsmOperandListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEExportDirectory ) ;
     std::cout << " SgAsmPEExportDirectory has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEExportDirectory ( SgAsmPEExportDirectoryStorageArray[i] ) ; 
              }
          delete [] SgAsmPEExportDirectoryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEExportEntry ) ;
     std::cout << " SgAsmPEExportEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEExportEntry ( SgAsmPEExportEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmPEExportEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEExportEntryList ) ;
     std::cout << " SgAsmPEExportEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEExportEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEExportEntryList ( SgAsmPEExportEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmPEExportEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEExportSection ) ;
     std::cout << " SgAsmPEExportSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEExportSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEExportSection ( SgAsmPEExportSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmPEExportSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEFileHeader ) ;
     std::cout << " SgAsmPEFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEFileHeader ( SgAsmPEFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmPEFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportDirectory ) ;
     std::cout << " SgAsmPEImportDirectory has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportDirectory ( SgAsmPEImportDirectoryStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportDirectoryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportDirectoryList ) ;
     std::cout << " SgAsmPEImportDirectoryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEImportDirectoryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportDirectoryList ( SgAsmPEImportDirectoryListStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportDirectoryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportItem ) ;
     std::cout << " SgAsmPEImportItem has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportItem ( SgAsmPEImportItemStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportItemStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportItemList ) ;
     std::cout << " SgAsmPEImportItemList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEImportItemListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportItemList ( SgAsmPEImportItemListStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportItemListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportSection ) ;
     std::cout << " SgAsmPEImportSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEImportSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportSection ( SgAsmPEImportSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPERVASizePair ) ;
     std::cout << " SgAsmPERVASizePair has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPERVASizePair ( SgAsmPERVASizePairStorageArray[i] ) ; 
              }
          delete [] SgAsmPERVASizePairStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPERVASizePairList ) ;
     std::cout << " SgAsmPERVASizePairList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPERVASizePairListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPERVASizePairList ( SgAsmPERVASizePairListStorageArray[i] ) ; 
              }
          delete [] SgAsmPERVASizePairListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPESection ) ;
     std::cout << " SgAsmPESection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPESectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPESection ( SgAsmPESectionStorageArray[i] ) ; 
              }
          delete [] SgAsmPESectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPESectionTable ) ;
     std::cout << " SgAsmPESectionTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPESectionTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPESectionTable ( SgAsmPESectionTableStorageArray[i] ) ; 
              }
          delete [] SgAsmPESectionTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPESectionTableEntry ) ;
     std::cout << " SgAsmPESectionTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPESectionTableEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPESectionTableEntry ( SgAsmPESectionTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmPESectionTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEStringSection ) ;
     std::cout << " SgAsmPEStringSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEStringSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEStringSection ( SgAsmPEStringSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmPEStringSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPowerpcInstruction ) ;
     std::cout << " SgAsmPowerpcInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPowerpcInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPowerpcInstruction ( SgAsmPowerpcInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmPowerpcInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmRegisterNames ) ;
     std::cout << " SgAsmRegisterNames has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmRegisterNamesStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmRegisterNames ( SgAsmRegisterNamesStorageArray[i] ) ; 
              }
          delete [] SgAsmRegisterNamesStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmRegisterReferenceExpression ) ;
     std::cout << " SgAsmRegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmRegisterReferenceExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmRegisterReferenceExpression ( SgAsmRegisterReferenceExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmRegisterReferenceExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmRiscOperation ) ;
     std::cout << " SgAsmRiscOperation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmRiscOperationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmRiscOperation ( SgAsmRiscOperationStorageArray[i] ) ; 
              }
          delete [] SgAsmRiscOperationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmScalarType ) ;
     std::cout << " SgAsmScalarType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmScalarType ( SgAsmScalarTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmScalarTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStatement ) ;
     std::cout << " SgAsmStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStatement ( SgAsmStatementStorageArray[i] ) ; 
              }
          delete [] SgAsmStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStaticData ) ;
     std::cout << " SgAsmStaticData has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStaticDataStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStaticData ( SgAsmStaticDataStorageArray[i] ) ; 
              }
          delete [] SgAsmStaticDataStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStmt ) ;
     std::cout << " SgAsmStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStmt ( SgAsmStmtStorageArray[i] ) ; 
              }
          delete [] SgAsmStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStoredString ) ;
     std::cout << " SgAsmStoredString has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStoredString ( SgAsmStoredStringStorageArray[i] ) ; 
              }
          delete [] SgAsmStoredStringStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStringStorage ) ;
     std::cout << " SgAsmStringStorage has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStringStorageStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStringStorage ( SgAsmStringStorageStorageArray[i] ) ; 
              }
          delete [] SgAsmStringStorageStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmType ) ;
     std::cout << " SgAsmType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmType ( SgAsmTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryExpression ) ;
     std::cout << " SgAsmUnaryExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryExpression ( SgAsmUnaryExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryMinus ) ;
     std::cout << " SgAsmUnaryMinus has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryMinusStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryMinus ( SgAsmUnaryMinusStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryMinusStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryPlus ) ;
     std::cout << " SgAsmUnaryPlus has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryPlusStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryPlus ( SgAsmUnaryPlusStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryPlusStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryRrx ) ;
     std::cout << " SgAsmUnaryRrx has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryRrxStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryRrx ( SgAsmUnaryRrxStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryRrxStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnarySignedExtend ) ;
     std::cout << " SgAsmUnarySignedExtend has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnarySignedExtendStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnarySignedExtend ( SgAsmUnarySignedExtendStorageArray[i] ) ; 
              }
          delete [] SgAsmUnarySignedExtendStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryUnsignedExtend ) ;
     std::cout << " SgAsmUnaryUnsignedExtend has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryUnsignedExtendStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryUnsignedExtend ( SgAsmUnaryUnsignedExtendStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryUnsignedExtendStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryTruncate ) ;
     std::cout << " SgAsmUnaryTruncate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryTruncateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryTruncate ( SgAsmUnaryTruncateStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryTruncateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmValueExpression ) ;
     std::cout << " SgAsmValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmValueExpression ( SgAsmValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmVectorType ) ;
     std::cout << " SgAsmVectorType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmVectorType ( SgAsmVectorTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmVectorTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmX86Instruction ) ;
     std::cout << " SgAsmX86Instruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmX86InstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmX86Instruction ( SgAsmX86InstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmX86InstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryAddressSymbol ) ;
     std::cout << " SgAsmBinaryAddressSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryAddressSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryAddressSymbol ( SgAsmBinaryAddressSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryAddressSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryDataSymbol ) ;
     std::cout << " SgAsmBinaryDataSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryDataSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryDataSymbol ( SgAsmBinaryDataSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryDataSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssertStmt ) ;
     std::cout << " SgAssertStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssertStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssertStmt ( SgAssertStmtStorageArray[i] ) ; 
              }
          delete [] SgAssertStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssignInitializer ) ;
     std::cout << " SgAssignInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssignInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssignInitializer ( SgAssignInitializerStorageArray[i] ) ; 
              }
          delete [] SgAssignInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssignOp ) ;
     std::cout << " SgAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssignOp ( SgAssignOpStorageArray[i] ) ; 
              }
          delete [] SgAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssignStatement ) ;
     std::cout << " SgAssignStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssignStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssignStatement ( SgAssignStatementStorageArray[i] ) ; 
              }
          delete [] SgAssignStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssignedGotoStatement ) ;
     std::cout << " SgAssignedGotoStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssignedGotoStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssignedGotoStatement ( SgAssignedGotoStatementStorageArray[i] ) ; 
              }
          delete [] SgAssignedGotoStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssociateStatement ) ;
     std::cout << " SgAssociateStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssociateStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssociateStatement ( SgAssociateStatementStorageArray[i] ) ; 
              }
          delete [] SgAssociateStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsteriskShapeExp ) ;
     std::cout << " SgAsteriskShapeExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsteriskShapeExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsteriskShapeExp ( SgAsteriskShapeExpStorageArray[i] ) ; 
              }
          delete [] SgAsteriskShapeExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAtOp ) ;
     std::cout << " SgAtOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAtOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAtOp ( SgAtOpStorageArray[i] ) ; 
              }
          delete [] SgAtOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAttribute ) ;
     std::cout << " SgAttribute has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAttributeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAttribute ( SgAttributeStorageArray[i] ) ; 
              }
          delete [] SgAttributeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAttributeSpecificationStatement ) ;
     std::cout << " SgAttributeSpecificationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAttributeSpecificationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAttributeSpecificationStatement ( SgAttributeSpecificationStatementStorageArray[i] ) ; 
              }
          delete [] SgAttributeSpecificationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAutoType ) ;
     std::cout << " SgAutoType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAutoTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAutoType ( SgAutoTypeStorageArray[i] ) ; 
              }
          delete [] SgAutoTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAwaitExpression ) ;
     std::cout << " SgAwaitExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAwaitExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAwaitExpression ( SgAwaitExpressionStorageArray[i] ) ; 
              }
          delete [] SgAwaitExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBackspaceStatement ) ;
     std::cout << " SgBackspaceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBackspaceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBackspaceStatement ( SgBackspaceStatementStorageArray[i] ) ; 
              }
          delete [] SgBackspaceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBaseClass ) ;
     std::cout << " SgBaseClass has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBaseClass ( SgBaseClassStorageArray[i] ) ; 
              }
          delete [] SgBaseClassStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExpBaseClass ) ;
     std::cout << " SgExpBaseClass has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExpBaseClass ( SgExpBaseClassStorageArray[i] ) ; 
              }
          delete [] SgExpBaseClassStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBaseClassModifier ) ;
     std::cout << " SgBaseClassModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBaseClassModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBaseClassModifier ( SgBaseClassModifierStorageArray[i] ) ; 
              }
          delete [] SgBaseClassModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBasicBlock ) ;
     std::cout << " SgBasicBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBasicBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBasicBlock ( SgBasicBlockStorageArray[i] ) ; 
              }
          delete [] SgBasicBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBidirectionalGraph ) ;
     std::cout << " SgBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBidirectionalGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBidirectionalGraph ( SgBidirectionalGraphStorageArray[i] ) ; 
              }
          delete [] SgBidirectionalGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBinaryComposite ) ;
     std::cout << " SgBinaryComposite has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBinaryCompositeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBinaryComposite ( SgBinaryCompositeStorageArray[i] ) ; 
              }
          delete [] SgBinaryCompositeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBinaryOp ) ;
     std::cout << " SgBinaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBinaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBinaryOp ( SgBinaryOpStorageArray[i] ) ; 
              }
          delete [] SgBinaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitAndOp ) ;
     std::cout << " SgBitAndOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitAndOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitAndOp ( SgBitAndOpStorageArray[i] ) ; 
              }
          delete [] SgBitAndOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitAttribute ) ;
     std::cout << " SgBitAttribute has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitAttributeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitAttribute ( SgBitAttributeStorageArray[i] ) ; 
              }
          delete [] SgBitAttributeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitComplementOp ) ;
     std::cout << " SgBitComplementOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitComplementOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitComplementOp ( SgBitComplementOpStorageArray[i] ) ; 
              }
          delete [] SgBitComplementOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitEqvOp ) ;
     std::cout << " SgBitEqvOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitEqvOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitEqvOp ( SgBitEqvOpStorageArray[i] ) ; 
              }
          delete [] SgBitEqvOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitOrOp ) ;
     std::cout << " SgBitOrOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitOrOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitOrOp ( SgBitOrOpStorageArray[i] ) ; 
              }
          delete [] SgBitOrOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitXorOp ) ;
     std::cout << " SgBitXorOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitXorOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitXorOp ( SgBitXorOpStorageArray[i] ) ; 
              }
          delete [] SgBitXorOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBlockDataStatement ) ;
     std::cout << " SgBlockDataStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBlockDataStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBlockDataStatement ( SgBlockDataStatementStorageArray[i] ) ; 
              }
          delete [] SgBlockDataStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBoolValExp ) ;
     std::cout << " SgBoolValExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBoolValExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBoolValExp ( SgBoolValExpStorageArray[i] ) ; 
              }
          delete [] SgBoolValExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBreakStmt ) ;
     std::cout << " SgBreakStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBreakStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBreakStmt ( SgBreakStmtStorageArray[i] ) ; 
              }
          delete [] SgBreakStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBracedInitializer ) ;
     std::cout << " SgBracedInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBracedInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBracedInitializer ( SgBracedInitializerStorageArray[i] ) ; 
              }
          delete [] SgBracedInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgC_PreprocessorDirectiveStatement ) ;
     std::cout << " SgC_PreprocessorDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgC_PreprocessorDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgC_PreprocessorDirectiveStatement ( SgC_PreprocessorDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgC_PreprocessorDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCaseOptionStmt ) ;
     std::cout << " SgCaseOptionStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCaseOptionStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCaseOptionStmt ( SgCaseOptionStmtStorageArray[i] ) ; 
              }
          delete [] SgCaseOptionStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCastExp ) ;
     std::cout << " SgCastExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCastExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCastExp ( SgCastExpStorageArray[i] ) ; 
              }
          delete [] SgCastExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCatchOptionStmt ) ;
     std::cout << " SgCatchOptionStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCatchOptionStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCatchOptionStmt ( SgCatchOptionStmtStorageArray[i] ) ; 
              }
          delete [] SgCatchOptionStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCatchStatementSeq ) ;
     std::cout << " SgCatchStatementSeq has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCatchStatementSeqStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCatchStatementSeq ( SgCatchStatementSeqStorageArray[i] ) ; 
              }
          delete [] SgCatchStatementSeqStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCharVal ) ;
     std::cout << " SgCharVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCharValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCharVal ( SgCharValStorageArray[i] ) ; 
              }
          delete [] SgCharValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgChar16Val ) ;
     std::cout << " SgChar16Val has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgChar16ValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgChar16Val ( SgChar16ValStorageArray[i] ) ; 
              }
          delete [] SgChar16ValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgChar32Val ) ;
     std::cout << " SgChar32Val has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgChar32ValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgChar32Val ( SgChar32ValStorageArray[i] ) ; 
              }
          delete [] SgChar32ValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgChooseExpression ) ;
     std::cout << " SgChooseExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgChooseExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgChooseExpression ( SgChooseExpressionStorageArray[i] ) ; 
              }
          delete [] SgChooseExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassDecl_attr ) ;
     std::cout << " SgClassDecl_attr has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassDecl_attrStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassDecl_attr ( SgClassDecl_attrStorageArray[i] ) ; 
              }
          delete [] SgClassDecl_attrStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassDeclaration ) ;
     std::cout << " SgClassDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassDeclaration ( SgClassDeclarationStorageArray[i] ) ; 
              }
          delete [] SgClassDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassDefinition ) ;
     std::cout << " SgClassDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassDefinition ( SgClassDefinitionStorageArray[i] ) ; 
              }
          delete [] SgClassDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassNameRefExp ) ;
     std::cout << " SgClassNameRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassNameRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassNameRefExp ( SgClassNameRefExpStorageArray[i] ) ; 
              }
          delete [] SgClassNameRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassSymbol ) ;
     std::cout << " SgClassSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassSymbol ( SgClassSymbolStorageArray[i] ) ; 
              }
          delete [] SgClassSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassType ) ;
     std::cout << " SgClassType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassType ( SgClassTypeStorageArray[i] ) ; 
              }
          delete [] SgClassTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClinkageDeclarationStatement ) ;
     std::cout << " SgClinkageDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClinkageDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClinkageDeclarationStatement ( SgClinkageDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgClinkageDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClinkageEndStatement ) ;
     std::cout << " SgClinkageEndStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClinkageEndStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClinkageEndStatement ( SgClinkageEndStatementStorageArray[i] ) ; 
              }
          delete [] SgClinkageEndStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClinkageStartStatement ) ;
     std::cout << " SgClinkageStartStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClinkageStartStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClinkageStartStatement ( SgClinkageStartStatementStorageArray[i] ) ; 
              }
          delete [] SgClinkageStartStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCloseStatement ) ;
     std::cout << " SgCloseStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCloseStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCloseStatement ( SgCloseStatementStorageArray[i] ) ; 
              }
          delete [] SgCloseStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgColonShapeExp ) ;
     std::cout << " SgColonShapeExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgColonShapeExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgColonShapeExp ( SgColonShapeExpStorageArray[i] ) ; 
              }
          delete [] SgColonShapeExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCommaOpExp ) ;
     std::cout << " SgCommaOpExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCommaOpExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCommaOpExp ( SgCommaOpExpStorageArray[i] ) ; 
              }
          delete [] SgCommaOpExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCommonBlock ) ;
     std::cout << " SgCommonBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCommonBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCommonBlock ( SgCommonBlockStorageArray[i] ) ; 
              }
          delete [] SgCommonBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCommonBlockObject ) ;
     std::cout << " SgCommonBlockObject has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCommonBlockObjectStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCommonBlockObject ( SgCommonBlockObjectStorageArray[i] ) ; 
              }
          delete [] SgCommonBlockObjectStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCommonSymbol ) ;
     std::cout << " SgCommonSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCommonSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCommonSymbol ( SgCommonSymbolStorageArray[i] ) ; 
              }
          delete [] SgCommonSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgComplexVal ) ;
     std::cout << " SgComplexVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgComplexValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgComplexVal ( SgComplexValStorageArray[i] ) ; 
              }
          delete [] SgComplexValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgComprehension ) ;
     std::cout << " SgComprehension has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgComprehensionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgComprehension ( SgComprehensionStorageArray[i] ) ; 
              }
          delete [] SgComprehensionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCompoundAssignOp ) ;
     std::cout << " SgCompoundAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCompoundAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCompoundAssignOp ( SgCompoundAssignOpStorageArray[i] ) ; 
              }
          delete [] SgCompoundAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCompoundInitializer ) ;
     std::cout << " SgCompoundInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCompoundInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCompoundInitializer ( SgCompoundInitializerStorageArray[i] ) ; 
              }
          delete [] SgCompoundInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCompoundLiteralExp ) ;
     std::cout << " SgCompoundLiteralExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCompoundLiteralExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCompoundLiteralExp ( SgCompoundLiteralExpStorageArray[i] ) ; 
              }
          delete [] SgCompoundLiteralExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgComputedGotoStatement ) ;
     std::cout << " SgComputedGotoStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgComputedGotoStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgComputedGotoStatement ( SgComputedGotoStatementStorageArray[i] ) ; 
              }
          delete [] SgComputedGotoStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConcatenationOp ) ;
     std::cout << " SgConcatenationOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgConcatenationOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConcatenationOp ( SgConcatenationOpStorageArray[i] ) ; 
              }
          delete [] SgConcatenationOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConditionalExp ) ;
     std::cout << " SgConditionalExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgConditionalExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConditionalExp ( SgConditionalExpStorageArray[i] ) ; 
              }
          delete [] SgConditionalExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConjugateOp ) ;
     std::cout << " SgConjugateOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgConjugateOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConjugateOp ( SgConjugateOpStorageArray[i] ) ; 
              }
          delete [] SgConjugateOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConstVolatileModifier ) ;
     std::cout << " SgConstVolatileModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConstVolatileModifier ( SgConstVolatileModifierStorageArray[i] ) ; 
              }
          delete [] SgConstVolatileModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConstructorInitializer ) ;
     std::cout << " SgConstructorInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgConstructorInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConstructorInitializer ( SgConstructorInitializerStorageArray[i] ) ; 
              }
          delete [] SgConstructorInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgContainsStatement ) ;
     std::cout << " SgContainsStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgContainsStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgContainsStatement ( SgContainsStatementStorageArray[i] ) ; 
              }
          delete [] SgContainsStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgContinueStmt ) ;
     std::cout << " SgContinueStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgContinueStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgContinueStmt ( SgContinueStmtStorageArray[i] ) ; 
              }
          delete [] SgContinueStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCtorInitializerList ) ;
     std::cout << " SgCtorInitializerList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCtorInitializerListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCtorInitializerList ( SgCtorInitializerListStorageArray[i] ) ; 
              }
          delete [] SgCtorInitializerListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDataStatementGroup ) ;
     std::cout << " SgDataStatementGroup has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDataStatementGroupStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDataStatementGroup ( SgDataStatementGroupStorageArray[i] ) ; 
              }
          delete [] SgDataStatementGroupStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDataStatementObject ) ;
     std::cout << " SgDataStatementObject has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDataStatementObject ( SgDataStatementObjectStorageArray[i] ) ; 
              }
          delete [] SgDataStatementObjectStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDataStatementValue ) ;
     std::cout << " SgDataStatementValue has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDataStatementValue ( SgDataStatementValueStorageArray[i] ) ; 
              }
          delete [] SgDataStatementValueStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeadIfDirectiveStatement ) ;
     std::cout << " SgDeadIfDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeadIfDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeadIfDirectiveStatement ( SgDeadIfDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgDeadIfDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeallocateStatement ) ;
     std::cout << " SgDeallocateStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeallocateStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeallocateStatement ( SgDeallocateStatementStorageArray[i] ) ; 
              }
          delete [] SgDeallocateStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeclarationModifier ) ;
     std::cout << " SgDeclarationModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeclarationModifier ( SgDeclarationModifierStorageArray[i] ) ; 
              }
          delete [] SgDeclarationModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeclarationScope ) ;
     std::cout << " SgDeclarationScope has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeclarationScopeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeclarationScope ( SgDeclarationScopeStorageArray[i] ) ; 
              }
          delete [] SgDeclarationScopeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeclarationStatement ) ;
     std::cout << " SgDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeclarationStatement ( SgDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeclType ) ;
     std::cout << " SgDeclType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeclTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeclType ( SgDeclTypeStorageArray[i] ) ; 
              }
          delete [] SgDeclTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDefaultOptionStmt ) ;
     std::cout << " SgDefaultOptionStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDefaultOptionStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDefaultOptionStmt ( SgDefaultOptionStmtStorageArray[i] ) ; 
              }
          delete [] SgDefaultOptionStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDefaultSymbol ) ;
     std::cout << " SgDefaultSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDefaultSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDefaultSymbol ( SgDefaultSymbolStorageArray[i] ) ; 
              }
          delete [] SgDefaultSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDefineDirectiveStatement ) ;
     std::cout << " SgDefineDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDefineDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDefineDirectiveStatement ( SgDefineDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgDefineDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeleteExp ) ;
     std::cout << " SgDeleteExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeleteExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeleteExp ( SgDeleteExpStorageArray[i] ) ; 
              }
          delete [] SgDeleteExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDerivedTypeStatement ) ;
     std::cout << " SgDerivedTypeStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDerivedTypeStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDerivedTypeStatement ( SgDerivedTypeStatementStorageArray[i] ) ; 
              }
          delete [] SgDerivedTypeStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDesignatedInitializer ) ;
     std::cout << " SgDesignatedInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDesignatedInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDesignatedInitializer ( SgDesignatedInitializerStorageArray[i] ) ; 
              }
          delete [] SgDesignatedInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDictionaryComprehension ) ;
     std::cout << " SgDictionaryComprehension has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDictionaryComprehensionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDictionaryComprehension ( SgDictionaryComprehensionStorageArray[i] ) ; 
              }
          delete [] SgDictionaryComprehensionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDictionaryExp ) ;
     std::cout << " SgDictionaryExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDictionaryExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDictionaryExp ( SgDictionaryExpStorageArray[i] ) ; 
              }
          delete [] SgDictionaryExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDimensionObject ) ;
     std::cout << " SgDimensionObject has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDimensionObject ( SgDimensionObjectStorageArray[i] ) ; 
              }
          delete [] SgDimensionObjectStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDirectedGraphEdge ) ;
     std::cout << " SgDirectedGraphEdge has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDirectedGraphEdgeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDirectedGraphEdge ( SgDirectedGraphEdgeStorageArray[i] ) ; 
              }
          delete [] SgDirectedGraphEdgeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDirectory ) ;
     std::cout << " SgDirectory has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDirectoryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDirectory ( SgDirectoryStorageArray[i] ) ; 
              }
          delete [] SgDirectoryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDirectoryList ) ;
     std::cout << " SgDirectoryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDirectoryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDirectoryList ( SgDirectoryListStorageArray[i] ) ; 
              }
          delete [] SgDirectoryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDivAssignOp ) ;
     std::cout << " SgDivAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDivAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDivAssignOp ( SgDivAssignOpStorageArray[i] ) ; 
              }
          delete [] SgDivAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDivideOp ) ;
     std::cout << " SgDivideOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDivideOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDivideOp ( SgDivideOpStorageArray[i] ) ; 
              }
          delete [] SgDivideOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDoWhileStmt ) ;
     std::cout << " SgDoWhileStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDoWhileStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDoWhileStmt ( SgDoWhileStmtStorageArray[i] ) ; 
              }
          delete [] SgDoWhileStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDotExp ) ;
     std::cout << " SgDotExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDotExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDotExp ( SgDotExpStorageArray[i] ) ; 
              }
          delete [] SgDotExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDotStarOp ) ;
     std::cout << " SgDotStarOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDotStarOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDotStarOp ( SgDotStarOpStorageArray[i] ) ; 
              }
          delete [] SgDotStarOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDoubleVal ) ;
     std::cout << " SgDoubleVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDoubleValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDoubleVal ( SgDoubleValStorageArray[i] ) ; 
              }
          delete [] SgDoubleValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElaboratedTypeModifier ) ;
     std::cout << " SgElaboratedTypeModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElaboratedTypeModifier ( SgElaboratedTypeModifierStorageArray[i] ) ; 
              }
          delete [] SgElaboratedTypeModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElementwiseOp ) ;
     std::cout << " SgElementwiseOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElementwiseOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElementwiseOp ( SgElementwiseOpStorageArray[i] ) ; 
              }
          delete [] SgElementwiseOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElementwiseAddOp ) ;
     std::cout << " SgElementwiseAddOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElementwiseAddOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElementwiseAddOp ( SgElementwiseAddOpStorageArray[i] ) ; 
              }
          delete [] SgElementwiseAddOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElementwiseDivideOp ) ;
     std::cout << " SgElementwiseDivideOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElementwiseDivideOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElementwiseDivideOp ( SgElementwiseDivideOpStorageArray[i] ) ; 
              }
          delete [] SgElementwiseDivideOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElementwiseLeftDivideOp ) ;
     std::cout << " SgElementwiseLeftDivideOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElementwiseLeftDivideOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElementwiseLeftDivideOp ( SgElementwiseLeftDivideOpStorageArray[i] ) ; 
              }
          delete [] SgElementwiseLeftDivideOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElementwiseMultiplyOp ) ;
     std::cout << " SgElementwiseMultiplyOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElementwiseMultiplyOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElementwiseMultiplyOp ( SgElementwiseMultiplyOpStorageArray[i] ) ; 
              }
          delete [] SgElementwiseMultiplyOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElementwisePowerOp ) ;
     std::cout << " SgElementwisePowerOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElementwisePowerOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElementwisePowerOp ( SgElementwisePowerOpStorageArray[i] ) ; 
              }
          delete [] SgElementwisePowerOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElementwiseSubtractOp ) ;
     std::cout << " SgElementwiseSubtractOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElementwiseSubtractOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElementwiseSubtractOp ( SgElementwiseSubtractOpStorageArray[i] ) ; 
              }
          delete [] SgElementwiseSubtractOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElseDirectiveStatement ) ;
     std::cout << " SgElseDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElseDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElseDirectiveStatement ( SgElseDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgElseDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElseWhereStatement ) ;
     std::cout << " SgElseWhereStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElseWhereStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElseWhereStatement ( SgElseWhereStatementStorageArray[i] ) ; 
              }
          delete [] SgElseWhereStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElseifDirectiveStatement ) ;
     std::cout << " SgElseifDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElseifDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElseifDirectiveStatement ( SgElseifDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgElseifDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEmptyDeclaration ) ;
     std::cout << " SgEmptyDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEmptyDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEmptyDeclaration ( SgEmptyDeclarationStorageArray[i] ) ; 
              }
          delete [] SgEmptyDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEmptyDirectiveStatement ) ;
     std::cout << " SgEmptyDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEmptyDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEmptyDirectiveStatement ( SgEmptyDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgEmptyDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEndfileStatement ) ;
     std::cout << " SgEndfileStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEndfileStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEndfileStatement ( SgEndfileStatementStorageArray[i] ) ; 
              }
          delete [] SgEndfileStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEndifDirectiveStatement ) ;
     std::cout << " SgEndifDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEndifDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEndifDirectiveStatement ( SgEndifDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgEndifDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEntryStatement ) ;
     std::cout << " SgEntryStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEntryStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEntryStatement ( SgEntryStatementStorageArray[i] ) ; 
              }
          delete [] SgEntryStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumDeclaration ) ;
     std::cout << " SgEnumDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumDeclaration ( SgEnumDeclarationStorageArray[i] ) ; 
              }
          delete [] SgEnumDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumFieldSymbol ) ;
     std::cout << " SgEnumFieldSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumFieldSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumFieldSymbol ( SgEnumFieldSymbolStorageArray[i] ) ; 
              }
          delete [] SgEnumFieldSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumSymbol ) ;
     std::cout << " SgEnumSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumSymbol ( SgEnumSymbolStorageArray[i] ) ; 
              }
          delete [] SgEnumSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumType ) ;
     std::cout << " SgEnumType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumType ( SgEnumTypeStorageArray[i] ) ; 
              }
          delete [] SgEnumTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumVal ) ;
     std::cout << " SgEnumVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumVal ( SgEnumValStorageArray[i] ) ; 
              }
          delete [] SgEnumValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEqualityOp ) ;
     std::cout << " SgEqualityOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEqualityOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEqualityOp ( SgEqualityOpStorageArray[i] ) ; 
              }
          delete [] SgEqualityOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEquivalenceStatement ) ;
     std::cout << " SgEquivalenceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEquivalenceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEquivalenceStatement ( SgEquivalenceStatementStorageArray[i] ) ; 
              }
          delete [] SgEquivalenceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgErrorDirectiveStatement ) ;
     std::cout << " SgErrorDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgErrorDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgErrorDirectiveStatement ( SgErrorDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgErrorDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExecStatement ) ;
     std::cout << " SgExecStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExecStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExecStatement ( SgExecStatementStorageArray[i] ) ; 
              }
          delete [] SgExecStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExponentiationOp ) ;
     std::cout << " SgExponentiationOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExponentiationOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExponentiationOp ( SgExponentiationOpStorageArray[i] ) ; 
              }
          delete [] SgExponentiationOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExponentiationAssignOp ) ;
     std::cout << " SgExponentiationAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExponentiationAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExponentiationAssignOp ( SgExponentiationAssignOpStorageArray[i] ) ; 
              }
          delete [] SgExponentiationAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExprListExp ) ;
     std::cout << " SgExprListExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExprListExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExprListExp ( SgExprListExpStorageArray[i] ) ; 
              }
          delete [] SgExprListExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExprStatement ) ;
     std::cout << " SgExprStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExprStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExprStatement ( SgExprStatementStorageArray[i] ) ; 
              }
          delete [] SgExprStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExpression ) ;
     std::cout << " SgExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExpression ( SgExpressionStorageArray[i] ) ; 
              }
          delete [] SgExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExpressionRoot ) ;
     std::cout << " SgExpressionRoot has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExpressionRootStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExpressionRoot ( SgExpressionRootStorageArray[i] ) ; 
              }
          delete [] SgExpressionRootStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFile ) ;
     std::cout << " SgFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFileStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFile ( SgFileStorageArray[i] ) ; 
              }
          delete [] SgFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFileList ) ;
     std::cout << " SgFileList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFileListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFileList ( SgFileListStorageArray[i] ) ; 
              }
          delete [] SgFileListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFloatVal ) ;
     std::cout << " SgFloatVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFloatValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFloatVal ( SgFloatValStorageArray[i] ) ; 
              }
          delete [] SgFloatValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFloat128Val ) ;
     std::cout << " SgFloat128Val has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFloat128ValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFloat128Val ( SgFloat128ValStorageArray[i] ) ; 
              }
          delete [] SgFloat128ValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFloat80Val ) ;
     std::cout << " SgFloat80Val has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFloat80ValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFloat80Val ( SgFloat80ValStorageArray[i] ) ; 
              }
          delete [] SgFloat80ValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFoldExpression ) ;
     std::cout << " SgFoldExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFoldExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFoldExpression ( SgFoldExpressionStorageArray[i] ) ; 
              }
          delete [] SgFoldExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFlushStatement ) ;
     std::cout << " SgFlushStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFlushStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFlushStatement ( SgFlushStatementStorageArray[i] ) ; 
              }
          delete [] SgFlushStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgForAllStatement ) ;
     std::cout << " SgForAllStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgForAllStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgForAllStatement ( SgForAllStatementStorageArray[i] ) ; 
              }
          delete [] SgForAllStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgForInitStatement ) ;
     std::cout << " SgForInitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgForInitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgForInitStatement ( SgForInitStatementStorageArray[i] ) ; 
              }
          delete [] SgForInitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgForStatement ) ;
     std::cout << " SgForStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgForStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgForStatement ( SgForStatementStorageArray[i] ) ; 
              }
          delete [] SgForStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFormatItem ) ;
     std::cout << " SgFormatItem has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFormatItem ( SgFormatItemStorageArray[i] ) ; 
              }
          delete [] SgFormatItemStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFormatItemList ) ;
     std::cout << " SgFormatItemList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFormatItemListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFormatItemList ( SgFormatItemListStorageArray[i] ) ; 
              }
          delete [] SgFormatItemListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFormatStatement ) ;
     std::cout << " SgFormatStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFormatStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFormatStatement ( SgFormatStatementStorageArray[i] ) ; 
              }
          delete [] SgFormatStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFortranDo ) ;
     std::cout << " SgFortranDo has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFortranDoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFortranDo ( SgFortranDoStorageArray[i] ) ; 
              }
          delete [] SgFortranDoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFortranIncludeLine ) ;
     std::cout << " SgFortranIncludeLine has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFortranIncludeLineStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFortranIncludeLine ( SgFortranIncludeLineStorageArray[i] ) ; 
              }
          delete [] SgFortranIncludeLineStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFortranNonblockedDo ) ;
     std::cout << " SgFortranNonblockedDo has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFortranNonblockedDoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFortranNonblockedDo ( SgFortranNonblockedDoStorageArray[i] ) ; 
              }
          delete [] SgFortranNonblockedDoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFuncDecl_attr ) ;
     std::cout << " SgFuncDecl_attr has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFuncDecl_attrStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFuncDecl_attr ( SgFuncDecl_attrStorageArray[i] ) ; 
              }
          delete [] SgFuncDecl_attrStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionCallExp ) ;
     std::cout << " SgFunctionCallExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionCallExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionCallExp ( SgFunctionCallExpStorageArray[i] ) ; 
              }
          delete [] SgFunctionCallExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionDeclaration ) ;
     std::cout << " SgFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionDeclaration ( SgFunctionDeclarationStorageArray[i] ) ; 
              }
          delete [] SgFunctionDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionDefinition ) ;
     std::cout << " SgFunctionDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionDefinition ( SgFunctionDefinitionStorageArray[i] ) ; 
              }
          delete [] SgFunctionDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionParameterScope ) ;
     std::cout << " SgFunctionParameterScope has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionParameterScopeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionParameterScope ( SgFunctionParameterScopeStorageArray[i] ) ; 
              }
          delete [] SgFunctionParameterScopeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionModifier ) ;
     std::cout << " SgFunctionModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionModifier ( SgFunctionModifierStorageArray[i] ) ; 
              }
          delete [] SgFunctionModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionParameterList ) ;
     std::cout << " SgFunctionParameterList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionParameterListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionParameterList ( SgFunctionParameterListStorageArray[i] ) ; 
              }
          delete [] SgFunctionParameterListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionParameterRefExp ) ;
     std::cout << " SgFunctionParameterRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionParameterRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionParameterRefExp ( SgFunctionParameterRefExpStorageArray[i] ) ; 
              }
          delete [] SgFunctionParameterRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionParameterTypeList ) ;
     std::cout << " SgFunctionParameterTypeList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionParameterTypeListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionParameterTypeList ( SgFunctionParameterTypeListStorageArray[i] ) ; 
              }
          delete [] SgFunctionParameterTypeListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionRefExp ) ;
     std::cout << " SgFunctionRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionRefExp ( SgFunctionRefExpStorageArray[i] ) ; 
              }
          delete [] SgFunctionRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionSymbol ) ;
     std::cout << " SgFunctionSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionSymbol ( SgFunctionSymbolStorageArray[i] ) ; 
              }
          delete [] SgFunctionSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionType ) ;
     std::cout << " SgFunctionType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionType ( SgFunctionTypeStorageArray[i] ) ; 
              }
          delete [] SgFunctionTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionTypeSymbol ) ;
     std::cout << " SgFunctionTypeSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionTypeSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionTypeSymbol ( SgFunctionTypeSymbolStorageArray[i] ) ; 
              }
          delete [] SgFunctionTypeSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionTypeTable ) ;
     std::cout << " SgFunctionTypeTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionTypeTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionTypeTable ( SgFunctionTypeTableStorageArray[i] ) ; 
              }
          delete [] SgFunctionTypeTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeTable ) ;
     std::cout << " SgTypeTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeTable ( SgTypeTableStorageArray[i] ) ; 
              }
          delete [] SgTypeTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGlobal ) ;
     std::cout << " SgGlobal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGlobalStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGlobal ( SgGlobalStorageArray[i] ) ; 
              }
          delete [] SgGlobalStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGotoStatement ) ;
     std::cout << " SgGotoStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGotoStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGotoStatement ( SgGotoStatementStorageArray[i] ) ; 
              }
          delete [] SgGotoStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraph ) ;
     std::cout << " SgGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraph ( SgGraphStorageArray[i] ) ; 
              }
          delete [] SgGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraphEdge ) ;
     std::cout << " SgGraphEdge has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGraphEdgeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraphEdge ( SgGraphEdgeStorageArray[i] ) ; 
              }
          delete [] SgGraphEdgeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraphEdgeList ) ;
     std::cout << " SgGraphEdgeList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraphEdgeList ( SgGraphEdgeListStorageArray[i] ) ; 
              }
          delete [] SgGraphEdgeListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraphNode ) ;
     std::cout << " SgGraphNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGraphNodeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraphNode ( SgGraphNodeStorageArray[i] ) ; 
              }
          delete [] SgGraphNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraphNodeList ) ;
     std::cout << " SgGraphNodeList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraphNodeList ( SgGraphNodeListStorageArray[i] ) ; 
              }
          delete [] SgGraphNodeListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGreaterOrEqualOp ) ;
     std::cout << " SgGreaterOrEqualOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGreaterOrEqualOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGreaterOrEqualOp ( SgGreaterOrEqualOpStorageArray[i] ) ; 
              }
          delete [] SgGreaterOrEqualOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGreaterThanOp ) ;
     std::cout << " SgGreaterThanOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGreaterThanOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGreaterThanOp ( SgGreaterThanOpStorageArray[i] ) ; 
              }
          delete [] SgGreaterThanOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIOItemExpression ) ;
     std::cout << " SgIOItemExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIOItemExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIOItemExpression ( SgIOItemExpressionStorageArray[i] ) ; 
              }
          delete [] SgIOItemExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIOStatement ) ;
     std::cout << " SgIOStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIOStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIOStatement ( SgIOStatementStorageArray[i] ) ; 
              }
          delete [] SgIOStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIdentDirectiveStatement ) ;
     std::cout << " SgIdentDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIdentDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIdentDirectiveStatement ( SgIdentDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIdentDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIfDirectiveStatement ) ;
     std::cout << " SgIfDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIfDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIfDirectiveStatement ( SgIfDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIfDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIfStmt ) ;
     std::cout << " SgIfStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIfStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIfStmt ( SgIfStmtStorageArray[i] ) ; 
              }
          delete [] SgIfStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIfdefDirectiveStatement ) ;
     std::cout << " SgIfdefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIfdefDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIfdefDirectiveStatement ( SgIfdefDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIfdefDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIfndefDirectiveStatement ) ;
     std::cout << " SgIfndefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIfndefDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIfndefDirectiveStatement ( SgIfndefDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIfndefDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgImageControlStatement ) ;
     std::cout << " SgImageControlStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgImageControlStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgImageControlStatement ( SgImageControlStatementStorageArray[i] ) ; 
              }
          delete [] SgImageControlStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgImagPartOp ) ;
     std::cout << " SgImagPartOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgImagPartOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgImagPartOp ( SgImagPartOpStorageArray[i] ) ; 
              }
          delete [] SgImagPartOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgImplicitStatement ) ;
     std::cout << " SgImplicitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgImplicitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgImplicitStatement ( SgImplicitStatementStorageArray[i] ) ; 
              }
          delete [] SgImplicitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgImpliedDo ) ;
     std::cout << " SgImpliedDo has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgImpliedDoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgImpliedDo ( SgImpliedDoStorageArray[i] ) ; 
              }
          delete [] SgImpliedDoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgImportStatement ) ;
     std::cout << " SgImportStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgImportStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgImportStatement ( SgImportStatementStorageArray[i] ) ; 
              }
          delete [] SgImportStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIncidenceDirectedGraph ) ;
     std::cout << " SgIncidenceDirectedGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIncidenceDirectedGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIncidenceDirectedGraph ( SgIncidenceDirectedGraphStorageArray[i] ) ; 
              }
          delete [] SgIncidenceDirectedGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIncidenceUndirectedGraph ) ;
     std::cout << " SgIncidenceUndirectedGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIncidenceUndirectedGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIncidenceUndirectedGraph ( SgIncidenceUndirectedGraphStorageArray[i] ) ; 
              }
          delete [] SgIncidenceUndirectedGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIncludeDirectiveStatement ) ;
     std::cout << " SgIncludeDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIncludeDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIncludeDirectiveStatement ( SgIncludeDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIncludeDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIncludeFile ) ;
     std::cout << " SgIncludeFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIncludeFileStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIncludeFile ( SgIncludeFileStorageArray[i] ) ; 
              }
          delete [] SgIncludeFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIncludeNextDirectiveStatement ) ;
     std::cout << " SgIncludeNextDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIncludeNextDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIncludeNextDirectiveStatement ( SgIncludeNextDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIncludeNextDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInitializedName ) ;
     std::cout << " SgInitializedName has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInitializedNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInitializedName ( SgInitializedNameStorageArray[i] ) ; 
              }
          delete [] SgInitializedNameStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInitializer ) ;
     std::cout << " SgInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInitializer ( SgInitializerStorageArray[i] ) ; 
              }
          delete [] SgInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInquireStatement ) ;
     std::cout << " SgInquireStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInquireStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInquireStatement ( SgInquireStatementStorageArray[i] ) ; 
              }
          delete [] SgInquireStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntKeyedBidirectionalGraph ) ;
     std::cout << " SgIntKeyedBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntKeyedBidirectionalGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntKeyedBidirectionalGraph ( SgIntKeyedBidirectionalGraphStorageArray[i] ) ; 
              }
          delete [] SgIntKeyedBidirectionalGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntVal ) ;
     std::cout << " SgIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntVal ( SgIntValStorageArray[i] ) ; 
              }
          delete [] SgIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntegerDivideOp ) ;
     std::cout << " SgIntegerDivideOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntegerDivideOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntegerDivideOp ( SgIntegerDivideOpStorageArray[i] ) ; 
              }
          delete [] SgIntegerDivideOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntegerDivideAssignOp ) ;
     std::cout << " SgIntegerDivideAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntegerDivideAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntegerDivideAssignOp ( SgIntegerDivideAssignOpStorageArray[i] ) ; 
              }
          delete [] SgIntegerDivideAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInterfaceBody ) ;
     std::cout << " SgInterfaceBody has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInterfaceBodyStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInterfaceBody ( SgInterfaceBodyStorageArray[i] ) ; 
              }
          delete [] SgInterfaceBodyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgHeaderFileBody ) ;
     std::cout << " SgHeaderFileBody has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgHeaderFileBodyStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgHeaderFileBody ( SgHeaderFileBodyStorageArray[i] ) ; 
              }
          delete [] SgHeaderFileBodyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgHeaderFileReport ) ;
     std::cout << " SgHeaderFileReport has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgHeaderFileReportStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgHeaderFileReport ( SgHeaderFileReportStorageArray[i] ) ; 
              }
          delete [] SgHeaderFileReportStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInterfaceStatement ) ;
     std::cout << " SgInterfaceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInterfaceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInterfaceStatement ( SgInterfaceStatementStorageArray[i] ) ; 
              }
          delete [] SgInterfaceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInterfaceSymbol ) ;
     std::cout << " SgInterfaceSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInterfaceSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInterfaceSymbol ( SgInterfaceSymbolStorageArray[i] ) ; 
              }
          delete [] SgInterfaceSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntrinsicSymbol ) ;
     std::cout << " SgIntrinsicSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntrinsicSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntrinsicSymbol ( SgIntrinsicSymbolStorageArray[i] ) ; 
              }
          delete [] SgIntrinsicSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIsOp ) ;
     std::cout << " SgIsOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIsOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIsOp ( SgIsOpStorageArray[i] ) ; 
              }
          delete [] SgIsOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIsNotOp ) ;
     std::cout << " SgIsNotOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIsNotOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIsNotOp ( SgIsNotOpStorageArray[i] ) ; 
              }
          delete [] SgIsNotOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIorAssignOp ) ;
     std::cout << " SgIorAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIorAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIorAssignOp ( SgIorAssignOpStorageArray[i] ) ; 
              }
          delete [] SgIorAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialBitType ) ;
     std::cout << " SgJovialBitType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialBitTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialBitType ( SgJovialBitTypeStorageArray[i] ) ; 
              }
          delete [] SgJovialBitTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialBitVal ) ;
     std::cout << " SgJovialBitVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialBitValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialBitVal ( SgJovialBitValStorageArray[i] ) ; 
              }
          delete [] SgJovialBitValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialTableType ) ;
     std::cout << " SgJovialTableType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialTableTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialTableType ( SgJovialTableTypeStorageArray[i] ) ; 
              }
          delete [] SgJovialTableTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialCompoolStatement ) ;
     std::cout << " SgJovialCompoolStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialCompoolStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialCompoolStatement ( SgJovialCompoolStatementStorageArray[i] ) ; 
              }
          delete [] SgJovialCompoolStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialForThenStatement ) ;
     std::cout << " SgJovialForThenStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialForThenStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialForThenStatement ( SgJovialForThenStatementStorageArray[i] ) ; 
              }
          delete [] SgJovialForThenStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialDefineDeclaration ) ;
     std::cout << " SgJovialDefineDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialDefineDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialDefineDeclaration ( SgJovialDefineDeclarationStorageArray[i] ) ; 
              }
          delete [] SgJovialDefineDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialDirectiveStatement ) ;
     std::cout << " SgJovialDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialDirectiveStatement ( SgJovialDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgJovialDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialOverlayDeclaration ) ;
     std::cout << " SgJovialOverlayDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialOverlayDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialOverlayDeclaration ( SgJovialOverlayDeclarationStorageArray[i] ) ; 
              }
          delete [] SgJovialOverlayDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialPresetPositionExp ) ;
     std::cout << " SgJovialPresetPositionExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialPresetPositionExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialPresetPositionExp ( SgJovialPresetPositionExpStorageArray[i] ) ; 
              }
          delete [] SgJovialPresetPositionExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialTablePresetExp ) ;
     std::cout << " SgJovialTablePresetExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialTablePresetExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialTablePresetExp ( SgJovialTablePresetExpStorageArray[i] ) ; 
              }
          delete [] SgJovialTablePresetExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialTableStatement ) ;
     std::cout << " SgJovialTableStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialTableStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialTableStatement ( SgJovialTableStatementStorageArray[i] ) ; 
              }
          delete [] SgJovialTableStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgKeyDatumPair ) ;
     std::cout << " SgKeyDatumPair has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgKeyDatumPairStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgKeyDatumPair ( SgKeyDatumPairStorageArray[i] ) ; 
              }
          delete [] SgKeyDatumPairStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCudaKernelExecConfig ) ;
     std::cout << " SgCudaKernelExecConfig has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCudaKernelExecConfigStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCudaKernelExecConfig ( SgCudaKernelExecConfigStorageArray[i] ) ; 
              }
          delete [] SgCudaKernelExecConfigStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCudaKernelCallExp ) ;
     std::cout << " SgCudaKernelCallExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCudaKernelCallExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCudaKernelCallExp ( SgCudaKernelCallExpStorageArray[i] ) ; 
              }
          delete [] SgCudaKernelCallExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLabelRefExp ) ;
     std::cout << " SgLabelRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLabelRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLabelRefExp ( SgLabelRefExpStorageArray[i] ) ; 
              }
          delete [] SgLabelRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLabelStatement ) ;
     std::cout << " SgLabelStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLabelStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLabelStatement ( SgLabelStatementStorageArray[i] ) ; 
              }
          delete [] SgLabelStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaLabelStatement ) ;
     std::cout << " SgJavaLabelStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaLabelStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaLabelStatement ( SgJavaLabelStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaLabelStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLabelSymbol ) ;
     std::cout << " SgLabelSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLabelSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLabelSymbol ( SgLabelSymbolStorageArray[i] ) ; 
              }
          delete [] SgLabelSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaLabelSymbol ) ;
     std::cout << " SgJavaLabelSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaLabelSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaLabelSymbol ( SgJavaLabelSymbolStorageArray[i] ) ; 
              }
          delete [] SgJavaLabelSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLambdaCapture ) ;
     std::cout << " SgLambdaCapture has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLambdaCaptureStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLambdaCapture ( SgLambdaCaptureStorageArray[i] ) ; 
              }
          delete [] SgLambdaCaptureStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLambdaCaptureList ) ;
     std::cout << " SgLambdaCaptureList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLambdaCaptureListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLambdaCaptureList ( SgLambdaCaptureListStorageArray[i] ) ; 
              }
          delete [] SgLambdaCaptureListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLambdaExp ) ;
     std::cout << " SgLambdaExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLambdaExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLambdaExp ( SgLambdaExpStorageArray[i] ) ; 
              }
          delete [] SgLambdaExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLambdaRefExp ) ;
     std::cout << " SgLambdaRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLambdaRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLambdaRefExp ( SgLambdaRefExpStorageArray[i] ) ; 
              }
          delete [] SgLambdaRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLeftDivideOp ) ;
     std::cout << " SgLeftDivideOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLeftDivideOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLeftDivideOp ( SgLeftDivideOpStorageArray[i] ) ; 
              }
          delete [] SgLeftDivideOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLessOrEqualOp ) ;
     std::cout << " SgLessOrEqualOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLessOrEqualOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLessOrEqualOp ( SgLessOrEqualOpStorageArray[i] ) ; 
              }
          delete [] SgLessOrEqualOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLessThanOp ) ;
     std::cout << " SgLessThanOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLessThanOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLessThanOp ( SgLessThanOpStorageArray[i] ) ; 
              }
          delete [] SgLessThanOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLineDirectiveStatement ) ;
     std::cout << " SgLineDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLineDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLineDirectiveStatement ( SgLineDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgLineDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLinemarkerDirectiveStatement ) ;
     std::cout << " SgLinemarkerDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLinemarkerDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLinemarkerDirectiveStatement ( SgLinemarkerDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgLinemarkerDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLinkageModifier ) ;
     std::cout << " SgLinkageModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLinkageModifier ( SgLinkageModifierStorageArray[i] ) ; 
              }
          delete [] SgLinkageModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgListComprehension ) ;
     std::cout << " SgListComprehension has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgListComprehensionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgListComprehension ( SgListComprehensionStorageArray[i] ) ; 
              }
          delete [] SgListComprehensionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgListExp ) ;
     std::cout << " SgListExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgListExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgListExp ( SgListExpStorageArray[i] ) ; 
              }
          delete [] SgListExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLocatedNode ) ;
     std::cout << " SgLocatedNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLocatedNodeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLocatedNode ( SgLocatedNodeStorageArray[i] ) ; 
              }
          delete [] SgLocatedNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLocatedNodeSupport ) ;
     std::cout << " SgLocatedNodeSupport has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLocatedNodeSupportStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLocatedNodeSupport ( SgLocatedNodeSupportStorageArray[i] ) ; 
              }
          delete [] SgLocatedNodeSupportStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLongDoubleVal ) ;
     std::cout << " SgLongDoubleVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLongDoubleValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLongDoubleVal ( SgLongDoubleValStorageArray[i] ) ; 
              }
          delete [] SgLongDoubleValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLongIntVal ) ;
     std::cout << " SgLongIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLongIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLongIntVal ( SgLongIntValStorageArray[i] ) ; 
              }
          delete [] SgLongIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLongLongIntVal ) ;
     std::cout << " SgLongLongIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLongLongIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLongLongIntVal ( SgLongLongIntValStorageArray[i] ) ; 
              }
          delete [] SgLongLongIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLshiftAssignOp ) ;
     std::cout << " SgLshiftAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLshiftAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLshiftAssignOp ( SgLshiftAssignOpStorageArray[i] ) ; 
              }
          delete [] SgLshiftAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLshiftOp ) ;
     std::cout << " SgLshiftOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLshiftOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLshiftOp ( SgLshiftOpStorageArray[i] ) ; 
              }
          delete [] SgLshiftOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMagicColonExp ) ;
     std::cout << " SgMagicColonExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMagicColonExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMagicColonExp ( SgMagicColonExpStorageArray[i] ) ; 
              }
          delete [] SgMagicColonExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMatrixExp ) ;
     std::cout << " SgMatrixExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMatrixExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMatrixExp ( SgMatrixExpStorageArray[i] ) ; 
              }
          delete [] SgMatrixExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMatrixTransposeOp ) ;
     std::cout << " SgMatrixTransposeOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMatrixTransposeOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMatrixTransposeOp ( SgMatrixTransposeOpStorageArray[i] ) ; 
              }
          delete [] SgMatrixTransposeOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMatlabForStatement ) ;
     std::cout << " SgMatlabForStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMatlabForStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMatlabForStatement ( SgMatlabForStatementStorageArray[i] ) ; 
              }
          delete [] SgMatlabForStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMemberFunctionDeclaration ) ;
     std::cout << " SgMemberFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMemberFunctionDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMemberFunctionDeclaration ( SgMemberFunctionDeclarationStorageArray[i] ) ; 
              }
          delete [] SgMemberFunctionDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMemberFunctionRefExp ) ;
     std::cout << " SgMemberFunctionRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMemberFunctionRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMemberFunctionRefExp ( SgMemberFunctionRefExpStorageArray[i] ) ; 
              }
          delete [] SgMemberFunctionRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMemberFunctionSymbol ) ;
     std::cout << " SgMemberFunctionSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMemberFunctionSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMemberFunctionSymbol ( SgMemberFunctionSymbolStorageArray[i] ) ; 
              }
          delete [] SgMemberFunctionSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMemberFunctionType ) ;
     std::cout << " SgMemberFunctionType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMemberFunctionTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMemberFunctionType ( SgMemberFunctionTypeStorageArray[i] ) ; 
              }
          delete [] SgMemberFunctionTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMembershipOp ) ;
     std::cout << " SgMembershipOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMembershipOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMembershipOp ( SgMembershipOpStorageArray[i] ) ; 
              }
          delete [] SgMembershipOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMicrosoftAttributeDeclaration ) ;
     std::cout << " SgMicrosoftAttributeDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMicrosoftAttributeDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMicrosoftAttributeDeclaration ( SgMicrosoftAttributeDeclarationStorageArray[i] ) ; 
              }
          delete [] SgMicrosoftAttributeDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMinusAssignOp ) ;
     std::cout << " SgMinusAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMinusAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMinusAssignOp ( SgMinusAssignOpStorageArray[i] ) ; 
              }
          delete [] SgMinusAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMinusMinusOp ) ;
     std::cout << " SgMinusMinusOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMinusMinusOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMinusMinusOp ( SgMinusMinusOpStorageArray[i] ) ; 
              }
          delete [] SgMinusMinusOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMinusOp ) ;
     std::cout << " SgMinusOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMinusOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMinusOp ( SgMinusOpStorageArray[i] ) ; 
              }
          delete [] SgMinusOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModAssignOp ) ;
     std::cout << " SgModAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModAssignOp ( SgModAssignOpStorageArray[i] ) ; 
              }
          delete [] SgModAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModOp ) ;
     std::cout << " SgModOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModOp ( SgModOpStorageArray[i] ) ; 
              }
          delete [] SgModOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModifier ) ;
     std::cout << " SgModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModifier ( SgModifierStorageArray[i] ) ; 
              }
          delete [] SgModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModifierNodes ) ;
     std::cout << " SgModifierNodes has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModifierNodesStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModifierNodes ( SgModifierNodesStorageArray[i] ) ; 
              }
          delete [] SgModifierNodesStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModifierType ) ;
     std::cout << " SgModifierType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModifierTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModifierType ( SgModifierTypeStorageArray[i] ) ; 
              }
          delete [] SgModifierTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModuleStatement ) ;
     std::cout << " SgModuleStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModuleStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModuleStatement ( SgModuleStatementStorageArray[i] ) ; 
              }
          delete [] SgModuleStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModuleSymbol ) ;
     std::cout << " SgModuleSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModuleSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModuleSymbol ( SgModuleSymbolStorageArray[i] ) ; 
              }
          delete [] SgModuleSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMultAssignOp ) ;
     std::cout << " SgMultAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMultAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMultAssignOp ( SgMultAssignOpStorageArray[i] ) ; 
              }
          delete [] SgMultAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMultiplyOp ) ;
     std::cout << " SgMultiplyOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMultiplyOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMultiplyOp ( SgMultiplyOpStorageArray[i] ) ; 
              }
          delete [] SgMultiplyOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgName ) ;
     std::cout << " SgName has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgName ( SgNameStorageArray[i] ) ; 
              }
          delete [] SgNameStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNameGroup ) ;
     std::cout << " SgNameGroup has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNameGroupStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNameGroup ( SgNameGroupStorageArray[i] ) ; 
              }
          delete [] SgNameGroupStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamedType ) ;
     std::cout << " SgNamedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamedType ( SgNamedTypeStorageArray[i] ) ; 
              }
          delete [] SgNamedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamelistStatement ) ;
     std::cout << " SgNamelistStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamelistStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamelistStatement ( SgNamelistStatementStorageArray[i] ) ; 
              }
          delete [] SgNamelistStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamespaceAliasDeclarationStatement ) ;
     std::cout << " SgNamespaceAliasDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamespaceAliasDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamespaceAliasDeclarationStatement ( SgNamespaceAliasDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgNamespaceAliasDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamespaceDeclarationStatement ) ;
     std::cout << " SgNamespaceDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamespaceDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamespaceDeclarationStatement ( SgNamespaceDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgNamespaceDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamespaceDefinitionStatement ) ;
     std::cout << " SgNamespaceDefinitionStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamespaceDefinitionStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamespaceDefinitionStatement ( SgNamespaceDefinitionStatementStorageArray[i] ) ; 
              }
          delete [] SgNamespaceDefinitionStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamespaceSymbol ) ;
     std::cout << " SgNamespaceSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamespaceSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamespaceSymbol ( SgNamespaceSymbolStorageArray[i] ) ; 
              }
          delete [] SgNamespaceSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNaryOp ) ;
     std::cout << " SgNaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNaryOp ( SgNaryOpStorageArray[i] ) ; 
              }
          delete [] SgNaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNaryBooleanOp ) ;
     std::cout << " SgNaryBooleanOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNaryBooleanOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNaryBooleanOp ( SgNaryBooleanOpStorageArray[i] ) ; 
              }
          delete [] SgNaryBooleanOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNaryComparisonOp ) ;
     std::cout << " SgNaryComparisonOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNaryComparisonOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNaryComparisonOp ( SgNaryComparisonOpStorageArray[i] ) ; 
              }
          delete [] SgNaryComparisonOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNewExp ) ;
     std::cout << " SgNewExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNewExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNewExp ( SgNewExpStorageArray[i] ) ; 
              }
          delete [] SgNewExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNode ) ;
     std::cout << " SgNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNode ( SgNodeStorageArray[i] ) ; 
              }
          delete [] SgNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNoexceptOp ) ;
     std::cout << " SgNoexceptOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNoexceptOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNoexceptOp ( SgNoexceptOpStorageArray[i] ) ; 
              }
          delete [] SgNoexceptOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNotEqualOp ) ;
     std::cout << " SgNotEqualOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNotEqualOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNotEqualOp ( SgNotEqualOpStorageArray[i] ) ; 
              }
          delete [] SgNotEqualOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNotOp ) ;
     std::cout << " SgNotOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNotOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNotOp ( SgNotOpStorageArray[i] ) ; 
              }
          delete [] SgNotOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNonMembershipOp ) ;
     std::cout << " SgNonMembershipOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNonMembershipOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNonMembershipOp ( SgNonMembershipOpStorageArray[i] ) ; 
              }
          delete [] SgNonMembershipOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNonrealDecl ) ;
     std::cout << " SgNonrealDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNonrealDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNonrealDecl ( SgNonrealDeclStorageArray[i] ) ; 
              }
          delete [] SgNonrealDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNonrealRefExp ) ;
     std::cout << " SgNonrealRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNonrealRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNonrealRefExp ( SgNonrealRefExpStorageArray[i] ) ; 
              }
          delete [] SgNonrealRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNonrealSymbol ) ;
     std::cout << " SgNonrealSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNonrealSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNonrealSymbol ( SgNonrealSymbolStorageArray[i] ) ; 
              }
          delete [] SgNonrealSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNonrealType ) ;
     std::cout << " SgNonrealType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNonrealTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNonrealType ( SgNonrealTypeStorageArray[i] ) ; 
              }
          delete [] SgNonrealTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNonrealBaseClass ) ;
     std::cout << " SgNonrealBaseClass has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNonrealBaseClass ( SgNonrealBaseClassStorageArray[i] ) ; 
              }
          delete [] SgNonrealBaseClassStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNullExpression ) ;
     std::cout << " SgNullExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNullExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNullExpression ( SgNullExpressionStorageArray[i] ) ; 
              }
          delete [] SgNullExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNullptrValExp ) ;
     std::cout << " SgNullptrValExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNullptrValExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNullptrValExp ( SgNullptrValExpStorageArray[i] ) ; 
              }
          delete [] SgNullptrValExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNullStatement ) ;
     std::cout << " SgNullStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNullStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNullStatement ( SgNullStatementStorageArray[i] ) ; 
              }
          delete [] SgNullStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNullifyStatement ) ;
     std::cout << " SgNullifyStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNullifyStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNullifyStatement ( SgNullifyStatementStorageArray[i] ) ; 
              }
          delete [] SgNullifyStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpAtomicStatement ) ;
     std::cout << " SgOmpAtomicStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpAtomicStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpAtomicStatement ( SgOmpAtomicStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpAtomicStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpBarrierStatement ) ;
     std::cout << " SgOmpBarrierStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpBarrierStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpBarrierStatement ( SgOmpBarrierStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpBarrierStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpCriticalStatement ) ;
     std::cout << " SgOmpCriticalStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpCriticalStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpCriticalStatement ( SgOmpCriticalStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpCriticalStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpClauseBodyStatement ) ;
     std::cout << " SgOmpClauseBodyStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpClauseBodyStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpClauseBodyStatement ( SgOmpClauseBodyStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpClauseBodyStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpBodyStatement ) ;
     std::cout << " SgOmpBodyStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpBodyStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpBodyStatement ( SgOmpBodyStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpBodyStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpDoStatement ) ;
     std::cout << " SgOmpDoStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpDoStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpDoStatement ( SgOmpDoStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpDoStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpFlushStatement ) ;
     std::cout << " SgOmpFlushStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpFlushStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpFlushStatement ( SgOmpFlushStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpFlushStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpDeclareSimdStatement ) ;
     std::cout << " SgOmpDeclareSimdStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpDeclareSimdStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpDeclareSimdStatement ( SgOmpDeclareSimdStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpDeclareSimdStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpForStatement ) ;
     std::cout << " SgOmpForStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpForStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpForStatement ( SgOmpForStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpForStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpForSimdStatement ) ;
     std::cout << " SgOmpForSimdStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpForSimdStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpForSimdStatement ( SgOmpForSimdStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpForSimdStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpMasterStatement ) ;
     std::cout << " SgOmpMasterStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpMasterStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpMasterStatement ( SgOmpMasterStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpMasterStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpOrderedStatement ) ;
     std::cout << " SgOmpOrderedStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpOrderedStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpOrderedStatement ( SgOmpOrderedStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpOrderedStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpParallelStatement ) ;
     std::cout << " SgOmpParallelStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpParallelStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpParallelStatement ( SgOmpParallelStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpParallelStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSectionStatement ) ;
     std::cout << " SgOmpSectionStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSectionStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSectionStatement ( SgOmpSectionStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpSectionStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSectionsStatement ) ;
     std::cout << " SgOmpSectionsStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSectionsStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSectionsStatement ( SgOmpSectionsStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpSectionsStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSingleStatement ) ;
     std::cout << " SgOmpSingleStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSingleStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSingleStatement ( SgOmpSingleStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpSingleStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpTaskStatement ) ;
     std::cout << " SgOmpTaskStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpTaskStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpTaskStatement ( SgOmpTaskStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpTaskStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpTaskwaitStatement ) ;
     std::cout << " SgOmpTaskwaitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpTaskwaitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpTaskwaitStatement ( SgOmpTaskwaitStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpTaskwaitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpThreadprivateStatement ) ;
     std::cout << " SgOmpThreadprivateStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpThreadprivateStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpThreadprivateStatement ( SgOmpThreadprivateStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpThreadprivateStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpWorkshareStatement ) ;
     std::cout << " SgOmpWorkshareStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpWorkshareStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpWorkshareStatement ( SgOmpWorkshareStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpWorkshareStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpTargetStatement ) ;
     std::cout << " SgOmpTargetStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpTargetStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpTargetStatement ( SgOmpTargetStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpTargetStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpTargetDataStatement ) ;
     std::cout << " SgOmpTargetDataStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpTargetDataStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpTargetDataStatement ( SgOmpTargetDataStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpTargetDataStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSimdStatement ) ;
     std::cout << " SgOmpSimdStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSimdStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSimdStatement ( SgOmpSimdStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpSimdStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpClause ) ;
     std::cout << " SgOmpClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpClause ( SgOmpClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpBeginClause ) ;
     std::cout << " SgOmpBeginClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpBeginClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpBeginClause ( SgOmpBeginClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpBeginClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpCollapseClause ) ;
     std::cout << " SgOmpCollapseClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpCollapseClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpCollapseClause ( SgOmpCollapseClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpCollapseClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpCopyinClause ) ;
     std::cout << " SgOmpCopyinClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpCopyinClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpCopyinClause ( SgOmpCopyinClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpCopyinClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpCopyprivateClause ) ;
     std::cout << " SgOmpCopyprivateClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpCopyprivateClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpCopyprivateClause ( SgOmpCopyprivateClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpCopyprivateClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpDefaultClause ) ;
     std::cout << " SgOmpDefaultClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpDefaultClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpDefaultClause ( SgOmpDefaultClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpDefaultClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpEndClause ) ;
     std::cout << " SgOmpEndClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpEndClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpEndClause ( SgOmpEndClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpEndClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpExpressionClause ) ;
     std::cout << " SgOmpExpressionClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpExpressionClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpExpressionClause ( SgOmpExpressionClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpExpressionClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpFirstprivateClause ) ;
     std::cout << " SgOmpFirstprivateClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpFirstprivateClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpFirstprivateClause ( SgOmpFirstprivateClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpFirstprivateClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpIfClause ) ;
     std::cout << " SgOmpIfClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpIfClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpIfClause ( SgOmpIfClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpIfClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpFinalClause ) ;
     std::cout << " SgOmpFinalClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpFinalClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpFinalClause ( SgOmpFinalClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpFinalClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpPriorityClause ) ;
     std::cout << " SgOmpPriorityClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpPriorityClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpPriorityClause ( SgOmpPriorityClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpPriorityClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpDeviceClause ) ;
     std::cout << " SgOmpDeviceClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpDeviceClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpDeviceClause ( SgOmpDeviceClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpDeviceClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpLastprivateClause ) ;
     std::cout << " SgOmpLastprivateClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpLastprivateClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpLastprivateClause ( SgOmpLastprivateClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpLastprivateClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpNowaitClause ) ;
     std::cout << " SgOmpNowaitClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpNowaitClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpNowaitClause ( SgOmpNowaitClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpNowaitClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpNumThreadsClause ) ;
     std::cout << " SgOmpNumThreadsClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpNumThreadsClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpNumThreadsClause ( SgOmpNumThreadsClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpNumThreadsClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpOrderedClause ) ;
     std::cout << " SgOmpOrderedClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpOrderedClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpOrderedClause ( SgOmpOrderedClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpOrderedClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpPrivateClause ) ;
     std::cout << " SgOmpPrivateClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpPrivateClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpPrivateClause ( SgOmpPrivateClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpPrivateClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpReductionClause ) ;
     std::cout << " SgOmpReductionClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpReductionClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpReductionClause ( SgOmpReductionClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpReductionClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpScheduleClause ) ;
     std::cout << " SgOmpScheduleClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpScheduleClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpScheduleClause ( SgOmpScheduleClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpScheduleClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSharedClause ) ;
     std::cout << " SgOmpSharedClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSharedClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSharedClause ( SgOmpSharedClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpSharedClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpUntiedClause ) ;
     std::cout << " SgOmpUntiedClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpUntiedClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpUntiedClause ( SgOmpUntiedClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpUntiedClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpMergeableClause ) ;
     std::cout << " SgOmpMergeableClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpMergeableClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpMergeableClause ( SgOmpMergeableClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpMergeableClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpVariablesClause ) ;
     std::cout << " SgOmpVariablesClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpVariablesClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpVariablesClause ( SgOmpVariablesClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpVariablesClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpMapClause ) ;
     std::cout << " SgOmpMapClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpMapClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpMapClause ( SgOmpMapClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpMapClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSafelenClause ) ;
     std::cout << " SgOmpSafelenClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSafelenClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSafelenClause ( SgOmpSafelenClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpSafelenClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSimdlenClause ) ;
     std::cout << " SgOmpSimdlenClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSimdlenClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSimdlenClause ( SgOmpSimdlenClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpSimdlenClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpLinearClause ) ;
     std::cout << " SgOmpLinearClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpLinearClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpLinearClause ( SgOmpLinearClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpLinearClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpUniformClause ) ;
     std::cout << " SgOmpUniformClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpUniformClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpUniformClause ( SgOmpUniformClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpUniformClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpAlignedClause ) ;
     std::cout << " SgOmpAlignedClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpAlignedClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpAlignedClause ( SgOmpAlignedClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpAlignedClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpProcBindClause ) ;
     std::cout << " SgOmpProcBindClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpProcBindClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpProcBindClause ( SgOmpProcBindClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpProcBindClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpAtomicClause ) ;
     std::cout << " SgOmpAtomicClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpAtomicClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpAtomicClause ( SgOmpAtomicClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpAtomicClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpInbranchClause ) ;
     std::cout << " SgOmpInbranchClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpInbranchClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpInbranchClause ( SgOmpInbranchClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpInbranchClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpNotinbranchClause ) ;
     std::cout << " SgOmpNotinbranchClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpNotinbranchClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpNotinbranchClause ( SgOmpNotinbranchClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpNotinbranchClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpDependClause ) ;
     std::cout << " SgOmpDependClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpDependClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpDependClause ( SgOmpDependClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpDependClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOpenclAccessModeModifier ) ;
     std::cout << " SgOpenclAccessModeModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOpenclAccessModeModifier ( SgOpenclAccessModeModifierStorageArray[i] ) ; 
              }
          delete [] SgOpenclAccessModeModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOpenStatement ) ;
     std::cout << " SgOpenStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOpenStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOpenStatement ( SgOpenStatementStorageArray[i] ) ; 
              }
          delete [] SgOpenStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOptions ) ;
     std::cout << " SgOptions has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOptions ( SgOptionsStorageArray[i] ) ; 
              }
          delete [] SgOptionsStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOrOp ) ;
     std::cout << " SgOrOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOrOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOrOp ( SgOrOpStorageArray[i] ) ; 
              }
          delete [] SgOrOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgParameterStatement ) ;
     std::cout << " SgParameterStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgParameterStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgParameterStatement ( SgParameterStatementStorageArray[i] ) ; 
              }
          delete [] SgParameterStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPartialFunctionModifierType ) ;
     std::cout << " SgPartialFunctionModifierType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPartialFunctionModifierTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPartialFunctionModifierType ( SgPartialFunctionModifierTypeStorageArray[i] ) ; 
              }
          delete [] SgPartialFunctionModifierTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPartialFunctionType ) ;
     std::cout << " SgPartialFunctionType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPartialFunctionTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPartialFunctionType ( SgPartialFunctionTypeStorageArray[i] ) ; 
              }
          delete [] SgPartialFunctionTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPassStatement ) ;
     std::cout << " SgPassStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPassStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPassStatement ( SgPassStatementStorageArray[i] ) ; 
              }
          delete [] SgPassStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPlusAssignOp ) ;
     std::cout << " SgPlusAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPlusAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPlusAssignOp ( SgPlusAssignOpStorageArray[i] ) ; 
              }
          delete [] SgPlusAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPlusPlusOp ) ;
     std::cout << " SgPlusPlusOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPlusPlusOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPlusPlusOp ( SgPlusPlusOpStorageArray[i] ) ; 
              }
          delete [] SgPlusPlusOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPntrArrRefExp ) ;
     std::cout << " SgPntrArrRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPntrArrRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPntrArrRefExp ( SgPntrArrRefExpStorageArray[i] ) ; 
              }
          delete [] SgPntrArrRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPointerAssignOp ) ;
     std::cout << " SgPointerAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPointerAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPointerAssignOp ( SgPointerAssignOpStorageArray[i] ) ; 
              }
          delete [] SgPointerAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPointerDerefExp ) ;
     std::cout << " SgPointerDerefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPointerDerefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPointerDerefExp ( SgPointerDerefExpStorageArray[i] ) ; 
              }
          delete [] SgPointerDerefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPointerMemberType ) ;
     std::cout << " SgPointerMemberType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPointerMemberTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPointerMemberType ( SgPointerMemberTypeStorageArray[i] ) ; 
              }
          delete [] SgPointerMemberTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPointerType ) ;
     std::cout << " SgPointerType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPointerTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPointerType ( SgPointerTypeStorageArray[i] ) ; 
              }
          delete [] SgPointerTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPowerOp ) ;
     std::cout << " SgPowerOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPowerOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPowerOp ( SgPowerOpStorageArray[i] ) ; 
              }
          delete [] SgPowerOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPragma ) ;
     std::cout << " SgPragma has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPragmaStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPragma ( SgPragmaStorageArray[i] ) ; 
              }
          delete [] SgPragmaStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPragmaDeclaration ) ;
     std::cout << " SgPragmaDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPragmaDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPragmaDeclaration ( SgPragmaDeclarationStorageArray[i] ) ; 
              }
          delete [] SgPragmaDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPrintStatement ) ;
     std::cout << " SgPrintStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPrintStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPrintStatement ( SgPrintStatementStorageArray[i] ) ; 
              }
          delete [] SgPrintStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgProcedureHeaderStatement ) ;
     std::cout << " SgProcedureHeaderStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgProcedureHeaderStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgProcedureHeaderStatement ( SgProcedureHeaderStatementStorageArray[i] ) ; 
              }
          delete [] SgProcedureHeaderStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgProgramHeaderStatement ) ;
     std::cout << " SgProgramHeaderStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgProgramHeaderStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgProgramHeaderStatement ( SgProgramHeaderStatementStorageArray[i] ) ; 
              }
          delete [] SgProgramHeaderStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgProject ) ;
     std::cout << " SgProject has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgProjectStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgProject ( SgProjectStorageArray[i] ) ; 
              }
          delete [] SgProjectStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPseudoDestructorRefExp ) ;
     std::cout << " SgPseudoDestructorRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPseudoDestructorRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPseudoDestructorRefExp ( SgPseudoDestructorRefExpStorageArray[i] ) ; 
              }
          delete [] SgPseudoDestructorRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPythonGlobalStmt ) ;
     std::cout << " SgPythonGlobalStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPythonGlobalStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPythonGlobalStmt ( SgPythonGlobalStmtStorageArray[i] ) ; 
              }
          delete [] SgPythonGlobalStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPythonPrintStmt ) ;
     std::cout << " SgPythonPrintStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPythonPrintStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPythonPrintStmt ( SgPythonPrintStmtStorageArray[i] ) ; 
              }
          delete [] SgPythonPrintStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgQualifiedName ) ;
     std::cout << " SgQualifiedName has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgQualifiedName ( SgQualifiedNameStorageArray[i] ) ; 
              }
          delete [] SgQualifiedNameStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgQualifiedNameType ) ;
     std::cout << " SgQualifiedNameType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgQualifiedNameTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgQualifiedNameType ( SgQualifiedNameTypeStorageArray[i] ) ; 
              }
          delete [] SgQualifiedNameTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRangeExp ) ;
     std::cout << " SgRangeExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRangeExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRangeExp ( SgRangeExpStorageArray[i] ) ; 
              }
          delete [] SgRangeExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRangeBasedForStatement ) ;
     std::cout << " SgRangeBasedForStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRangeBasedForStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRangeBasedForStatement ( SgRangeBasedForStatementStorageArray[i] ) ; 
              }
          delete [] SgRangeBasedForStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgReadStatement ) ;
     std::cout << " SgReadStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgReadStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgReadStatement ( SgReadStatementStorageArray[i] ) ; 
              }
          delete [] SgReadStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRealPartOp ) ;
     std::cout << " SgRealPartOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRealPartOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRealPartOp ( SgRealPartOpStorageArray[i] ) ; 
              }
          delete [] SgRealPartOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRefExp ) ;
     std::cout << " SgRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRefExp ( SgRefExpStorageArray[i] ) ; 
              }
          delete [] SgRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgReferenceType ) ;
     std::cout << " SgReferenceType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgReferenceTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgReferenceType ( SgReferenceTypeStorageArray[i] ) ; 
              }
          delete [] SgReferenceTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRemOp ) ;
     std::cout << " SgRemOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRemOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRemOp ( SgRemOpStorageArray[i] ) ; 
              }
          delete [] SgRemOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRenamePair ) ;
     std::cout << " SgRenamePair has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRenamePairStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRenamePair ( SgRenamePairStorageArray[i] ) ; 
              }
          delete [] SgRenamePairStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRenameSymbol ) ;
     std::cout << " SgRenameSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRenameSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRenameSymbol ( SgRenameSymbolStorageArray[i] ) ; 
              }
          delete [] SgRenameSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgReplicationOp ) ;
     std::cout << " SgReplicationOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgReplicationOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgReplicationOp ( SgReplicationOpStorageArray[i] ) ; 
              }
          delete [] SgReplicationOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgReturnStmt ) ;
     std::cout << " SgReturnStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgReturnStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgReturnStmt ( SgReturnStmtStorageArray[i] ) ; 
              }
          delete [] SgReturnStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRewindStatement ) ;
     std::cout << " SgRewindStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRewindStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRewindStatement ( SgRewindStatementStorageArray[i] ) ; 
              }
          delete [] SgRewindStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRshiftAssignOp ) ;
     std::cout << " SgRshiftAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRshiftAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRshiftAssignOp ( SgRshiftAssignOpStorageArray[i] ) ; 
              }
          delete [] SgRshiftAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRshiftOp ) ;
     std::cout << " SgRshiftOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRshiftOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRshiftOp ( SgRshiftOpStorageArray[i] ) ; 
              }
          delete [] SgRshiftOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRvalueReferenceType ) ;
     std::cout << " SgRvalueReferenceType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRvalueReferenceTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRvalueReferenceType ( SgRvalueReferenceTypeStorageArray[i] ) ; 
              }
          delete [] SgRvalueReferenceTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaUnsignedRshiftAssignOp ) ;
     std::cout << " SgJavaUnsignedRshiftAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaUnsignedRshiftAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaUnsignedRshiftAssignOp ( SgJavaUnsignedRshiftAssignOpStorageArray[i] ) ; 
              }
          delete [] SgJavaUnsignedRshiftAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaUnsignedRshiftOp ) ;
     std::cout << " SgJavaUnsignedRshiftOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaUnsignedRshiftOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaUnsignedRshiftOp ( SgJavaUnsignedRshiftOpStorageArray[i] ) ; 
              }
          delete [] SgJavaUnsignedRshiftOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgScopeOp ) ;
     std::cout << " SgScopeOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgScopeOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgScopeOp ( SgScopeOpStorageArray[i] ) ; 
              }
          delete [] SgScopeOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgScopeStatement ) ;
     std::cout << " SgScopeStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgScopeStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgScopeStatement ( SgScopeStatementStorageArray[i] ) ; 
              }
          delete [] SgScopeStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSequenceStatement ) ;
     std::cout << " SgSequenceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSequenceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSequenceStatement ( SgSequenceStatementStorageArray[i] ) ; 
              }
          delete [] SgSequenceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSetComprehension ) ;
     std::cout << " SgSetComprehension has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSetComprehensionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSetComprehension ( SgSetComprehensionStorageArray[i] ) ; 
              }
          delete [] SgSetComprehensionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgShortVal ) ;
     std::cout << " SgShortVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgShortValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgShortVal ( SgShortValStorageArray[i] ) ; 
              }
          delete [] SgShortValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSizeOfOp ) ;
     std::cout << " SgSizeOfOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSizeOfOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSizeOfOp ( SgSizeOfOpStorageArray[i] ) ; 
              }
          delete [] SgSizeOfOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAlignOfOp ) ;
     std::cout << " SgAlignOfOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAlignOfOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAlignOfOp ( SgAlignOfOpStorageArray[i] ) ; 
              }
          delete [] SgAlignOfOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaInstanceOfOp ) ;
     std::cout << " SgJavaInstanceOfOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaInstanceOfOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaInstanceOfOp ( SgJavaInstanceOfOpStorageArray[i] ) ; 
              }
          delete [] SgJavaInstanceOfOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSourceFile ) ;
     std::cout << " SgSourceFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSourceFileStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSourceFile ( SgSourceFileStorageArray[i] ) ; 
              }
          delete [] SgSourceFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSpaceshipOp ) ;
     std::cout << " SgSpaceshipOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSpaceshipOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSpaceshipOp ( SgSpaceshipOpStorageArray[i] ) ; 
              }
          delete [] SgSpaceshipOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSpawnStmt ) ;
     std::cout << " SgSpawnStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSpawnStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSpawnStmt ( SgSpawnStmtStorageArray[i] ) ; 
              }
          delete [] SgSpawnStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSyncAllStatement ) ;
     std::cout << " SgSyncAllStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSyncAllStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSyncAllStatement ( SgSyncAllStatementStorageArray[i] ) ; 
              }
          delete [] SgSyncAllStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSyncImagesStatement ) ;
     std::cout << " SgSyncImagesStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSyncImagesStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSyncImagesStatement ( SgSyncImagesStatementStorageArray[i] ) ; 
              }
          delete [] SgSyncImagesStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSyncMemoryStatement ) ;
     std::cout << " SgSyncMemoryStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSyncMemoryStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSyncMemoryStatement ( SgSyncMemoryStatementStorageArray[i] ) ; 
              }
          delete [] SgSyncMemoryStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSyncTeamStatement ) ;
     std::cout << " SgSyncTeamStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSyncTeamStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSyncTeamStatement ( SgSyncTeamStatementStorageArray[i] ) ; 
              }
          delete [] SgSyncTeamStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLockStatement ) ;
     std::cout << " SgLockStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLockStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLockStatement ( SgLockStatementStorageArray[i] ) ; 
              }
          delete [] SgLockStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnlockStatement ) ;
     std::cout << " SgUnlockStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnlockStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnlockStatement ( SgUnlockStatementStorageArray[i] ) ; 
              }
          delete [] SgUnlockStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaThrowStatement ) ;
     std::cout << " SgJavaThrowStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaThrowStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaThrowStatement ( SgJavaThrowStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaThrowStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaForEachStatement ) ;
     std::cout << " SgJavaForEachStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaForEachStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaForEachStatement ( SgJavaForEachStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaForEachStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaSynchronizedStatement ) ;
     std::cout << " SgJavaSynchronizedStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaSynchronizedStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaSynchronizedStatement ( SgJavaSynchronizedStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaSynchronizedStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaParameterizedType ) ;
     std::cout << " SgJavaParameterizedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaParameterizedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaParameterizedType ( SgJavaParameterizedTypeStorageArray[i] ) ; 
              }
          delete [] SgJavaParameterizedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaWildcardType ) ;
     std::cout << " SgJavaWildcardType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaWildcardTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaWildcardType ( SgJavaWildcardTypeStorageArray[i] ) ; 
              }
          delete [] SgJavaWildcardTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgProcessControlStatement ) ;
     std::cout << " SgProcessControlStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgProcessControlStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgProcessControlStatement ( SgProcessControlStatementStorageArray[i] ) ; 
              }
          delete [] SgProcessControlStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSpecialFunctionModifier ) ;
     std::cout << " SgSpecialFunctionModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSpecialFunctionModifier ( SgSpecialFunctionModifierStorageArray[i] ) ; 
              }
          delete [] SgSpecialFunctionModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStatement ) ;
     std::cout << " SgStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStatement ( SgStatementStorageArray[i] ) ; 
              }
          delete [] SgStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStaticAssertionDeclaration ) ;
     std::cout << " SgStaticAssertionDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStaticAssertionDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStaticAssertionDeclaration ( SgStaticAssertionDeclarationStorageArray[i] ) ; 
              }
          delete [] SgStaticAssertionDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStmtDeclarationStatement ) ;
     std::cout << " SgStmtDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStmtDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStmtDeclarationStatement ( SgStmtDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgStmtDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStatementExpression ) ;
     std::cout << " SgStatementExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStatementExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStatementExpression ( SgStatementExpressionStorageArray[i] ) ; 
              }
          delete [] SgStatementExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStatementFunctionStatement ) ;
     std::cout << " SgStatementFunctionStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStatementFunctionStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStatementFunctionStatement ( SgStatementFunctionStatementStorageArray[i] ) ; 
              }
          delete [] SgStatementFunctionStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStorageModifier ) ;
     std::cout << " SgStorageModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStorageModifier ( SgStorageModifierStorageArray[i] ) ; 
              }
          delete [] SgStorageModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStringConversion ) ;
     std::cout << " SgStringConversion has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStringConversionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStringConversion ( SgStringConversionStorageArray[i] ) ; 
              }
          delete [] SgStringConversionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStringKeyedBidirectionalGraph ) ;
     std::cout << " SgStringKeyedBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStringKeyedBidirectionalGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStringKeyedBidirectionalGraph ( SgStringKeyedBidirectionalGraphStorageArray[i] ) ; 
              }
          delete [] SgStringKeyedBidirectionalGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStringVal ) ;
     std::cout << " SgStringVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStringValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStringVal ( SgStringValStorageArray[i] ) ; 
              }
          delete [] SgStringValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStructureModifier ) ;
     std::cout << " SgStructureModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStructureModifier ( SgStructureModifierStorageArray[i] ) ; 
              }
          delete [] SgStructureModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSubscriptExpression ) ;
     std::cout << " SgSubscriptExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSubscriptExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSubscriptExpression ( SgSubscriptExpressionStorageArray[i] ) ; 
              }
          delete [] SgSubscriptExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSubtractOp ) ;
     std::cout << " SgSubtractOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSubtractOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSubtractOp ( SgSubtractOpStorageArray[i] ) ; 
              }
          delete [] SgSubtractOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSupport ) ;
     std::cout << " SgSupport has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSupport ( SgSupportStorageArray[i] ) ; 
              }
          delete [] SgSupportStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSwitchStatement ) ;
     std::cout << " SgSwitchStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSwitchStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSwitchStatement ( SgSwitchStatementStorageArray[i] ) ; 
              }
          delete [] SgSwitchStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSymbolTable ) ;
     std::cout << " SgSymbolTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSymbolTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSymbolTable ( SgSymbolTableStorageArray[i] ) ; 
              }
          delete [] SgSymbolTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateArgument ) ;
     std::cout << " SgTemplateArgument has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateArgument ( SgTemplateArgumentStorageArray[i] ) ; 
              }
          delete [] SgTemplateArgumentStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateArgumentList ) ;
     std::cout << " SgTemplateArgumentList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateArgumentListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateArgumentList ( SgTemplateArgumentListStorageArray[i] ) ; 
              }
          delete [] SgTemplateArgumentListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateDeclaration ) ;
     std::cout << " SgTemplateDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateDeclaration ( SgTemplateDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateClassDeclaration ) ;
     std::cout << " SgTemplateClassDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateClassDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateClassDeclaration ( SgTemplateClassDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateClassDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateClassSymbol ) ;
     std::cout << " SgTemplateClassSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateClassSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateClassSymbol ( SgTemplateClassSymbolStorageArray[i] ) ; 
              }
          delete [] SgTemplateClassSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateFunctionDeclaration ) ;
     std::cout << " SgTemplateFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateFunctionDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateFunctionDeclaration ( SgTemplateFunctionDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateFunctionDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateFunctionRefExp ) ;
     std::cout << " SgTemplateFunctionRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateFunctionRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateFunctionRefExp ( SgTemplateFunctionRefExpStorageArray[i] ) ; 
              }
          delete [] SgTemplateFunctionRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateFunctionSymbol ) ;
     std::cout << " SgTemplateFunctionSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateFunctionSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateFunctionSymbol ( SgTemplateFunctionSymbolStorageArray[i] ) ; 
              }
          delete [] SgTemplateFunctionSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateMemberFunctionDeclaration ) ;
     std::cout << " SgTemplateMemberFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateMemberFunctionDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateMemberFunctionDeclaration ( SgTemplateMemberFunctionDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateMemberFunctionDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateMemberFunctionRefExp ) ;
     std::cout << " SgTemplateMemberFunctionRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateMemberFunctionRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateMemberFunctionRefExp ( SgTemplateMemberFunctionRefExpStorageArray[i] ) ; 
              }
          delete [] SgTemplateMemberFunctionRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateMemberFunctionSymbol ) ;
     std::cout << " SgTemplateMemberFunctionSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateMemberFunctionSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateMemberFunctionSymbol ( SgTemplateMemberFunctionSymbolStorageArray[i] ) ; 
              }
          delete [] SgTemplateMemberFunctionSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateTypedefDeclaration ) ;
     std::cout << " SgTemplateTypedefDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateTypedefDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateTypedefDeclaration ( SgTemplateTypedefDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateTypedefDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateTypedefSymbol ) ;
     std::cout << " SgTemplateTypedefSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateTypedefSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateTypedefSymbol ( SgTemplateTypedefSymbolStorageArray[i] ) ; 
              }
          delete [] SgTemplateTypedefSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateVariableDeclaration ) ;
     std::cout << " SgTemplateVariableDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateVariableDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateVariableDeclaration ( SgTemplateVariableDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateVariableDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateVariableSymbol ) ;
     std::cout << " SgTemplateVariableSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateVariableSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateVariableSymbol ( SgTemplateVariableSymbolStorageArray[i] ) ; 
              }
          delete [] SgTemplateVariableSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateClassDefinition ) ;
     std::cout << " SgTemplateClassDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateClassDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateClassDefinition ( SgTemplateClassDefinitionStorageArray[i] ) ; 
              }
          delete [] SgTemplateClassDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateFunctionDefinition ) ;
     std::cout << " SgTemplateFunctionDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateFunctionDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateFunctionDefinition ( SgTemplateFunctionDefinitionStorageArray[i] ) ; 
              }
          delete [] SgTemplateFunctionDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationDecl ) ;
     std::cout << " SgTemplateInstantiationDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationDecl ( SgTemplateInstantiationDeclStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationDefn ) ;
     std::cout << " SgTemplateInstantiationDefn has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationDefnStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationDefn ( SgTemplateInstantiationDefnStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationDefnStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationDirectiveStatement ) ;
     std::cout << " SgTemplateInstantiationDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationDirectiveStatement ( SgTemplateInstantiationDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationFunctionDecl ) ;
     std::cout << " SgTemplateInstantiationFunctionDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationFunctionDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationFunctionDecl ( SgTemplateInstantiationFunctionDeclStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationFunctionDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationMemberFunctionDecl ) ;
     std::cout << " SgTemplateInstantiationMemberFunctionDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationMemberFunctionDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationMemberFunctionDecl ( SgTemplateInstantiationMemberFunctionDeclStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationMemberFunctionDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationTypedefDeclaration ) ;
     std::cout << " SgTemplateInstantiationTypedefDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationTypedefDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationTypedefDeclaration ( SgTemplateInstantiationTypedefDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationTypedefDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateParameter ) ;
     std::cout << " SgTemplateParameter has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateParameter ( SgTemplateParameterStorageArray[i] ) ; 
              }
          delete [] SgTemplateParameterStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateParameterVal ) ;
     std::cout << " SgTemplateParameterVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateParameterValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateParameterVal ( SgTemplateParameterValStorageArray[i] ) ; 
              }
          delete [] SgTemplateParameterValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateParameterList ) ;
     std::cout << " SgTemplateParameterList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateParameterListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateParameterList ( SgTemplateParameterListStorageArray[i] ) ; 
              }
          delete [] SgTemplateParameterListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateSymbol ) ;
     std::cout << " SgTemplateSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateSymbol ( SgTemplateSymbolStorageArray[i] ) ; 
              }
          delete [] SgTemplateSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateType ) ;
     std::cout << " SgTemplateType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateType ( SgTemplateTypeStorageArray[i] ) ; 
              }
          delete [] SgTemplateTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgThisExp ) ;
     std::cout << " SgThisExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgThisExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgThisExp ( SgThisExpStorageArray[i] ) ; 
              }
          delete [] SgThisExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeTraitBuiltinOperator ) ;
     std::cout << " SgTypeTraitBuiltinOperator has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeTraitBuiltinOperatorStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeTraitBuiltinOperator ( SgTypeTraitBuiltinOperatorStorageArray[i] ) ; 
              }
          delete [] SgTypeTraitBuiltinOperatorStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSuperExp ) ;
     std::cout << " SgSuperExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSuperExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSuperExp ( SgSuperExpStorageArray[i] ) ; 
              }
          delete [] SgSuperExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgThrowOp ) ;
     std::cout << " SgThrowOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgThrowOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgThrowOp ( SgThrowOpStorageArray[i] ) ; 
              }
          delete [] SgThrowOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgToken ) ;
     std::cout << " SgToken has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTokenStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgToken ( SgTokenStorageArray[i] ) ; 
              }
          delete [] SgTokenStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTryStmt ) ;
     std::cout << " SgTryStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTryStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTryStmt ( SgTryStmtStorageArray[i] ) ; 
              }
          delete [] SgTryStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTupleExp ) ;
     std::cout << " SgTupleExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTupleExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTupleExp ( SgTupleExpStorageArray[i] ) ; 
              }
          delete [] SgTupleExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgType ) ;
     std::cout << " SgType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgType ( SgTypeStorageArray[i] ) ; 
              }
          delete [] SgTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeBool ) ;
     std::cout << " SgTypeBool has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeBoolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeBool ( SgTypeBoolStorageArray[i] ) ; 
              }
          delete [] SgTypeBoolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeChar ) ;
     std::cout << " SgTypeChar has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeCharStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeChar ( SgTypeCharStorageArray[i] ) ; 
              }
          delete [] SgTypeCharStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeChar16 ) ;
     std::cout << " SgTypeChar16 has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeChar16StorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeChar16 ( SgTypeChar16StorageArray[i] ) ; 
              }
          delete [] SgTypeChar16StorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeChar32 ) ;
     std::cout << " SgTypeChar32 has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeChar32StorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeChar32 ( SgTypeChar32StorageArray[i] ) ; 
              }
          delete [] SgTypeChar32StorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeComplex ) ;
     std::cout << " SgTypeComplex has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeComplexStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeComplex ( SgTypeComplexStorageArray[i] ) ; 
              }
          delete [] SgTypeComplexStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeDefault ) ;
     std::cout << " SgTypeDefault has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeDefaultStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeDefault ( SgTypeDefaultStorageArray[i] ) ; 
              }
          delete [] SgTypeDefaultStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeExpression ) ;
     std::cout << " SgTypeExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeExpression ( SgTypeExpressionStorageArray[i] ) ; 
              }
          delete [] SgTypeExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeLabel ) ;
     std::cout << " SgTypeLabel has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeLabelStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeLabel ( SgTypeLabelStorageArray[i] ) ; 
              }
          delete [] SgTypeLabelStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeDouble ) ;
     std::cout << " SgTypeDouble has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeDoubleStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeDouble ( SgTypeDoubleStorageArray[i] ) ; 
              }
          delete [] SgTypeDoubleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeEllipse ) ;
     std::cout << " SgTypeEllipse has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeEllipseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeEllipse ( SgTypeEllipseStorageArray[i] ) ; 
              }
          delete [] SgTypeEllipseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeFixed ) ;
     std::cout << " SgTypeFixed has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeFixedStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeFixed ( SgTypeFixedStorageArray[i] ) ; 
              }
          delete [] SgTypeFixedStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeFloat ) ;
     std::cout << " SgTypeFloat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeFloatStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeFloat ( SgTypeFloatStorageArray[i] ) ; 
              }
          delete [] SgTypeFloatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeFloat128 ) ;
     std::cout << " SgTypeFloat128 has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeFloat128StorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeFloat128 ( SgTypeFloat128StorageArray[i] ) ; 
              }
          delete [] SgTypeFloat128StorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeFloat80 ) ;
     std::cout << " SgTypeFloat80 has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeFloat80StorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeFloat80 ( SgTypeFloat80StorageArray[i] ) ; 
              }
          delete [] SgTypeFloat80StorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeGlobalVoid ) ;
     std::cout << " SgTypeGlobalVoid has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeGlobalVoidStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeGlobalVoid ( SgTypeGlobalVoidStorageArray[i] ) ; 
              }
          delete [] SgTypeGlobalVoidStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeIdOp ) ;
     std::cout << " SgTypeIdOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeIdOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeIdOp ( SgTypeIdOpStorageArray[i] ) ; 
              }
          delete [] SgTypeIdOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeImaginary ) ;
     std::cout << " SgTypeImaginary has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeImaginaryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeImaginary ( SgTypeImaginaryStorageArray[i] ) ; 
              }
          delete [] SgTypeImaginaryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeInt ) ;
     std::cout << " SgTypeInt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeIntStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeInt ( SgTypeIntStorageArray[i] ) ; 
              }
          delete [] SgTypeIntStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeLong ) ;
     std::cout << " SgTypeLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeLong ( SgTypeLongStorageArray[i] ) ; 
              }
          delete [] SgTypeLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeLongDouble ) ;
     std::cout << " SgTypeLongDouble has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeLongDoubleStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeLongDouble ( SgTypeLongDoubleStorageArray[i] ) ; 
              }
          delete [] SgTypeLongDoubleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeLongLong ) ;
     std::cout << " SgTypeLongLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeLongLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeLongLong ( SgTypeLongLongStorageArray[i] ) ; 
              }
          delete [] SgTypeLongLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeModifier ) ;
     std::cout << " SgTypeModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeModifier ( SgTypeModifierStorageArray[i] ) ; 
              }
          delete [] SgTypeModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeMatrix ) ;
     std::cout << " SgTypeMatrix has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeMatrixStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeMatrix ( SgTypeMatrixStorageArray[i] ) ; 
              }
          delete [] SgTypeMatrixStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeTuple ) ;
     std::cout << " SgTypeTuple has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeTupleStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeTuple ( SgTypeTupleStorageArray[i] ) ; 
              }
          delete [] SgTypeTupleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeNullptr ) ;
     std::cout << " SgTypeNullptr has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeNullptrStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeNullptr ( SgTypeNullptrStorageArray[i] ) ; 
              }
          delete [] SgTypeNullptrStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeOfType ) ;
     std::cout << " SgTypeOfType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeOfTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeOfType ( SgTypeOfTypeStorageArray[i] ) ; 
              }
          delete [] SgTypeOfTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeShort ) ;
     std::cout << " SgTypeShort has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeShortStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeShort ( SgTypeShortStorageArray[i] ) ; 
              }
          delete [] SgTypeShortStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSigned128bitInteger ) ;
     std::cout << " SgTypeSigned128bitInteger has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSigned128bitIntegerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSigned128bitInteger ( SgTypeSigned128bitIntegerStorageArray[i] ) ; 
              }
          delete [] SgTypeSigned128bitIntegerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedChar ) ;
     std::cout << " SgTypeSignedChar has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedCharStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedChar ( SgTypeSignedCharStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedCharStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedInt ) ;
     std::cout << " SgTypeSignedInt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedIntStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedInt ( SgTypeSignedIntStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedIntStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedLong ) ;
     std::cout << " SgTypeSignedLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedLong ( SgTypeSignedLongStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedLongLong ) ;
     std::cout << " SgTypeSignedLongLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedLongLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedLongLong ( SgTypeSignedLongLongStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedLongLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedShort ) ;
     std::cout << " SgTypeSignedShort has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedShortStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedShort ( SgTypeSignedShortStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedShortStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeString ) ;
     std::cout << " SgTypeString has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeStringStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeString ( SgTypeStringStorageArray[i] ) ; 
              }
          delete [] SgTypeStringStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnknown ) ;
     std::cout << " SgTypeUnknown has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnknownStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnknown ( SgTypeUnknownStorageArray[i] ) ; 
              }
          delete [] SgTypeUnknownStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsigned128bitInteger ) ;
     std::cout << " SgTypeUnsigned128bitInteger has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsigned128bitIntegerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsigned128bitInteger ( SgTypeUnsigned128bitIntegerStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsigned128bitIntegerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedChar ) ;
     std::cout << " SgTypeUnsignedChar has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedCharStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedChar ( SgTypeUnsignedCharStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedCharStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedInt ) ;
     std::cout << " SgTypeUnsignedInt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedIntStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedInt ( SgTypeUnsignedIntStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedIntStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedLong ) ;
     std::cout << " SgTypeUnsignedLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedLong ( SgTypeUnsignedLongStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedLongLong ) ;
     std::cout << " SgTypeUnsignedLongLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedLongLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedLongLong ( SgTypeUnsignedLongLongStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedLongLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedShort ) ;
     std::cout << " SgTypeUnsignedShort has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedShortStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedShort ( SgTypeUnsignedShortStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedShortStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeVoid ) ;
     std::cout << " SgTypeVoid has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeVoidStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeVoid ( SgTypeVoidStorageArray[i] ) ; 
              }
          delete [] SgTypeVoidStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeWchar ) ;
     std::cout << " SgTypeWchar has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeWcharStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeWchar ( SgTypeWcharStorageArray[i] ) ; 
              }
          delete [] SgTypeWcharStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypedefDeclaration ) ;
     std::cout << " SgTypedefDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypedefDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypedefDeclaration ( SgTypedefDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTypedefDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypedefSeq ) ;
     std::cout << " SgTypedefSeq has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypedefSeqStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypedefSeq ( SgTypedefSeqStorageArray[i] ) ; 
              }
          delete [] SgTypedefSeqStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypedefSymbol ) ;
     std::cout << " SgTypedefSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypedefSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypedefSymbol ( SgTypedefSymbolStorageArray[i] ) ; 
              }
          delete [] SgTypedefSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypedefType ) ;
     std::cout << " SgTypedefType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypedefTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypedefType ( SgTypedefTypeStorageArray[i] ) ; 
              }
          delete [] SgTypedefTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUPC_AccessModifier ) ;
     std::cout << " SgUPC_AccessModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUPC_AccessModifier ( SgUPC_AccessModifierStorageArray[i] ) ; 
              }
          delete [] SgUPC_AccessModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnaryAddOp ) ;
     std::cout << " SgUnaryAddOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnaryAddOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnaryAddOp ( SgUnaryAddOpStorageArray[i] ) ; 
              }
          delete [] SgUnaryAddOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnaryOp ) ;
     std::cout << " SgUnaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnaryOp ( SgUnaryOpStorageArray[i] ) ; 
              }
          delete [] SgUnaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUndefDirectiveStatement ) ;
     std::cout << " SgUndefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUndefDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUndefDirectiveStatement ( SgUndefDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgUndefDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUndirectedGraphEdge ) ;
     std::cout << " SgUndirectedGraphEdge has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUndirectedGraphEdgeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUndirectedGraphEdge ( SgUndirectedGraphEdgeStorageArray[i] ) ; 
              }
          delete [] SgUndirectedGraphEdgeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnknownArrayOrFunctionReference ) ;
     std::cout << " SgUnknownArrayOrFunctionReference has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnknownArrayOrFunctionReferenceStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnknownArrayOrFunctionReference ( SgUnknownArrayOrFunctionReferenceStorageArray[i] ) ; 
              }
          delete [] SgUnknownArrayOrFunctionReferenceStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnknownFile ) ;
     std::cout << " SgUnknownFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnknownFileStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnknownFile ( SgUnknownFileStorageArray[i] ) ; 
              }
          delete [] SgUnknownFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnparse_Info ) ;
     std::cout << " SgUnparse_Info has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnparse_InfoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnparse_Info ( SgUnparse_InfoStorageArray[i] ) ; 
              }
          delete [] SgUnparse_InfoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedCharVal ) ;
     std::cout << " SgUnsignedCharVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedCharValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedCharVal ( SgUnsignedCharValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedCharValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedIntVal ) ;
     std::cout << " SgUnsignedIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedIntVal ( SgUnsignedIntValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedLongLongIntVal ) ;
     std::cout << " SgUnsignedLongLongIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedLongLongIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedLongLongIntVal ( SgUnsignedLongLongIntValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedLongLongIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedLongVal ) ;
     std::cout << " SgUnsignedLongVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedLongValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedLongVal ( SgUnsignedLongValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedLongValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedShortVal ) ;
     std::cout << " SgUnsignedShortVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedShortValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedShortVal ( SgUnsignedShortValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedShortValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcBarrierStatement ) ;
     std::cout << " SgUpcBarrierStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcBarrierStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcBarrierStatement ( SgUpcBarrierStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcBarrierStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcBlocksizeofExpression ) ;
     std::cout << " SgUpcBlocksizeofExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcBlocksizeofExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcBlocksizeofExpression ( SgUpcBlocksizeofExpressionStorageArray[i] ) ; 
              }
          delete [] SgUpcBlocksizeofExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcElemsizeofExpression ) ;
     std::cout << " SgUpcElemsizeofExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcElemsizeofExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcElemsizeofExpression ( SgUpcElemsizeofExpressionStorageArray[i] ) ; 
              }
          delete [] SgUpcElemsizeofExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcFenceStatement ) ;
     std::cout << " SgUpcFenceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcFenceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcFenceStatement ( SgUpcFenceStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcFenceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcForAllStatement ) ;
     std::cout << " SgUpcForAllStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcForAllStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcForAllStatement ( SgUpcForAllStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcForAllStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcLocalsizeofExpression ) ;
     std::cout << " SgUpcLocalsizeofExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcLocalsizeofExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcLocalsizeofExpression ( SgUpcLocalsizeofExpressionStorageArray[i] ) ; 
              }
          delete [] SgUpcLocalsizeofExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcMythread ) ;
     std::cout << " SgUpcMythread has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcMythreadStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcMythread ( SgUpcMythreadStorageArray[i] ) ; 
              }
          delete [] SgUpcMythreadStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcNotifyStatement ) ;
     std::cout << " SgUpcNotifyStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcNotifyStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcNotifyStatement ( SgUpcNotifyStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcNotifyStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcThreads ) ;
     std::cout << " SgUpcThreads has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcThreadsStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcThreads ( SgUpcThreadsStorageArray[i] ) ; 
              }
          delete [] SgUpcThreadsStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcWaitStatement ) ;
     std::cout << " SgUpcWaitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcWaitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcWaitStatement ( SgUpcWaitStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcWaitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUseStatement ) ;
     std::cout << " SgUseStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUseStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUseStatement ( SgUseStatementStorageArray[i] ) ; 
              }
          delete [] SgUseStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUserDefinedBinaryOp ) ;
     std::cout << " SgUserDefinedBinaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUserDefinedBinaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUserDefinedBinaryOp ( SgUserDefinedBinaryOpStorageArray[i] ) ; 
              }
          delete [] SgUserDefinedBinaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUserDefinedUnaryOp ) ;
     std::cout << " SgUserDefinedUnaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUserDefinedUnaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUserDefinedUnaryOp ( SgUserDefinedUnaryOpStorageArray[i] ) ; 
              }
          delete [] SgUserDefinedUnaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUsingDeclarationStatement ) ;
     std::cout << " SgUsingDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUsingDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUsingDeclarationStatement ( SgUsingDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgUsingDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUsingDirectiveStatement ) ;
     std::cout << " SgUsingDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUsingDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUsingDirectiveStatement ( SgUsingDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgUsingDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgValueExp ) ;
     std::cout << " SgValueExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgValueExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgValueExp ( SgValueExpStorageArray[i] ) ; 
              }
          delete [] SgValueExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgCopyOp ) ;
     std::cout << " SgVarArgCopyOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgCopyOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgCopyOp ( SgVarArgCopyOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgCopyOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgEndOp ) ;
     std::cout << " SgVarArgEndOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgEndOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgEndOp ( SgVarArgEndOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgEndOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgOp ) ;
     std::cout << " SgVarArgOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgOp ( SgVarArgOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgStartOneOperandOp ) ;
     std::cout << " SgVarArgStartOneOperandOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgStartOneOperandOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgStartOneOperandOp ( SgVarArgStartOneOperandOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgStartOneOperandOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgStartOp ) ;
     std::cout << " SgVarArgStartOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgStartOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgStartOp ( SgVarArgStartOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgStartOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarRefExp ) ;
     std::cout << " SgVarRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarRefExp ( SgVarRefExpStorageArray[i] ) ; 
              }
          delete [] SgVarRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariableDeclaration ) ;
     std::cout << " SgVariableDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariableDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariableDeclaration ( SgVariableDeclarationStorageArray[i] ) ; 
              }
          delete [] SgVariableDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariableDefinition ) ;
     std::cout << " SgVariableDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariableDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariableDefinition ( SgVariableDefinitionStorageArray[i] ) ; 
              }
          delete [] SgVariableDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariableSymbol ) ;
     std::cout << " SgVariableSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariableSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariableSymbol ( SgVariableSymbolStorageArray[i] ) ; 
              }
          delete [] SgVariableSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariantExpression ) ;
     std::cout << " SgVariantExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariantExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariantExpression ( SgVariantExpressionStorageArray[i] ) ; 
              }
          delete [] SgVariantExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariantStatement ) ;
     std::cout << " SgVariantStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariantStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariantStatement ( SgVariantStatementStorageArray[i] ) ; 
              }
          delete [] SgVariantStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVoidVal ) ;
     std::cout << " SgVoidVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVoidValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVoidVal ( SgVoidValStorageArray[i] ) ; 
              }
          delete [] SgVoidValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWaitStatement ) ;
     std::cout << " SgWaitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWaitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWaitStatement ( SgWaitStatementStorageArray[i] ) ; 
              }
          delete [] SgWaitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWarningDirectiveStatement ) ;
     std::cout << " SgWarningDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWarningDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWarningDirectiveStatement ( SgWarningDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgWarningDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWithStatement ) ;
     std::cout << " SgWithStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWithStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWithStatement ( SgWithStatementStorageArray[i] ) ; 
              }
          delete [] SgWithStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWcharVal ) ;
     std::cout << " SgWcharVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWcharValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWcharVal ( SgWcharValStorageArray[i] ) ; 
              }
          delete [] SgWcharValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWhereStatement ) ;
     std::cout << " SgWhereStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWhereStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWhereStatement ( SgWhereStatementStorageArray[i] ) ; 
              }
          delete [] SgWhereStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWhileStmt ) ;
     std::cout << " SgWhileStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWhileStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWhileStmt ( SgWhileStmtStorageArray[i] ) ; 
              }
          delete [] SgWhileStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWriteStatement ) ;
     std::cout << " SgWriteStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWriteStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWriteStatement ( SgWriteStatementStorageArray[i] ) ; 
              }
          delete [] SgWriteStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgXorAssignOp ) ;
     std::cout << " SgXorAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgXorAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgXorAssignOp ( SgXorAssignOpStorageArray[i] ) ; 
              }
          delete [] SgXorAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgYieldExpression ) ;
     std::cout << " SgYieldExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgYieldExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgYieldExpression ( SgYieldExpressionStorageArray[i] ) ; 
              }
          delete [] SgYieldExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_Sg_File_Info ) ;
     std::cout << " Sg_File_Info has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          Sg_File_InfoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new Sg_File_Info ( Sg_File_InfoStorageArray[i] ) ; 
              }
          delete [] Sg_File_InfoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeCAFTeam ) ;
     std::cout << " SgTypeCAFTeam has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeCAFTeamStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeCAFTeam ( SgTypeCAFTeamStorageArray[i] ) ; 
              }
          delete [] SgTypeCAFTeamStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCAFWithTeamStatement ) ;
     std::cout << " SgCAFWithTeamStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCAFWithTeamStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCAFWithTeamStatement ( SgCAFWithTeamStatementStorageArray[i] ) ; 
              }
          delete [] SgCAFWithTeamStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCAFCoExpression ) ;
     std::cout << " SgCAFCoExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCAFCoExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCAFCoExpression ( SgCAFCoExpressionStorageArray[i] ) ; 
              }
          delete [] SgCAFCoExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCallExpression ) ;
     std::cout << " SgCallExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCallExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCallExpression ( SgCallExpressionStorageArray[i] ) ; 
              }
          delete [] SgCallExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeCrayPointer ) ;
     std::cout << " SgTypeCrayPointer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeCrayPointerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeCrayPointer ( SgTypeCrayPointerStorageArray[i] ) ; 
              }
          delete [] SgTypeCrayPointerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaImportStatement ) ;
     std::cout << " SgJavaImportStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaImportStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaImportStatement ( SgJavaImportStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaImportStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaPackageDeclaration ) ;
     std::cout << " SgJavaPackageDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaPackageDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaPackageDeclaration ( SgJavaPackageDeclarationStorageArray[i] ) ; 
              }
          delete [] SgJavaPackageDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaPackageStatement ) ;
     std::cout << " SgJavaPackageStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaPackageStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaPackageStatement ( SgJavaPackageStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaPackageStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaImportStatementList ) ;
     std::cout << " SgJavaImportStatementList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaImportStatementListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaImportStatementList ( SgJavaImportStatementListStorageArray[i] ) ; 
              }
          delete [] SgJavaImportStatementListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaClassDeclarationList ) ;
     std::cout << " SgJavaClassDeclarationList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaClassDeclarationListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaClassDeclarationList ( SgJavaClassDeclarationListStorageArray[i] ) ; 
              }
          delete [] SgJavaClassDeclarationListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaMemberValuePair ) ;
     std::cout << " SgJavaMemberValuePair has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaMemberValuePairStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaMemberValuePair ( SgJavaMemberValuePairStorageArray[i] ) ; 
              }
          delete [] SgJavaMemberValuePairStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaAnnotation ) ;
     std::cout << " SgJavaAnnotation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaAnnotationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaAnnotation ( SgJavaAnnotationStorageArray[i] ) ; 
              }
          delete [] SgJavaAnnotationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaMarkerAnnotation ) ;
     std::cout << " SgJavaMarkerAnnotation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaMarkerAnnotationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaMarkerAnnotation ( SgJavaMarkerAnnotationStorageArray[i] ) ; 
              }
          delete [] SgJavaMarkerAnnotationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaSingleMemberAnnotation ) ;
     std::cout << " SgJavaSingleMemberAnnotation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaSingleMemberAnnotationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaSingleMemberAnnotation ( SgJavaSingleMemberAnnotationStorageArray[i] ) ; 
              }
          delete [] SgJavaSingleMemberAnnotationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaNormalAnnotation ) ;
     std::cout << " SgJavaNormalAnnotation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaNormalAnnotationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaNormalAnnotation ( SgJavaNormalAnnotationStorageArray[i] ) ; 
              }
          delete [] SgJavaNormalAnnotationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaTypeExpression ) ;
     std::cout << " SgJavaTypeExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaTypeExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaTypeExpression ( SgJavaTypeExpressionStorageArray[i] ) ; 
              }
          delete [] SgJavaTypeExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaQualifiedType ) ;
     std::cout << " SgJavaQualifiedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaQualifiedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaQualifiedType ( SgJavaQualifiedTypeStorageArray[i] ) ; 
              }
          delete [] SgJavaQualifiedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassExp ) ;
     std::cout << " SgClassExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassExp ( SgClassExpStorageArray[i] ) ; 
              }
          delete [] SgClassExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaUnionType ) ;
     std::cout << " SgJavaUnionType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaUnionTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaUnionType ( SgJavaUnionTypeStorageArray[i] ) ; 
              }
          delete [] SgJavaUnionTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaParameterType ) ;
     std::cout << " SgJavaParameterType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaParameterTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaParameterType ( SgJavaParameterTypeStorageArray[i] ) ; 
              }
          delete [] SgJavaParameterTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsyncStmt ) ;
     std::cout << " SgAsyncStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsyncStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsyncStmt ( SgAsyncStmtStorageArray[i] ) ; 
              }
          delete [] SgAsyncStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFinishStmt ) ;
     std::cout << " SgFinishStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFinishStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFinishStmt ( SgFinishStmtStorageArray[i] ) ; 
              }
          delete [] SgFinishStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAtStmt ) ;
     std::cout << " SgAtStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAtStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAtStmt ( SgAtStmtStorageArray[i] ) ; 
              }
          delete [] SgAtStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAtomicStmt ) ;
     std::cout << " SgAtomicStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAtomicStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAtomicStmt ( SgAtomicStmtStorageArray[i] ) ; 
              }
          delete [] SgAtomicStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWhenStmt ) ;
     std::cout << " SgWhenStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWhenStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWhenStmt ( SgWhenStmtStorageArray[i] ) ; 
              }
          delete [] SgWhenStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAtExp ) ;
     std::cout << " SgAtExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAtExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAtExp ( SgAtExpStorageArray[i] ) ; 
              }
          delete [] SgAtExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFinishExp ) ;
     std::cout << " SgFinishExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFinishExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFinishExp ( SgFinishExpStorageArray[i] ) ; 
              }
          delete [] SgFinishExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgHereExp ) ;
     std::cout << " SgHereExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgHereExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgHereExp ( SgHereExpStorageArray[i] ) ; 
              }
          delete [] SgHereExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDotDotExp ) ;
     std::cout << " SgDotDotExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDotDotExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDotDotExp ( SgDotDotExpStorageArray[i] ) ; 
              }
          delete [] SgDotDotExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNullInstruction ) ;
     std::cout << " SgAsmNullInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNullInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNullInstruction ( SgAsmNullInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmNullInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaComponentClause ) ;
     std::cout << " SgAdaComponentClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaComponentClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaComponentClause ( SgAdaComponentClauseStorageArray[i] ) ; 
              }
          delete [] SgAdaComponentClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaIndexConstraint ) ;
     std::cout << " SgAdaIndexConstraint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaIndexConstraintStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaIndexConstraint ( SgAdaIndexConstraintStorageArray[i] ) ; 
              }
          delete [] SgAdaIndexConstraintStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaModularType ) ;
     std::cout << " SgAdaModularType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaModularTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaModularType ( SgAdaModularTypeStorageArray[i] ) ; 
              }
          delete [] SgAdaModularTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaRepresentationClause ) ;
     std::cout << " SgAdaRepresentationClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaRepresentationClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaRepresentationClause ( SgAdaRepresentationClauseStorageArray[i] ) ; 
              }
          delete [] SgAdaRepresentationClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaFunctionRenamingDecl ) ;
     std::cout << " SgAdaFunctionRenamingDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaFunctionRenamingDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaFunctionRenamingDecl ( SgAdaFunctionRenamingDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaFunctionRenamingDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaSelectStmt ) ;
     std::cout << " SgAdaSelectStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaSelectStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaSelectStmt ( SgAdaSelectStmtStorageArray[i] ) ; 
              }
          delete [] SgAdaSelectStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaSelectAlternativeStmt ) ;
     std::cout << " SgAdaSelectAlternativeStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaSelectAlternativeStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaSelectAlternativeStmt ( SgAdaSelectAlternativeStmtStorageArray[i] ) ; 
              }
          delete [] SgAdaSelectAlternativeStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaTerminateStmt ) ;
     std::cout << " SgAdaTerminateStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaTerminateStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaTerminateStmt ( SgAdaTerminateStmtStorageArray[i] ) ; 
              }
          delete [] SgAdaTerminateStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmAarch32Coprocessor ) ;
     std::cout << " SgAsmAarch32Coprocessor has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmAarch32CoprocessorStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmAarch32Coprocessor ( SgAsmAarch32CoprocessorStorageArray[i] ) ; 
              }
          delete [] SgAsmAarch32CoprocessorStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaAttributeClause ) ;
     std::cout << " SgAdaAttributeClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaAttributeClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaAttributeClause ( SgAdaAttributeClauseStorageArray[i] ) ; 
              }
          delete [] SgAdaAttributeClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryConcat ) ;
     std::cout << " SgAsmBinaryConcat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryConcatStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryConcat ( SgAsmBinaryConcatStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryConcatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmByteOrder ) ;
     std::cout << " SgAsmByteOrder has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmByteOrderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmByteOrder ( SgAsmByteOrderStorageArray[i] ) ; 
              }
          delete [] SgAsmByteOrderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaDerivedType ) ;
     std::cout << " SgAdaDerivedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaDerivedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaDerivedType ( SgAdaDerivedTypeStorageArray[i] ) ; 
              }
          delete [] SgAdaDerivedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaAttributeExp ) ;
     std::cout << " SgAdaAttributeExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaAttributeExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaAttributeExp ( SgAdaAttributeExpStorageArray[i] ) ; 
              }
          delete [] SgAdaAttributeExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaEnumRepresentationClause ) ;
     std::cout << " SgAdaEnumRepresentationClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaEnumRepresentationClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaEnumRepresentationClause ( SgAdaEnumRepresentationClauseStorageArray[i] ) ; 
              }
          delete [] SgAdaEnumRepresentationClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryPreupdate ) ;
     std::cout << " SgAsmBinaryPreupdate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryPreupdateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryPreupdate ( SgAsmBinaryPreupdateStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryPreupdateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryPostupdate ) ;
     std::cout << " SgAsmBinaryPostupdate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryPostupdateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryPostupdate ( SgAsmBinaryPostupdateStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryPostupdateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaOthersExp ) ;
     std::cout << " SgAdaOthersExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaOthersExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaOthersExp ( SgAdaOthersExpStorageArray[i] ) ; 
              }
          delete [] SgAdaOthersExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaRenamingSymbol ) ;
     std::cout << " SgAdaRenamingSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaRenamingSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaRenamingSymbol ( SgAdaRenamingSymbolStorageArray[i] ) ; 
              }
          delete [] SgAdaRenamingSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaRenamingRefExp ) ;
     std::cout << " SgAdaRenamingRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaRenamingRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaRenamingRefExp ( SgAdaRenamingRefExpStorageArray[i] ) ; 
              }
          delete [] SgAdaRenamingRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaGenericDecl ) ;
     std::cout << " SgAdaGenericDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaGenericDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaGenericDecl ( SgAdaGenericDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaGenericDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaGenericDefn ) ;
     std::cout << " SgAdaGenericDefn has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaGenericDefnStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaGenericDefn ( SgAdaGenericDefnStorageArray[i] ) ; 
              }
          delete [] SgAdaGenericDefnStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaFormalType ) ;
     std::cout << " SgAdaFormalType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaFormalTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaFormalType ( SgAdaFormalTypeStorageArray[i] ) ; 
              }
          delete [] SgAdaFormalTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaGenericSymbol ) ;
     std::cout << " SgAdaGenericSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaGenericSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaGenericSymbol ( SgAdaGenericSymbolStorageArray[i] ) ; 
              }
          delete [] SgAdaGenericSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaFormalTypeDecl ) ;
     std::cout << " SgAdaFormalTypeDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaFormalTypeDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaFormalTypeDecl ( SgAdaFormalTypeDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaFormalTypeDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaUnitRefExp ) ;
     std::cout << " SgAdaUnitRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaUnitRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaUnitRefExp ( SgAdaUnitRefExpStorageArray[i] ) ; 
              }
          delete [] SgAdaUnitRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaDiscriminatedTypeDecl ) ;
     std::cout << " SgAdaDiscriminatedTypeDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaDiscriminatedTypeDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaDiscriminatedTypeDecl ( SgAdaDiscriminatedTypeDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaDiscriminatedTypeDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaDiscriminatedType ) ;
     std::cout << " SgAdaDiscriminatedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaDiscriminatedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaDiscriminatedType ( SgAdaDiscriminatedTypeStorageArray[i] ) ; 
              }
          delete [] SgAdaDiscriminatedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaDiscriminantConstraint ) ;
     std::cout << " SgAdaDiscriminantConstraint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaDiscriminantConstraintStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaDiscriminantConstraint ( SgAdaDiscriminantConstraintStorageArray[i] ) ; 
              }
          delete [] SgAdaDiscriminantConstraintStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaGenericInstanceDecl ) ;
     std::cout << " SgAdaGenericInstanceDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaGenericInstanceDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaGenericInstanceDecl ( SgAdaGenericInstanceDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaGenericInstanceDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaUnscopedBlock ) ;
     std::cout << " SgAdaUnscopedBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaUnscopedBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaUnscopedBlock ( SgAdaUnscopedBlockStorageArray[i] ) ; 
              }
          delete [] SgAdaUnscopedBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaInheritedFunctionSymbol ) ;
     std::cout << " SgAdaInheritedFunctionSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaInheritedFunctionSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaInheritedFunctionSymbol ( SgAdaInheritedFunctionSymbolStorageArray[i] ) ; 
              }
          delete [] SgAdaInheritedFunctionSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaProtectedBody ) ;
     std::cout << " SgAdaProtectedBody has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaProtectedBodyStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaProtectedBody ( SgAdaProtectedBodyStorageArray[i] ) ; 
              }
          delete [] SgAdaProtectedBodyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaProtectedBodyDecl ) ;
     std::cout << " SgAdaProtectedBodyDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaProtectedBodyDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaProtectedBodyDecl ( SgAdaProtectedBodyDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaProtectedBodyDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaProtectedSpec ) ;
     std::cout << " SgAdaProtectedSpec has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaProtectedSpecStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaProtectedSpec ( SgAdaProtectedSpecStorageArray[i] ) ; 
              }
          delete [] SgAdaProtectedSpecStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaProtectedSpecDecl ) ;
     std::cout << " SgAdaProtectedSpecDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaProtectedSpecDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaProtectedSpecDecl ( SgAdaProtectedSpecDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaProtectedSpecDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaProtectedSymbol ) ;
     std::cout << " SgAdaProtectedSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaProtectedSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaProtectedSymbol ( SgAdaProtectedSymbolStorageArray[i] ) ; 
              }
          delete [] SgAdaProtectedSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaProtectedRefExp ) ;
     std::cout << " SgAdaProtectedRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaProtectedRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaProtectedRefExp ( SgAdaProtectedRefExpStorageArray[i] ) ; 
              }
          delete [] SgAdaProtectedRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaProtectedType ) ;
     std::cout << " SgAdaProtectedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaProtectedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaProtectedType ( SgAdaProtectedTypeStorageArray[i] ) ; 
              }
          delete [] SgAdaProtectedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaProtectedTypeDecl ) ;
     std::cout << " SgAdaProtectedTypeDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaProtectedTypeDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaProtectedTypeDecl ( SgAdaProtectedTypeDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaProtectedTypeDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaDigitsConstraint ) ;
     std::cout << " SgAdaDigitsConstraint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaDigitsConstraintStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaDigitsConstraint ( SgAdaDigitsConstraintStorageArray[i] ) ; 
              }
          delete [] SgAdaDigitsConstraintStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaAncestorInitializer ) ;
     std::cout << " SgAdaAncestorInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaAncestorInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaAncestorInitializer ( SgAdaAncestorInitializerStorageArray[i] ) ; 
              }
          delete [] SgAdaAncestorInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaDeltaConstraint ) ;
     std::cout << " SgAdaDeltaConstraint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaDeltaConstraintStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaDeltaConstraint ( SgAdaDeltaConstraintStorageArray[i] ) ; 
              }
          delete [] SgAdaDeltaConstraintStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaSubroutineType ) ;
     std::cout << " SgAdaSubroutineType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaSubroutineTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaSubroutineType ( SgAdaSubroutineTypeStorageArray[i] ) ; 
              }
          delete [] SgAdaSubroutineTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaGenericInstanceSymbol ) ;
     std::cout << " SgAdaGenericInstanceSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaGenericInstanceSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaGenericInstanceSymbol ( SgAdaGenericInstanceSymbolStorageArray[i] ) ; 
              }
          delete [] SgAdaGenericInstanceSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaFormalPackageDecl ) ;
     std::cout << " SgAdaFormalPackageDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaFormalPackageDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaFormalPackageDecl ( SgAdaFormalPackageDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaFormalPackageDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaFormalPackageSymbol ) ;
     std::cout << " SgAdaFormalPackageSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaFormalPackageSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaFormalPackageSymbol ( SgAdaFormalPackageSymbolStorageArray[i] ) ; 
              }
          delete [] SgAdaFormalPackageSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmAttributeTable ) ;
     std::cout << " SgAsmJvmAttributeTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmAttributeTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmAttributeTable ( SgAsmJvmAttributeTableStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmAttributeTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmMethodTable ) ;
     std::cout << " SgAsmJvmMethodTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmMethodTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmMethodTable ( SgAsmJvmMethodTableStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmMethodTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmField ) ;
     std::cout << " SgAsmJvmField has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmField ( SgAsmJvmFieldStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmFieldStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmFieldTable ) ;
     std::cout << " SgAsmJvmFieldTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmFieldTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmFieldTable ( SgAsmJvmFieldTableStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmFieldTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmExceptionHandler ) ;
     std::cout << " SgAsmJvmExceptionHandler has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmExceptionHandler ( SgAsmJvmExceptionHandlerStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmExceptionHandlerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmExceptionTable ) ;
     std::cout << " SgAsmJvmExceptionTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmExceptionTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmExceptionTable ( SgAsmJvmExceptionTableStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmExceptionTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmClass ) ;
     std::cout << " SgAsmJvmClass has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmClass ( SgAsmJvmClassStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmClassStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmLineNumberEntry ) ;
     std::cout << " SgAsmJvmLineNumberEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmLineNumberEntry ( SgAsmJvmLineNumberEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmLineNumberEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmLineNumberTable ) ;
     std::cout << " SgAsmJvmLineNumberTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmLineNumberTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmLineNumberTable ( SgAsmJvmLineNumberTableStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmLineNumberTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmInnerClassesEntry ) ;
     std::cout << " SgAsmJvmInnerClassesEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmInnerClassesEntry ( SgAsmJvmInnerClassesEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmInnerClassesEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmInnerClasses ) ;
     std::cout << " SgAsmJvmInnerClasses has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmInnerClassesStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmInnerClasses ( SgAsmJvmInnerClassesStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmInnerClassesStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilInstruction ) ;
     std::cout << " SgAsmCilInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilInstruction ( SgAsmCilInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmCilInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStackExpression ) ;
     std::cout << " SgAsmStackExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStackExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStackExpression ( SgAsmStackExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmStackExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmEnclosingMethod ) ;
     std::cout << " SgAsmJvmEnclosingMethod has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmEnclosingMethod ( SgAsmJvmEnclosingMethodStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmEnclosingMethodStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaNullConstraint ) ;
     std::cout << " SgAdaNullConstraint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaNullConstraintStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaNullConstraint ( SgAdaNullConstraintStorageArray[i] ) ; 
              }
          delete [] SgAdaNullConstraintStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmModuleMainClass ) ;
     std::cout << " SgAsmJvmModuleMainClass has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmModuleMainClass ( SgAsmJvmModuleMainClassStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmModuleMainClassStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmInstructionList ) ;
     std::cout << " SgAsmInstructionList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmInstructionListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmInstructionList ( SgAsmInstructionListStorageArray[i] ) ; 
              }
          delete [] SgAsmInstructionListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilNode ) ;
     std::cout << " SgAsmCilNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilNode ( SgAsmCilNodeStorageArray[i] ) ; 
              }
          delete [] SgAsmCilNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssembly ) ;
     std::cout << " SgAsmCilAssembly has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssembly ( SgAsmCilAssemblyStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyOS ) ;
     std::cout << " SgAsmCilAssemblyOS has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyOS ( SgAsmCilAssemblyOSStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyOSStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyProcessor ) ;
     std::cout << " SgAsmCilAssemblyProcessor has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyProcessor ( SgAsmCilAssemblyProcessorStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyProcessorStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyRef ) ;
     std::cout << " SgAsmCilAssemblyRef has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyRef ( SgAsmCilAssemblyRefStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyRefStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyRefOS ) ;
     std::cout << " SgAsmCilAssemblyRefOS has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyRefOS ( SgAsmCilAssemblyRefOSStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyRefOSStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyRefProcessor ) ;
     std::cout << " SgAsmCilAssemblyRefProcessor has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyRefProcessor ( SgAsmCilAssemblyRefProcessorStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyRefProcessorStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilClassLayout ) ;
     std::cout << " SgAsmCilClassLayout has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilClassLayout ( SgAsmCilClassLayoutStorageArray[i] ) ; 
              }
          delete [] SgAsmCilClassLayoutStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilConstant ) ;
     std::cout << " SgAsmCilConstant has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilConstant ( SgAsmCilConstantStorageArray[i] ) ; 
              }
          delete [] SgAsmCilConstantStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilCustomAttribute ) ;
     std::cout << " SgAsmCilCustomAttribute has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilCustomAttribute ( SgAsmCilCustomAttributeStorageArray[i] ) ; 
              }
          delete [] SgAsmCilCustomAttributeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilDeclSecurity ) ;
     std::cout << " SgAsmCilDeclSecurity has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilDeclSecurity ( SgAsmCilDeclSecurityStorageArray[i] ) ; 
              }
          delete [] SgAsmCilDeclSecurityStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilEvent ) ;
     std::cout << " SgAsmCilEvent has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilEvent ( SgAsmCilEventStorageArray[i] ) ; 
              }
          delete [] SgAsmCilEventStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilEventMap ) ;
     std::cout << " SgAsmCilEventMap has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilEventMap ( SgAsmCilEventMapStorageArray[i] ) ; 
              }
          delete [] SgAsmCilEventMapStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilExportedType ) ;
     std::cout << " SgAsmCilExportedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilExportedType ( SgAsmCilExportedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmCilExportedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilField ) ;
     std::cout << " SgAsmCilField has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilField ( SgAsmCilFieldStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFieldStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilFieldLayout ) ;
     std::cout << " SgAsmCilFieldLayout has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilFieldLayout ( SgAsmCilFieldLayoutStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFieldLayoutStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilFieldMarshal ) ;
     std::cout << " SgAsmCilFieldMarshal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilFieldMarshal ( SgAsmCilFieldMarshalStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFieldMarshalStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilFieldRVA ) ;
     std::cout << " SgAsmCilFieldRVA has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilFieldRVA ( SgAsmCilFieldRVAStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFieldRVAStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilFile ) ;
     std::cout << " SgAsmCilFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilFile ( SgAsmCilFileStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilGenericParam ) ;
     std::cout << " SgAsmCilGenericParam has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilGenericParam ( SgAsmCilGenericParamStorageArray[i] ) ; 
              }
          delete [] SgAsmCilGenericParamStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilGenericParamConstraint ) ;
     std::cout << " SgAsmCilGenericParamConstraint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilGenericParamConstraint ( SgAsmCilGenericParamConstraintStorageArray[i] ) ; 
              }
          delete [] SgAsmCilGenericParamConstraintStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilImplMap ) ;
     std::cout << " SgAsmCilImplMap has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilImplMap ( SgAsmCilImplMapStorageArray[i] ) ; 
              }
          delete [] SgAsmCilImplMapStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilInterfaceImpl ) ;
     std::cout << " SgAsmCilInterfaceImpl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilInterfaceImpl ( SgAsmCilInterfaceImplStorageArray[i] ) ; 
              }
          delete [] SgAsmCilInterfaceImplStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilManifestResource ) ;
     std::cout << " SgAsmCilManifestResource has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilManifestResource ( SgAsmCilManifestResourceStorageArray[i] ) ; 
              }
          delete [] SgAsmCilManifestResourceStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMemberRef ) ;
     std::cout << " SgAsmCilMemberRef has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMemberRef ( SgAsmCilMemberRefStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMemberRefStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMethodDef ) ;
     std::cout << " SgAsmCilMethodDef has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilMethodDefStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMethodDef ( SgAsmCilMethodDefStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMethodDefStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMethodImpl ) ;
     std::cout << " SgAsmCilMethodImpl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMethodImpl ( SgAsmCilMethodImplStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMethodImplStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMethodSemantics ) ;
     std::cout << " SgAsmCilMethodSemantics has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMethodSemantics ( SgAsmCilMethodSemanticsStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMethodSemanticsStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMethodSpec ) ;
     std::cout << " SgAsmCilMethodSpec has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMethodSpec ( SgAsmCilMethodSpecStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMethodSpecStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilModule ) ;
     std::cout << " SgAsmCilModule has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilModule ( SgAsmCilModuleStorageArray[i] ) ; 
              }
          delete [] SgAsmCilModuleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilModuleRef ) ;
     std::cout << " SgAsmCilModuleRef has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilModuleRef ( SgAsmCilModuleRefStorageArray[i] ) ; 
              }
          delete [] SgAsmCilModuleRefStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilNestedClass ) ;
     std::cout << " SgAsmCilNestedClass has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilNestedClass ( SgAsmCilNestedClassStorageArray[i] ) ; 
              }
          delete [] SgAsmCilNestedClassStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilParam ) ;
     std::cout << " SgAsmCilParam has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilParam ( SgAsmCilParamStorageArray[i] ) ; 
              }
          delete [] SgAsmCilParamStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilProperty ) ;
     std::cout << " SgAsmCilProperty has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilProperty ( SgAsmCilPropertyStorageArray[i] ) ; 
              }
          delete [] SgAsmCilPropertyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilPropertyMap ) ;
     std::cout << " SgAsmCilPropertyMap has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilPropertyMap ( SgAsmCilPropertyMapStorageArray[i] ) ; 
              }
          delete [] SgAsmCilPropertyMapStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilStandAloneSig ) ;
     std::cout << " SgAsmCilStandAloneSig has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilStandAloneSig ( SgAsmCilStandAloneSigStorageArray[i] ) ; 
              }
          delete [] SgAsmCilStandAloneSigStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilTypeDef ) ;
     std::cout << " SgAsmCilTypeDef has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilTypeDef ( SgAsmCilTypeDefStorageArray[i] ) ; 
              }
          delete [] SgAsmCilTypeDefStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilTypeRef ) ;
     std::cout << " SgAsmCilTypeRef has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilTypeRef ( SgAsmCilTypeRefStorageArray[i] ) ; 
              }
          delete [] SgAsmCilTypeRefStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilTypeSpec ) ;
     std::cout << " SgAsmCilTypeSpec has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilTypeSpec ( SgAsmCilTypeSpecStorageArray[i] ) ; 
              }
          delete [] SgAsmCilTypeSpecStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaParameterList ) ;
     std::cout << " SgAdaParameterList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaParameterListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaParameterList ( SgAdaParameterListStorageArray[i] ) ; 
              }
          delete [] SgAdaParameterListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMetadata ) ;
     std::cout << " SgAsmCilMetadata has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMetadata ( SgAsmCilMetadataStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMetadataStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMetadataRoot ) ;
     std::cout << " SgAsmCilMetadataRoot has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilMetadataRootStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMetadataRoot ( SgAsmCilMetadataRootStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMetadataRootStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilDataStream ) ;
     std::cout << " SgAsmCilDataStream has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilDataStreamStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilDataStream ( SgAsmCilDataStreamStorageArray[i] ) ; 
              }
          delete [] SgAsmCilDataStreamStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMetadataHeap ) ;
     std::cout << " SgAsmCilMetadataHeap has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilMetadataHeapStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMetadataHeap ( SgAsmCilMetadataHeapStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMetadataHeapStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilUint8Heap ) ;
     std::cout << " SgAsmCilUint8Heap has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilUint8HeapStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilUint8Heap ( SgAsmCilUint8HeapStorageArray[i] ) ; 
              }
          delete [] SgAsmCilUint8HeapStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilUint32Heap ) ;
     std::cout << " SgAsmCilUint32Heap has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilUint32HeapStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilUint32Heap ( SgAsmCilUint32HeapStorageArray[i] ) ; 
              }
          delete [] SgAsmCilUint32HeapStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCliHeader ) ;
     std::cout << " SgAsmCliHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCliHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCliHeader ( SgAsmCliHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmCliHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaVariantDecl ) ;
     std::cout << " SgAdaVariantDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaVariantDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaVariantDecl ( SgAdaVariantDeclStorageArray[i] ) ; 
              }
          delete [] SgAdaVariantDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAdaVariantWhenStmt ) ;
     std::cout << " SgAdaVariantWhenStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAdaVariantWhenStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAdaVariantWhenStmt ( SgAdaVariantWhenStmtStorageArray[i] ) ; 
              }
          delete [] SgAdaVariantWhenStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyTable ) ;
     std::cout << " SgAsmCilAssemblyTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilAssemblyTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyTable ( SgAsmCilAssemblyTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyOSTable ) ;
     std::cout << " SgAsmCilAssemblyOSTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilAssemblyOSTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyOSTable ( SgAsmCilAssemblyOSTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyOSTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyProcessorTable ) ;
     std::cout << " SgAsmCilAssemblyProcessorTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilAssemblyProcessorTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyProcessorTable ( SgAsmCilAssemblyProcessorTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyProcessorTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyRefTable ) ;
     std::cout << " SgAsmCilAssemblyRefTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilAssemblyRefTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyRefTable ( SgAsmCilAssemblyRefTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyRefTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyRefOSTable ) ;
     std::cout << " SgAsmCilAssemblyRefOSTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilAssemblyRefOSTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyRefOSTable ( SgAsmCilAssemblyRefOSTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyRefOSTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilAssemblyRefProcessorTable ) ;
     std::cout << " SgAsmCilAssemblyRefProcessorTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilAssemblyRefProcessorTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilAssemblyRefProcessorTable ( SgAsmCilAssemblyRefProcessorTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilAssemblyRefProcessorTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilClassLayoutTable ) ;
     std::cout << " SgAsmCilClassLayoutTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilClassLayoutTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilClassLayoutTable ( SgAsmCilClassLayoutTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilClassLayoutTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilConstantTable ) ;
     std::cout << " SgAsmCilConstantTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilConstantTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilConstantTable ( SgAsmCilConstantTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilConstantTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilCustomAttributeTable ) ;
     std::cout << " SgAsmCilCustomAttributeTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilCustomAttributeTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilCustomAttributeTable ( SgAsmCilCustomAttributeTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilCustomAttributeTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilDeclSecurityTable ) ;
     std::cout << " SgAsmCilDeclSecurityTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilDeclSecurityTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilDeclSecurityTable ( SgAsmCilDeclSecurityTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilDeclSecurityTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilEventTable ) ;
     std::cout << " SgAsmCilEventTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilEventTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilEventTable ( SgAsmCilEventTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilEventTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilEventMapTable ) ;
     std::cout << " SgAsmCilEventMapTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilEventMapTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilEventMapTable ( SgAsmCilEventMapTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilEventMapTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilExportedTypeTable ) ;
     std::cout << " SgAsmCilExportedTypeTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilExportedTypeTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilExportedTypeTable ( SgAsmCilExportedTypeTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilExportedTypeTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilFieldTable ) ;
     std::cout << " SgAsmCilFieldTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilFieldTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilFieldTable ( SgAsmCilFieldTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFieldTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilFieldLayoutTable ) ;
     std::cout << " SgAsmCilFieldLayoutTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilFieldLayoutTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilFieldLayoutTable ( SgAsmCilFieldLayoutTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFieldLayoutTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilFieldMarshalTable ) ;
     std::cout << " SgAsmCilFieldMarshalTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilFieldMarshalTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilFieldMarshalTable ( SgAsmCilFieldMarshalTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFieldMarshalTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilFieldRVATable ) ;
     std::cout << " SgAsmCilFieldRVATable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilFieldRVATableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilFieldRVATable ( SgAsmCilFieldRVATableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFieldRVATableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilFileTable ) ;
     std::cout << " SgAsmCilFileTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilFileTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilFileTable ( SgAsmCilFileTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilFileTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilGenericParamTable ) ;
     std::cout << " SgAsmCilGenericParamTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilGenericParamTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilGenericParamTable ( SgAsmCilGenericParamTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilGenericParamTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilGenericParamConstraintTable ) ;
     std::cout << " SgAsmCilGenericParamConstraintTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilGenericParamConstraintTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilGenericParamConstraintTable ( SgAsmCilGenericParamConstraintTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilGenericParamConstraintTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilImplMapTable ) ;
     std::cout << " SgAsmCilImplMapTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilImplMapTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilImplMapTable ( SgAsmCilImplMapTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilImplMapTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilInterfaceImplTable ) ;
     std::cout << " SgAsmCilInterfaceImplTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilInterfaceImplTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilInterfaceImplTable ( SgAsmCilInterfaceImplTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilInterfaceImplTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilManifestResourceTable ) ;
     std::cout << " SgAsmCilManifestResourceTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilManifestResourceTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilManifestResourceTable ( SgAsmCilManifestResourceTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilManifestResourceTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMemberRefTable ) ;
     std::cout << " SgAsmCilMemberRefTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilMemberRefTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMemberRefTable ( SgAsmCilMemberRefTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMemberRefTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMethodDefTable ) ;
     std::cout << " SgAsmCilMethodDefTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilMethodDefTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMethodDefTable ( SgAsmCilMethodDefTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMethodDefTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMethodImplTable ) ;
     std::cout << " SgAsmCilMethodImplTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilMethodImplTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMethodImplTable ( SgAsmCilMethodImplTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMethodImplTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMethodSemanticsTable ) ;
     std::cout << " SgAsmCilMethodSemanticsTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilMethodSemanticsTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMethodSemanticsTable ( SgAsmCilMethodSemanticsTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMethodSemanticsTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMethodSpecTable ) ;
     std::cout << " SgAsmCilMethodSpecTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilMethodSpecTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMethodSpecTable ( SgAsmCilMethodSpecTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMethodSpecTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilModuleTable ) ;
     std::cout << " SgAsmCilModuleTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilModuleTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilModuleTable ( SgAsmCilModuleTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilModuleTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilModuleRefTable ) ;
     std::cout << " SgAsmCilModuleRefTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilModuleRefTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilModuleRefTable ( SgAsmCilModuleRefTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilModuleRefTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilNestedClassTable ) ;
     std::cout << " SgAsmCilNestedClassTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilNestedClassTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilNestedClassTable ( SgAsmCilNestedClassTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilNestedClassTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilParamTable ) ;
     std::cout << " SgAsmCilParamTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilParamTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilParamTable ( SgAsmCilParamTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilParamTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilPropertyTable ) ;
     std::cout << " SgAsmCilPropertyTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilPropertyTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilPropertyTable ( SgAsmCilPropertyTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilPropertyTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilPropertyMapTable ) ;
     std::cout << " SgAsmCilPropertyMapTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilPropertyMapTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilPropertyMapTable ( SgAsmCilPropertyMapTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilPropertyMapTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilStandAloneSigTable ) ;
     std::cout << " SgAsmCilStandAloneSigTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilStandAloneSigTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilStandAloneSigTable ( SgAsmCilStandAloneSigTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilStandAloneSigTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilTypeDefTable ) ;
     std::cout << " SgAsmCilTypeDefTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilTypeDefTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilTypeDefTable ( SgAsmCilTypeDefTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilTypeDefTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilTypeRefTable ) ;
     std::cout << " SgAsmCilTypeRefTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilTypeRefTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilTypeRefTable ( SgAsmCilTypeRefTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilTypeRefTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilTypeSpecTable ) ;
     std::cout << " SgAsmCilTypeSpecTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilTypeSpecTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilTypeSpecTable ( SgAsmCilTypeSpecTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCilTypeSpecTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJvmComposite ) ;
     std::cout << " SgJvmComposite has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJvmCompositeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJvmComposite ( SgJvmCompositeStorageArray[i] ) ; 
              }
          delete [] SgJvmCompositeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFortranContinueStmt ) ;
     std::cout << " SgFortranContinueStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFortranContinueStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFortranContinueStmt ( SgFortranContinueStmtStorageArray[i] ) ; 
              }
          delete [] SgFortranContinueStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmStackMapTable ) ;
     std::cout << " SgAsmJvmStackMapTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmStackMapTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmStackMapTable ( SgAsmJvmStackMapTableStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmStackMapTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmStackMapFrame ) ;
     std::cout << " SgAsmJvmStackMapFrame has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmStackMapFrameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmStackMapFrame ( SgAsmJvmStackMapFrameStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmStackMapFrameStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmStackMapVerificationType ) ;
     std::cout << " SgAsmJvmStackMapVerificationType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmStackMapVerificationType ( SgAsmJvmStackMapVerificationTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmStackMapVerificationTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmBootstrapMethod ) ;
     std::cout << " SgAsmJvmBootstrapMethod has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmBootstrapMethodStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmBootstrapMethod ( SgAsmJvmBootstrapMethodStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmBootstrapMethodStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmBootstrapMethods ) ;
     std::cout << " SgAsmJvmBootstrapMethods has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmBootstrapMethodsStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmBootstrapMethods ( SgAsmJvmBootstrapMethodsStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmBootstrapMethodsStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmExceptions ) ;
     std::cout << " SgAsmJvmExceptions has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmExceptionsStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmExceptions ( SgAsmJvmExceptionsStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmExceptionsStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmNestMembers ) ;
     std::cout << " SgAsmJvmNestMembers has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmNestMembersStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmNestMembers ( SgAsmJvmNestMembersStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmNestMembersStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmNestHost ) ;
     std::cout << " SgAsmJvmNestHost has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmNestHost ( SgAsmJvmNestHostStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmNestHostStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJovialLabelDeclaration ) ;
     std::cout << " SgJovialLabelDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJovialLabelDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJovialLabelDeclaration ( SgJovialLabelDeclarationStorageArray[i] ) ; 
              }
          delete [] SgJovialLabelDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmLocalVariableEntry ) ;
     std::cout << " SgAsmJvmLocalVariableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmLocalVariableEntry ( SgAsmJvmLocalVariableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmLocalVariableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmLocalVariableTable ) ;
     std::cout << " SgAsmJvmLocalVariableTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmLocalVariableTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmLocalVariableTable ( SgAsmJvmLocalVariableTableStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmLocalVariableTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmLocalVariableTypeEntry ) ;
     std::cout << " SgAsmJvmLocalVariableTypeEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmLocalVariableTypeEntry ( SgAsmJvmLocalVariableTypeEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmLocalVariableTypeEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmLocalVariableTypeTable ) ;
     std::cout << " SgAsmJvmLocalVariableTypeTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmLocalVariableTypeTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmLocalVariableTypeTable ( SgAsmJvmLocalVariableTypeTableStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmLocalVariableTypeTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUserInstruction ) ;
     std::cout << " SgAsmUserInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUserInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUserInstruction ( SgAsmUserInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmUserInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmMethodParameters ) ;
     std::cout << " SgAsmJvmMethodParameters has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmJvmMethodParametersStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmMethodParameters ( SgAsmJvmMethodParametersStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmMethodParametersStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmMethodParametersEntry ) ;
     std::cout << " SgAsmJvmMethodParametersEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmMethodParametersEntry ( SgAsmJvmMethodParametersEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmMethodParametersEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmVoidType ) ;
     std::cout << " SgAsmVoidType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmVoidType ( SgAsmVoidTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmVoidTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPointerType ) ;
     std::cout << " SgAsmPointerType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPointerType ( SgAsmPointerTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmPointerTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRangeType ) ;
     std::cout << " SgRangeType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRangeTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRangeType ( SgRangeTypeStorageArray[i] ) ; 
              }
          delete [] SgRangeTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilExceptionData ) ;
     std::cout << " SgAsmCilExceptionData has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilExceptionData ( SgAsmCilExceptionDataStorageArray[i] ) ; 
              }
          delete [] SgAsmCilExceptionDataStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilMethodData ) ;
     std::cout << " SgAsmCilMethodData has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilMethodDataStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilMethodData ( SgAsmCilMethodDataStorageArray[i] ) ; 
              }
          delete [] SgAsmCilMethodDataStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateVariableInstantiation ) ;
     std::cout << " SgTemplateVariableInstantiation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateVariableInstantiationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateVariableInstantiation ( SgTemplateVariableInstantiationStorageArray[i] ) ; 
              }
          delete [] SgTemplateVariableInstantiationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgReferenceExp ) ;
     std::cout << " SgReferenceExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgReferenceExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgReferenceExp ( SgReferenceExpStorageArray[i] ) ; 
              }
          delete [] SgReferenceExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeRefExp ) ;
     std::cout << " SgTypeRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeRefExp ( SgTypeRefExpStorageArray[i] ) ; 
              }
          delete [] SgTypeRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgScopedRefExp ) ;
     std::cout << " SgScopedRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgScopedRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgScopedRefExp ( SgScopedRefExpStorageArray[i] ) ; 
              }
          delete [] SgScopedRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgScopedType ) ;
     std::cout << " SgScopedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgScopedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgScopedType ( SgScopedTypeStorageArray[i] ) ; 
              }
          delete [] SgScopedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSymbol ) ;
     std::cout << " SgTypeSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSymbol ( SgTypeSymbolStorageArray[i] ) ; 
              }
          delete [] SgTypeSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmSynthetic ) ;
     std::cout << " SgAsmJvmSynthetic has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmSynthetic ( SgAsmJvmSyntheticStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmSyntheticStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmJvmDeprecated ) ;
     std::cout << " SgAsmJvmDeprecated has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmJvmDeprecated ( SgAsmJvmDeprecatedStorageArray[i] ) ; 
              }
          delete [] SgAsmJvmDeprecatedStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSignedCharVal ) ;
     std::cout << " SgSignedCharVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSignedCharValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSignedCharVal ( SgSignedCharValStorageArray[i] ) ; 
              }
          delete [] SgSignedCharValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCilErrorHeap ) ;
     std::cout << " SgAsmCilErrorHeap has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCilErrorHeapStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCilErrorHeap ( SgAsmCilErrorHeapStorageArray[i] ) ; 
              }
          delete [] SgAsmCilErrorHeapStorageArray;
        } 

/* #line 251 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

#if FILE_IO_EXTRA_CHECK
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::compressAstInMemoryPool() FILE_IO_EXTRA_CHECK:");
 
     for ( int i = 0; i < totalNumberOfIRNodes; ++i)
        {
          listOfMemoryPoolSizes[i] += getPoolSizeOfNewAst(i);
        }
     listOfMemoryPoolSizes[totalNumberOfIRNodes] += getTotalNumberOfNodesOfNewAst();
  // std::cout << "Starting check, that all IRNodes are in the memory pools ... " << std::flush;
#if FILE_IO_MEMORY_POOL_CHECK
  // AST_FileIO::MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     memoryCheckingTraversal.traverseMemoryPool();
#endif
     // std::cout << "  done ! " << std::endl;
#endif

   }


void
AST_FILE_IO :: resetValidAstAfterWriting ( )
   {
// DQ (2/26/2010): Test this uncommented.
#if 1
     SgAccessModifier::resetValidFreepointers( );
     SgActualArgumentExpression::resetValidFreepointers( );
     SgAbsOp::resetValidFreepointers( );
     SgAdaAccessType::resetValidFreepointers( );
     SgAdaAcceptStmt::resetValidFreepointers( );
     SgAdaDelayStmt::resetValidFreepointers( );
     SgAdaEntryDecl::resetValidFreepointers( );
     SgAdaExitStmt::resetValidFreepointers( );
     SgAdaDiscreteType::resetValidFreepointers( );
     SgAdaFloatVal::resetValidFreepointers( );
     SgAdaLoopStmt::resetValidFreepointers( );
     SgAdaPackageBody::resetValidFreepointers( );
     SgAdaPackageBodyDecl::resetValidFreepointers( );
     SgAdaPackageSpec::resetValidFreepointers( );
     SgAdaPackageSpecDecl::resetValidFreepointers( );
     SgAdaPackageSymbol::resetValidFreepointers( );
     SgAdaRangeConstraint::resetValidFreepointers( );
     SgAdaRenamingDecl::resetValidFreepointers( );
     SgAdaSubtype::resetValidFreepointers( );
     SgAdaTaskBody::resetValidFreepointers( );
     SgAdaTaskBodyDecl::resetValidFreepointers( );
     SgAdaTaskSpec::resetValidFreepointers( );
     SgAdaTaskSpecDecl::resetValidFreepointers( );
     SgAdaTaskSymbol::resetValidFreepointers( );
     SgAdaTaskRefExp::resetValidFreepointers( );
     SgAdaTaskType::resetValidFreepointers( );
     SgAdaTaskTypeDecl::resetValidFreepointers( );
     SgAdaTypeConstraint::resetValidFreepointers( );
     SgAddOp::resetValidFreepointers( );
     SgAddressOfOp::resetValidFreepointers( );
     SgAggregateInitializer::resetValidFreepointers( );
     SgAliasSymbol::resetValidFreepointers( );
     SgAllocateStatement::resetValidFreepointers( );
     SgAndAssignOp::resetValidFreepointers( );
     SgAndOp::resetValidFreepointers( );
     SgArithmeticIfStatement::resetValidFreepointers( );
     SgArrayType::resetValidFreepointers( );
     SgArrowExp::resetValidFreepointers( );
     SgArrowStarOp::resetValidFreepointers( );
     SgAsmBasicString::resetValidFreepointers( );
     SgAsmBinaryAdd::resetValidFreepointers( );
     SgAsmBinaryAsr::resetValidFreepointers( );
     SgAsmBinaryDivide::resetValidFreepointers( );
     SgAsmBinaryExpression::resetValidFreepointers( );
     SgAsmBinaryLsl::resetValidFreepointers( );
     SgAsmBinaryLsr::resetValidFreepointers( );
     SgAsmBinaryMod::resetValidFreepointers( );
     SgAsmBinaryMsl::resetValidFreepointers( );
     SgAsmBinaryMultiply::resetValidFreepointers( );
     SgAsmBinaryRor::resetValidFreepointers( );
     SgAsmBinarySubtract::resetValidFreepointers( );
     SgAsmBlock::resetValidFreepointers( );
     SgAsmCoffStrtab::resetValidFreepointers( );
     SgAsmCoffSymbol::resetValidFreepointers( );
     SgAsmCoffSymbolList::resetValidFreepointers( );
     SgAsmCoffSymbolTable::resetValidFreepointers( );
     SgAsmCommonSubExpression::resetValidFreepointers( );
     SgAsmControlFlagsExpression::resetValidFreepointers( );
     SgAsmConstantExpression::resetValidFreepointers( );
     SgAsmDOSExtendedHeader::resetValidFreepointers( );
     SgAsmDOSFileHeader::resetValidFreepointers( );
     SgAsmSynthesizedDataStructureDeclaration::resetValidFreepointers( );
     SgAsmSynthesizedDeclaration::resetValidFreepointers( );
     SgAsmDirectRegisterExpression::resetValidFreepointers( );
     SgAsmDwarfAccessDeclaration::resetValidFreepointers( );
     SgAsmDwarfArrayType::resetValidFreepointers( );
     SgAsmDwarfBaseType::resetValidFreepointers( );
     SgAsmDwarfCatchBlock::resetValidFreepointers( );
     SgAsmDwarfClassTemplate::resetValidFreepointers( );
     SgAsmDwarfClassType::resetValidFreepointers( );
     SgAsmDwarfCommonBlock::resetValidFreepointers( );
     SgAsmDwarfCommonInclusion::resetValidFreepointers( );
     SgAsmDwarfCompilationUnit::resetValidFreepointers( );
     SgAsmDwarfCompilationUnitList::resetValidFreepointers( );
     SgAsmDwarfCondition::resetValidFreepointers( );
     SgAsmDwarfConstType::resetValidFreepointers( );
     SgAsmDwarfConstant::resetValidFreepointers( );
     SgAsmDwarfConstruct::resetValidFreepointers( );
     SgAsmDwarfConstructList::resetValidFreepointers( );
     SgAsmDwarfDwarfProcedure::resetValidFreepointers( );
     SgAsmDwarfEntryPoint::resetValidFreepointers( );
     SgAsmDwarfEnumerationType::resetValidFreepointers( );
     SgAsmDwarfEnumerator::resetValidFreepointers( );
     SgAsmDwarfFileType::resetValidFreepointers( );
     SgAsmDwarfFormalParameter::resetValidFreepointers( );
     SgAsmDwarfFormatLabel::resetValidFreepointers( );
     SgAsmDwarfFriend::resetValidFreepointers( );
     SgAsmDwarfFunctionTemplate::resetValidFreepointers( );
     SgAsmDwarfImportedDeclaration::resetValidFreepointers( );
     SgAsmDwarfImportedModule::resetValidFreepointers( );
     SgAsmDwarfImportedUnit::resetValidFreepointers( );
     SgAsmDwarfInformation::resetValidFreepointers( );
     SgAsmDwarfInheritance::resetValidFreepointers( );
     SgAsmDwarfInlinedSubroutine::resetValidFreepointers( );
     SgAsmDwarfInterfaceType::resetValidFreepointers( );
     SgAsmDwarfLabel::resetValidFreepointers( );
     SgAsmDwarfLexicalBlock::resetValidFreepointers( );
     SgAsmDwarfLine::resetValidFreepointers( );
     SgAsmDwarfLineList::resetValidFreepointers( );
     SgAsmDwarfMacro::resetValidFreepointers( );
     SgAsmDwarfMacroList::resetValidFreepointers( );
     SgAsmDwarfMember::resetValidFreepointers( );
     SgAsmDwarfModule::resetValidFreepointers( );
     SgAsmDwarfMutableType::resetValidFreepointers( );
     SgAsmDwarfNamelist::resetValidFreepointers( );
     SgAsmDwarfNamelistItem::resetValidFreepointers( );
     SgAsmDwarfNamespace::resetValidFreepointers( );
     SgAsmDwarfPackedType::resetValidFreepointers( );
     SgAsmDwarfPartialUnit::resetValidFreepointers( );
     SgAsmDwarfPointerType::resetValidFreepointers( );
     SgAsmDwarfPtrToMemberType::resetValidFreepointers( );
     SgAsmDwarfReferenceType::resetValidFreepointers( );
     SgAsmDwarfRestrictType::resetValidFreepointers( );
     SgAsmDwarfSetType::resetValidFreepointers( );
     SgAsmDwarfSharedType::resetValidFreepointers( );
     SgAsmDwarfStringType::resetValidFreepointers( );
     SgAsmDwarfStructureType::resetValidFreepointers( );
     SgAsmDwarfSubprogram::resetValidFreepointers( );
     SgAsmDwarfSubrangeType::resetValidFreepointers( );
     SgAsmDwarfSubroutineType::resetValidFreepointers( );
     SgAsmDwarfTemplateTypeParameter::resetValidFreepointers( );
     SgAsmDwarfTemplateValueParameter::resetValidFreepointers( );
     SgAsmDwarfThrownType::resetValidFreepointers( );
     SgAsmDwarfTryBlock::resetValidFreepointers( );
     SgAsmDwarfTypedef::resetValidFreepointers( );
     SgAsmDwarfUnionType::resetValidFreepointers( );
     SgAsmDwarfUnknownConstruct::resetValidFreepointers( );
     SgAsmDwarfUnspecifiedParameters::resetValidFreepointers( );
     SgAsmDwarfUnspecifiedType::resetValidFreepointers( );
     SgAsmDwarfUpcRelaxedType::resetValidFreepointers( );
     SgAsmDwarfUpcSharedType::resetValidFreepointers( );
     SgAsmDwarfUpcStrictType::resetValidFreepointers( );
     SgAsmDwarfVariable::resetValidFreepointers( );
     SgAsmDwarfVariant::resetValidFreepointers( );
     SgAsmDwarfVariantPart::resetValidFreepointers( );
     SgAsmDwarfVolatileType::resetValidFreepointers( );
     SgAsmDwarfWithStmt::resetValidFreepointers( );
     SgAsmElfDynamicEntry::resetValidFreepointers( );
     SgAsmElfDynamicEntryList::resetValidFreepointers( );
     SgAsmElfDynamicSection::resetValidFreepointers( );
     SgAsmElfEHFrameEntryCI::resetValidFreepointers( );
     SgAsmElfEHFrameEntryCIList::resetValidFreepointers( );
     SgAsmElfEHFrameEntryFD::resetValidFreepointers( );
     SgAsmElfEHFrameEntryFDList::resetValidFreepointers( );
     SgAsmElfEHFrameSection::resetValidFreepointers( );
     SgAsmElfFileHeader::resetValidFreepointers( );
     SgAsmElfNoteEntry::resetValidFreepointers( );
     SgAsmElfNoteEntryList::resetValidFreepointers( );
     SgAsmElfNoteSection::resetValidFreepointers( );
     SgAsmElfRelocEntry::resetValidFreepointers( );
     SgAsmElfRelocEntryList::resetValidFreepointers( );
     SgAsmElfRelocSection::resetValidFreepointers( );
     SgAsmElfSection::resetValidFreepointers( );
     SgAsmElfSectionTable::resetValidFreepointers( );
     SgAsmElfSectionTableEntry::resetValidFreepointers( );
     SgAsmElfSegmentTable::resetValidFreepointers( );
     SgAsmElfSegmentTableEntry::resetValidFreepointers( );
     SgAsmElfSegmentTableEntryList::resetValidFreepointers( );
     SgAsmElfStringSection::resetValidFreepointers( );
     SgAsmElfStrtab::resetValidFreepointers( );
     SgAsmElfSymbol::resetValidFreepointers( );
     SgAsmElfSymbolList::resetValidFreepointers( );
     SgAsmElfSymbolSection::resetValidFreepointers( );
     SgAsmElfSymverDefinedAux::resetValidFreepointers( );
     SgAsmElfSymverDefinedAuxList::resetValidFreepointers( );
     SgAsmElfSymverDefinedEntry::resetValidFreepointers( );
     SgAsmElfSymverDefinedEntryList::resetValidFreepointers( );
     SgAsmElfSymverDefinedSection::resetValidFreepointers( );
     SgAsmElfSymverEntry::resetValidFreepointers( );
     SgAsmElfSymverEntryList::resetValidFreepointers( );
     SgAsmElfSymverNeededAux::resetValidFreepointers( );
     SgAsmElfSymverNeededAuxList::resetValidFreepointers( );
     SgAsmElfSymverNeededEntry::resetValidFreepointers( );
     SgAsmElfSymverNeededEntryList::resetValidFreepointers( );
     SgAsmElfSymverNeededSection::resetValidFreepointers( );
     SgAsmElfSymverSection::resetValidFreepointers( );
     SgAsmExecutableFileFormat::resetValidFreepointers( );
     SgAsmExprListExp::resetValidFreepointers( );
     SgAsmExpression::resetValidFreepointers( );
     SgAsmSynthesizedFieldDeclaration::resetValidFreepointers( );
     SgAsmFloatType::resetValidFreepointers( );
     SgAsmFloatValueExpression::resetValidFreepointers( );
     SgAsmFunction::resetValidFreepointers( );
     SgAsmGenericDLL::resetValidFreepointers( );
     SgAsmGenericDLLList::resetValidFreepointers( );
     SgAsmGenericFile::resetValidFreepointers( );
     SgAsmGenericFileList::resetValidFreepointers( );
     SgAsmGenericFormat::resetValidFreepointers( );
     SgAsmGenericHeader::resetValidFreepointers( );
     SgAsmGenericHeaderList::resetValidFreepointers( );
     SgAsmGenericSection::resetValidFreepointers( );
     SgAsmGenericSectionList::resetValidFreepointers( );
     SgAsmGenericString::resetValidFreepointers( );
     SgAsmGenericStrtab::resetValidFreepointers( );
     SgAsmGenericSymbol::resetValidFreepointers( );
     SgAsmGenericSymbolList::resetValidFreepointers( );
     SgAsmIndirectRegisterExpression::resetValidFreepointers( );
     SgAsmInstruction::resetValidFreepointers( );
     SgAsmIntegerValueExpression::resetValidFreepointers( );
     SgAsmIntegerType::resetValidFreepointers( );
     SgAsmInterpretation::resetValidFreepointers( );
     SgAsmInterpretationList::resetValidFreepointers( );
     SgAsmJvmAttribute::resetValidFreepointers( );
     SgAsmJvmCodeAttribute::resetValidFreepointers( );
     SgAsmJvmMethod::resetValidFreepointers( );
     SgAsmJvmConstantPool::resetValidFreepointers( );
     SgAsmJvmConstantPoolEntry::resetValidFreepointers( );
     SgAsmJvmConstantValue::resetValidFreepointers( );
     SgAsmJvmInstruction::resetValidFreepointers( );
     SgAsmJvmFileHeader::resetValidFreepointers( );
     SgAsmJvmNode::resetValidFreepointers( );
     SgAsmJvmSignature::resetValidFreepointers( );
     SgAsmJvmSourceFile::resetValidFreepointers( );
     SgAsmLEEntryPoint::resetValidFreepointers( );
     SgAsmLEEntryTable::resetValidFreepointers( );
     SgAsmLEFileHeader::resetValidFreepointers( );
     SgAsmLENameTable::resetValidFreepointers( );
     SgAsmLEPageTable::resetValidFreepointers( );
     SgAsmLEPageTableEntry::resetValidFreepointers( );
     SgAsmLERelocTable::resetValidFreepointers( );
     SgAsmLESection::resetValidFreepointers( );
     SgAsmLESectionTable::resetValidFreepointers( );
     SgAsmLESectionTableEntry::resetValidFreepointers( );
     SgAsmM68kInstruction::resetValidFreepointers( );
     SgAsmMemoryReferenceExpression::resetValidFreepointers( );
     SgAsmMipsInstruction::resetValidFreepointers( );
     SgAsmNEEntryPoint::resetValidFreepointers( );
     SgAsmNEEntryTable::resetValidFreepointers( );
     SgAsmNEFileHeader::resetValidFreepointers( );
     SgAsmNEModuleTable::resetValidFreepointers( );
     SgAsmNENameTable::resetValidFreepointers( );
     SgAsmNERelocEntry::resetValidFreepointers( );
     SgAsmNERelocTable::resetValidFreepointers( );
     SgAsmNESection::resetValidFreepointers( );
     SgAsmNESectionTable::resetValidFreepointers( );
     SgAsmNESectionTableEntry::resetValidFreepointers( );
     SgAsmNEStringTable::resetValidFreepointers( );
     SgAsmNode::resetValidFreepointers( );
     SgAsmOp::resetValidFreepointers( );
     SgAsmOperandList::resetValidFreepointers( );
     SgAsmPEExportDirectory::resetValidFreepointers( );
     SgAsmPEExportEntry::resetValidFreepointers( );
     SgAsmPEExportEntryList::resetValidFreepointers( );
     SgAsmPEExportSection::resetValidFreepointers( );
     SgAsmPEFileHeader::resetValidFreepointers( );
     SgAsmPEImportDirectory::resetValidFreepointers( );
     SgAsmPEImportDirectoryList::resetValidFreepointers( );
     SgAsmPEImportItem::resetValidFreepointers( );
     SgAsmPEImportItemList::resetValidFreepointers( );
     SgAsmPEImportSection::resetValidFreepointers( );
     SgAsmPERVASizePair::resetValidFreepointers( );
     SgAsmPERVASizePairList::resetValidFreepointers( );
     SgAsmPESection::resetValidFreepointers( );
     SgAsmPESectionTable::resetValidFreepointers( );
     SgAsmPESectionTableEntry::resetValidFreepointers( );
     SgAsmPEStringSection::resetValidFreepointers( );
     SgAsmPowerpcInstruction::resetValidFreepointers( );
     SgAsmRegisterNames::resetValidFreepointers( );
     SgAsmRegisterReferenceExpression::resetValidFreepointers( );
     SgAsmRiscOperation::resetValidFreepointers( );
     SgAsmScalarType::resetValidFreepointers( );
     SgAsmStatement::resetValidFreepointers( );
     SgAsmStaticData::resetValidFreepointers( );
     SgAsmStmt::resetValidFreepointers( );
     SgAsmStoredString::resetValidFreepointers( );
     SgAsmStringStorage::resetValidFreepointers( );
     SgAsmType::resetValidFreepointers( );
     SgAsmUnaryExpression::resetValidFreepointers( );
     SgAsmUnaryMinus::resetValidFreepointers( );
     SgAsmUnaryPlus::resetValidFreepointers( );
     SgAsmUnaryRrx::resetValidFreepointers( );
     SgAsmUnarySignedExtend::resetValidFreepointers( );
     SgAsmUnaryUnsignedExtend::resetValidFreepointers( );
     SgAsmUnaryTruncate::resetValidFreepointers( );
     SgAsmValueExpression::resetValidFreepointers( );
     SgAsmVectorType::resetValidFreepointers( );
     SgAsmX86Instruction::resetValidFreepointers( );
     SgAsmBinaryAddressSymbol::resetValidFreepointers( );
     SgAsmBinaryDataSymbol::resetValidFreepointers( );
     SgAssertStmt::resetValidFreepointers( );
     SgAssignInitializer::resetValidFreepointers( );
     SgAssignOp::resetValidFreepointers( );
     SgAssignStatement::resetValidFreepointers( );
     SgAssignedGotoStatement::resetValidFreepointers( );
     SgAssociateStatement::resetValidFreepointers( );
     SgAsteriskShapeExp::resetValidFreepointers( );
     SgAtOp::resetValidFreepointers( );
     SgAttribute::resetValidFreepointers( );
     SgAttributeSpecificationStatement::resetValidFreepointers( );
     SgAutoType::resetValidFreepointers( );
     SgAwaitExpression::resetValidFreepointers( );
     SgBackspaceStatement::resetValidFreepointers( );
     SgBaseClass::resetValidFreepointers( );
     SgExpBaseClass::resetValidFreepointers( );
     SgBaseClassModifier::resetValidFreepointers( );
     SgBasicBlock::resetValidFreepointers( );
     SgBidirectionalGraph::resetValidFreepointers( );
     SgBinaryComposite::resetValidFreepointers( );
     SgBinaryOp::resetValidFreepointers( );
     SgBitAndOp::resetValidFreepointers( );
     SgBitAttribute::resetValidFreepointers( );
     SgBitComplementOp::resetValidFreepointers( );
     SgBitEqvOp::resetValidFreepointers( );
     SgBitOrOp::resetValidFreepointers( );
     SgBitXorOp::resetValidFreepointers( );
     SgBlockDataStatement::resetValidFreepointers( );
     SgBoolValExp::resetValidFreepointers( );
     SgBreakStmt::resetValidFreepointers( );
     SgBracedInitializer::resetValidFreepointers( );
     SgC_PreprocessorDirectiveStatement::resetValidFreepointers( );
     SgCaseOptionStmt::resetValidFreepointers( );
     SgCastExp::resetValidFreepointers( );
     SgCatchOptionStmt::resetValidFreepointers( );
     SgCatchStatementSeq::resetValidFreepointers( );
     SgCharVal::resetValidFreepointers( );
     SgChar16Val::resetValidFreepointers( );
     SgChar32Val::resetValidFreepointers( );
     SgChooseExpression::resetValidFreepointers( );
     SgClassDecl_attr::resetValidFreepointers( );
     SgClassDeclaration::resetValidFreepointers( );
     SgClassDefinition::resetValidFreepointers( );
     SgClassNameRefExp::resetValidFreepointers( );
     SgClassSymbol::resetValidFreepointers( );
     SgClassType::resetValidFreepointers( );
     SgClinkageDeclarationStatement::resetValidFreepointers( );
     SgClinkageEndStatement::resetValidFreepointers( );
     SgClinkageStartStatement::resetValidFreepointers( );
     SgCloseStatement::resetValidFreepointers( );
     SgColonShapeExp::resetValidFreepointers( );
     SgCommaOpExp::resetValidFreepointers( );
     SgCommonBlock::resetValidFreepointers( );
     SgCommonBlockObject::resetValidFreepointers( );
     SgCommonSymbol::resetValidFreepointers( );
     SgComplexVal::resetValidFreepointers( );
     SgComprehension::resetValidFreepointers( );
     SgCompoundAssignOp::resetValidFreepointers( );
     SgCompoundInitializer::resetValidFreepointers( );
     SgCompoundLiteralExp::resetValidFreepointers( );
     SgComputedGotoStatement::resetValidFreepointers( );
     SgConcatenationOp::resetValidFreepointers( );
     SgConditionalExp::resetValidFreepointers( );
     SgConjugateOp::resetValidFreepointers( );
     SgConstVolatileModifier::resetValidFreepointers( );
     SgConstructorInitializer::resetValidFreepointers( );
     SgContainsStatement::resetValidFreepointers( );
     SgContinueStmt::resetValidFreepointers( );
     SgCtorInitializerList::resetValidFreepointers( );
     SgDataStatementGroup::resetValidFreepointers( );
     SgDataStatementObject::resetValidFreepointers( );
     SgDataStatementValue::resetValidFreepointers( );
     SgDeadIfDirectiveStatement::resetValidFreepointers( );
     SgDeallocateStatement::resetValidFreepointers( );
     SgDeclarationModifier::resetValidFreepointers( );
     SgDeclarationScope::resetValidFreepointers( );
     SgDeclarationStatement::resetValidFreepointers( );
     SgDeclType::resetValidFreepointers( );
     SgDefaultOptionStmt::resetValidFreepointers( );
     SgDefaultSymbol::resetValidFreepointers( );
     SgDefineDirectiveStatement::resetValidFreepointers( );
     SgDeleteExp::resetValidFreepointers( );
     SgDerivedTypeStatement::resetValidFreepointers( );
     SgDesignatedInitializer::resetValidFreepointers( );
     SgDictionaryComprehension::resetValidFreepointers( );
     SgDictionaryExp::resetValidFreepointers( );
     SgDimensionObject::resetValidFreepointers( );
     SgDirectedGraphEdge::resetValidFreepointers( );
     SgDirectory::resetValidFreepointers( );
     SgDirectoryList::resetValidFreepointers( );
     SgDivAssignOp::resetValidFreepointers( );
     SgDivideOp::resetValidFreepointers( );
     SgDoWhileStmt::resetValidFreepointers( );
     SgDotExp::resetValidFreepointers( );
     SgDotStarOp::resetValidFreepointers( );
     SgDoubleVal::resetValidFreepointers( );
     SgElaboratedTypeModifier::resetValidFreepointers( );
     SgElementwiseOp::resetValidFreepointers( );
     SgElementwiseAddOp::resetValidFreepointers( );
     SgElementwiseDivideOp::resetValidFreepointers( );
     SgElementwiseLeftDivideOp::resetValidFreepointers( );
     SgElementwiseMultiplyOp::resetValidFreepointers( );
     SgElementwisePowerOp::resetValidFreepointers( );
     SgElementwiseSubtractOp::resetValidFreepointers( );
     SgElseDirectiveStatement::resetValidFreepointers( );
     SgElseWhereStatement::resetValidFreepointers( );
     SgElseifDirectiveStatement::resetValidFreepointers( );
     SgEmptyDeclaration::resetValidFreepointers( );
     SgEmptyDirectiveStatement::resetValidFreepointers( );
     SgEndfileStatement::resetValidFreepointers( );
     SgEndifDirectiveStatement::resetValidFreepointers( );
     SgEntryStatement::resetValidFreepointers( );
     SgEnumDeclaration::resetValidFreepointers( );
     SgEnumFieldSymbol::resetValidFreepointers( );
     SgEnumSymbol::resetValidFreepointers( );
     SgEnumType::resetValidFreepointers( );
     SgEnumVal::resetValidFreepointers( );
     SgEqualityOp::resetValidFreepointers( );
     SgEquivalenceStatement::resetValidFreepointers( );
     SgErrorDirectiveStatement::resetValidFreepointers( );
     SgExecStatement::resetValidFreepointers( );
     SgExponentiationOp::resetValidFreepointers( );
     SgExponentiationAssignOp::resetValidFreepointers( );
     SgExprListExp::resetValidFreepointers( );
     SgExprStatement::resetValidFreepointers( );
     SgExpression::resetValidFreepointers( );
     SgExpressionRoot::resetValidFreepointers( );
     SgFile::resetValidFreepointers( );
     SgFileList::resetValidFreepointers( );
     SgFloatVal::resetValidFreepointers( );
     SgFloat128Val::resetValidFreepointers( );
     SgFloat80Val::resetValidFreepointers( );
     SgFoldExpression::resetValidFreepointers( );
     SgFlushStatement::resetValidFreepointers( );
     SgForAllStatement::resetValidFreepointers( );
     SgForInitStatement::resetValidFreepointers( );
     SgForStatement::resetValidFreepointers( );
     SgFormatItem::resetValidFreepointers( );
     SgFormatItemList::resetValidFreepointers( );
     SgFormatStatement::resetValidFreepointers( );
     SgFortranDo::resetValidFreepointers( );
     SgFortranIncludeLine::resetValidFreepointers( );
     SgFortranNonblockedDo::resetValidFreepointers( );
     SgFuncDecl_attr::resetValidFreepointers( );
     SgFunctionCallExp::resetValidFreepointers( );
     SgFunctionDeclaration::resetValidFreepointers( );
     SgFunctionDefinition::resetValidFreepointers( );
     SgFunctionParameterScope::resetValidFreepointers( );
     SgFunctionModifier::resetValidFreepointers( );
     SgFunctionParameterList::resetValidFreepointers( );
     SgFunctionParameterRefExp::resetValidFreepointers( );
     SgFunctionParameterTypeList::resetValidFreepointers( );
     SgFunctionRefExp::resetValidFreepointers( );
     SgFunctionSymbol::resetValidFreepointers( );
     SgFunctionType::resetValidFreepointers( );
     SgFunctionTypeSymbol::resetValidFreepointers( );
     SgFunctionTypeTable::resetValidFreepointers( );
     SgTypeTable::resetValidFreepointers( );
     SgGlobal::resetValidFreepointers( );
     SgGotoStatement::resetValidFreepointers( );
     SgGraph::resetValidFreepointers( );
     SgGraphEdge::resetValidFreepointers( );
     SgGraphEdgeList::resetValidFreepointers( );
     SgGraphNode::resetValidFreepointers( );
     SgGraphNodeList::resetValidFreepointers( );
     SgGreaterOrEqualOp::resetValidFreepointers( );
     SgGreaterThanOp::resetValidFreepointers( );
     SgIOItemExpression::resetValidFreepointers( );
     SgIOStatement::resetValidFreepointers( );
     SgIdentDirectiveStatement::resetValidFreepointers( );
     SgIfDirectiveStatement::resetValidFreepointers( );
     SgIfStmt::resetValidFreepointers( );
     SgIfdefDirectiveStatement::resetValidFreepointers( );
     SgIfndefDirectiveStatement::resetValidFreepointers( );
     SgImageControlStatement::resetValidFreepointers( );
     SgImagPartOp::resetValidFreepointers( );
     SgImplicitStatement::resetValidFreepointers( );
     SgImpliedDo::resetValidFreepointers( );
     SgImportStatement::resetValidFreepointers( );
     SgIncidenceDirectedGraph::resetValidFreepointers( );
     SgIncidenceUndirectedGraph::resetValidFreepointers( );
     SgIncludeDirectiveStatement::resetValidFreepointers( );
     SgIncludeFile::resetValidFreepointers( );
     SgIncludeNextDirectiveStatement::resetValidFreepointers( );
     SgInitializedName::resetValidFreepointers( );
     SgInitializer::resetValidFreepointers( );
     SgInquireStatement::resetValidFreepointers( );
     SgIntKeyedBidirectionalGraph::resetValidFreepointers( );
     SgIntVal::resetValidFreepointers( );
     SgIntegerDivideOp::resetValidFreepointers( );
     SgIntegerDivideAssignOp::resetValidFreepointers( );
     SgInterfaceBody::resetValidFreepointers( );
     SgHeaderFileBody::resetValidFreepointers( );
     SgHeaderFileReport::resetValidFreepointers( );
     SgInterfaceStatement::resetValidFreepointers( );
     SgInterfaceSymbol::resetValidFreepointers( );
     SgIntrinsicSymbol::resetValidFreepointers( );
     SgIsOp::resetValidFreepointers( );
     SgIsNotOp::resetValidFreepointers( );
     SgIorAssignOp::resetValidFreepointers( );
     SgJovialBitType::resetValidFreepointers( );
     SgJovialBitVal::resetValidFreepointers( );
     SgJovialTableType::resetValidFreepointers( );
     SgJovialCompoolStatement::resetValidFreepointers( );
     SgJovialForThenStatement::resetValidFreepointers( );
     SgJovialDefineDeclaration::resetValidFreepointers( );
     SgJovialDirectiveStatement::resetValidFreepointers( );
     SgJovialOverlayDeclaration::resetValidFreepointers( );
     SgJovialPresetPositionExp::resetValidFreepointers( );
     SgJovialTablePresetExp::resetValidFreepointers( );
     SgJovialTableStatement::resetValidFreepointers( );
     SgKeyDatumPair::resetValidFreepointers( );
     SgCudaKernelExecConfig::resetValidFreepointers( );
     SgCudaKernelCallExp::resetValidFreepointers( );
     SgLabelRefExp::resetValidFreepointers( );
     SgLabelStatement::resetValidFreepointers( );
     SgJavaLabelStatement::resetValidFreepointers( );
     SgLabelSymbol::resetValidFreepointers( );
     SgJavaLabelSymbol::resetValidFreepointers( );
     SgLambdaCapture::resetValidFreepointers( );
     SgLambdaCaptureList::resetValidFreepointers( );
     SgLambdaExp::resetValidFreepointers( );
     SgLambdaRefExp::resetValidFreepointers( );
     SgLeftDivideOp::resetValidFreepointers( );
     SgLessOrEqualOp::resetValidFreepointers( );
     SgLessThanOp::resetValidFreepointers( );
     SgLineDirectiveStatement::resetValidFreepointers( );
     SgLinemarkerDirectiveStatement::resetValidFreepointers( );
     SgLinkageModifier::resetValidFreepointers( );
     SgListComprehension::resetValidFreepointers( );
     SgListExp::resetValidFreepointers( );
     SgLocatedNode::resetValidFreepointers( );
     SgLocatedNodeSupport::resetValidFreepointers( );
     SgLongDoubleVal::resetValidFreepointers( );
     SgLongIntVal::resetValidFreepointers( );
     SgLongLongIntVal::resetValidFreepointers( );
     SgLshiftAssignOp::resetValidFreepointers( );
     SgLshiftOp::resetValidFreepointers( );
     SgMagicColonExp::resetValidFreepointers( );
     SgMatrixExp::resetValidFreepointers( );
     SgMatrixTransposeOp::resetValidFreepointers( );
     SgMatlabForStatement::resetValidFreepointers( );
     SgMemberFunctionDeclaration::resetValidFreepointers( );
     SgMemberFunctionRefExp::resetValidFreepointers( );
     SgMemberFunctionSymbol::resetValidFreepointers( );
     SgMemberFunctionType::resetValidFreepointers( );
     SgMembershipOp::resetValidFreepointers( );
     SgMicrosoftAttributeDeclaration::resetValidFreepointers( );
     SgMinusAssignOp::resetValidFreepointers( );
     SgMinusMinusOp::resetValidFreepointers( );
     SgMinusOp::resetValidFreepointers( );
     SgModAssignOp::resetValidFreepointers( );
     SgModOp::resetValidFreepointers( );
     SgModifier::resetValidFreepointers( );
     SgModifierNodes::resetValidFreepointers( );
     SgModifierType::resetValidFreepointers( );
     SgModuleStatement::resetValidFreepointers( );
     SgModuleSymbol::resetValidFreepointers( );
     SgMultAssignOp::resetValidFreepointers( );
     SgMultiplyOp::resetValidFreepointers( );
     SgName::resetValidFreepointers( );
     SgNameGroup::resetValidFreepointers( );
     SgNamedType::resetValidFreepointers( );
     SgNamelistStatement::resetValidFreepointers( );
     SgNamespaceAliasDeclarationStatement::resetValidFreepointers( );
     SgNamespaceDeclarationStatement::resetValidFreepointers( );
     SgNamespaceDefinitionStatement::resetValidFreepointers( );
     SgNamespaceSymbol::resetValidFreepointers( );
     SgNaryOp::resetValidFreepointers( );
     SgNaryBooleanOp::resetValidFreepointers( );
     SgNaryComparisonOp::resetValidFreepointers( );
     SgNewExp::resetValidFreepointers( );
     SgNode::resetValidFreepointers( );
     SgNoexceptOp::resetValidFreepointers( );
     SgNotEqualOp::resetValidFreepointers( );
     SgNotOp::resetValidFreepointers( );
     SgNonMembershipOp::resetValidFreepointers( );
     SgNonrealDecl::resetValidFreepointers( );
     SgNonrealRefExp::resetValidFreepointers( );
     SgNonrealSymbol::resetValidFreepointers( );
     SgNonrealType::resetValidFreepointers( );
     SgNonrealBaseClass::resetValidFreepointers( );
     SgNullExpression::resetValidFreepointers( );
     SgNullptrValExp::resetValidFreepointers( );
     SgNullStatement::resetValidFreepointers( );
     SgNullifyStatement::resetValidFreepointers( );
     SgOmpAtomicStatement::resetValidFreepointers( );
     SgOmpBarrierStatement::resetValidFreepointers( );
     SgOmpCriticalStatement::resetValidFreepointers( );
     SgOmpClauseBodyStatement::resetValidFreepointers( );
     SgOmpBodyStatement::resetValidFreepointers( );
     SgOmpDoStatement::resetValidFreepointers( );
     SgOmpFlushStatement::resetValidFreepointers( );
     SgOmpDeclareSimdStatement::resetValidFreepointers( );
     SgOmpForStatement::resetValidFreepointers( );
     SgOmpForSimdStatement::resetValidFreepointers( );
     SgOmpMasterStatement::resetValidFreepointers( );
     SgOmpOrderedStatement::resetValidFreepointers( );
     SgOmpParallelStatement::resetValidFreepointers( );
     SgOmpSectionStatement::resetValidFreepointers( );
     SgOmpSectionsStatement::resetValidFreepointers( );
     SgOmpSingleStatement::resetValidFreepointers( );
     SgOmpTaskStatement::resetValidFreepointers( );
     SgOmpTaskwaitStatement::resetValidFreepointers( );
     SgOmpThreadprivateStatement::resetValidFreepointers( );
     SgOmpWorkshareStatement::resetValidFreepointers( );
     SgOmpTargetStatement::resetValidFreepointers( );
     SgOmpTargetDataStatement::resetValidFreepointers( );
     SgOmpSimdStatement::resetValidFreepointers( );
     SgOmpClause::resetValidFreepointers( );
     SgOmpBeginClause::resetValidFreepointers( );
     SgOmpCollapseClause::resetValidFreepointers( );
     SgOmpCopyinClause::resetValidFreepointers( );
     SgOmpCopyprivateClause::resetValidFreepointers( );
     SgOmpDefaultClause::resetValidFreepointers( );
     SgOmpEndClause::resetValidFreepointers( );
     SgOmpExpressionClause::resetValidFreepointers( );
     SgOmpFirstprivateClause::resetValidFreepointers( );
     SgOmpIfClause::resetValidFreepointers( );
     SgOmpFinalClause::resetValidFreepointers( );
     SgOmpPriorityClause::resetValidFreepointers( );
     SgOmpDeviceClause::resetValidFreepointers( );
     SgOmpLastprivateClause::resetValidFreepointers( );
     SgOmpNowaitClause::resetValidFreepointers( );
     SgOmpNumThreadsClause::resetValidFreepointers( );
     SgOmpOrderedClause::resetValidFreepointers( );
     SgOmpPrivateClause::resetValidFreepointers( );
     SgOmpReductionClause::resetValidFreepointers( );
     SgOmpScheduleClause::resetValidFreepointers( );
     SgOmpSharedClause::resetValidFreepointers( );
     SgOmpUntiedClause::resetValidFreepointers( );
     SgOmpMergeableClause::resetValidFreepointers( );
     SgOmpVariablesClause::resetValidFreepointers( );
     SgOmpMapClause::resetValidFreepointers( );
     SgOmpSafelenClause::resetValidFreepointers( );
     SgOmpSimdlenClause::resetValidFreepointers( );
     SgOmpLinearClause::resetValidFreepointers( );
     SgOmpUniformClause::resetValidFreepointers( );
     SgOmpAlignedClause::resetValidFreepointers( );
     SgOmpProcBindClause::resetValidFreepointers( );
     SgOmpAtomicClause::resetValidFreepointers( );
     SgOmpInbranchClause::resetValidFreepointers( );
     SgOmpNotinbranchClause::resetValidFreepointers( );
     SgOmpDependClause::resetValidFreepointers( );
     SgOpenclAccessModeModifier::resetValidFreepointers( );
     SgOpenStatement::resetValidFreepointers( );
     SgOptions::resetValidFreepointers( );
     SgOrOp::resetValidFreepointers( );
     SgParameterStatement::resetValidFreepointers( );
     SgPartialFunctionModifierType::resetValidFreepointers( );
     SgPartialFunctionType::resetValidFreepointers( );
     SgPassStatement::resetValidFreepointers( );
     SgPlusAssignOp::resetValidFreepointers( );
     SgPlusPlusOp::resetValidFreepointers( );
     SgPntrArrRefExp::resetValidFreepointers( );
     SgPointerAssignOp::resetValidFreepointers( );
     SgPointerDerefExp::resetValidFreepointers( );
     SgPointerMemberType::resetValidFreepointers( );
     SgPointerType::resetValidFreepointers( );
     SgPowerOp::resetValidFreepointers( );
     SgPragma::resetValidFreepointers( );
     SgPragmaDeclaration::resetValidFreepointers( );
     SgPrintStatement::resetValidFreepointers( );
     SgProcedureHeaderStatement::resetValidFreepointers( );
     SgProgramHeaderStatement::resetValidFreepointers( );
     SgProject::resetValidFreepointers( );
     SgPseudoDestructorRefExp::resetValidFreepointers( );
     SgPythonGlobalStmt::resetValidFreepointers( );
     SgPythonPrintStmt::resetValidFreepointers( );
     SgQualifiedName::resetValidFreepointers( );
     SgQualifiedNameType::resetValidFreepointers( );
     SgRangeExp::resetValidFreepointers( );
     SgRangeBasedForStatement::resetValidFreepointers( );
     SgReadStatement::resetValidFreepointers( );
     SgRealPartOp::resetValidFreepointers( );
     SgRefExp::resetValidFreepointers( );
     SgReferenceType::resetValidFreepointers( );
     SgRemOp::resetValidFreepointers( );
     SgRenamePair::resetValidFreepointers( );
     SgRenameSymbol::resetValidFreepointers( );
     SgReplicationOp::resetValidFreepointers( );
     SgReturnStmt::resetValidFreepointers( );
     SgRewindStatement::resetValidFreepointers( );
     SgRshiftAssignOp::resetValidFreepointers( );
     SgRshiftOp::resetValidFreepointers( );
     SgRvalueReferenceType::resetValidFreepointers( );
     SgJavaUnsignedRshiftAssignOp::resetValidFreepointers( );
     SgJavaUnsignedRshiftOp::resetValidFreepointers( );
     SgScopeOp::resetValidFreepointers( );
     SgScopeStatement::resetValidFreepointers( );
     SgSequenceStatement::resetValidFreepointers( );
     SgSetComprehension::resetValidFreepointers( );
     SgShortVal::resetValidFreepointers( );
     SgSizeOfOp::resetValidFreepointers( );
     SgAlignOfOp::resetValidFreepointers( );
     SgJavaInstanceOfOp::resetValidFreepointers( );
     SgSourceFile::resetValidFreepointers( );
     SgSpaceshipOp::resetValidFreepointers( );
     SgSpawnStmt::resetValidFreepointers( );
     SgSyncAllStatement::resetValidFreepointers( );
     SgSyncImagesStatement::resetValidFreepointers( );
     SgSyncMemoryStatement::resetValidFreepointers( );
     SgSyncTeamStatement::resetValidFreepointers( );
     SgLockStatement::resetValidFreepointers( );
     SgUnlockStatement::resetValidFreepointers( );
     SgJavaThrowStatement::resetValidFreepointers( );
     SgJavaForEachStatement::resetValidFreepointers( );
     SgJavaSynchronizedStatement::resetValidFreepointers( );
     SgJavaParameterizedType::resetValidFreepointers( );
     SgJavaWildcardType::resetValidFreepointers( );
     SgProcessControlStatement::resetValidFreepointers( );
     SgSpecialFunctionModifier::resetValidFreepointers( );
     SgStatement::resetValidFreepointers( );
     SgStaticAssertionDeclaration::resetValidFreepointers( );
     SgStmtDeclarationStatement::resetValidFreepointers( );
     SgStatementExpression::resetValidFreepointers( );
     SgStatementFunctionStatement::resetValidFreepointers( );
     SgStorageModifier::resetValidFreepointers( );
     SgStringConversion::resetValidFreepointers( );
     SgStringKeyedBidirectionalGraph::resetValidFreepointers( );
     SgStringVal::resetValidFreepointers( );
     SgStructureModifier::resetValidFreepointers( );
     SgSubscriptExpression::resetValidFreepointers( );
     SgSubtractOp::resetValidFreepointers( );
     SgSupport::resetValidFreepointers( );
     SgSwitchStatement::resetValidFreepointers( );
     SgSymbol::resetValidFreepointers( );
     SgSymbolTable::resetValidFreepointers( );
     SgTemplateArgument::resetValidFreepointers( );
     SgTemplateArgumentList::resetValidFreepointers( );
     SgTemplateDeclaration::resetValidFreepointers( );
     SgTemplateClassDeclaration::resetValidFreepointers( );
     SgTemplateClassSymbol::resetValidFreepointers( );
     SgTemplateFunctionDeclaration::resetValidFreepointers( );
     SgTemplateFunctionRefExp::resetValidFreepointers( );
     SgTemplateFunctionSymbol::resetValidFreepointers( );
     SgTemplateMemberFunctionDeclaration::resetValidFreepointers( );
     SgTemplateMemberFunctionRefExp::resetValidFreepointers( );
     SgTemplateMemberFunctionSymbol::resetValidFreepointers( );
     SgTemplateTypedefDeclaration::resetValidFreepointers( );
     SgTemplateTypedefSymbol::resetValidFreepointers( );
     SgTemplateVariableDeclaration::resetValidFreepointers( );
     SgTemplateVariableSymbol::resetValidFreepointers( );
     SgTemplateClassDefinition::resetValidFreepointers( );
     SgTemplateFunctionDefinition::resetValidFreepointers( );
     SgTemplateInstantiationDecl::resetValidFreepointers( );
     SgTemplateInstantiationDefn::resetValidFreepointers( );
     SgTemplateInstantiationDirectiveStatement::resetValidFreepointers( );
     SgTemplateInstantiationFunctionDecl::resetValidFreepointers( );
     SgTemplateInstantiationMemberFunctionDecl::resetValidFreepointers( );
     SgTemplateInstantiationTypedefDeclaration::resetValidFreepointers( );
     SgTemplateParameter::resetValidFreepointers( );
     SgTemplateParameterVal::resetValidFreepointers( );
     SgTemplateParameterList::resetValidFreepointers( );
     SgTemplateSymbol::resetValidFreepointers( );
     SgTemplateType::resetValidFreepointers( );
     SgThisExp::resetValidFreepointers( );
     SgTypeTraitBuiltinOperator::resetValidFreepointers( );
     SgSuperExp::resetValidFreepointers( );
     SgThrowOp::resetValidFreepointers( );
     SgToken::resetValidFreepointers( );
     SgTryStmt::resetValidFreepointers( );
     SgTupleExp::resetValidFreepointers( );
     SgType::resetValidFreepointers( );
     SgTypeBool::resetValidFreepointers( );
     SgTypeChar::resetValidFreepointers( );
     SgTypeChar16::resetValidFreepointers( );
     SgTypeChar32::resetValidFreepointers( );
     SgTypeComplex::resetValidFreepointers( );
     SgTypeDefault::resetValidFreepointers( );
     SgTypeExpression::resetValidFreepointers( );
     SgTypeLabel::resetValidFreepointers( );
     SgTypeDouble::resetValidFreepointers( );
     SgTypeEllipse::resetValidFreepointers( );
     SgTypeFixed::resetValidFreepointers( );
     SgTypeFloat::resetValidFreepointers( );
     SgTypeFloat128::resetValidFreepointers( );
     SgTypeFloat80::resetValidFreepointers( );
     SgTypeGlobalVoid::resetValidFreepointers( );
     SgTypeIdOp::resetValidFreepointers( );
     SgTypeImaginary::resetValidFreepointers( );
     SgTypeInt::resetValidFreepointers( );
     SgTypeLong::resetValidFreepointers( );
     SgTypeLongDouble::resetValidFreepointers( );
     SgTypeLongLong::resetValidFreepointers( );
     SgTypeModifier::resetValidFreepointers( );
     SgTypeMatrix::resetValidFreepointers( );
     SgTypeTuple::resetValidFreepointers( );
     SgTypeNullptr::resetValidFreepointers( );
     SgTypeOfType::resetValidFreepointers( );
     SgTypeShort::resetValidFreepointers( );
     SgTypeSigned128bitInteger::resetValidFreepointers( );
     SgTypeSignedChar::resetValidFreepointers( );
     SgTypeSignedInt::resetValidFreepointers( );
     SgTypeSignedLong::resetValidFreepointers( );
     SgTypeSignedLongLong::resetValidFreepointers( );
     SgTypeSignedShort::resetValidFreepointers( );
     SgTypeString::resetValidFreepointers( );
     SgTypeUnknown::resetValidFreepointers( );
     SgTypeUnsigned128bitInteger::resetValidFreepointers( );
     SgTypeUnsignedChar::resetValidFreepointers( );
     SgTypeUnsignedInt::resetValidFreepointers( );
     SgTypeUnsignedLong::resetValidFreepointers( );
     SgTypeUnsignedLongLong::resetValidFreepointers( );
     SgTypeUnsignedShort::resetValidFreepointers( );
     SgTypeVoid::resetValidFreepointers( );
     SgTypeWchar::resetValidFreepointers( );
     SgTypedefDeclaration::resetValidFreepointers( );
     SgTypedefSeq::resetValidFreepointers( );
     SgTypedefSymbol::resetValidFreepointers( );
     SgTypedefType::resetValidFreepointers( );
     SgUPC_AccessModifier::resetValidFreepointers( );
     SgUnaryAddOp::resetValidFreepointers( );
     SgUnaryOp::resetValidFreepointers( );
     SgUndefDirectiveStatement::resetValidFreepointers( );
     SgUndirectedGraphEdge::resetValidFreepointers( );
     SgUnknownArrayOrFunctionReference::resetValidFreepointers( );
     SgUnknownFile::resetValidFreepointers( );
     SgUnparse_Info::resetValidFreepointers( );
     SgUnsignedCharVal::resetValidFreepointers( );
     SgUnsignedIntVal::resetValidFreepointers( );
     SgUnsignedLongLongIntVal::resetValidFreepointers( );
     SgUnsignedLongVal::resetValidFreepointers( );
     SgUnsignedShortVal::resetValidFreepointers( );
     SgUpcBarrierStatement::resetValidFreepointers( );
     SgUpcBlocksizeofExpression::resetValidFreepointers( );
     SgUpcElemsizeofExpression::resetValidFreepointers( );
     SgUpcFenceStatement::resetValidFreepointers( );
     SgUpcForAllStatement::resetValidFreepointers( );
     SgUpcLocalsizeofExpression::resetValidFreepointers( );
     SgUpcMythread::resetValidFreepointers( );
     SgUpcNotifyStatement::resetValidFreepointers( );
     SgUpcThreads::resetValidFreepointers( );
     SgUpcWaitStatement::resetValidFreepointers( );
     SgUseStatement::resetValidFreepointers( );
     SgUserDefinedBinaryOp::resetValidFreepointers( );
     SgUserDefinedUnaryOp::resetValidFreepointers( );
     SgUsingDeclarationStatement::resetValidFreepointers( );
     SgUsingDirectiveStatement::resetValidFreepointers( );
     SgValueExp::resetValidFreepointers( );
     SgVarArgCopyOp::resetValidFreepointers( );
     SgVarArgEndOp::resetValidFreepointers( );
     SgVarArgOp::resetValidFreepointers( );
     SgVarArgStartOneOperandOp::resetValidFreepointers( );
     SgVarArgStartOp::resetValidFreepointers( );
     SgVarRefExp::resetValidFreepointers( );
     SgVariableDeclaration::resetValidFreepointers( );
     SgVariableDefinition::resetValidFreepointers( );
     SgVariableSymbol::resetValidFreepointers( );
     SgVariantExpression::resetValidFreepointers( );
     SgVariantStatement::resetValidFreepointers( );
     SgVoidVal::resetValidFreepointers( );
     SgWaitStatement::resetValidFreepointers( );
     SgWarningDirectiveStatement::resetValidFreepointers( );
     SgWithStatement::resetValidFreepointers( );
     SgWcharVal::resetValidFreepointers( );
     SgWhereStatement::resetValidFreepointers( );
     SgWhileStmt::resetValidFreepointers( );
     SgWriteStatement::resetValidFreepointers( );
     SgXorAssignOp::resetValidFreepointers( );
     SgYieldExpression::resetValidFreepointers( );
     Sg_File_Info::resetValidFreepointers( );
     SgTypeCAFTeam::resetValidFreepointers( );
     SgCAFWithTeamStatement::resetValidFreepointers( );
     SgCAFCoExpression::resetValidFreepointers( );
     SgCallExpression::resetValidFreepointers( );
     SgTypeCrayPointer::resetValidFreepointers( );
     SgJavaImportStatement::resetValidFreepointers( );
     SgJavaPackageDeclaration::resetValidFreepointers( );
     SgJavaPackageStatement::resetValidFreepointers( );
     SgJavaImportStatementList::resetValidFreepointers( );
     SgJavaClassDeclarationList::resetValidFreepointers( );
     SgJavaMemberValuePair::resetValidFreepointers( );
     SgJavaAnnotation::resetValidFreepointers( );
     SgJavaMarkerAnnotation::resetValidFreepointers( );
     SgJavaSingleMemberAnnotation::resetValidFreepointers( );
     SgJavaNormalAnnotation::resetValidFreepointers( );
     SgJavaTypeExpression::resetValidFreepointers( );
     SgJavaQualifiedType::resetValidFreepointers( );
     SgClassExp::resetValidFreepointers( );
     SgJavaUnionType::resetValidFreepointers( );
     SgJavaParameterType::resetValidFreepointers( );
     SgAsyncStmt::resetValidFreepointers( );
     SgFinishStmt::resetValidFreepointers( );
     SgAtStmt::resetValidFreepointers( );
     SgAtomicStmt::resetValidFreepointers( );
     SgWhenStmt::resetValidFreepointers( );
     SgAtExp::resetValidFreepointers( );
     SgFinishExp::resetValidFreepointers( );
     SgHereExp::resetValidFreepointers( );
     SgDotDotExp::resetValidFreepointers( );
     SgAsmNullInstruction::resetValidFreepointers( );
     SgAdaComponentClause::resetValidFreepointers( );
     SgAdaIndexConstraint::resetValidFreepointers( );
     SgAdaModularType::resetValidFreepointers( );
     SgAdaRepresentationClause::resetValidFreepointers( );
     SgAdaFunctionRenamingDecl::resetValidFreepointers( );
     SgAdaSelectStmt::resetValidFreepointers( );
     SgAdaSelectAlternativeStmt::resetValidFreepointers( );
     SgAdaTerminateStmt::resetValidFreepointers( );
     SgAsmAarch32Coprocessor::resetValidFreepointers( );
     SgAdaAttributeClause::resetValidFreepointers( );
     SgAsmBinaryConcat::resetValidFreepointers( );
     SgAsmByteOrder::resetValidFreepointers( );
     SgAdaDerivedType::resetValidFreepointers( );
     SgAdaAttributeExp::resetValidFreepointers( );
     SgAdaEnumRepresentationClause::resetValidFreepointers( );
     SgAsmBinaryPreupdate::resetValidFreepointers( );
     SgAsmBinaryPostupdate::resetValidFreepointers( );
     SgAdaOthersExp::resetValidFreepointers( );
     SgAdaRenamingSymbol::resetValidFreepointers( );
     SgAdaRenamingRefExp::resetValidFreepointers( );
     SgAdaGenericDecl::resetValidFreepointers( );
     SgAdaGenericDefn::resetValidFreepointers( );
     SgAdaFormalType::resetValidFreepointers( );
     SgAdaGenericSymbol::resetValidFreepointers( );
     SgAdaFormalTypeDecl::resetValidFreepointers( );
     SgAdaUnitRefExp::resetValidFreepointers( );
     SgAdaDiscriminatedTypeDecl::resetValidFreepointers( );
     SgAdaDiscriminatedType::resetValidFreepointers( );
     SgAdaDiscriminantConstraint::resetValidFreepointers( );
     SgAdaGenericInstanceDecl::resetValidFreepointers( );
     SgAdaUnscopedBlock::resetValidFreepointers( );
     SgAdaInheritedFunctionSymbol::resetValidFreepointers( );
     SgAdaProtectedBody::resetValidFreepointers( );
     SgAdaProtectedBodyDecl::resetValidFreepointers( );
     SgAdaProtectedSpec::resetValidFreepointers( );
     SgAdaProtectedSpecDecl::resetValidFreepointers( );
     SgAdaProtectedSymbol::resetValidFreepointers( );
     SgAdaProtectedRefExp::resetValidFreepointers( );
     SgAdaProtectedType::resetValidFreepointers( );
     SgAdaProtectedTypeDecl::resetValidFreepointers( );
     SgAdaDigitsConstraint::resetValidFreepointers( );
     SgAdaAncestorInitializer::resetValidFreepointers( );
     SgAdaDeltaConstraint::resetValidFreepointers( );
     SgAdaSubroutineType::resetValidFreepointers( );
     SgAdaGenericInstanceSymbol::resetValidFreepointers( );
     SgAdaFormalPackageDecl::resetValidFreepointers( );
     SgAdaFormalPackageSymbol::resetValidFreepointers( );
     SgAsmJvmAttributeTable::resetValidFreepointers( );
     SgAsmJvmMethodTable::resetValidFreepointers( );
     SgAsmJvmField::resetValidFreepointers( );
     SgAsmJvmFieldTable::resetValidFreepointers( );
     SgAsmJvmExceptionHandler::resetValidFreepointers( );
     SgAsmJvmExceptionTable::resetValidFreepointers( );
     SgAsmJvmClass::resetValidFreepointers( );
     SgAsmJvmLineNumberEntry::resetValidFreepointers( );
     SgAsmJvmLineNumberTable::resetValidFreepointers( );
     SgAsmJvmInnerClassesEntry::resetValidFreepointers( );
     SgAsmJvmInnerClasses::resetValidFreepointers( );
     SgAsmCilInstruction::resetValidFreepointers( );
     SgAsmStackExpression::resetValidFreepointers( );
     SgAsmJvmEnclosingMethod::resetValidFreepointers( );
     SgAdaNullConstraint::resetValidFreepointers( );
     SgAsmJvmModuleMainClass::resetValidFreepointers( );
     SgAsmInstructionList::resetValidFreepointers( );
     SgAsmCilNode::resetValidFreepointers( );
     SgAsmCilAssembly::resetValidFreepointers( );
     SgAsmCilAssemblyOS::resetValidFreepointers( );
     SgAsmCilAssemblyProcessor::resetValidFreepointers( );
     SgAsmCilAssemblyRef::resetValidFreepointers( );
     SgAsmCilAssemblyRefOS::resetValidFreepointers( );
     SgAsmCilAssemblyRefProcessor::resetValidFreepointers( );
     SgAsmCilClassLayout::resetValidFreepointers( );
     SgAsmCilConstant::resetValidFreepointers( );
     SgAsmCilCustomAttribute::resetValidFreepointers( );
     SgAsmCilDeclSecurity::resetValidFreepointers( );
     SgAsmCilEvent::resetValidFreepointers( );
     SgAsmCilEventMap::resetValidFreepointers( );
     SgAsmCilExportedType::resetValidFreepointers( );
     SgAsmCilField::resetValidFreepointers( );
     SgAsmCilFieldLayout::resetValidFreepointers( );
     SgAsmCilFieldMarshal::resetValidFreepointers( );
     SgAsmCilFieldRVA::resetValidFreepointers( );
     SgAsmCilFile::resetValidFreepointers( );
     SgAsmCilGenericParam::resetValidFreepointers( );
     SgAsmCilGenericParamConstraint::resetValidFreepointers( );
     SgAsmCilImplMap::resetValidFreepointers( );
     SgAsmCilInterfaceImpl::resetValidFreepointers( );
     SgAsmCilManifestResource::resetValidFreepointers( );
     SgAsmCilMemberRef::resetValidFreepointers( );
     SgAsmCilMethodDef::resetValidFreepointers( );
     SgAsmCilMethodImpl::resetValidFreepointers( );
     SgAsmCilMethodSemantics::resetValidFreepointers( );
     SgAsmCilMethodSpec::resetValidFreepointers( );
     SgAsmCilModule::resetValidFreepointers( );
     SgAsmCilModuleRef::resetValidFreepointers( );
     SgAsmCilNestedClass::resetValidFreepointers( );
     SgAsmCilParam::resetValidFreepointers( );
     SgAsmCilProperty::resetValidFreepointers( );
     SgAsmCilPropertyMap::resetValidFreepointers( );
     SgAsmCilStandAloneSig::resetValidFreepointers( );
     SgAsmCilTypeDef::resetValidFreepointers( );
     SgAsmCilTypeRef::resetValidFreepointers( );
     SgAsmCilTypeSpec::resetValidFreepointers( );
     SgAdaParameterList::resetValidFreepointers( );
     SgAsmCilMetadata::resetValidFreepointers( );
     SgAsmCilMetadataRoot::resetValidFreepointers( );
     SgAsmCilDataStream::resetValidFreepointers( );
     SgAsmCilMetadataHeap::resetValidFreepointers( );
     SgAsmCilUint8Heap::resetValidFreepointers( );
     SgAsmCilUint32Heap::resetValidFreepointers( );
     SgAsmCliHeader::resetValidFreepointers( );
     SgAdaVariantDecl::resetValidFreepointers( );
     SgAdaVariantWhenStmt::resetValidFreepointers( );
     SgAsmCilAssemblyTable::resetValidFreepointers( );
     SgAsmCilAssemblyOSTable::resetValidFreepointers( );
     SgAsmCilAssemblyProcessorTable::resetValidFreepointers( );
     SgAsmCilAssemblyRefTable::resetValidFreepointers( );
     SgAsmCilAssemblyRefOSTable::resetValidFreepointers( );
     SgAsmCilAssemblyRefProcessorTable::resetValidFreepointers( );
     SgAsmCilClassLayoutTable::resetValidFreepointers( );
     SgAsmCilConstantTable::resetValidFreepointers( );
     SgAsmCilCustomAttributeTable::resetValidFreepointers( );
     SgAsmCilDeclSecurityTable::resetValidFreepointers( );
     SgAsmCilEventTable::resetValidFreepointers( );
     SgAsmCilEventMapTable::resetValidFreepointers( );
     SgAsmCilExportedTypeTable::resetValidFreepointers( );
     SgAsmCilFieldTable::resetValidFreepointers( );
     SgAsmCilFieldLayoutTable::resetValidFreepointers( );
     SgAsmCilFieldMarshalTable::resetValidFreepointers( );
     SgAsmCilFieldRVATable::resetValidFreepointers( );
     SgAsmCilFileTable::resetValidFreepointers( );
     SgAsmCilGenericParamTable::resetValidFreepointers( );
     SgAsmCilGenericParamConstraintTable::resetValidFreepointers( );
     SgAsmCilImplMapTable::resetValidFreepointers( );
     SgAsmCilInterfaceImplTable::resetValidFreepointers( );
     SgAsmCilManifestResourceTable::resetValidFreepointers( );
     SgAsmCilMemberRefTable::resetValidFreepointers( );
     SgAsmCilMethodDefTable::resetValidFreepointers( );
     SgAsmCilMethodImplTable::resetValidFreepointers( );
     SgAsmCilMethodSemanticsTable::resetValidFreepointers( );
     SgAsmCilMethodSpecTable::resetValidFreepointers( );
     SgAsmCilModuleTable::resetValidFreepointers( );
     SgAsmCilModuleRefTable::resetValidFreepointers( );
     SgAsmCilNestedClassTable::resetValidFreepointers( );
     SgAsmCilParamTable::resetValidFreepointers( );
     SgAsmCilPropertyTable::resetValidFreepointers( );
     SgAsmCilPropertyMapTable::resetValidFreepointers( );
     SgAsmCilStandAloneSigTable::resetValidFreepointers( );
     SgAsmCilTypeDefTable::resetValidFreepointers( );
     SgAsmCilTypeRefTable::resetValidFreepointers( );
     SgAsmCilTypeSpecTable::resetValidFreepointers( );
     SgJvmComposite::resetValidFreepointers( );
     SgFortranContinueStmt::resetValidFreepointers( );
     SgAsmJvmStackMapTable::resetValidFreepointers( );
     SgAsmJvmStackMapFrame::resetValidFreepointers( );
     SgAsmJvmStackMapVerificationType::resetValidFreepointers( );
     SgAsmJvmBootstrapMethod::resetValidFreepointers( );
     SgAsmJvmBootstrapMethods::resetValidFreepointers( );
     SgAsmJvmExceptions::resetValidFreepointers( );
     SgAsmJvmNestMembers::resetValidFreepointers( );
     SgAsmJvmNestHost::resetValidFreepointers( );
     SgJovialLabelDeclaration::resetValidFreepointers( );
     SgAsmJvmLocalVariableEntry::resetValidFreepointers( );
     SgAsmJvmLocalVariableTable::resetValidFreepointers( );
     SgAsmJvmLocalVariableTypeEntry::resetValidFreepointers( );
     SgAsmJvmLocalVariableTypeTable::resetValidFreepointers( );
     SgAsmUserInstruction::resetValidFreepointers( );
     SgAsmJvmMethodParameters::resetValidFreepointers( );
     SgAsmJvmMethodParametersEntry::resetValidFreepointers( );
     SgAsmVoidType::resetValidFreepointers( );
     SgAsmPointerType::resetValidFreepointers( );
     SgRangeType::resetValidFreepointers( );
     SgAsmCilExceptionData::resetValidFreepointers( );
     SgAsmCilMethodData::resetValidFreepointers( );
     SgTemplateVariableInstantiation::resetValidFreepointers( );
     SgReferenceExp::resetValidFreepointers( );
     SgTypeRefExp::resetValidFreepointers( );
     SgScopedRefExp::resetValidFreepointers( );
     SgScopedType::resetValidFreepointers( );
     SgTypeSymbol::resetValidFreepointers( );
     SgAsmJvmSynthetic::resetValidFreepointers( );
     SgAsmJvmDeprecated::resetValidFreepointers( );
     SgSignedCharVal::resetValidFreepointers( );
     SgAsmCilErrorHeap::resetValidFreepointers( );

/* #line 279 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
#endif
     freepointersOfCurrentAstAreSetToGlobalIndices = false;
   }


bool
AST_FILE_IO :: areFreepointersContainingGlobalIndices ( )
   {
      return freepointersOfCurrentAstAreSetToGlobalIndices;
   }

#define DEBUG_AstFileIO_getGlobalIndexFromSgClassPointer 0

unsigned long AST_FILE_IO::getGlobalIndexFromSgClassPointer(SgNode * pointer) {
  if (pointer == nullptr) return 0;

  ROSE_ASSERT(freepointersOfCurrentAstAreSetToGlobalIndices);
#if DEBUG_AstFileIO_getGlobalIndexFromSgClassPointer
  printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer():\n");
  printf ("  pointer = %p = %s \n", pointer, pointer ? pointer->class_name().c_str() : "");
  printf ("  pointer->p_freepointer = %p \n", pointer ? pointer->p_freepointer : nullptr);
#endif
//ROSE_ASSERT(pointer->p_freepointer != nullptr);
  ROSE_ASSERT(pointer->p_freepointer != AST_FileIO::IS_VALID_POINTER());

  unsigned long globalIndex = (unsigned long) (pointer->p_freepointer);
#if DEBUG_AstFileIO_getGlobalIndexFromSgClassPointer
  printf ("  globalIndex = %zd \n", globalIndex);
#endif
  return globalIndex;
}

#define DEBUG_AstFileIO_getSgClassPointerFromGlobalIndex 0

SgNode * AST_FILE_IO :: getSgClassPointerFromGlobalIndex ( unsigned long globalIndex ) {
  if (globalIndex == 0) return nullptr;

#if DEBUG_AstFileIO_getGlobalIndexFromSgClassPointer
  printf ("In AST_FILE_IO::getSgClassPointerFromGlobalIndex():\n");
  printf ("  globalIndex = %zd \n", globalIndex);
#endif

  ROSE_ASSERT(!freepointersOfCurrentAstAreSetToGlobalIndices);
  ROSE_ASSERT( globalIndex < getTotalNumberOfNodesOfAstInMemoryPool() + getTotalNumberOfNodesOfNewAst() );

  SgNode* returnPointer = NULL;

    if ( 0 < globalIndex )
       { 
         unsigned long sgVariantOfIRNodeTypeOfIndex = binarySearch ( globalIndex );
#if FILE_IO_EXTRA_CHECK
         // Check, wheather the index is really within the range of this memory pool
         assert ( getAccumulatedPoolSizeOfNewAst(sgVariantOfIRNodeTypeOfIndex) <= globalIndex );
         assert ( globalIndex < AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(sgVariantOfIRNodeTypeOfIndex+1) );
#endif
         switch ( sgVariantOfIRNodeTypeOfIndex )
            {
             case V_SgAccessModifier: 
                 returnPointer =  SgAccessModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgActualArgumentExpression: 
                 returnPointer =  SgActualArgumentExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAbsOp: 
                 returnPointer =  SgAbsOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaAccessType: 
                 returnPointer =  SgAdaAccessType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaAcceptStmt: 
                 returnPointer =  SgAdaAcceptStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaDelayStmt: 
                 returnPointer =  SgAdaDelayStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaEntryDecl: 
                 returnPointer =  SgAdaEntryDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaExitStmt: 
                 returnPointer =  SgAdaExitStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaDiscreteType: 
                 returnPointer =  SgAdaDiscreteType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaFloatVal: 
                 returnPointer =  SgAdaFloatVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaLoopStmt: 
                 returnPointer =  SgAdaLoopStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaPackageBody: 
                 returnPointer =  SgAdaPackageBody::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaPackageBodyDecl: 
                 returnPointer =  SgAdaPackageBodyDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaPackageSpec: 
                 returnPointer =  SgAdaPackageSpec::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaPackageSpecDecl: 
                 returnPointer =  SgAdaPackageSpecDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaPackageSymbol: 
                 returnPointer =  SgAdaPackageSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaRangeConstraint: 
                 returnPointer =  SgAdaRangeConstraint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaRenamingDecl: 
                 returnPointer =  SgAdaRenamingDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaSubtype: 
                 returnPointer =  SgAdaSubtype::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTaskBody: 
                 returnPointer =  SgAdaTaskBody::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTaskBodyDecl: 
                 returnPointer =  SgAdaTaskBodyDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTaskSpec: 
                 returnPointer =  SgAdaTaskSpec::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTaskSpecDecl: 
                 returnPointer =  SgAdaTaskSpecDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTaskSymbol: 
                 returnPointer =  SgAdaTaskSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTaskRefExp: 
                 returnPointer =  SgAdaTaskRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTaskType: 
                 returnPointer =  SgAdaTaskType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTaskTypeDecl: 
                 returnPointer =  SgAdaTaskTypeDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTypeConstraint: 
                 returnPointer =  SgAdaTypeConstraint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAddOp: 
                 returnPointer =  SgAddOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAddressOfOp: 
                 returnPointer =  SgAddressOfOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAggregateInitializer: 
                 returnPointer =  SgAggregateInitializer::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAliasSymbol: 
                 returnPointer =  SgAliasSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAllocateStatement: 
                 returnPointer =  SgAllocateStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAndAssignOp: 
                 returnPointer =  SgAndAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAndOp: 
                 returnPointer =  SgAndOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgArithmeticIfStatement: 
                 returnPointer =  SgArithmeticIfStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgArrayType: 
                 returnPointer =  SgArrayType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgArrowExp: 
                 returnPointer =  SgArrowExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgArrowStarOp: 
                 returnPointer =  SgArrowStarOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBasicString: 
                 returnPointer =  SgAsmBasicString::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryAdd: 
                 returnPointer =  SgAsmBinaryAdd::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryAsr: 
                 returnPointer =  SgAsmBinaryAsr::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryDivide: 
                 returnPointer =  SgAsmBinaryDivide::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryExpression: 
                 returnPointer =  SgAsmBinaryExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryLsl: 
                 returnPointer =  SgAsmBinaryLsl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryLsr: 
                 returnPointer =  SgAsmBinaryLsr::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryMod: 
                 returnPointer =  SgAsmBinaryMod::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryMsl: 
                 returnPointer =  SgAsmBinaryMsl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryMultiply: 
                 returnPointer =  SgAsmBinaryMultiply::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryRor: 
                 returnPointer =  SgAsmBinaryRor::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinarySubtract: 
                 returnPointer =  SgAsmBinarySubtract::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBlock: 
                 returnPointer =  SgAsmBlock::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCoffStrtab: 
                 returnPointer =  SgAsmCoffStrtab::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCoffSymbol: 
                 returnPointer =  SgAsmCoffSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCoffSymbolList: 
                 returnPointer =  SgAsmCoffSymbolList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCoffSymbolTable: 
                 returnPointer =  SgAsmCoffSymbolTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCommonSubExpression: 
                 returnPointer =  SgAsmCommonSubExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmControlFlagsExpression: 
                 returnPointer =  SgAsmControlFlagsExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmConstantExpression: 
                 returnPointer =  SgAsmConstantExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDOSExtendedHeader: 
                 returnPointer =  SgAsmDOSExtendedHeader::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDOSFileHeader: 
                 returnPointer =  SgAsmDOSFileHeader::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmSynthesizedDataStructureDeclaration: 
                 returnPointer =  SgAsmSynthesizedDataStructureDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmSynthesizedDeclaration: 
                 returnPointer =  SgAsmSynthesizedDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDirectRegisterExpression: 
                 returnPointer =  SgAsmDirectRegisterExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfAccessDeclaration: 
                 returnPointer =  SgAsmDwarfAccessDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfArrayType: 
                 returnPointer =  SgAsmDwarfArrayType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfBaseType: 
                 returnPointer =  SgAsmDwarfBaseType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCatchBlock: 
                 returnPointer =  SgAsmDwarfCatchBlock::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfClassTemplate: 
                 returnPointer =  SgAsmDwarfClassTemplate::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfClassType: 
                 returnPointer =  SgAsmDwarfClassType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCommonBlock: 
                 returnPointer =  SgAsmDwarfCommonBlock::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCommonInclusion: 
                 returnPointer =  SgAsmDwarfCommonInclusion::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCompilationUnit: 
                 returnPointer =  SgAsmDwarfCompilationUnit::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCompilationUnitList: 
                 returnPointer =  SgAsmDwarfCompilationUnitList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCondition: 
                 returnPointer =  SgAsmDwarfCondition::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfConstType: 
                 returnPointer =  SgAsmDwarfConstType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfConstant: 
                 returnPointer =  SgAsmDwarfConstant::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfConstruct: 
                 returnPointer =  SgAsmDwarfConstruct::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfConstructList: 
                 returnPointer =  SgAsmDwarfConstructList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfDwarfProcedure: 
                 returnPointer =  SgAsmDwarfDwarfProcedure::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfEntryPoint: 
                 returnPointer =  SgAsmDwarfEntryPoint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfEnumerationType: 
                 returnPointer =  SgAsmDwarfEnumerationType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfEnumerator: 
                 returnPointer =  SgAsmDwarfEnumerator::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFileType: 
                 returnPointer =  SgAsmDwarfFileType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFormalParameter: 
                 returnPointer =  SgAsmDwarfFormalParameter::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFormatLabel: 
                 returnPointer =  SgAsmDwarfFormatLabel::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFriend: 
                 returnPointer =  SgAsmDwarfFriend::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFunctionTemplate: 
                 returnPointer =  SgAsmDwarfFunctionTemplate::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfImportedDeclaration: 
                 returnPointer =  SgAsmDwarfImportedDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfImportedModule: 
                 returnPointer =  SgAsmDwarfImportedModule::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfImportedUnit: 
                 returnPointer =  SgAsmDwarfImportedUnit::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfInformation: 
                 returnPointer =  SgAsmDwarfInformation::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfInheritance: 
                 returnPointer =  SgAsmDwarfInheritance::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfInlinedSubroutine: 
                 returnPointer =  SgAsmDwarfInlinedSubroutine::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfInterfaceType: 
                 returnPointer =  SgAsmDwarfInterfaceType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfLabel: 
                 returnPointer =  SgAsmDwarfLabel::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfLexicalBlock: 
                 returnPointer =  SgAsmDwarfLexicalBlock::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfLine: 
                 returnPointer =  SgAsmDwarfLine::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfLineList: 
                 returnPointer =  SgAsmDwarfLineList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfMacro: 
                 returnPointer =  SgAsmDwarfMacro::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfMacroList: 
                 returnPointer =  SgAsmDwarfMacroList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfMember: 
                 returnPointer =  SgAsmDwarfMember::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfModule: 
                 returnPointer =  SgAsmDwarfModule::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfMutableType: 
                 returnPointer =  SgAsmDwarfMutableType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfNamelist: 
                 returnPointer =  SgAsmDwarfNamelist::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfNamelistItem: 
                 returnPointer =  SgAsmDwarfNamelistItem::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfNamespace: 
                 returnPointer =  SgAsmDwarfNamespace::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfPackedType: 
                 returnPointer =  SgAsmDwarfPackedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfPartialUnit: 
                 returnPointer =  SgAsmDwarfPartialUnit::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfPointerType: 
                 returnPointer =  SgAsmDwarfPointerType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfPtrToMemberType: 
                 returnPointer =  SgAsmDwarfPtrToMemberType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfReferenceType: 
                 returnPointer =  SgAsmDwarfReferenceType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfRestrictType: 
                 returnPointer =  SgAsmDwarfRestrictType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSetType: 
                 returnPointer =  SgAsmDwarfSetType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSharedType: 
                 returnPointer =  SgAsmDwarfSharedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfStringType: 
                 returnPointer =  SgAsmDwarfStringType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfStructureType: 
                 returnPointer =  SgAsmDwarfStructureType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSubprogram: 
                 returnPointer =  SgAsmDwarfSubprogram::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSubrangeType: 
                 returnPointer =  SgAsmDwarfSubrangeType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSubroutineType: 
                 returnPointer =  SgAsmDwarfSubroutineType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfTemplateTypeParameter: 
                 returnPointer =  SgAsmDwarfTemplateTypeParameter::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfTemplateValueParameter: 
                 returnPointer =  SgAsmDwarfTemplateValueParameter::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfThrownType: 
                 returnPointer =  SgAsmDwarfThrownType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfTryBlock: 
                 returnPointer =  SgAsmDwarfTryBlock::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfTypedef: 
                 returnPointer =  SgAsmDwarfTypedef::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUnionType: 
                 returnPointer =  SgAsmDwarfUnionType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUnknownConstruct: 
                 returnPointer =  SgAsmDwarfUnknownConstruct::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUnspecifiedParameters: 
                 returnPointer =  SgAsmDwarfUnspecifiedParameters::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUnspecifiedType: 
                 returnPointer =  SgAsmDwarfUnspecifiedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUpcRelaxedType: 
                 returnPointer =  SgAsmDwarfUpcRelaxedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUpcSharedType: 
                 returnPointer =  SgAsmDwarfUpcSharedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUpcStrictType: 
                 returnPointer =  SgAsmDwarfUpcStrictType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfVariable: 
                 returnPointer =  SgAsmDwarfVariable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfVariant: 
                 returnPointer =  SgAsmDwarfVariant::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfVariantPart: 
                 returnPointer =  SgAsmDwarfVariantPart::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfVolatileType: 
                 returnPointer =  SgAsmDwarfVolatileType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfWithStmt: 
                 returnPointer =  SgAsmDwarfWithStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfDynamicEntry: 
                 returnPointer =  SgAsmElfDynamicEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfDynamicEntryList: 
                 returnPointer =  SgAsmElfDynamicEntryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfDynamicSection: 
                 returnPointer =  SgAsmElfDynamicSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameEntryCI: 
                 returnPointer =  SgAsmElfEHFrameEntryCI::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameEntryCIList: 
                 returnPointer =  SgAsmElfEHFrameEntryCIList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameEntryFD: 
                 returnPointer =  SgAsmElfEHFrameEntryFD::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameEntryFDList: 
                 returnPointer =  SgAsmElfEHFrameEntryFDList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameSection: 
                 returnPointer =  SgAsmElfEHFrameSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfFileHeader: 
                 returnPointer =  SgAsmElfFileHeader::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfNoteEntry: 
                 returnPointer =  SgAsmElfNoteEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfNoteEntryList: 
                 returnPointer =  SgAsmElfNoteEntryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfNoteSection: 
                 returnPointer =  SgAsmElfNoteSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfRelocEntry: 
                 returnPointer =  SgAsmElfRelocEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfRelocEntryList: 
                 returnPointer =  SgAsmElfRelocEntryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfRelocSection: 
                 returnPointer =  SgAsmElfRelocSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSection: 
                 returnPointer =  SgAsmElfSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSectionTable: 
                 returnPointer =  SgAsmElfSectionTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSectionTableEntry: 
                 returnPointer =  SgAsmElfSectionTableEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSegmentTable: 
                 returnPointer =  SgAsmElfSegmentTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSegmentTableEntry: 
                 returnPointer =  SgAsmElfSegmentTableEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSegmentTableEntryList: 
                 returnPointer =  SgAsmElfSegmentTableEntryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfStringSection: 
                 returnPointer =  SgAsmElfStringSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfStrtab: 
                 returnPointer =  SgAsmElfStrtab::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymbol: 
                 returnPointer =  SgAsmElfSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymbolList: 
                 returnPointer =  SgAsmElfSymbolList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymbolSection: 
                 returnPointer =  SgAsmElfSymbolSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedAux: 
                 returnPointer =  SgAsmElfSymverDefinedAux::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedAuxList: 
                 returnPointer =  SgAsmElfSymverDefinedAuxList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedEntry: 
                 returnPointer =  SgAsmElfSymverDefinedEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedEntryList: 
                 returnPointer =  SgAsmElfSymverDefinedEntryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedSection: 
                 returnPointer =  SgAsmElfSymverDefinedSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverEntry: 
                 returnPointer =  SgAsmElfSymverEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverEntryList: 
                 returnPointer =  SgAsmElfSymverEntryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededAux: 
                 returnPointer =  SgAsmElfSymverNeededAux::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededAuxList: 
                 returnPointer =  SgAsmElfSymverNeededAuxList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededEntry: 
                 returnPointer =  SgAsmElfSymverNeededEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededEntryList: 
                 returnPointer =  SgAsmElfSymverNeededEntryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededSection: 
                 returnPointer =  SgAsmElfSymverNeededSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverSection: 
                 returnPointer =  SgAsmElfSymverSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmExecutableFileFormat: 
                 returnPointer =  SgAsmExecutableFileFormat::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmExprListExp: 
                 returnPointer =  SgAsmExprListExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmExpression: 
                 returnPointer =  SgAsmExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmSynthesizedFieldDeclaration: 
                 returnPointer =  SgAsmSynthesizedFieldDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmFloatType: 
                 returnPointer =  SgAsmFloatType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmFloatValueExpression: 
                 returnPointer =  SgAsmFloatValueExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmFunction: 
                 returnPointer =  SgAsmFunction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericDLL: 
                 returnPointer =  SgAsmGenericDLL::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericDLLList: 
                 returnPointer =  SgAsmGenericDLLList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericFile: 
                 returnPointer =  SgAsmGenericFile::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericFileList: 
                 returnPointer =  SgAsmGenericFileList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericFormat: 
                 returnPointer =  SgAsmGenericFormat::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericHeader: 
                 returnPointer =  SgAsmGenericHeader::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericHeaderList: 
                 returnPointer =  SgAsmGenericHeaderList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericSection: 
                 returnPointer =  SgAsmGenericSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericSectionList: 
                 returnPointer =  SgAsmGenericSectionList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericString: 
                 returnPointer =  SgAsmGenericString::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericStrtab: 
                 returnPointer =  SgAsmGenericStrtab::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericSymbol: 
                 returnPointer =  SgAsmGenericSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericSymbolList: 
                 returnPointer =  SgAsmGenericSymbolList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmIndirectRegisterExpression: 
                 returnPointer =  SgAsmIndirectRegisterExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmInstruction: 
                 returnPointer =  SgAsmInstruction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmIntegerValueExpression: 
                 returnPointer =  SgAsmIntegerValueExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmIntegerType: 
                 returnPointer =  SgAsmIntegerType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmInterpretation: 
                 returnPointer =  SgAsmInterpretation::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmInterpretationList: 
                 returnPointer =  SgAsmInterpretationList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmAttribute: 
                 returnPointer =  SgAsmJvmAttribute::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmCodeAttribute: 
                 returnPointer =  SgAsmJvmCodeAttribute::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmMethod: 
                 returnPointer =  SgAsmJvmMethod::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmConstantPool: 
                 returnPointer =  SgAsmJvmConstantPool::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmConstantPoolEntry: 
                 returnPointer =  SgAsmJvmConstantPoolEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmConstantValue: 
                 returnPointer =  SgAsmJvmConstantValue::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmInstruction: 
                 returnPointer =  SgAsmJvmInstruction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmFileHeader: 
                 returnPointer =  SgAsmJvmFileHeader::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmNode: 
                 returnPointer =  SgAsmJvmNode::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmSignature: 
                 returnPointer =  SgAsmJvmSignature::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmSourceFile: 
                 returnPointer =  SgAsmJvmSourceFile::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEEntryPoint: 
                 returnPointer =  SgAsmLEEntryPoint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEEntryTable: 
                 returnPointer =  SgAsmLEEntryTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEFileHeader: 
                 returnPointer =  SgAsmLEFileHeader::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLENameTable: 
                 returnPointer =  SgAsmLENameTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEPageTable: 
                 returnPointer =  SgAsmLEPageTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEPageTableEntry: 
                 returnPointer =  SgAsmLEPageTableEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLERelocTable: 
                 returnPointer =  SgAsmLERelocTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLESection: 
                 returnPointer =  SgAsmLESection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLESectionTable: 
                 returnPointer =  SgAsmLESectionTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLESectionTableEntry: 
                 returnPointer =  SgAsmLESectionTableEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmM68kInstruction: 
                 returnPointer =  SgAsmM68kInstruction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmMemoryReferenceExpression: 
                 returnPointer =  SgAsmMemoryReferenceExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmMipsInstruction: 
                 returnPointer =  SgAsmMipsInstruction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEEntryPoint: 
                 returnPointer =  SgAsmNEEntryPoint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEEntryTable: 
                 returnPointer =  SgAsmNEEntryTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEFileHeader: 
                 returnPointer =  SgAsmNEFileHeader::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEModuleTable: 
                 returnPointer =  SgAsmNEModuleTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNENameTable: 
                 returnPointer =  SgAsmNENameTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNERelocEntry: 
                 returnPointer =  SgAsmNERelocEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNERelocTable: 
                 returnPointer =  SgAsmNERelocTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNESection: 
                 returnPointer =  SgAsmNESection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNESectionTable: 
                 returnPointer =  SgAsmNESectionTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNESectionTableEntry: 
                 returnPointer =  SgAsmNESectionTableEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEStringTable: 
                 returnPointer =  SgAsmNEStringTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNode: 
                 returnPointer =  SgAsmNode::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmOp: 
                 returnPointer =  SgAsmOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmOperandList: 
                 returnPointer =  SgAsmOperandList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEExportDirectory: 
                 returnPointer =  SgAsmPEExportDirectory::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEExportEntry: 
                 returnPointer =  SgAsmPEExportEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEExportEntryList: 
                 returnPointer =  SgAsmPEExportEntryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEExportSection: 
                 returnPointer =  SgAsmPEExportSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEFileHeader: 
                 returnPointer =  SgAsmPEFileHeader::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportDirectory: 
                 returnPointer =  SgAsmPEImportDirectory::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportDirectoryList: 
                 returnPointer =  SgAsmPEImportDirectoryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportItem: 
                 returnPointer =  SgAsmPEImportItem::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportItemList: 
                 returnPointer =  SgAsmPEImportItemList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportSection: 
                 returnPointer =  SgAsmPEImportSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPERVASizePair: 
                 returnPointer =  SgAsmPERVASizePair::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPERVASizePairList: 
                 returnPointer =  SgAsmPERVASizePairList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPESection: 
                 returnPointer =  SgAsmPESection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPESectionTable: 
                 returnPointer =  SgAsmPESectionTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPESectionTableEntry: 
                 returnPointer =  SgAsmPESectionTableEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEStringSection: 
                 returnPointer =  SgAsmPEStringSection::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPowerpcInstruction: 
                 returnPointer =  SgAsmPowerpcInstruction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmRegisterNames: 
                 returnPointer =  SgAsmRegisterNames::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmRegisterReferenceExpression: 
                 returnPointer =  SgAsmRegisterReferenceExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmRiscOperation: 
                 returnPointer =  SgAsmRiscOperation::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmScalarType: 
                 returnPointer =  SgAsmScalarType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStatement: 
                 returnPointer =  SgAsmStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStaticData: 
                 returnPointer =  SgAsmStaticData::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStmt: 
                 returnPointer =  SgAsmStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStoredString: 
                 returnPointer =  SgAsmStoredString::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStringStorage: 
                 returnPointer =  SgAsmStringStorage::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmType: 
                 returnPointer =  SgAsmType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryExpression: 
                 returnPointer =  SgAsmUnaryExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryMinus: 
                 returnPointer =  SgAsmUnaryMinus::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryPlus: 
                 returnPointer =  SgAsmUnaryPlus::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryRrx: 
                 returnPointer =  SgAsmUnaryRrx::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnarySignedExtend: 
                 returnPointer =  SgAsmUnarySignedExtend::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryUnsignedExtend: 
                 returnPointer =  SgAsmUnaryUnsignedExtend::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryTruncate: 
                 returnPointer =  SgAsmUnaryTruncate::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmValueExpression: 
                 returnPointer =  SgAsmValueExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmVectorType: 
                 returnPointer =  SgAsmVectorType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmX86Instruction: 
                 returnPointer =  SgAsmX86Instruction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryAddressSymbol: 
                 returnPointer =  SgAsmBinaryAddressSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryDataSymbol: 
                 returnPointer =  SgAsmBinaryDataSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssertStmt: 
                 returnPointer =  SgAssertStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssignInitializer: 
                 returnPointer =  SgAssignInitializer::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssignOp: 
                 returnPointer =  SgAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssignStatement: 
                 returnPointer =  SgAssignStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssignedGotoStatement: 
                 returnPointer =  SgAssignedGotoStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssociateStatement: 
                 returnPointer =  SgAssociateStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsteriskShapeExp: 
                 returnPointer =  SgAsteriskShapeExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAtOp: 
                 returnPointer =  SgAtOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAttribute: 
                 returnPointer =  SgAttribute::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAttributeSpecificationStatement: 
                 returnPointer =  SgAttributeSpecificationStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAutoType: 
                 returnPointer =  SgAutoType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAwaitExpression: 
                 returnPointer =  SgAwaitExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBackspaceStatement: 
                 returnPointer =  SgBackspaceStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBaseClass: 
                 returnPointer =  SgBaseClass::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExpBaseClass: 
                 returnPointer =  SgExpBaseClass::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBaseClassModifier: 
                 returnPointer =  SgBaseClassModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBasicBlock: 
                 returnPointer =  SgBasicBlock::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBidirectionalGraph: 
                 returnPointer =  SgBidirectionalGraph::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBinaryComposite: 
                 returnPointer =  SgBinaryComposite::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBinaryOp: 
                 returnPointer =  SgBinaryOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitAndOp: 
                 returnPointer =  SgBitAndOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitAttribute: 
                 returnPointer =  SgBitAttribute::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitComplementOp: 
                 returnPointer =  SgBitComplementOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitEqvOp: 
                 returnPointer =  SgBitEqvOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitOrOp: 
                 returnPointer =  SgBitOrOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitXorOp: 
                 returnPointer =  SgBitXorOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBlockDataStatement: 
                 returnPointer =  SgBlockDataStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBoolValExp: 
                 returnPointer =  SgBoolValExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBreakStmt: 
                 returnPointer =  SgBreakStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBracedInitializer: 
                 returnPointer =  SgBracedInitializer::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgC_PreprocessorDirectiveStatement: 
                 returnPointer =  SgC_PreprocessorDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCaseOptionStmt: 
                 returnPointer =  SgCaseOptionStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCastExp: 
                 returnPointer =  SgCastExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCatchOptionStmt: 
                 returnPointer =  SgCatchOptionStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCatchStatementSeq: 
                 returnPointer =  SgCatchStatementSeq::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCharVal: 
                 returnPointer =  SgCharVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgChar16Val: 
                 returnPointer =  SgChar16Val::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgChar32Val: 
                 returnPointer =  SgChar32Val::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgChooseExpression: 
                 returnPointer =  SgChooseExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassDecl_attr: 
                 returnPointer =  SgClassDecl_attr::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassDeclaration: 
                 returnPointer =  SgClassDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassDefinition: 
                 returnPointer =  SgClassDefinition::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassNameRefExp: 
                 returnPointer =  SgClassNameRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassSymbol: 
                 returnPointer =  SgClassSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassType: 
                 returnPointer =  SgClassType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClinkageDeclarationStatement: 
                 returnPointer =  SgClinkageDeclarationStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClinkageEndStatement: 
                 returnPointer =  SgClinkageEndStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClinkageStartStatement: 
                 returnPointer =  SgClinkageStartStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCloseStatement: 
                 returnPointer =  SgCloseStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgColonShapeExp: 
                 returnPointer =  SgColonShapeExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCommaOpExp: 
                 returnPointer =  SgCommaOpExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCommonBlock: 
                 returnPointer =  SgCommonBlock::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCommonBlockObject: 
                 returnPointer =  SgCommonBlockObject::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCommonSymbol: 
                 returnPointer =  SgCommonSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgComplexVal: 
                 returnPointer =  SgComplexVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgComprehension: 
                 returnPointer =  SgComprehension::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCompoundAssignOp: 
                 returnPointer =  SgCompoundAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCompoundInitializer: 
                 returnPointer =  SgCompoundInitializer::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCompoundLiteralExp: 
                 returnPointer =  SgCompoundLiteralExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgComputedGotoStatement: 
                 returnPointer =  SgComputedGotoStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConcatenationOp: 
                 returnPointer =  SgConcatenationOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConditionalExp: 
                 returnPointer =  SgConditionalExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConjugateOp: 
                 returnPointer =  SgConjugateOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConstVolatileModifier: 
                 returnPointer =  SgConstVolatileModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConstructorInitializer: 
                 returnPointer =  SgConstructorInitializer::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgContainsStatement: 
                 returnPointer =  SgContainsStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgContinueStmt: 
                 returnPointer =  SgContinueStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCtorInitializerList: 
                 returnPointer =  SgCtorInitializerList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDataStatementGroup: 
                 returnPointer =  SgDataStatementGroup::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDataStatementObject: 
                 returnPointer =  SgDataStatementObject::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDataStatementValue: 
                 returnPointer =  SgDataStatementValue::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeadIfDirectiveStatement: 
                 returnPointer =  SgDeadIfDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeallocateStatement: 
                 returnPointer =  SgDeallocateStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeclarationModifier: 
                 returnPointer =  SgDeclarationModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeclarationScope: 
                 returnPointer =  SgDeclarationScope::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeclarationStatement: 
                 returnPointer =  SgDeclarationStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeclType: 
                 returnPointer =  SgDeclType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDefaultOptionStmt: 
                 returnPointer =  SgDefaultOptionStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDefaultSymbol: 
                 returnPointer =  SgDefaultSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDefineDirectiveStatement: 
                 returnPointer =  SgDefineDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeleteExp: 
                 returnPointer =  SgDeleteExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDerivedTypeStatement: 
                 returnPointer =  SgDerivedTypeStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDesignatedInitializer: 
                 returnPointer =  SgDesignatedInitializer::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDictionaryComprehension: 
                 returnPointer =  SgDictionaryComprehension::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDictionaryExp: 
                 returnPointer =  SgDictionaryExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDimensionObject: 
                 returnPointer =  SgDimensionObject::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDirectedGraphEdge: 
                 returnPointer =  SgDirectedGraphEdge::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDirectory: 
                 returnPointer =  SgDirectory::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDirectoryList: 
                 returnPointer =  SgDirectoryList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDivAssignOp: 
                 returnPointer =  SgDivAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDivideOp: 
                 returnPointer =  SgDivideOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDoWhileStmt: 
                 returnPointer =  SgDoWhileStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDotExp: 
                 returnPointer =  SgDotExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDotStarOp: 
                 returnPointer =  SgDotStarOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDoubleVal: 
                 returnPointer =  SgDoubleVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElaboratedTypeModifier: 
                 returnPointer =  SgElaboratedTypeModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElementwiseOp: 
                 returnPointer =  SgElementwiseOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElementwiseAddOp: 
                 returnPointer =  SgElementwiseAddOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElementwiseDivideOp: 
                 returnPointer =  SgElementwiseDivideOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElementwiseLeftDivideOp: 
                 returnPointer =  SgElementwiseLeftDivideOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElementwiseMultiplyOp: 
                 returnPointer =  SgElementwiseMultiplyOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElementwisePowerOp: 
                 returnPointer =  SgElementwisePowerOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElementwiseSubtractOp: 
                 returnPointer =  SgElementwiseSubtractOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElseDirectiveStatement: 
                 returnPointer =  SgElseDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElseWhereStatement: 
                 returnPointer =  SgElseWhereStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElseifDirectiveStatement: 
                 returnPointer =  SgElseifDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEmptyDeclaration: 
                 returnPointer =  SgEmptyDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEmptyDirectiveStatement: 
                 returnPointer =  SgEmptyDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEndfileStatement: 
                 returnPointer =  SgEndfileStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEndifDirectiveStatement: 
                 returnPointer =  SgEndifDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEntryStatement: 
                 returnPointer =  SgEntryStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumDeclaration: 
                 returnPointer =  SgEnumDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumFieldSymbol: 
                 returnPointer =  SgEnumFieldSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumSymbol: 
                 returnPointer =  SgEnumSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumType: 
                 returnPointer =  SgEnumType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumVal: 
                 returnPointer =  SgEnumVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEqualityOp: 
                 returnPointer =  SgEqualityOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEquivalenceStatement: 
                 returnPointer =  SgEquivalenceStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgErrorDirectiveStatement: 
                 returnPointer =  SgErrorDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExecStatement: 
                 returnPointer =  SgExecStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExponentiationOp: 
                 returnPointer =  SgExponentiationOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExponentiationAssignOp: 
                 returnPointer =  SgExponentiationAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExprListExp: 
                 returnPointer =  SgExprListExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExprStatement: 
                 returnPointer =  SgExprStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExpression: 
                 returnPointer =  SgExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExpressionRoot: 
                 returnPointer =  SgExpressionRoot::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFile: 
                 returnPointer =  SgFile::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFileList: 
                 returnPointer =  SgFileList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFloatVal: 
                 returnPointer =  SgFloatVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFloat128Val: 
                 returnPointer =  SgFloat128Val::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFloat80Val: 
                 returnPointer =  SgFloat80Val::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFoldExpression: 
                 returnPointer =  SgFoldExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFlushStatement: 
                 returnPointer =  SgFlushStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgForAllStatement: 
                 returnPointer =  SgForAllStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgForInitStatement: 
                 returnPointer =  SgForInitStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgForStatement: 
                 returnPointer =  SgForStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFormatItem: 
                 returnPointer =  SgFormatItem::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFormatItemList: 
                 returnPointer =  SgFormatItemList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFormatStatement: 
                 returnPointer =  SgFormatStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFortranDo: 
                 returnPointer =  SgFortranDo::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFortranIncludeLine: 
                 returnPointer =  SgFortranIncludeLine::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFortranNonblockedDo: 
                 returnPointer =  SgFortranNonblockedDo::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFuncDecl_attr: 
                 returnPointer =  SgFuncDecl_attr::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionCallExp: 
                 returnPointer =  SgFunctionCallExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionDeclaration: 
                 returnPointer =  SgFunctionDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionDefinition: 
                 returnPointer =  SgFunctionDefinition::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionParameterScope: 
                 returnPointer =  SgFunctionParameterScope::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionModifier: 
                 returnPointer =  SgFunctionModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionParameterList: 
                 returnPointer =  SgFunctionParameterList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionParameterRefExp: 
                 returnPointer =  SgFunctionParameterRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionParameterTypeList: 
                 returnPointer =  SgFunctionParameterTypeList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionRefExp: 
                 returnPointer =  SgFunctionRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionSymbol: 
                 returnPointer =  SgFunctionSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionType: 
                 returnPointer =  SgFunctionType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionTypeSymbol: 
                 returnPointer =  SgFunctionTypeSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionTypeTable: 
                 returnPointer =  SgFunctionTypeTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeTable: 
                 returnPointer =  SgTypeTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGlobal: 
                 returnPointer =  SgGlobal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGotoStatement: 
                 returnPointer =  SgGotoStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraph: 
                 returnPointer =  SgGraph::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraphEdge: 
                 returnPointer =  SgGraphEdge::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraphEdgeList: 
                 returnPointer =  SgGraphEdgeList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraphNode: 
                 returnPointer =  SgGraphNode::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraphNodeList: 
                 returnPointer =  SgGraphNodeList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGreaterOrEqualOp: 
                 returnPointer =  SgGreaterOrEqualOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGreaterThanOp: 
                 returnPointer =  SgGreaterThanOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIOItemExpression: 
                 returnPointer =  SgIOItemExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIOStatement: 
                 returnPointer =  SgIOStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIdentDirectiveStatement: 
                 returnPointer =  SgIdentDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIfDirectiveStatement: 
                 returnPointer =  SgIfDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIfStmt: 
                 returnPointer =  SgIfStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIfdefDirectiveStatement: 
                 returnPointer =  SgIfdefDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIfndefDirectiveStatement: 
                 returnPointer =  SgIfndefDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgImageControlStatement: 
                 returnPointer =  SgImageControlStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgImagPartOp: 
                 returnPointer =  SgImagPartOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgImplicitStatement: 
                 returnPointer =  SgImplicitStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgImpliedDo: 
                 returnPointer =  SgImpliedDo::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgImportStatement: 
                 returnPointer =  SgImportStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIncidenceDirectedGraph: 
                 returnPointer =  SgIncidenceDirectedGraph::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIncidenceUndirectedGraph: 
                 returnPointer =  SgIncidenceUndirectedGraph::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIncludeDirectiveStatement: 
                 returnPointer =  SgIncludeDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIncludeFile: 
                 returnPointer =  SgIncludeFile::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIncludeNextDirectiveStatement: 
                 returnPointer =  SgIncludeNextDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInitializedName: 
                 returnPointer =  SgInitializedName::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInitializer: 
                 returnPointer =  SgInitializer::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInquireStatement: 
                 returnPointer =  SgInquireStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntKeyedBidirectionalGraph: 
                 returnPointer =  SgIntKeyedBidirectionalGraph::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntVal: 
                 returnPointer =  SgIntVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntegerDivideOp: 
                 returnPointer =  SgIntegerDivideOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntegerDivideAssignOp: 
                 returnPointer =  SgIntegerDivideAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInterfaceBody: 
                 returnPointer =  SgInterfaceBody::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgHeaderFileBody: 
                 returnPointer =  SgHeaderFileBody::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgHeaderFileReport: 
                 returnPointer =  SgHeaderFileReport::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInterfaceStatement: 
                 returnPointer =  SgInterfaceStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInterfaceSymbol: 
                 returnPointer =  SgInterfaceSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntrinsicSymbol: 
                 returnPointer =  SgIntrinsicSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIsOp: 
                 returnPointer =  SgIsOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIsNotOp: 
                 returnPointer =  SgIsNotOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIorAssignOp: 
                 returnPointer =  SgIorAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialBitType: 
                 returnPointer =  SgJovialBitType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialBitVal: 
                 returnPointer =  SgJovialBitVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialTableType: 
                 returnPointer =  SgJovialTableType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialCompoolStatement: 
                 returnPointer =  SgJovialCompoolStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialForThenStatement: 
                 returnPointer =  SgJovialForThenStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialDefineDeclaration: 
                 returnPointer =  SgJovialDefineDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialDirectiveStatement: 
                 returnPointer =  SgJovialDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialOverlayDeclaration: 
                 returnPointer =  SgJovialOverlayDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialPresetPositionExp: 
                 returnPointer =  SgJovialPresetPositionExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialTablePresetExp: 
                 returnPointer =  SgJovialTablePresetExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialTableStatement: 
                 returnPointer =  SgJovialTableStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgKeyDatumPair: 
                 returnPointer =  SgKeyDatumPair::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCudaKernelExecConfig: 
                 returnPointer =  SgCudaKernelExecConfig::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCudaKernelCallExp: 
                 returnPointer =  SgCudaKernelCallExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLabelRefExp: 
                 returnPointer =  SgLabelRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLabelStatement: 
                 returnPointer =  SgLabelStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaLabelStatement: 
                 returnPointer =  SgJavaLabelStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLabelSymbol: 
                 returnPointer =  SgLabelSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaLabelSymbol: 
                 returnPointer =  SgJavaLabelSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLambdaCapture: 
                 returnPointer =  SgLambdaCapture::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLambdaCaptureList: 
                 returnPointer =  SgLambdaCaptureList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLambdaExp: 
                 returnPointer =  SgLambdaExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLambdaRefExp: 
                 returnPointer =  SgLambdaRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLeftDivideOp: 
                 returnPointer =  SgLeftDivideOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLessOrEqualOp: 
                 returnPointer =  SgLessOrEqualOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLessThanOp: 
                 returnPointer =  SgLessThanOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLineDirectiveStatement: 
                 returnPointer =  SgLineDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLinemarkerDirectiveStatement: 
                 returnPointer =  SgLinemarkerDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLinkageModifier: 
                 returnPointer =  SgLinkageModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgListComprehension: 
                 returnPointer =  SgListComprehension::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgListExp: 
                 returnPointer =  SgListExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLocatedNode: 
                 returnPointer =  SgLocatedNode::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLocatedNodeSupport: 
                 returnPointer =  SgLocatedNodeSupport::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLongDoubleVal: 
                 returnPointer =  SgLongDoubleVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLongIntVal: 
                 returnPointer =  SgLongIntVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLongLongIntVal: 
                 returnPointer =  SgLongLongIntVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLshiftAssignOp: 
                 returnPointer =  SgLshiftAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLshiftOp: 
                 returnPointer =  SgLshiftOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMagicColonExp: 
                 returnPointer =  SgMagicColonExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMatrixExp: 
                 returnPointer =  SgMatrixExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMatrixTransposeOp: 
                 returnPointer =  SgMatrixTransposeOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMatlabForStatement: 
                 returnPointer =  SgMatlabForStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMemberFunctionDeclaration: 
                 returnPointer =  SgMemberFunctionDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMemberFunctionRefExp: 
                 returnPointer =  SgMemberFunctionRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMemberFunctionSymbol: 
                 returnPointer =  SgMemberFunctionSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMemberFunctionType: 
                 returnPointer =  SgMemberFunctionType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMembershipOp: 
                 returnPointer =  SgMembershipOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMicrosoftAttributeDeclaration: 
                 returnPointer =  SgMicrosoftAttributeDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMinusAssignOp: 
                 returnPointer =  SgMinusAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMinusMinusOp: 
                 returnPointer =  SgMinusMinusOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMinusOp: 
                 returnPointer =  SgMinusOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModAssignOp: 
                 returnPointer =  SgModAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModOp: 
                 returnPointer =  SgModOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModifier: 
                 returnPointer =  SgModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModifierNodes: 
                 returnPointer =  SgModifierNodes::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModifierType: 
                 returnPointer =  SgModifierType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModuleStatement: 
                 returnPointer =  SgModuleStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModuleSymbol: 
                 returnPointer =  SgModuleSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMultAssignOp: 
                 returnPointer =  SgMultAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMultiplyOp: 
                 returnPointer =  SgMultiplyOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgName: 
                 returnPointer =  SgName::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNameGroup: 
                 returnPointer =  SgNameGroup::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamedType: 
                 returnPointer =  SgNamedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamelistStatement: 
                 returnPointer =  SgNamelistStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamespaceAliasDeclarationStatement: 
                 returnPointer =  SgNamespaceAliasDeclarationStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamespaceDeclarationStatement: 
                 returnPointer =  SgNamespaceDeclarationStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamespaceDefinitionStatement: 
                 returnPointer =  SgNamespaceDefinitionStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamespaceSymbol: 
                 returnPointer =  SgNamespaceSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNaryOp: 
                 returnPointer =  SgNaryOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNaryBooleanOp: 
                 returnPointer =  SgNaryBooleanOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNaryComparisonOp: 
                 returnPointer =  SgNaryComparisonOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNewExp: 
                 returnPointer =  SgNewExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNode: 
                 returnPointer =  SgNode::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNoexceptOp: 
                 returnPointer =  SgNoexceptOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNotEqualOp: 
                 returnPointer =  SgNotEqualOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNotOp: 
                 returnPointer =  SgNotOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNonMembershipOp: 
                 returnPointer =  SgNonMembershipOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNonrealDecl: 
                 returnPointer =  SgNonrealDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNonrealRefExp: 
                 returnPointer =  SgNonrealRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNonrealSymbol: 
                 returnPointer =  SgNonrealSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNonrealType: 
                 returnPointer =  SgNonrealType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNonrealBaseClass: 
                 returnPointer =  SgNonrealBaseClass::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNullExpression: 
                 returnPointer =  SgNullExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNullptrValExp: 
                 returnPointer =  SgNullptrValExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNullStatement: 
                 returnPointer =  SgNullStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNullifyStatement: 
                 returnPointer =  SgNullifyStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpAtomicStatement: 
                 returnPointer =  SgOmpAtomicStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpBarrierStatement: 
                 returnPointer =  SgOmpBarrierStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpCriticalStatement: 
                 returnPointer =  SgOmpCriticalStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpClauseBodyStatement: 
                 returnPointer =  SgOmpClauseBodyStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpBodyStatement: 
                 returnPointer =  SgOmpBodyStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpDoStatement: 
                 returnPointer =  SgOmpDoStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpFlushStatement: 
                 returnPointer =  SgOmpFlushStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpDeclareSimdStatement: 
                 returnPointer =  SgOmpDeclareSimdStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpForStatement: 
                 returnPointer =  SgOmpForStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpForSimdStatement: 
                 returnPointer =  SgOmpForSimdStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpMasterStatement: 
                 returnPointer =  SgOmpMasterStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpOrderedStatement: 
                 returnPointer =  SgOmpOrderedStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpParallelStatement: 
                 returnPointer =  SgOmpParallelStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSectionStatement: 
                 returnPointer =  SgOmpSectionStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSectionsStatement: 
                 returnPointer =  SgOmpSectionsStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSingleStatement: 
                 returnPointer =  SgOmpSingleStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpTaskStatement: 
                 returnPointer =  SgOmpTaskStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpTaskwaitStatement: 
                 returnPointer =  SgOmpTaskwaitStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpThreadprivateStatement: 
                 returnPointer =  SgOmpThreadprivateStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpWorkshareStatement: 
                 returnPointer =  SgOmpWorkshareStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpTargetStatement: 
                 returnPointer =  SgOmpTargetStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpTargetDataStatement: 
                 returnPointer =  SgOmpTargetDataStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSimdStatement: 
                 returnPointer =  SgOmpSimdStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpClause: 
                 returnPointer =  SgOmpClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpBeginClause: 
                 returnPointer =  SgOmpBeginClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpCollapseClause: 
                 returnPointer =  SgOmpCollapseClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpCopyinClause: 
                 returnPointer =  SgOmpCopyinClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpCopyprivateClause: 
                 returnPointer =  SgOmpCopyprivateClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpDefaultClause: 
                 returnPointer =  SgOmpDefaultClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpEndClause: 
                 returnPointer =  SgOmpEndClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpExpressionClause: 
                 returnPointer =  SgOmpExpressionClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpFirstprivateClause: 
                 returnPointer =  SgOmpFirstprivateClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpIfClause: 
                 returnPointer =  SgOmpIfClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpFinalClause: 
                 returnPointer =  SgOmpFinalClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpPriorityClause: 
                 returnPointer =  SgOmpPriorityClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpDeviceClause: 
                 returnPointer =  SgOmpDeviceClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpLastprivateClause: 
                 returnPointer =  SgOmpLastprivateClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpNowaitClause: 
                 returnPointer =  SgOmpNowaitClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpNumThreadsClause: 
                 returnPointer =  SgOmpNumThreadsClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpOrderedClause: 
                 returnPointer =  SgOmpOrderedClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpPrivateClause: 
                 returnPointer =  SgOmpPrivateClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpReductionClause: 
                 returnPointer =  SgOmpReductionClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpScheduleClause: 
                 returnPointer =  SgOmpScheduleClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSharedClause: 
                 returnPointer =  SgOmpSharedClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpUntiedClause: 
                 returnPointer =  SgOmpUntiedClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpMergeableClause: 
                 returnPointer =  SgOmpMergeableClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpVariablesClause: 
                 returnPointer =  SgOmpVariablesClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpMapClause: 
                 returnPointer =  SgOmpMapClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSafelenClause: 
                 returnPointer =  SgOmpSafelenClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSimdlenClause: 
                 returnPointer =  SgOmpSimdlenClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpLinearClause: 
                 returnPointer =  SgOmpLinearClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpUniformClause: 
                 returnPointer =  SgOmpUniformClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpAlignedClause: 
                 returnPointer =  SgOmpAlignedClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpProcBindClause: 
                 returnPointer =  SgOmpProcBindClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpAtomicClause: 
                 returnPointer =  SgOmpAtomicClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpInbranchClause: 
                 returnPointer =  SgOmpInbranchClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpNotinbranchClause: 
                 returnPointer =  SgOmpNotinbranchClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpDependClause: 
                 returnPointer =  SgOmpDependClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOpenclAccessModeModifier: 
                 returnPointer =  SgOpenclAccessModeModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOpenStatement: 
                 returnPointer =  SgOpenStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOptions: 
                 returnPointer =  SgOptions::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOrOp: 
                 returnPointer =  SgOrOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgParameterStatement: 
                 returnPointer =  SgParameterStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPartialFunctionModifierType: 
                 returnPointer =  SgPartialFunctionModifierType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPartialFunctionType: 
                 returnPointer =  SgPartialFunctionType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPassStatement: 
                 returnPointer =  SgPassStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPlusAssignOp: 
                 returnPointer =  SgPlusAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPlusPlusOp: 
                 returnPointer =  SgPlusPlusOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPntrArrRefExp: 
                 returnPointer =  SgPntrArrRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPointerAssignOp: 
                 returnPointer =  SgPointerAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPointerDerefExp: 
                 returnPointer =  SgPointerDerefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPointerMemberType: 
                 returnPointer =  SgPointerMemberType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPointerType: 
                 returnPointer =  SgPointerType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPowerOp: 
                 returnPointer =  SgPowerOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPragma: 
                 returnPointer =  SgPragma::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPragmaDeclaration: 
                 returnPointer =  SgPragmaDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPrintStatement: 
                 returnPointer =  SgPrintStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgProcedureHeaderStatement: 
                 returnPointer =  SgProcedureHeaderStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgProgramHeaderStatement: 
                 returnPointer =  SgProgramHeaderStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgProject: 
                 returnPointer =  SgProject::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPseudoDestructorRefExp: 
                 returnPointer =  SgPseudoDestructorRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPythonGlobalStmt: 
                 returnPointer =  SgPythonGlobalStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPythonPrintStmt: 
                 returnPointer =  SgPythonPrintStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgQualifiedName: 
                 returnPointer =  SgQualifiedName::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgQualifiedNameType: 
                 returnPointer =  SgQualifiedNameType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRangeExp: 
                 returnPointer =  SgRangeExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRangeBasedForStatement: 
                 returnPointer =  SgRangeBasedForStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgReadStatement: 
                 returnPointer =  SgReadStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRealPartOp: 
                 returnPointer =  SgRealPartOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRefExp: 
                 returnPointer =  SgRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgReferenceType: 
                 returnPointer =  SgReferenceType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRemOp: 
                 returnPointer =  SgRemOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRenamePair: 
                 returnPointer =  SgRenamePair::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRenameSymbol: 
                 returnPointer =  SgRenameSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgReplicationOp: 
                 returnPointer =  SgReplicationOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgReturnStmt: 
                 returnPointer =  SgReturnStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRewindStatement: 
                 returnPointer =  SgRewindStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRshiftAssignOp: 
                 returnPointer =  SgRshiftAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRshiftOp: 
                 returnPointer =  SgRshiftOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRvalueReferenceType: 
                 returnPointer =  SgRvalueReferenceType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaUnsignedRshiftAssignOp: 
                 returnPointer =  SgJavaUnsignedRshiftAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaUnsignedRshiftOp: 
                 returnPointer =  SgJavaUnsignedRshiftOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgScopeOp: 
                 returnPointer =  SgScopeOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgScopeStatement: 
                 returnPointer =  SgScopeStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSequenceStatement: 
                 returnPointer =  SgSequenceStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSetComprehension: 
                 returnPointer =  SgSetComprehension::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgShortVal: 
                 returnPointer =  SgShortVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSizeOfOp: 
                 returnPointer =  SgSizeOfOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAlignOfOp: 
                 returnPointer =  SgAlignOfOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaInstanceOfOp: 
                 returnPointer =  SgJavaInstanceOfOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSourceFile: 
                 returnPointer =  SgSourceFile::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSpaceshipOp: 
                 returnPointer =  SgSpaceshipOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSpawnStmt: 
                 returnPointer =  SgSpawnStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSyncAllStatement: 
                 returnPointer =  SgSyncAllStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSyncImagesStatement: 
                 returnPointer =  SgSyncImagesStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSyncMemoryStatement: 
                 returnPointer =  SgSyncMemoryStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSyncTeamStatement: 
                 returnPointer =  SgSyncTeamStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLockStatement: 
                 returnPointer =  SgLockStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnlockStatement: 
                 returnPointer =  SgUnlockStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaThrowStatement: 
                 returnPointer =  SgJavaThrowStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaForEachStatement: 
                 returnPointer =  SgJavaForEachStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaSynchronizedStatement: 
                 returnPointer =  SgJavaSynchronizedStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaParameterizedType: 
                 returnPointer =  SgJavaParameterizedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaWildcardType: 
                 returnPointer =  SgJavaWildcardType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgProcessControlStatement: 
                 returnPointer =  SgProcessControlStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSpecialFunctionModifier: 
                 returnPointer =  SgSpecialFunctionModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStatement: 
                 returnPointer =  SgStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStaticAssertionDeclaration: 
                 returnPointer =  SgStaticAssertionDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStmtDeclarationStatement: 
                 returnPointer =  SgStmtDeclarationStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStatementExpression: 
                 returnPointer =  SgStatementExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStatementFunctionStatement: 
                 returnPointer =  SgStatementFunctionStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStorageModifier: 
                 returnPointer =  SgStorageModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStringConversion: 
                 returnPointer =  SgStringConversion::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStringKeyedBidirectionalGraph: 
                 returnPointer =  SgStringKeyedBidirectionalGraph::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStringVal: 
                 returnPointer =  SgStringVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStructureModifier: 
                 returnPointer =  SgStructureModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSubscriptExpression: 
                 returnPointer =  SgSubscriptExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSubtractOp: 
                 returnPointer =  SgSubtractOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSupport: 
                 returnPointer =  SgSupport::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSwitchStatement: 
                 returnPointer =  SgSwitchStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSymbol: 
                 returnPointer =  SgSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSymbolTable: 
                 returnPointer =  SgSymbolTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateArgument: 
                 returnPointer =  SgTemplateArgument::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateArgumentList: 
                 returnPointer =  SgTemplateArgumentList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateDeclaration: 
                 returnPointer =  SgTemplateDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateClassDeclaration: 
                 returnPointer =  SgTemplateClassDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateClassSymbol: 
                 returnPointer =  SgTemplateClassSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateFunctionDeclaration: 
                 returnPointer =  SgTemplateFunctionDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateFunctionRefExp: 
                 returnPointer =  SgTemplateFunctionRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateFunctionSymbol: 
                 returnPointer =  SgTemplateFunctionSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateMemberFunctionDeclaration: 
                 returnPointer =  SgTemplateMemberFunctionDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateMemberFunctionRefExp: 
                 returnPointer =  SgTemplateMemberFunctionRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateMemberFunctionSymbol: 
                 returnPointer =  SgTemplateMemberFunctionSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateTypedefDeclaration: 
                 returnPointer =  SgTemplateTypedefDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateTypedefSymbol: 
                 returnPointer =  SgTemplateTypedefSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateVariableDeclaration: 
                 returnPointer =  SgTemplateVariableDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateVariableSymbol: 
                 returnPointer =  SgTemplateVariableSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateClassDefinition: 
                 returnPointer =  SgTemplateClassDefinition::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateFunctionDefinition: 
                 returnPointer =  SgTemplateFunctionDefinition::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationDecl: 
                 returnPointer =  SgTemplateInstantiationDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationDefn: 
                 returnPointer =  SgTemplateInstantiationDefn::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationDirectiveStatement: 
                 returnPointer =  SgTemplateInstantiationDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationFunctionDecl: 
                 returnPointer =  SgTemplateInstantiationFunctionDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationMemberFunctionDecl: 
                 returnPointer =  SgTemplateInstantiationMemberFunctionDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationTypedefDeclaration: 
                 returnPointer =  SgTemplateInstantiationTypedefDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateParameter: 
                 returnPointer =  SgTemplateParameter::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateParameterVal: 
                 returnPointer =  SgTemplateParameterVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateParameterList: 
                 returnPointer =  SgTemplateParameterList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateSymbol: 
                 returnPointer =  SgTemplateSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateType: 
                 returnPointer =  SgTemplateType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgThisExp: 
                 returnPointer =  SgThisExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeTraitBuiltinOperator: 
                 returnPointer =  SgTypeTraitBuiltinOperator::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSuperExp: 
                 returnPointer =  SgSuperExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgThrowOp: 
                 returnPointer =  SgThrowOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgToken: 
                 returnPointer =  SgToken::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTryStmt: 
                 returnPointer =  SgTryStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTupleExp: 
                 returnPointer =  SgTupleExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgType: 
                 returnPointer =  SgType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeBool: 
                 returnPointer =  SgTypeBool::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeChar: 
                 returnPointer =  SgTypeChar::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeChar16: 
                 returnPointer =  SgTypeChar16::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeChar32: 
                 returnPointer =  SgTypeChar32::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeComplex: 
                 returnPointer =  SgTypeComplex::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeDefault: 
                 returnPointer =  SgTypeDefault::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeExpression: 
                 returnPointer =  SgTypeExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeLabel: 
                 returnPointer =  SgTypeLabel::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeDouble: 
                 returnPointer =  SgTypeDouble::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeEllipse: 
                 returnPointer =  SgTypeEllipse::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeFixed: 
                 returnPointer =  SgTypeFixed::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeFloat: 
                 returnPointer =  SgTypeFloat::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeFloat128: 
                 returnPointer =  SgTypeFloat128::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeFloat80: 
                 returnPointer =  SgTypeFloat80::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeGlobalVoid: 
                 returnPointer =  SgTypeGlobalVoid::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeIdOp: 
                 returnPointer =  SgTypeIdOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeImaginary: 
                 returnPointer =  SgTypeImaginary::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeInt: 
                 returnPointer =  SgTypeInt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeLong: 
                 returnPointer =  SgTypeLong::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeLongDouble: 
                 returnPointer =  SgTypeLongDouble::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeLongLong: 
                 returnPointer =  SgTypeLongLong::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeModifier: 
                 returnPointer =  SgTypeModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeMatrix: 
                 returnPointer =  SgTypeMatrix::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeTuple: 
                 returnPointer =  SgTypeTuple::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeNullptr: 
                 returnPointer =  SgTypeNullptr::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeOfType: 
                 returnPointer =  SgTypeOfType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeShort: 
                 returnPointer =  SgTypeShort::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSigned128bitInteger: 
                 returnPointer =  SgTypeSigned128bitInteger::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedChar: 
                 returnPointer =  SgTypeSignedChar::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedInt: 
                 returnPointer =  SgTypeSignedInt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedLong: 
                 returnPointer =  SgTypeSignedLong::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedLongLong: 
                 returnPointer =  SgTypeSignedLongLong::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedShort: 
                 returnPointer =  SgTypeSignedShort::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeString: 
                 returnPointer =  SgTypeString::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnknown: 
                 returnPointer =  SgTypeUnknown::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsigned128bitInteger: 
                 returnPointer =  SgTypeUnsigned128bitInteger::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedChar: 
                 returnPointer =  SgTypeUnsignedChar::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedInt: 
                 returnPointer =  SgTypeUnsignedInt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedLong: 
                 returnPointer =  SgTypeUnsignedLong::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedLongLong: 
                 returnPointer =  SgTypeUnsignedLongLong::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedShort: 
                 returnPointer =  SgTypeUnsignedShort::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeVoid: 
                 returnPointer =  SgTypeVoid::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeWchar: 
                 returnPointer =  SgTypeWchar::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypedefDeclaration: 
                 returnPointer =  SgTypedefDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypedefSeq: 
                 returnPointer =  SgTypedefSeq::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypedefSymbol: 
                 returnPointer =  SgTypedefSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypedefType: 
                 returnPointer =  SgTypedefType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUPC_AccessModifier: 
                 returnPointer =  SgUPC_AccessModifier::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnaryAddOp: 
                 returnPointer =  SgUnaryAddOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnaryOp: 
                 returnPointer =  SgUnaryOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUndefDirectiveStatement: 
                 returnPointer =  SgUndefDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUndirectedGraphEdge: 
                 returnPointer =  SgUndirectedGraphEdge::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnknownArrayOrFunctionReference: 
                 returnPointer =  SgUnknownArrayOrFunctionReference::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnknownFile: 
                 returnPointer =  SgUnknownFile::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnparse_Info: 
                 returnPointer =  SgUnparse_Info::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedCharVal: 
                 returnPointer =  SgUnsignedCharVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedIntVal: 
                 returnPointer =  SgUnsignedIntVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedLongLongIntVal: 
                 returnPointer =  SgUnsignedLongLongIntVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedLongVal: 
                 returnPointer =  SgUnsignedLongVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedShortVal: 
                 returnPointer =  SgUnsignedShortVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcBarrierStatement: 
                 returnPointer =  SgUpcBarrierStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcBlocksizeofExpression: 
                 returnPointer =  SgUpcBlocksizeofExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcElemsizeofExpression: 
                 returnPointer =  SgUpcElemsizeofExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcFenceStatement: 
                 returnPointer =  SgUpcFenceStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcForAllStatement: 
                 returnPointer =  SgUpcForAllStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcLocalsizeofExpression: 
                 returnPointer =  SgUpcLocalsizeofExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcMythread: 
                 returnPointer =  SgUpcMythread::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcNotifyStatement: 
                 returnPointer =  SgUpcNotifyStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcThreads: 
                 returnPointer =  SgUpcThreads::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcWaitStatement: 
                 returnPointer =  SgUpcWaitStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUseStatement: 
                 returnPointer =  SgUseStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUserDefinedBinaryOp: 
                 returnPointer =  SgUserDefinedBinaryOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUserDefinedUnaryOp: 
                 returnPointer =  SgUserDefinedUnaryOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUsingDeclarationStatement: 
                 returnPointer =  SgUsingDeclarationStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUsingDirectiveStatement: 
                 returnPointer =  SgUsingDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgValueExp: 
                 returnPointer =  SgValueExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgCopyOp: 
                 returnPointer =  SgVarArgCopyOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgEndOp: 
                 returnPointer =  SgVarArgEndOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgOp: 
                 returnPointer =  SgVarArgOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgStartOneOperandOp: 
                 returnPointer =  SgVarArgStartOneOperandOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgStartOp: 
                 returnPointer =  SgVarArgStartOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarRefExp: 
                 returnPointer =  SgVarRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariableDeclaration: 
                 returnPointer =  SgVariableDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariableDefinition: 
                 returnPointer =  SgVariableDefinition::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariableSymbol: 
                 returnPointer =  SgVariableSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariantExpression: 
                 returnPointer =  SgVariantExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariantStatement: 
                 returnPointer =  SgVariantStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVoidVal: 
                 returnPointer =  SgVoidVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWaitStatement: 
                 returnPointer =  SgWaitStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWarningDirectiveStatement: 
                 returnPointer =  SgWarningDirectiveStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWithStatement: 
                 returnPointer =  SgWithStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWcharVal: 
                 returnPointer =  SgWcharVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWhereStatement: 
                 returnPointer =  SgWhereStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWhileStmt: 
                 returnPointer =  SgWhileStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWriteStatement: 
                 returnPointer =  SgWriteStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgXorAssignOp: 
                 returnPointer =  SgXorAssignOp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgYieldExpression: 
                 returnPointer =  SgYieldExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_Sg_File_Info: 
                 returnPointer =  Sg_File_Info::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeCAFTeam: 
                 returnPointer =  SgTypeCAFTeam::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCAFWithTeamStatement: 
                 returnPointer =  SgCAFWithTeamStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCAFCoExpression: 
                 returnPointer =  SgCAFCoExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCallExpression: 
                 returnPointer =  SgCallExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeCrayPointer: 
                 returnPointer =  SgTypeCrayPointer::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaImportStatement: 
                 returnPointer =  SgJavaImportStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaPackageDeclaration: 
                 returnPointer =  SgJavaPackageDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaPackageStatement: 
                 returnPointer =  SgJavaPackageStatement::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaImportStatementList: 
                 returnPointer =  SgJavaImportStatementList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaClassDeclarationList: 
                 returnPointer =  SgJavaClassDeclarationList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaMemberValuePair: 
                 returnPointer =  SgJavaMemberValuePair::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaAnnotation: 
                 returnPointer =  SgJavaAnnotation::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaMarkerAnnotation: 
                 returnPointer =  SgJavaMarkerAnnotation::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaSingleMemberAnnotation: 
                 returnPointer =  SgJavaSingleMemberAnnotation::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaNormalAnnotation: 
                 returnPointer =  SgJavaNormalAnnotation::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaTypeExpression: 
                 returnPointer =  SgJavaTypeExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaQualifiedType: 
                 returnPointer =  SgJavaQualifiedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassExp: 
                 returnPointer =  SgClassExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaUnionType: 
                 returnPointer =  SgJavaUnionType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaParameterType: 
                 returnPointer =  SgJavaParameterType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsyncStmt: 
                 returnPointer =  SgAsyncStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFinishStmt: 
                 returnPointer =  SgFinishStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAtStmt: 
                 returnPointer =  SgAtStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAtomicStmt: 
                 returnPointer =  SgAtomicStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWhenStmt: 
                 returnPointer =  SgWhenStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAtExp: 
                 returnPointer =  SgAtExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFinishExp: 
                 returnPointer =  SgFinishExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgHereExp: 
                 returnPointer =  SgHereExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDotDotExp: 
                 returnPointer =  SgDotDotExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNullInstruction: 
                 returnPointer =  SgAsmNullInstruction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaComponentClause: 
                 returnPointer =  SgAdaComponentClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaIndexConstraint: 
                 returnPointer =  SgAdaIndexConstraint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaModularType: 
                 returnPointer =  SgAdaModularType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaRepresentationClause: 
                 returnPointer =  SgAdaRepresentationClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaFunctionRenamingDecl: 
                 returnPointer =  SgAdaFunctionRenamingDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaSelectStmt: 
                 returnPointer =  SgAdaSelectStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaSelectAlternativeStmt: 
                 returnPointer =  SgAdaSelectAlternativeStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaTerminateStmt: 
                 returnPointer =  SgAdaTerminateStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmAarch32Coprocessor: 
                 returnPointer =  SgAsmAarch32Coprocessor::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaAttributeClause: 
                 returnPointer =  SgAdaAttributeClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryConcat: 
                 returnPointer =  SgAsmBinaryConcat::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmByteOrder: 
                 returnPointer =  SgAsmByteOrder::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaDerivedType: 
                 returnPointer =  SgAdaDerivedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaAttributeExp: 
                 returnPointer =  SgAdaAttributeExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaEnumRepresentationClause: 
                 returnPointer =  SgAdaEnumRepresentationClause::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryPreupdate: 
                 returnPointer =  SgAsmBinaryPreupdate::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryPostupdate: 
                 returnPointer =  SgAsmBinaryPostupdate::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaOthersExp: 
                 returnPointer =  SgAdaOthersExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaRenamingSymbol: 
                 returnPointer =  SgAdaRenamingSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaRenamingRefExp: 
                 returnPointer =  SgAdaRenamingRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaGenericDecl: 
                 returnPointer =  SgAdaGenericDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaGenericDefn: 
                 returnPointer =  SgAdaGenericDefn::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaFormalType: 
                 returnPointer =  SgAdaFormalType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaGenericSymbol: 
                 returnPointer =  SgAdaGenericSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaFormalTypeDecl: 
                 returnPointer =  SgAdaFormalTypeDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaUnitRefExp: 
                 returnPointer =  SgAdaUnitRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaDiscriminatedTypeDecl: 
                 returnPointer =  SgAdaDiscriminatedTypeDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaDiscriminatedType: 
                 returnPointer =  SgAdaDiscriminatedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaDiscriminantConstraint: 
                 returnPointer =  SgAdaDiscriminantConstraint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaGenericInstanceDecl: 
                 returnPointer =  SgAdaGenericInstanceDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaUnscopedBlock: 
                 returnPointer =  SgAdaUnscopedBlock::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaInheritedFunctionSymbol: 
                 returnPointer =  SgAdaInheritedFunctionSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaProtectedBody: 
                 returnPointer =  SgAdaProtectedBody::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaProtectedBodyDecl: 
                 returnPointer =  SgAdaProtectedBodyDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaProtectedSpec: 
                 returnPointer =  SgAdaProtectedSpec::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaProtectedSpecDecl: 
                 returnPointer =  SgAdaProtectedSpecDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaProtectedSymbol: 
                 returnPointer =  SgAdaProtectedSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaProtectedRefExp: 
                 returnPointer =  SgAdaProtectedRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaProtectedType: 
                 returnPointer =  SgAdaProtectedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaProtectedTypeDecl: 
                 returnPointer =  SgAdaProtectedTypeDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaDigitsConstraint: 
                 returnPointer =  SgAdaDigitsConstraint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaAncestorInitializer: 
                 returnPointer =  SgAdaAncestorInitializer::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaDeltaConstraint: 
                 returnPointer =  SgAdaDeltaConstraint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaSubroutineType: 
                 returnPointer =  SgAdaSubroutineType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaGenericInstanceSymbol: 
                 returnPointer =  SgAdaGenericInstanceSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaFormalPackageDecl: 
                 returnPointer =  SgAdaFormalPackageDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaFormalPackageSymbol: 
                 returnPointer =  SgAdaFormalPackageSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmAttributeTable: 
                 returnPointer =  SgAsmJvmAttributeTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmMethodTable: 
                 returnPointer =  SgAsmJvmMethodTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmField: 
                 returnPointer =  SgAsmJvmField::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmFieldTable: 
                 returnPointer =  SgAsmJvmFieldTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmExceptionHandler: 
                 returnPointer =  SgAsmJvmExceptionHandler::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmExceptionTable: 
                 returnPointer =  SgAsmJvmExceptionTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmClass: 
                 returnPointer =  SgAsmJvmClass::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmLineNumberEntry: 
                 returnPointer =  SgAsmJvmLineNumberEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmLineNumberTable: 
                 returnPointer =  SgAsmJvmLineNumberTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmInnerClassesEntry: 
                 returnPointer =  SgAsmJvmInnerClassesEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmInnerClasses: 
                 returnPointer =  SgAsmJvmInnerClasses::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilInstruction: 
                 returnPointer =  SgAsmCilInstruction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStackExpression: 
                 returnPointer =  SgAsmStackExpression::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmEnclosingMethod: 
                 returnPointer =  SgAsmJvmEnclosingMethod::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaNullConstraint: 
                 returnPointer =  SgAdaNullConstraint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmModuleMainClass: 
                 returnPointer =  SgAsmJvmModuleMainClass::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmInstructionList: 
                 returnPointer =  SgAsmInstructionList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilNode: 
                 returnPointer =  SgAsmCilNode::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssembly: 
                 returnPointer =  SgAsmCilAssembly::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyOS: 
                 returnPointer =  SgAsmCilAssemblyOS::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyProcessor: 
                 returnPointer =  SgAsmCilAssemblyProcessor::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyRef: 
                 returnPointer =  SgAsmCilAssemblyRef::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyRefOS: 
                 returnPointer =  SgAsmCilAssemblyRefOS::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyRefProcessor: 
                 returnPointer =  SgAsmCilAssemblyRefProcessor::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilClassLayout: 
                 returnPointer =  SgAsmCilClassLayout::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilConstant: 
                 returnPointer =  SgAsmCilConstant::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilCustomAttribute: 
                 returnPointer =  SgAsmCilCustomAttribute::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilDeclSecurity: 
                 returnPointer =  SgAsmCilDeclSecurity::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilEvent: 
                 returnPointer =  SgAsmCilEvent::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilEventMap: 
                 returnPointer =  SgAsmCilEventMap::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilExportedType: 
                 returnPointer =  SgAsmCilExportedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilField: 
                 returnPointer =  SgAsmCilField::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilFieldLayout: 
                 returnPointer =  SgAsmCilFieldLayout::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilFieldMarshal: 
                 returnPointer =  SgAsmCilFieldMarshal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilFieldRVA: 
                 returnPointer =  SgAsmCilFieldRVA::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilFile: 
                 returnPointer =  SgAsmCilFile::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilGenericParam: 
                 returnPointer =  SgAsmCilGenericParam::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilGenericParamConstraint: 
                 returnPointer =  SgAsmCilGenericParamConstraint::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilImplMap: 
                 returnPointer =  SgAsmCilImplMap::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilInterfaceImpl: 
                 returnPointer =  SgAsmCilInterfaceImpl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilManifestResource: 
                 returnPointer =  SgAsmCilManifestResource::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMemberRef: 
                 returnPointer =  SgAsmCilMemberRef::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMethodDef: 
                 returnPointer =  SgAsmCilMethodDef::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMethodImpl: 
                 returnPointer =  SgAsmCilMethodImpl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMethodSemantics: 
                 returnPointer =  SgAsmCilMethodSemantics::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMethodSpec: 
                 returnPointer =  SgAsmCilMethodSpec::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilModule: 
                 returnPointer =  SgAsmCilModule::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilModuleRef: 
                 returnPointer =  SgAsmCilModuleRef::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilNestedClass: 
                 returnPointer =  SgAsmCilNestedClass::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilParam: 
                 returnPointer =  SgAsmCilParam::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilProperty: 
                 returnPointer =  SgAsmCilProperty::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilPropertyMap: 
                 returnPointer =  SgAsmCilPropertyMap::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilStandAloneSig: 
                 returnPointer =  SgAsmCilStandAloneSig::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilTypeDef: 
                 returnPointer =  SgAsmCilTypeDef::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilTypeRef: 
                 returnPointer =  SgAsmCilTypeRef::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilTypeSpec: 
                 returnPointer =  SgAsmCilTypeSpec::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaParameterList: 
                 returnPointer =  SgAdaParameterList::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMetadata: 
                 returnPointer =  SgAsmCilMetadata::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMetadataRoot: 
                 returnPointer =  SgAsmCilMetadataRoot::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilDataStream: 
                 returnPointer =  SgAsmCilDataStream::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMetadataHeap: 
                 returnPointer =  SgAsmCilMetadataHeap::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilUint8Heap: 
                 returnPointer =  SgAsmCilUint8Heap::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilUint32Heap: 
                 returnPointer =  SgAsmCilUint32Heap::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCliHeader: 
                 returnPointer =  SgAsmCliHeader::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaVariantDecl: 
                 returnPointer =  SgAdaVariantDecl::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAdaVariantWhenStmt: 
                 returnPointer =  SgAdaVariantWhenStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyTable: 
                 returnPointer =  SgAsmCilAssemblyTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyOSTable: 
                 returnPointer =  SgAsmCilAssemblyOSTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyProcessorTable: 
                 returnPointer =  SgAsmCilAssemblyProcessorTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyRefTable: 
                 returnPointer =  SgAsmCilAssemblyRefTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyRefOSTable: 
                 returnPointer =  SgAsmCilAssemblyRefOSTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilAssemblyRefProcessorTable: 
                 returnPointer =  SgAsmCilAssemblyRefProcessorTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilClassLayoutTable: 
                 returnPointer =  SgAsmCilClassLayoutTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilConstantTable: 
                 returnPointer =  SgAsmCilConstantTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilCustomAttributeTable: 
                 returnPointer =  SgAsmCilCustomAttributeTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilDeclSecurityTable: 
                 returnPointer =  SgAsmCilDeclSecurityTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilEventTable: 
                 returnPointer =  SgAsmCilEventTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilEventMapTable: 
                 returnPointer =  SgAsmCilEventMapTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilExportedTypeTable: 
                 returnPointer =  SgAsmCilExportedTypeTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilFieldTable: 
                 returnPointer =  SgAsmCilFieldTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilFieldLayoutTable: 
                 returnPointer =  SgAsmCilFieldLayoutTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilFieldMarshalTable: 
                 returnPointer =  SgAsmCilFieldMarshalTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilFieldRVATable: 
                 returnPointer =  SgAsmCilFieldRVATable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilFileTable: 
                 returnPointer =  SgAsmCilFileTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilGenericParamTable: 
                 returnPointer =  SgAsmCilGenericParamTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilGenericParamConstraintTable: 
                 returnPointer =  SgAsmCilGenericParamConstraintTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilImplMapTable: 
                 returnPointer =  SgAsmCilImplMapTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilInterfaceImplTable: 
                 returnPointer =  SgAsmCilInterfaceImplTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilManifestResourceTable: 
                 returnPointer =  SgAsmCilManifestResourceTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMemberRefTable: 
                 returnPointer =  SgAsmCilMemberRefTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMethodDefTable: 
                 returnPointer =  SgAsmCilMethodDefTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMethodImplTable: 
                 returnPointer =  SgAsmCilMethodImplTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMethodSemanticsTable: 
                 returnPointer =  SgAsmCilMethodSemanticsTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMethodSpecTable: 
                 returnPointer =  SgAsmCilMethodSpecTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilModuleTable: 
                 returnPointer =  SgAsmCilModuleTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilModuleRefTable: 
                 returnPointer =  SgAsmCilModuleRefTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilNestedClassTable: 
                 returnPointer =  SgAsmCilNestedClassTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilParamTable: 
                 returnPointer =  SgAsmCilParamTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilPropertyTable: 
                 returnPointer =  SgAsmCilPropertyTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilPropertyMapTable: 
                 returnPointer =  SgAsmCilPropertyMapTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilStandAloneSigTable: 
                 returnPointer =  SgAsmCilStandAloneSigTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilTypeDefTable: 
                 returnPointer =  SgAsmCilTypeDefTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilTypeRefTable: 
                 returnPointer =  SgAsmCilTypeRefTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilTypeSpecTable: 
                 returnPointer =  SgAsmCilTypeSpecTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJvmComposite: 
                 returnPointer =  SgJvmComposite::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFortranContinueStmt: 
                 returnPointer =  SgFortranContinueStmt::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmStackMapTable: 
                 returnPointer =  SgAsmJvmStackMapTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmStackMapFrame: 
                 returnPointer =  SgAsmJvmStackMapFrame::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmStackMapVerificationType: 
                 returnPointer =  SgAsmJvmStackMapVerificationType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmBootstrapMethod: 
                 returnPointer =  SgAsmJvmBootstrapMethod::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmBootstrapMethods: 
                 returnPointer =  SgAsmJvmBootstrapMethods::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmExceptions: 
                 returnPointer =  SgAsmJvmExceptions::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmNestMembers: 
                 returnPointer =  SgAsmJvmNestMembers::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmNestHost: 
                 returnPointer =  SgAsmJvmNestHost::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJovialLabelDeclaration: 
                 returnPointer =  SgJovialLabelDeclaration::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmLocalVariableEntry: 
                 returnPointer =  SgAsmJvmLocalVariableEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmLocalVariableTable: 
                 returnPointer =  SgAsmJvmLocalVariableTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmLocalVariableTypeEntry: 
                 returnPointer =  SgAsmJvmLocalVariableTypeEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmLocalVariableTypeTable: 
                 returnPointer =  SgAsmJvmLocalVariableTypeTable::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUserInstruction: 
                 returnPointer =  SgAsmUserInstruction::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmMethodParameters: 
                 returnPointer =  SgAsmJvmMethodParameters::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmMethodParametersEntry: 
                 returnPointer =  SgAsmJvmMethodParametersEntry::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmVoidType: 
                 returnPointer =  SgAsmVoidType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPointerType: 
                 returnPointer =  SgAsmPointerType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRangeType: 
                 returnPointer =  SgRangeType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilExceptionData: 
                 returnPointer =  SgAsmCilExceptionData::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilMethodData: 
                 returnPointer =  SgAsmCilMethodData::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateVariableInstantiation: 
                 returnPointer =  SgTemplateVariableInstantiation::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgReferenceExp: 
                 returnPointer =  SgReferenceExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeRefExp: 
                 returnPointer =  SgTypeRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgScopedRefExp: 
                 returnPointer =  SgScopedRefExp::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgScopedType: 
                 returnPointer =  SgScopedType::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSymbol: 
                 returnPointer =  SgTypeSymbol::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmSynthetic: 
                 returnPointer =  SgAsmJvmSynthetic::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmJvmDeprecated: 
                 returnPointer =  SgAsmJvmDeprecated::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSignedCharVal: 
                 returnPointer =  SgSignedCharVal::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCilErrorHeap: 
                 returnPointer =  SgAsmCilErrorHeap::getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
              default:
                 assert ( !" Index error in getPointerFromGlobalIndex !" ) ;
                 break ;
            }
#if FILE_IO_EXTRA_CHECK
         assert ( returnPointer != NULL );
#endif
       }

/* #line 327 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

#if DEBUG_AstFileIO_getSgClassPointerFromGlobalIndex
  printf ("  returnPointer = %p\n", returnPointer); // might not have been read yet
#endif

  return returnPointer;
}



/* JH (01/03/2006) This mehtods steps through all memory pools and deletes all data contained in
   the pools, to prepare the base for starting the memory extension for rebuilding the AST.
*/
void AST_FILE_IO::clearAllMemoryPools( ) {
    freepointersOfCurrentAstAreSetToGlobalIndices = false;
 // JH (08/08/2006) calling delete on the roots of the stored ASTs, in order to have 
 // empty memory pools afterwards
    for (unsigned long i = 0; i < vectorOfASTs.size(); ++i)
       {
         delete (vectorOfASTs[i]->getRootOfAst());
       }
 // JH (08/08/2006) the new version of clear memory pools has nothing to delete anymore, 
 // but still sets the freepointers to have a ordered linked list - maybe this method 
 // should now be renamed  ...

     SgAccessModifier::clearMemoryPool( );
     SgActualArgumentExpression::clearMemoryPool( );
     SgAbsOp::clearMemoryPool( );
     SgAdaAccessType::clearMemoryPool( );
     SgAdaAcceptStmt::clearMemoryPool( );
     SgAdaDelayStmt::clearMemoryPool( );
     SgAdaEntryDecl::clearMemoryPool( );
     SgAdaExitStmt::clearMemoryPool( );
     SgAdaDiscreteType::clearMemoryPool( );
     SgAdaFloatVal::clearMemoryPool( );
     SgAdaLoopStmt::clearMemoryPool( );
     SgAdaPackageBody::clearMemoryPool( );
     SgAdaPackageBodyDecl::clearMemoryPool( );
     SgAdaPackageSpec::clearMemoryPool( );
     SgAdaPackageSpecDecl::clearMemoryPool( );
     SgAdaPackageSymbol::clearMemoryPool( );
     SgAdaRangeConstraint::clearMemoryPool( );
     SgAdaRenamingDecl::clearMemoryPool( );
     SgAdaSubtype::clearMemoryPool( );
     SgAdaTaskBody::clearMemoryPool( );
     SgAdaTaskBodyDecl::clearMemoryPool( );
     SgAdaTaskSpec::clearMemoryPool( );
     SgAdaTaskSpecDecl::clearMemoryPool( );
     SgAdaTaskSymbol::clearMemoryPool( );
     SgAdaTaskRefExp::clearMemoryPool( );
     SgAdaTaskType::clearMemoryPool( );
     SgAdaTaskTypeDecl::clearMemoryPool( );
     SgAdaTypeConstraint::clearMemoryPool( );
     SgAddOp::clearMemoryPool( );
     SgAddressOfOp::clearMemoryPool( );
     SgAggregateInitializer::clearMemoryPool( );
     SgAliasSymbol::clearMemoryPool( );
     SgAllocateStatement::clearMemoryPool( );
     SgAndAssignOp::clearMemoryPool( );
     SgAndOp::clearMemoryPool( );
     SgArithmeticIfStatement::clearMemoryPool( );
     SgArrayType::clearMemoryPool( );
     SgArrowExp::clearMemoryPool( );
     SgArrowStarOp::clearMemoryPool( );
     SgAsmBasicString::clearMemoryPool( );
     SgAsmBinaryAdd::clearMemoryPool( );
     SgAsmBinaryAsr::clearMemoryPool( );
     SgAsmBinaryDivide::clearMemoryPool( );
     SgAsmBinaryExpression::clearMemoryPool( );
     SgAsmBinaryLsl::clearMemoryPool( );
     SgAsmBinaryLsr::clearMemoryPool( );
     SgAsmBinaryMod::clearMemoryPool( );
     SgAsmBinaryMsl::clearMemoryPool( );
     SgAsmBinaryMultiply::clearMemoryPool( );
     SgAsmBinaryRor::clearMemoryPool( );
     SgAsmBinarySubtract::clearMemoryPool( );
     SgAsmBlock::clearMemoryPool( );
     SgAsmCoffStrtab::clearMemoryPool( );
     SgAsmCoffSymbol::clearMemoryPool( );
     SgAsmCoffSymbolList::clearMemoryPool( );
     SgAsmCoffSymbolTable::clearMemoryPool( );
     SgAsmCommonSubExpression::clearMemoryPool( );
     SgAsmControlFlagsExpression::clearMemoryPool( );
     SgAsmConstantExpression::clearMemoryPool( );
     SgAsmDOSExtendedHeader::clearMemoryPool( );
     SgAsmDOSFileHeader::clearMemoryPool( );
     SgAsmSynthesizedDataStructureDeclaration::clearMemoryPool( );
     SgAsmSynthesizedDeclaration::clearMemoryPool( );
     SgAsmDirectRegisterExpression::clearMemoryPool( );
     SgAsmDwarfAccessDeclaration::clearMemoryPool( );
     SgAsmDwarfArrayType::clearMemoryPool( );
     SgAsmDwarfBaseType::clearMemoryPool( );
     SgAsmDwarfCatchBlock::clearMemoryPool( );
     SgAsmDwarfClassTemplate::clearMemoryPool( );
     SgAsmDwarfClassType::clearMemoryPool( );
     SgAsmDwarfCommonBlock::clearMemoryPool( );
     SgAsmDwarfCommonInclusion::clearMemoryPool( );
     SgAsmDwarfCompilationUnit::clearMemoryPool( );
     SgAsmDwarfCompilationUnitList::clearMemoryPool( );
     SgAsmDwarfCondition::clearMemoryPool( );
     SgAsmDwarfConstType::clearMemoryPool( );
     SgAsmDwarfConstant::clearMemoryPool( );
     SgAsmDwarfConstruct::clearMemoryPool( );
     SgAsmDwarfConstructList::clearMemoryPool( );
     SgAsmDwarfDwarfProcedure::clearMemoryPool( );
     SgAsmDwarfEntryPoint::clearMemoryPool( );
     SgAsmDwarfEnumerationType::clearMemoryPool( );
     SgAsmDwarfEnumerator::clearMemoryPool( );
     SgAsmDwarfFileType::clearMemoryPool( );
     SgAsmDwarfFormalParameter::clearMemoryPool( );
     SgAsmDwarfFormatLabel::clearMemoryPool( );
     SgAsmDwarfFriend::clearMemoryPool( );
     SgAsmDwarfFunctionTemplate::clearMemoryPool( );
     SgAsmDwarfImportedDeclaration::clearMemoryPool( );
     SgAsmDwarfImportedModule::clearMemoryPool( );
     SgAsmDwarfImportedUnit::clearMemoryPool( );
     SgAsmDwarfInformation::clearMemoryPool( );
     SgAsmDwarfInheritance::clearMemoryPool( );
     SgAsmDwarfInlinedSubroutine::clearMemoryPool( );
     SgAsmDwarfInterfaceType::clearMemoryPool( );
     SgAsmDwarfLabel::clearMemoryPool( );
     SgAsmDwarfLexicalBlock::clearMemoryPool( );
     SgAsmDwarfLine::clearMemoryPool( );
     SgAsmDwarfLineList::clearMemoryPool( );
     SgAsmDwarfMacro::clearMemoryPool( );
     SgAsmDwarfMacroList::clearMemoryPool( );
     SgAsmDwarfMember::clearMemoryPool( );
     SgAsmDwarfModule::clearMemoryPool( );
     SgAsmDwarfMutableType::clearMemoryPool( );
     SgAsmDwarfNamelist::clearMemoryPool( );
     SgAsmDwarfNamelistItem::clearMemoryPool( );
     SgAsmDwarfNamespace::clearMemoryPool( );
     SgAsmDwarfPackedType::clearMemoryPool( );
     SgAsmDwarfPartialUnit::clearMemoryPool( );
     SgAsmDwarfPointerType::clearMemoryPool( );
     SgAsmDwarfPtrToMemberType::clearMemoryPool( );
     SgAsmDwarfReferenceType::clearMemoryPool( );
     SgAsmDwarfRestrictType::clearMemoryPool( );
     SgAsmDwarfSetType::clearMemoryPool( );
     SgAsmDwarfSharedType::clearMemoryPool( );
     SgAsmDwarfStringType::clearMemoryPool( );
     SgAsmDwarfStructureType::clearMemoryPool( );
     SgAsmDwarfSubprogram::clearMemoryPool( );
     SgAsmDwarfSubrangeType::clearMemoryPool( );
     SgAsmDwarfSubroutineType::clearMemoryPool( );
     SgAsmDwarfTemplateTypeParameter::clearMemoryPool( );
     SgAsmDwarfTemplateValueParameter::clearMemoryPool( );
     SgAsmDwarfThrownType::clearMemoryPool( );
     SgAsmDwarfTryBlock::clearMemoryPool( );
     SgAsmDwarfTypedef::clearMemoryPool( );
     SgAsmDwarfUnionType::clearMemoryPool( );
     SgAsmDwarfUnknownConstruct::clearMemoryPool( );
     SgAsmDwarfUnspecifiedParameters::clearMemoryPool( );
     SgAsmDwarfUnspecifiedType::clearMemoryPool( );
     SgAsmDwarfUpcRelaxedType::clearMemoryPool( );
     SgAsmDwarfUpcSharedType::clearMemoryPool( );
     SgAsmDwarfUpcStrictType::clearMemoryPool( );
     SgAsmDwarfVariable::clearMemoryPool( );
     SgAsmDwarfVariant::clearMemoryPool( );
     SgAsmDwarfVariantPart::clearMemoryPool( );
     SgAsmDwarfVolatileType::clearMemoryPool( );
     SgAsmDwarfWithStmt::clearMemoryPool( );
     SgAsmElfDynamicEntry::clearMemoryPool( );
     SgAsmElfDynamicEntryList::clearMemoryPool( );
     SgAsmElfDynamicSection::clearMemoryPool( );
     SgAsmElfEHFrameEntryCI::clearMemoryPool( );
     SgAsmElfEHFrameEntryCIList::clearMemoryPool( );
     SgAsmElfEHFrameEntryFD::clearMemoryPool( );
     SgAsmElfEHFrameEntryFDList::clearMemoryPool( );
     SgAsmElfEHFrameSection::clearMemoryPool( );
     SgAsmElfFileHeader::clearMemoryPool( );
     SgAsmElfNoteEntry::clearMemoryPool( );
     SgAsmElfNoteEntryList::clearMemoryPool( );
     SgAsmElfNoteSection::clearMemoryPool( );
     SgAsmElfRelocEntry::clearMemoryPool( );
     SgAsmElfRelocEntryList::clearMemoryPool( );
     SgAsmElfRelocSection::clearMemoryPool( );
     SgAsmElfSection::clearMemoryPool( );
     SgAsmElfSectionTable::clearMemoryPool( );
     SgAsmElfSectionTableEntry::clearMemoryPool( );
     SgAsmElfSegmentTable::clearMemoryPool( );
     SgAsmElfSegmentTableEntry::clearMemoryPool( );
     SgAsmElfSegmentTableEntryList::clearMemoryPool( );
     SgAsmElfStringSection::clearMemoryPool( );
     SgAsmElfStrtab::clearMemoryPool( );
     SgAsmElfSymbol::clearMemoryPool( );
     SgAsmElfSymbolList::clearMemoryPool( );
     SgAsmElfSymbolSection::clearMemoryPool( );
     SgAsmElfSymverDefinedAux::clearMemoryPool( );
     SgAsmElfSymverDefinedAuxList::clearMemoryPool( );
     SgAsmElfSymverDefinedEntry::clearMemoryPool( );
     SgAsmElfSymverDefinedEntryList::clearMemoryPool( );
     SgAsmElfSymverDefinedSection::clearMemoryPool( );
     SgAsmElfSymverEntry::clearMemoryPool( );
     SgAsmElfSymverEntryList::clearMemoryPool( );
     SgAsmElfSymverNeededAux::clearMemoryPool( );
     SgAsmElfSymverNeededAuxList::clearMemoryPool( );
     SgAsmElfSymverNeededEntry::clearMemoryPool( );
     SgAsmElfSymverNeededEntryList::clearMemoryPool( );
     SgAsmElfSymverNeededSection::clearMemoryPool( );
     SgAsmElfSymverSection::clearMemoryPool( );
     SgAsmExecutableFileFormat::clearMemoryPool( );
     SgAsmExprListExp::clearMemoryPool( );
     SgAsmExpression::clearMemoryPool( );
     SgAsmSynthesizedFieldDeclaration::clearMemoryPool( );
     SgAsmFloatType::clearMemoryPool( );
     SgAsmFloatValueExpression::clearMemoryPool( );
     SgAsmFunction::clearMemoryPool( );
     SgAsmGenericDLL::clearMemoryPool( );
     SgAsmGenericDLLList::clearMemoryPool( );
     SgAsmGenericFile::clearMemoryPool( );
     SgAsmGenericFileList::clearMemoryPool( );
     SgAsmGenericFormat::clearMemoryPool( );
     SgAsmGenericHeader::clearMemoryPool( );
     SgAsmGenericHeaderList::clearMemoryPool( );
     SgAsmGenericSection::clearMemoryPool( );
     SgAsmGenericSectionList::clearMemoryPool( );
     SgAsmGenericString::clearMemoryPool( );
     SgAsmGenericStrtab::clearMemoryPool( );
     SgAsmGenericSymbol::clearMemoryPool( );
     SgAsmGenericSymbolList::clearMemoryPool( );
     SgAsmIndirectRegisterExpression::clearMemoryPool( );
     SgAsmInstruction::clearMemoryPool( );
     SgAsmIntegerValueExpression::clearMemoryPool( );
     SgAsmIntegerType::clearMemoryPool( );
     SgAsmInterpretation::clearMemoryPool( );
     SgAsmInterpretationList::clearMemoryPool( );
     SgAsmJvmAttribute::clearMemoryPool( );
     SgAsmJvmCodeAttribute::clearMemoryPool( );
     SgAsmJvmMethod::clearMemoryPool( );
     SgAsmJvmConstantPool::clearMemoryPool( );
     SgAsmJvmConstantPoolEntry::clearMemoryPool( );
     SgAsmJvmConstantValue::clearMemoryPool( );
     SgAsmJvmInstruction::clearMemoryPool( );
     SgAsmJvmFileHeader::clearMemoryPool( );
     SgAsmJvmNode::clearMemoryPool( );
     SgAsmJvmSignature::clearMemoryPool( );
     SgAsmJvmSourceFile::clearMemoryPool( );
     SgAsmLEEntryPoint::clearMemoryPool( );
     SgAsmLEEntryTable::clearMemoryPool( );
     SgAsmLEFileHeader::clearMemoryPool( );
     SgAsmLENameTable::clearMemoryPool( );
     SgAsmLEPageTable::clearMemoryPool( );
     SgAsmLEPageTableEntry::clearMemoryPool( );
     SgAsmLERelocTable::clearMemoryPool( );
     SgAsmLESection::clearMemoryPool( );
     SgAsmLESectionTable::clearMemoryPool( );
     SgAsmLESectionTableEntry::clearMemoryPool( );
     SgAsmM68kInstruction::clearMemoryPool( );
     SgAsmMemoryReferenceExpression::clearMemoryPool( );
     SgAsmMipsInstruction::clearMemoryPool( );
     SgAsmNEEntryPoint::clearMemoryPool( );
     SgAsmNEEntryTable::clearMemoryPool( );
     SgAsmNEFileHeader::clearMemoryPool( );
     SgAsmNEModuleTable::clearMemoryPool( );
     SgAsmNENameTable::clearMemoryPool( );
     SgAsmNERelocEntry::clearMemoryPool( );
     SgAsmNERelocTable::clearMemoryPool( );
     SgAsmNESection::clearMemoryPool( );
     SgAsmNESectionTable::clearMemoryPool( );
     SgAsmNESectionTableEntry::clearMemoryPool( );
     SgAsmNEStringTable::clearMemoryPool( );
     SgAsmNode::clearMemoryPool( );
     SgAsmOp::clearMemoryPool( );
     SgAsmOperandList::clearMemoryPool( );
     SgAsmPEExportDirectory::clearMemoryPool( );
     SgAsmPEExportEntry::clearMemoryPool( );
     SgAsmPEExportEntryList::clearMemoryPool( );
     SgAsmPEExportSection::clearMemoryPool( );
     SgAsmPEFileHeader::clearMemoryPool( );
     SgAsmPEImportDirectory::clearMemoryPool( );
     SgAsmPEImportDirectoryList::clearMemoryPool( );
     SgAsmPEImportItem::clearMemoryPool( );
     SgAsmPEImportItemList::clearMemoryPool( );
     SgAsmPEImportSection::clearMemoryPool( );
     SgAsmPERVASizePair::clearMemoryPool( );
     SgAsmPERVASizePairList::clearMemoryPool( );
     SgAsmPESection::clearMemoryPool( );
     SgAsmPESectionTable::clearMemoryPool( );
     SgAsmPESectionTableEntry::clearMemoryPool( );
     SgAsmPEStringSection::clearMemoryPool( );
     SgAsmPowerpcInstruction::clearMemoryPool( );
     SgAsmRegisterNames::clearMemoryPool( );
     SgAsmRegisterReferenceExpression::clearMemoryPool( );
     SgAsmRiscOperation::clearMemoryPool( );
     SgAsmScalarType::clearMemoryPool( );
     SgAsmStatement::clearMemoryPool( );
     SgAsmStaticData::clearMemoryPool( );
     SgAsmStmt::clearMemoryPool( );
     SgAsmStoredString::clearMemoryPool( );
     SgAsmStringStorage::clearMemoryPool( );
     SgAsmType::clearMemoryPool( );
     SgAsmUnaryExpression::clearMemoryPool( );
     SgAsmUnaryMinus::clearMemoryPool( );
     SgAsmUnaryPlus::clearMemoryPool( );
     SgAsmUnaryRrx::clearMemoryPool( );
     SgAsmUnarySignedExtend::clearMemoryPool( );
     SgAsmUnaryUnsignedExtend::clearMemoryPool( );
     SgAsmUnaryTruncate::clearMemoryPool( );
     SgAsmValueExpression::clearMemoryPool( );
     SgAsmVectorType::clearMemoryPool( );
     SgAsmX86Instruction::clearMemoryPool( );
     SgAsmBinaryAddressSymbol::clearMemoryPool( );
     SgAsmBinaryDataSymbol::clearMemoryPool( );
     SgAssertStmt::clearMemoryPool( );
     SgAssignInitializer::clearMemoryPool( );
     SgAssignOp::clearMemoryPool( );
     SgAssignStatement::clearMemoryPool( );
     SgAssignedGotoStatement::clearMemoryPool( );
     SgAssociateStatement::clearMemoryPool( );
     SgAsteriskShapeExp::clearMemoryPool( );
     SgAtOp::clearMemoryPool( );
     SgAttribute::clearMemoryPool( );
     SgAttributeSpecificationStatement::clearMemoryPool( );
     SgAutoType::clearMemoryPool( );
     SgAwaitExpression::clearMemoryPool( );
     SgBackspaceStatement::clearMemoryPool( );
     SgBaseClass::clearMemoryPool( );
     SgExpBaseClass::clearMemoryPool( );
     SgBaseClassModifier::clearMemoryPool( );
     SgBasicBlock::clearMemoryPool( );
     SgBidirectionalGraph::clearMemoryPool( );
     SgBinaryComposite::clearMemoryPool( );
     SgBinaryOp::clearMemoryPool( );
     SgBitAndOp::clearMemoryPool( );
     SgBitAttribute::clearMemoryPool( );
     SgBitComplementOp::clearMemoryPool( );
     SgBitEqvOp::clearMemoryPool( );
     SgBitOrOp::clearMemoryPool( );
     SgBitXorOp::clearMemoryPool( );
     SgBlockDataStatement::clearMemoryPool( );
     SgBoolValExp::clearMemoryPool( );
     SgBreakStmt::clearMemoryPool( );
     SgBracedInitializer::clearMemoryPool( );
     SgC_PreprocessorDirectiveStatement::clearMemoryPool( );
     SgCaseOptionStmt::clearMemoryPool( );
     SgCastExp::clearMemoryPool( );
     SgCatchOptionStmt::clearMemoryPool( );
     SgCatchStatementSeq::clearMemoryPool( );
     SgCharVal::clearMemoryPool( );
     SgChar16Val::clearMemoryPool( );
     SgChar32Val::clearMemoryPool( );
     SgChooseExpression::clearMemoryPool( );
     SgClassDecl_attr::clearMemoryPool( );
     SgClassDeclaration::clearMemoryPool( );
     SgClassDefinition::clearMemoryPool( );
     SgClassNameRefExp::clearMemoryPool( );
     SgClassSymbol::clearMemoryPool( );
     SgClassType::clearMemoryPool( );
     SgClinkageDeclarationStatement::clearMemoryPool( );
     SgClinkageEndStatement::clearMemoryPool( );
     SgClinkageStartStatement::clearMemoryPool( );
     SgCloseStatement::clearMemoryPool( );
     SgColonShapeExp::clearMemoryPool( );
     SgCommaOpExp::clearMemoryPool( );
     SgCommonBlock::clearMemoryPool( );
     SgCommonBlockObject::clearMemoryPool( );
     SgCommonSymbol::clearMemoryPool( );
     SgComplexVal::clearMemoryPool( );
     SgComprehension::clearMemoryPool( );
     SgCompoundAssignOp::clearMemoryPool( );
     SgCompoundInitializer::clearMemoryPool( );
     SgCompoundLiteralExp::clearMemoryPool( );
     SgComputedGotoStatement::clearMemoryPool( );
     SgConcatenationOp::clearMemoryPool( );
     SgConditionalExp::clearMemoryPool( );
     SgConjugateOp::clearMemoryPool( );
     SgConstVolatileModifier::clearMemoryPool( );
     SgConstructorInitializer::clearMemoryPool( );
     SgContainsStatement::clearMemoryPool( );
     SgContinueStmt::clearMemoryPool( );
     SgCtorInitializerList::clearMemoryPool( );
     SgDataStatementGroup::clearMemoryPool( );
     SgDataStatementObject::clearMemoryPool( );
     SgDataStatementValue::clearMemoryPool( );
     SgDeadIfDirectiveStatement::clearMemoryPool( );
     SgDeallocateStatement::clearMemoryPool( );
     SgDeclarationModifier::clearMemoryPool( );
     SgDeclarationScope::clearMemoryPool( );
     SgDeclarationStatement::clearMemoryPool( );
     SgDeclType::clearMemoryPool( );
     SgDefaultOptionStmt::clearMemoryPool( );
     SgDefaultSymbol::clearMemoryPool( );
     SgDefineDirectiveStatement::clearMemoryPool( );
     SgDeleteExp::clearMemoryPool( );
     SgDerivedTypeStatement::clearMemoryPool( );
     SgDesignatedInitializer::clearMemoryPool( );
     SgDictionaryComprehension::clearMemoryPool( );
     SgDictionaryExp::clearMemoryPool( );
     SgDimensionObject::clearMemoryPool( );
     SgDirectedGraphEdge::clearMemoryPool( );
     SgDirectory::clearMemoryPool( );
     SgDirectoryList::clearMemoryPool( );
     SgDivAssignOp::clearMemoryPool( );
     SgDivideOp::clearMemoryPool( );
     SgDoWhileStmt::clearMemoryPool( );
     SgDotExp::clearMemoryPool( );
     SgDotStarOp::clearMemoryPool( );
     SgDoubleVal::clearMemoryPool( );
     SgElaboratedTypeModifier::clearMemoryPool( );
     SgElementwiseOp::clearMemoryPool( );
     SgElementwiseAddOp::clearMemoryPool( );
     SgElementwiseDivideOp::clearMemoryPool( );
     SgElementwiseLeftDivideOp::clearMemoryPool( );
     SgElementwiseMultiplyOp::clearMemoryPool( );
     SgElementwisePowerOp::clearMemoryPool( );
     SgElementwiseSubtractOp::clearMemoryPool( );
     SgElseDirectiveStatement::clearMemoryPool( );
     SgElseWhereStatement::clearMemoryPool( );
     SgElseifDirectiveStatement::clearMemoryPool( );
     SgEmptyDeclaration::clearMemoryPool( );
     SgEmptyDirectiveStatement::clearMemoryPool( );
     SgEndfileStatement::clearMemoryPool( );
     SgEndifDirectiveStatement::clearMemoryPool( );
     SgEntryStatement::clearMemoryPool( );
     SgEnumDeclaration::clearMemoryPool( );
     SgEnumFieldSymbol::clearMemoryPool( );
     SgEnumSymbol::clearMemoryPool( );
     SgEnumType::clearMemoryPool( );
     SgEnumVal::clearMemoryPool( );
     SgEqualityOp::clearMemoryPool( );
     SgEquivalenceStatement::clearMemoryPool( );
     SgErrorDirectiveStatement::clearMemoryPool( );
     SgExecStatement::clearMemoryPool( );
     SgExponentiationOp::clearMemoryPool( );
     SgExponentiationAssignOp::clearMemoryPool( );
     SgExprListExp::clearMemoryPool( );
     SgExprStatement::clearMemoryPool( );
     SgExpression::clearMemoryPool( );
     SgExpressionRoot::clearMemoryPool( );
     SgFile::clearMemoryPool( );
     SgFileList::clearMemoryPool( );
     SgFloatVal::clearMemoryPool( );
     SgFloat128Val::clearMemoryPool( );
     SgFloat80Val::clearMemoryPool( );
     SgFoldExpression::clearMemoryPool( );
     SgFlushStatement::clearMemoryPool( );
     SgForAllStatement::clearMemoryPool( );
     SgForInitStatement::clearMemoryPool( );
     SgForStatement::clearMemoryPool( );
     SgFormatItem::clearMemoryPool( );
     SgFormatItemList::clearMemoryPool( );
     SgFormatStatement::clearMemoryPool( );
     SgFortranDo::clearMemoryPool( );
     SgFortranIncludeLine::clearMemoryPool( );
     SgFortranNonblockedDo::clearMemoryPool( );
     SgFuncDecl_attr::clearMemoryPool( );
     SgFunctionCallExp::clearMemoryPool( );
     SgFunctionDeclaration::clearMemoryPool( );
     SgFunctionDefinition::clearMemoryPool( );
     SgFunctionParameterScope::clearMemoryPool( );
     SgFunctionModifier::clearMemoryPool( );
     SgFunctionParameterList::clearMemoryPool( );
     SgFunctionParameterRefExp::clearMemoryPool( );
     SgFunctionParameterTypeList::clearMemoryPool( );
     SgFunctionRefExp::clearMemoryPool( );
     SgFunctionSymbol::clearMemoryPool( );
     SgFunctionType::clearMemoryPool( );
     SgFunctionTypeSymbol::clearMemoryPool( );
     SgFunctionTypeTable::clearMemoryPool( );
     SgTypeTable::clearMemoryPool( );
     SgGlobal::clearMemoryPool( );
     SgGotoStatement::clearMemoryPool( );
     SgGraph::clearMemoryPool( );
     SgGraphEdge::clearMemoryPool( );
     SgGraphEdgeList::clearMemoryPool( );
     SgGraphNode::clearMemoryPool( );
     SgGraphNodeList::clearMemoryPool( );
     SgGreaterOrEqualOp::clearMemoryPool( );
     SgGreaterThanOp::clearMemoryPool( );
     SgIOItemExpression::clearMemoryPool( );
     SgIOStatement::clearMemoryPool( );
     SgIdentDirectiveStatement::clearMemoryPool( );
     SgIfDirectiveStatement::clearMemoryPool( );
     SgIfStmt::clearMemoryPool( );
     SgIfdefDirectiveStatement::clearMemoryPool( );
     SgIfndefDirectiveStatement::clearMemoryPool( );
     SgImageControlStatement::clearMemoryPool( );
     SgImagPartOp::clearMemoryPool( );
     SgImplicitStatement::clearMemoryPool( );
     SgImpliedDo::clearMemoryPool( );
     SgImportStatement::clearMemoryPool( );
     SgIncidenceDirectedGraph::clearMemoryPool( );
     SgIncidenceUndirectedGraph::clearMemoryPool( );
     SgIncludeDirectiveStatement::clearMemoryPool( );
     SgIncludeFile::clearMemoryPool( );
     SgIncludeNextDirectiveStatement::clearMemoryPool( );
     SgInitializedName::clearMemoryPool( );
     SgInitializer::clearMemoryPool( );
     SgInquireStatement::clearMemoryPool( );
     SgIntKeyedBidirectionalGraph::clearMemoryPool( );
     SgIntVal::clearMemoryPool( );
     SgIntegerDivideOp::clearMemoryPool( );
     SgIntegerDivideAssignOp::clearMemoryPool( );
     SgInterfaceBody::clearMemoryPool( );
     SgHeaderFileBody::clearMemoryPool( );
     SgHeaderFileReport::clearMemoryPool( );
     SgInterfaceStatement::clearMemoryPool( );
     SgInterfaceSymbol::clearMemoryPool( );
     SgIntrinsicSymbol::clearMemoryPool( );
     SgIsOp::clearMemoryPool( );
     SgIsNotOp::clearMemoryPool( );
     SgIorAssignOp::clearMemoryPool( );
     SgJovialBitType::clearMemoryPool( );
     SgJovialBitVal::clearMemoryPool( );
     SgJovialTableType::clearMemoryPool( );
     SgJovialCompoolStatement::clearMemoryPool( );
     SgJovialForThenStatement::clearMemoryPool( );
     SgJovialDefineDeclaration::clearMemoryPool( );
     SgJovialDirectiveStatement::clearMemoryPool( );
     SgJovialOverlayDeclaration::clearMemoryPool( );
     SgJovialPresetPositionExp::clearMemoryPool( );
     SgJovialTablePresetExp::clearMemoryPool( );
     SgJovialTableStatement::clearMemoryPool( );
     SgKeyDatumPair::clearMemoryPool( );
     SgCudaKernelExecConfig::clearMemoryPool( );
     SgCudaKernelCallExp::clearMemoryPool( );
     SgLabelRefExp::clearMemoryPool( );
     SgLabelStatement::clearMemoryPool( );
     SgJavaLabelStatement::clearMemoryPool( );
     SgLabelSymbol::clearMemoryPool( );
     SgJavaLabelSymbol::clearMemoryPool( );
     SgLambdaCapture::clearMemoryPool( );
     SgLambdaCaptureList::clearMemoryPool( );
     SgLambdaExp::clearMemoryPool( );
     SgLambdaRefExp::clearMemoryPool( );
     SgLeftDivideOp::clearMemoryPool( );
     SgLessOrEqualOp::clearMemoryPool( );
     SgLessThanOp::clearMemoryPool( );
     SgLineDirectiveStatement::clearMemoryPool( );
     SgLinemarkerDirectiveStatement::clearMemoryPool( );
     SgLinkageModifier::clearMemoryPool( );
     SgListComprehension::clearMemoryPool( );
     SgListExp::clearMemoryPool( );
     SgLocatedNode::clearMemoryPool( );
     SgLocatedNodeSupport::clearMemoryPool( );
     SgLongDoubleVal::clearMemoryPool( );
     SgLongIntVal::clearMemoryPool( );
     SgLongLongIntVal::clearMemoryPool( );
     SgLshiftAssignOp::clearMemoryPool( );
     SgLshiftOp::clearMemoryPool( );
     SgMagicColonExp::clearMemoryPool( );
     SgMatrixExp::clearMemoryPool( );
     SgMatrixTransposeOp::clearMemoryPool( );
     SgMatlabForStatement::clearMemoryPool( );
     SgMemberFunctionDeclaration::clearMemoryPool( );
     SgMemberFunctionRefExp::clearMemoryPool( );
     SgMemberFunctionSymbol::clearMemoryPool( );
     SgMemberFunctionType::clearMemoryPool( );
     SgMembershipOp::clearMemoryPool( );
     SgMicrosoftAttributeDeclaration::clearMemoryPool( );
     SgMinusAssignOp::clearMemoryPool( );
     SgMinusMinusOp::clearMemoryPool( );
     SgMinusOp::clearMemoryPool( );
     SgModAssignOp::clearMemoryPool( );
     SgModOp::clearMemoryPool( );
     SgModifier::clearMemoryPool( );
     SgModifierNodes::clearMemoryPool( );
     SgModifierType::clearMemoryPool( );
     SgModuleStatement::clearMemoryPool( );
     SgModuleSymbol::clearMemoryPool( );
     SgMultAssignOp::clearMemoryPool( );
     SgMultiplyOp::clearMemoryPool( );
     SgName::clearMemoryPool( );
     SgNameGroup::clearMemoryPool( );
     SgNamedType::clearMemoryPool( );
     SgNamelistStatement::clearMemoryPool( );
     SgNamespaceAliasDeclarationStatement::clearMemoryPool( );
     SgNamespaceDeclarationStatement::clearMemoryPool( );
     SgNamespaceDefinitionStatement::clearMemoryPool( );
     SgNamespaceSymbol::clearMemoryPool( );
     SgNaryOp::clearMemoryPool( );
     SgNaryBooleanOp::clearMemoryPool( );
     SgNaryComparisonOp::clearMemoryPool( );
     SgNewExp::clearMemoryPool( );
     SgNode::clearMemoryPool( );
     SgNoexceptOp::clearMemoryPool( );
     SgNotEqualOp::clearMemoryPool( );
     SgNotOp::clearMemoryPool( );
     SgNonMembershipOp::clearMemoryPool( );
     SgNonrealDecl::clearMemoryPool( );
     SgNonrealRefExp::clearMemoryPool( );
     SgNonrealSymbol::clearMemoryPool( );
     SgNonrealType::clearMemoryPool( );
     SgNonrealBaseClass::clearMemoryPool( );
     SgNullExpression::clearMemoryPool( );
     SgNullptrValExp::clearMemoryPool( );
     SgNullStatement::clearMemoryPool( );
     SgNullifyStatement::clearMemoryPool( );
     SgOmpAtomicStatement::clearMemoryPool( );
     SgOmpBarrierStatement::clearMemoryPool( );
     SgOmpCriticalStatement::clearMemoryPool( );
     SgOmpClauseBodyStatement::clearMemoryPool( );
     SgOmpBodyStatement::clearMemoryPool( );
     SgOmpDoStatement::clearMemoryPool( );
     SgOmpFlushStatement::clearMemoryPool( );
     SgOmpDeclareSimdStatement::clearMemoryPool( );
     SgOmpForStatement::clearMemoryPool( );
     SgOmpForSimdStatement::clearMemoryPool( );
     SgOmpMasterStatement::clearMemoryPool( );
     SgOmpOrderedStatement::clearMemoryPool( );
     SgOmpParallelStatement::clearMemoryPool( );
     SgOmpSectionStatement::clearMemoryPool( );
     SgOmpSectionsStatement::clearMemoryPool( );
     SgOmpSingleStatement::clearMemoryPool( );
     SgOmpTaskStatement::clearMemoryPool( );
     SgOmpTaskwaitStatement::clearMemoryPool( );
     SgOmpThreadprivateStatement::clearMemoryPool( );
     SgOmpWorkshareStatement::clearMemoryPool( );
     SgOmpTargetStatement::clearMemoryPool( );
     SgOmpTargetDataStatement::clearMemoryPool( );
     SgOmpSimdStatement::clearMemoryPool( );
     SgOmpClause::clearMemoryPool( );
     SgOmpBeginClause::clearMemoryPool( );
     SgOmpCollapseClause::clearMemoryPool( );
     SgOmpCopyinClause::clearMemoryPool( );
     SgOmpCopyprivateClause::clearMemoryPool( );
     SgOmpDefaultClause::clearMemoryPool( );
     SgOmpEndClause::clearMemoryPool( );
     SgOmpExpressionClause::clearMemoryPool( );
     SgOmpFirstprivateClause::clearMemoryPool( );
     SgOmpIfClause::clearMemoryPool( );
     SgOmpFinalClause::clearMemoryPool( );
     SgOmpPriorityClause::clearMemoryPool( );
     SgOmpDeviceClause::clearMemoryPool( );
     SgOmpLastprivateClause::clearMemoryPool( );
     SgOmpNowaitClause::clearMemoryPool( );
     SgOmpNumThreadsClause::clearMemoryPool( );
     SgOmpOrderedClause::clearMemoryPool( );
     SgOmpPrivateClause::clearMemoryPool( );
     SgOmpReductionClause::clearMemoryPool( );
     SgOmpScheduleClause::clearMemoryPool( );
     SgOmpSharedClause::clearMemoryPool( );
     SgOmpUntiedClause::clearMemoryPool( );
     SgOmpMergeableClause::clearMemoryPool( );
     SgOmpVariablesClause::clearMemoryPool( );
     SgOmpMapClause::clearMemoryPool( );
     SgOmpSafelenClause::clearMemoryPool( );
     SgOmpSimdlenClause::clearMemoryPool( );
     SgOmpLinearClause::clearMemoryPool( );
     SgOmpUniformClause::clearMemoryPool( );
     SgOmpAlignedClause::clearMemoryPool( );
     SgOmpProcBindClause::clearMemoryPool( );
     SgOmpAtomicClause::clearMemoryPool( );
     SgOmpInbranchClause::clearMemoryPool( );
     SgOmpNotinbranchClause::clearMemoryPool( );
     SgOmpDependClause::clearMemoryPool( );
     SgOpenclAccessModeModifier::clearMemoryPool( );
     SgOpenStatement::clearMemoryPool( );
     SgOptions::clearMemoryPool( );
     SgOrOp::clearMemoryPool( );
     SgParameterStatement::clearMemoryPool( );
     SgPartialFunctionModifierType::clearMemoryPool( );
     SgPartialFunctionType::clearMemoryPool( );
     SgPassStatement::clearMemoryPool( );
     SgPlusAssignOp::clearMemoryPool( );
     SgPlusPlusOp::clearMemoryPool( );
     SgPntrArrRefExp::clearMemoryPool( );
     SgPointerAssignOp::clearMemoryPool( );
     SgPointerDerefExp::clearMemoryPool( );
     SgPointerMemberType::clearMemoryPool( );
     SgPointerType::clearMemoryPool( );
     SgPowerOp::clearMemoryPool( );
     SgPragma::clearMemoryPool( );
     SgPragmaDeclaration::clearMemoryPool( );
     SgPrintStatement::clearMemoryPool( );
     SgProcedureHeaderStatement::clearMemoryPool( );
     SgProgramHeaderStatement::clearMemoryPool( );
     SgProject::clearMemoryPool( );
     SgPseudoDestructorRefExp::clearMemoryPool( );
     SgPythonGlobalStmt::clearMemoryPool( );
     SgPythonPrintStmt::clearMemoryPool( );
     SgQualifiedName::clearMemoryPool( );
     SgQualifiedNameType::clearMemoryPool( );
     SgRangeExp::clearMemoryPool( );
     SgRangeBasedForStatement::clearMemoryPool( );
     SgReadStatement::clearMemoryPool( );
     SgRealPartOp::clearMemoryPool( );
     SgRefExp::clearMemoryPool( );
     SgReferenceType::clearMemoryPool( );
     SgRemOp::clearMemoryPool( );
     SgRenamePair::clearMemoryPool( );
     SgRenameSymbol::clearMemoryPool( );
     SgReplicationOp::clearMemoryPool( );
     SgReturnStmt::clearMemoryPool( );
     SgRewindStatement::clearMemoryPool( );
     SgRshiftAssignOp::clearMemoryPool( );
     SgRshiftOp::clearMemoryPool( );
     SgRvalueReferenceType::clearMemoryPool( );
     SgJavaUnsignedRshiftAssignOp::clearMemoryPool( );
     SgJavaUnsignedRshiftOp::clearMemoryPool( );
     SgScopeOp::clearMemoryPool( );
     SgScopeStatement::clearMemoryPool( );
     SgSequenceStatement::clearMemoryPool( );
     SgSetComprehension::clearMemoryPool( );
     SgShortVal::clearMemoryPool( );
     SgSizeOfOp::clearMemoryPool( );
     SgAlignOfOp::clearMemoryPool( );
     SgJavaInstanceOfOp::clearMemoryPool( );
     SgSourceFile::clearMemoryPool( );
     SgSpaceshipOp::clearMemoryPool( );
     SgSpawnStmt::clearMemoryPool( );
     SgSyncAllStatement::clearMemoryPool( );
     SgSyncImagesStatement::clearMemoryPool( );
     SgSyncMemoryStatement::clearMemoryPool( );
     SgSyncTeamStatement::clearMemoryPool( );
     SgLockStatement::clearMemoryPool( );
     SgUnlockStatement::clearMemoryPool( );
     SgJavaThrowStatement::clearMemoryPool( );
     SgJavaForEachStatement::clearMemoryPool( );
     SgJavaSynchronizedStatement::clearMemoryPool( );
     SgJavaParameterizedType::clearMemoryPool( );
     SgJavaWildcardType::clearMemoryPool( );
     SgProcessControlStatement::clearMemoryPool( );
     SgSpecialFunctionModifier::clearMemoryPool( );
     SgStatement::clearMemoryPool( );
     SgStaticAssertionDeclaration::clearMemoryPool( );
     SgStmtDeclarationStatement::clearMemoryPool( );
     SgStatementExpression::clearMemoryPool( );
     SgStatementFunctionStatement::clearMemoryPool( );
     SgStorageModifier::clearMemoryPool( );
     SgStringConversion::clearMemoryPool( );
     SgStringKeyedBidirectionalGraph::clearMemoryPool( );
     SgStringVal::clearMemoryPool( );
     SgStructureModifier::clearMemoryPool( );
     SgSubscriptExpression::clearMemoryPool( );
     SgSubtractOp::clearMemoryPool( );
     SgSupport::clearMemoryPool( );
     SgSwitchStatement::clearMemoryPool( );
     SgSymbol::clearMemoryPool( );
     SgSymbolTable::clearMemoryPool( );
     SgTemplateArgument::clearMemoryPool( );
     SgTemplateArgumentList::clearMemoryPool( );
     SgTemplateDeclaration::clearMemoryPool( );
     SgTemplateClassDeclaration::clearMemoryPool( );
     SgTemplateClassSymbol::clearMemoryPool( );
     SgTemplateFunctionDeclaration::clearMemoryPool( );
     SgTemplateFunctionRefExp::clearMemoryPool( );
     SgTemplateFunctionSymbol::clearMemoryPool( );
     SgTemplateMemberFunctionDeclaration::clearMemoryPool( );
     SgTemplateMemberFunctionRefExp::clearMemoryPool( );
     SgTemplateMemberFunctionSymbol::clearMemoryPool( );
     SgTemplateTypedefDeclaration::clearMemoryPool( );
     SgTemplateTypedefSymbol::clearMemoryPool( );
     SgTemplateVariableDeclaration::clearMemoryPool( );
     SgTemplateVariableSymbol::clearMemoryPool( );
     SgTemplateClassDefinition::clearMemoryPool( );
     SgTemplateFunctionDefinition::clearMemoryPool( );
     SgTemplateInstantiationDecl::clearMemoryPool( );
     SgTemplateInstantiationDefn::clearMemoryPool( );
     SgTemplateInstantiationDirectiveStatement::clearMemoryPool( );
     SgTemplateInstantiationFunctionDecl::clearMemoryPool( );
     SgTemplateInstantiationMemberFunctionDecl::clearMemoryPool( );
     SgTemplateInstantiationTypedefDeclaration::clearMemoryPool( );
     SgTemplateParameter::clearMemoryPool( );
     SgTemplateParameterVal::clearMemoryPool( );
     SgTemplateParameterList::clearMemoryPool( );
     SgTemplateSymbol::clearMemoryPool( );
     SgTemplateType::clearMemoryPool( );
     SgThisExp::clearMemoryPool( );
     SgTypeTraitBuiltinOperator::clearMemoryPool( );
     SgSuperExp::clearMemoryPool( );
     SgThrowOp::clearMemoryPool( );
     SgToken::clearMemoryPool( );
     SgTryStmt::clearMemoryPool( );
     SgTupleExp::clearMemoryPool( );
     SgType::clearMemoryPool( );
     SgTypeBool::clearMemoryPool( );
     SgTypeChar::clearMemoryPool( );
     SgTypeChar16::clearMemoryPool( );
     SgTypeChar32::clearMemoryPool( );
     SgTypeComplex::clearMemoryPool( );
     SgTypeDefault::clearMemoryPool( );
     SgTypeExpression::clearMemoryPool( );
     SgTypeLabel::clearMemoryPool( );
     SgTypeDouble::clearMemoryPool( );
     SgTypeEllipse::clearMemoryPool( );
     SgTypeFixed::clearMemoryPool( );
     SgTypeFloat::clearMemoryPool( );
     SgTypeFloat128::clearMemoryPool( );
     SgTypeFloat80::clearMemoryPool( );
     SgTypeGlobalVoid::clearMemoryPool( );
     SgTypeIdOp::clearMemoryPool( );
     SgTypeImaginary::clearMemoryPool( );
     SgTypeInt::clearMemoryPool( );
     SgTypeLong::clearMemoryPool( );
     SgTypeLongDouble::clearMemoryPool( );
     SgTypeLongLong::clearMemoryPool( );
     SgTypeModifier::clearMemoryPool( );
     SgTypeMatrix::clearMemoryPool( );
     SgTypeTuple::clearMemoryPool( );
     SgTypeNullptr::clearMemoryPool( );
     SgTypeOfType::clearMemoryPool( );
     SgTypeShort::clearMemoryPool( );
     SgTypeSigned128bitInteger::clearMemoryPool( );
     SgTypeSignedChar::clearMemoryPool( );
     SgTypeSignedInt::clearMemoryPool( );
     SgTypeSignedLong::clearMemoryPool( );
     SgTypeSignedLongLong::clearMemoryPool( );
     SgTypeSignedShort::clearMemoryPool( );
     SgTypeString::clearMemoryPool( );
     SgTypeUnknown::clearMemoryPool( );
     SgTypeUnsigned128bitInteger::clearMemoryPool( );
     SgTypeUnsignedChar::clearMemoryPool( );
     SgTypeUnsignedInt::clearMemoryPool( );
     SgTypeUnsignedLong::clearMemoryPool( );
     SgTypeUnsignedLongLong::clearMemoryPool( );
     SgTypeUnsignedShort::clearMemoryPool( );
     SgTypeVoid::clearMemoryPool( );
     SgTypeWchar::clearMemoryPool( );
     SgTypedefDeclaration::clearMemoryPool( );
     SgTypedefSeq::clearMemoryPool( );
     SgTypedefSymbol::clearMemoryPool( );
     SgTypedefType::clearMemoryPool( );
     SgUPC_AccessModifier::clearMemoryPool( );
     SgUnaryAddOp::clearMemoryPool( );
     SgUnaryOp::clearMemoryPool( );
     SgUndefDirectiveStatement::clearMemoryPool( );
     SgUndirectedGraphEdge::clearMemoryPool( );
     SgUnknownArrayOrFunctionReference::clearMemoryPool( );
     SgUnknownFile::clearMemoryPool( );
     SgUnparse_Info::clearMemoryPool( );
     SgUnsignedCharVal::clearMemoryPool( );
     SgUnsignedIntVal::clearMemoryPool( );
     SgUnsignedLongLongIntVal::clearMemoryPool( );
     SgUnsignedLongVal::clearMemoryPool( );
     SgUnsignedShortVal::clearMemoryPool( );
     SgUpcBarrierStatement::clearMemoryPool( );
     SgUpcBlocksizeofExpression::clearMemoryPool( );
     SgUpcElemsizeofExpression::clearMemoryPool( );
     SgUpcFenceStatement::clearMemoryPool( );
     SgUpcForAllStatement::clearMemoryPool( );
     SgUpcLocalsizeofExpression::clearMemoryPool( );
     SgUpcMythread::clearMemoryPool( );
     SgUpcNotifyStatement::clearMemoryPool( );
     SgUpcThreads::clearMemoryPool( );
     SgUpcWaitStatement::clearMemoryPool( );
     SgUseStatement::clearMemoryPool( );
     SgUserDefinedBinaryOp::clearMemoryPool( );
     SgUserDefinedUnaryOp::clearMemoryPool( );
     SgUsingDeclarationStatement::clearMemoryPool( );
     SgUsingDirectiveStatement::clearMemoryPool( );
     SgValueExp::clearMemoryPool( );
     SgVarArgCopyOp::clearMemoryPool( );
     SgVarArgEndOp::clearMemoryPool( );
     SgVarArgOp::clearMemoryPool( );
     SgVarArgStartOneOperandOp::clearMemoryPool( );
     SgVarArgStartOp::clearMemoryPool( );
     SgVarRefExp::clearMemoryPool( );
     SgVariableDeclaration::clearMemoryPool( );
     SgVariableDefinition::clearMemoryPool( );
     SgVariableSymbol::clearMemoryPool( );
     SgVariantExpression::clearMemoryPool( );
     SgVariantStatement::clearMemoryPool( );
     SgVoidVal::clearMemoryPool( );
     SgWaitStatement::clearMemoryPool( );
     SgWarningDirectiveStatement::clearMemoryPool( );
     SgWithStatement::clearMemoryPool( );
     SgWcharVal::clearMemoryPool( );
     SgWhereStatement::clearMemoryPool( );
     SgWhileStmt::clearMemoryPool( );
     SgWriteStatement::clearMemoryPool( );
     SgXorAssignOp::clearMemoryPool( );
     SgYieldExpression::clearMemoryPool( );
     Sg_File_Info::clearMemoryPool( );
     SgTypeCAFTeam::clearMemoryPool( );
     SgCAFWithTeamStatement::clearMemoryPool( );
     SgCAFCoExpression::clearMemoryPool( );
     SgCallExpression::clearMemoryPool( );
     SgTypeCrayPointer::clearMemoryPool( );
     SgJavaImportStatement::clearMemoryPool( );
     SgJavaPackageDeclaration::clearMemoryPool( );
     SgJavaPackageStatement::clearMemoryPool( );
     SgJavaImportStatementList::clearMemoryPool( );
     SgJavaClassDeclarationList::clearMemoryPool( );
     SgJavaMemberValuePair::clearMemoryPool( );
     SgJavaAnnotation::clearMemoryPool( );
     SgJavaMarkerAnnotation::clearMemoryPool( );
     SgJavaSingleMemberAnnotation::clearMemoryPool( );
     SgJavaNormalAnnotation::clearMemoryPool( );
     SgJavaTypeExpression::clearMemoryPool( );
     SgJavaQualifiedType::clearMemoryPool( );
     SgClassExp::clearMemoryPool( );
     SgJavaUnionType::clearMemoryPool( );
     SgJavaParameterType::clearMemoryPool( );
     SgAsyncStmt::clearMemoryPool( );
     SgFinishStmt::clearMemoryPool( );
     SgAtStmt::clearMemoryPool( );
     SgAtomicStmt::clearMemoryPool( );
     SgWhenStmt::clearMemoryPool( );
     SgAtExp::clearMemoryPool( );
     SgFinishExp::clearMemoryPool( );
     SgHereExp::clearMemoryPool( );
     SgDotDotExp::clearMemoryPool( );
     SgAsmNullInstruction::clearMemoryPool( );
     SgAdaComponentClause::clearMemoryPool( );
     SgAdaIndexConstraint::clearMemoryPool( );
     SgAdaModularType::clearMemoryPool( );
     SgAdaRepresentationClause::clearMemoryPool( );
     SgAdaFunctionRenamingDecl::clearMemoryPool( );
     SgAdaSelectStmt::clearMemoryPool( );
     SgAdaSelectAlternativeStmt::clearMemoryPool( );
     SgAdaTerminateStmt::clearMemoryPool( );
     SgAsmAarch32Coprocessor::clearMemoryPool( );
     SgAdaAttributeClause::clearMemoryPool( );
     SgAsmBinaryConcat::clearMemoryPool( );
     SgAsmByteOrder::clearMemoryPool( );
     SgAdaDerivedType::clearMemoryPool( );
     SgAdaAttributeExp::clearMemoryPool( );
     SgAdaEnumRepresentationClause::clearMemoryPool( );
     SgAsmBinaryPreupdate::clearMemoryPool( );
     SgAsmBinaryPostupdate::clearMemoryPool( );
     SgAdaOthersExp::clearMemoryPool( );
     SgAdaRenamingSymbol::clearMemoryPool( );
     SgAdaRenamingRefExp::clearMemoryPool( );
     SgAdaGenericDecl::clearMemoryPool( );
     SgAdaGenericDefn::clearMemoryPool( );
     SgAdaFormalType::clearMemoryPool( );
     SgAdaGenericSymbol::clearMemoryPool( );
     SgAdaFormalTypeDecl::clearMemoryPool( );
     SgAdaUnitRefExp::clearMemoryPool( );
     SgAdaDiscriminatedTypeDecl::clearMemoryPool( );
     SgAdaDiscriminatedType::clearMemoryPool( );
     SgAdaDiscriminantConstraint::clearMemoryPool( );
     SgAdaGenericInstanceDecl::clearMemoryPool( );
     SgAdaUnscopedBlock::clearMemoryPool( );
     SgAdaInheritedFunctionSymbol::clearMemoryPool( );
     SgAdaProtectedBody::clearMemoryPool( );
     SgAdaProtectedBodyDecl::clearMemoryPool( );
     SgAdaProtectedSpec::clearMemoryPool( );
     SgAdaProtectedSpecDecl::clearMemoryPool( );
     SgAdaProtectedSymbol::clearMemoryPool( );
     SgAdaProtectedRefExp::clearMemoryPool( );
     SgAdaProtectedType::clearMemoryPool( );
     SgAdaProtectedTypeDecl::clearMemoryPool( );
     SgAdaDigitsConstraint::clearMemoryPool( );
     SgAdaAncestorInitializer::clearMemoryPool( );
     SgAdaDeltaConstraint::clearMemoryPool( );
     SgAdaSubroutineType::clearMemoryPool( );
     SgAdaGenericInstanceSymbol::clearMemoryPool( );
     SgAdaFormalPackageDecl::clearMemoryPool( );
     SgAdaFormalPackageSymbol::clearMemoryPool( );
     SgAsmJvmAttributeTable::clearMemoryPool( );
     SgAsmJvmMethodTable::clearMemoryPool( );
     SgAsmJvmField::clearMemoryPool( );
     SgAsmJvmFieldTable::clearMemoryPool( );
     SgAsmJvmExceptionHandler::clearMemoryPool( );
     SgAsmJvmExceptionTable::clearMemoryPool( );
     SgAsmJvmClass::clearMemoryPool( );
     SgAsmJvmLineNumberEntry::clearMemoryPool( );
     SgAsmJvmLineNumberTable::clearMemoryPool( );
     SgAsmJvmInnerClassesEntry::clearMemoryPool( );
     SgAsmJvmInnerClasses::clearMemoryPool( );
     SgAsmCilInstruction::clearMemoryPool( );
     SgAsmStackExpression::clearMemoryPool( );
     SgAsmJvmEnclosingMethod::clearMemoryPool( );
     SgAdaNullConstraint::clearMemoryPool( );
     SgAsmJvmModuleMainClass::clearMemoryPool( );
     SgAsmInstructionList::clearMemoryPool( );
     SgAsmCilNode::clearMemoryPool( );
     SgAsmCilAssembly::clearMemoryPool( );
     SgAsmCilAssemblyOS::clearMemoryPool( );
     SgAsmCilAssemblyProcessor::clearMemoryPool( );
     SgAsmCilAssemblyRef::clearMemoryPool( );
     SgAsmCilAssemblyRefOS::clearMemoryPool( );
     SgAsmCilAssemblyRefProcessor::clearMemoryPool( );
     SgAsmCilClassLayout::clearMemoryPool( );
     SgAsmCilConstant::clearMemoryPool( );
     SgAsmCilCustomAttribute::clearMemoryPool( );
     SgAsmCilDeclSecurity::clearMemoryPool( );
     SgAsmCilEvent::clearMemoryPool( );
     SgAsmCilEventMap::clearMemoryPool( );
     SgAsmCilExportedType::clearMemoryPool( );
     SgAsmCilField::clearMemoryPool( );
     SgAsmCilFieldLayout::clearMemoryPool( );
     SgAsmCilFieldMarshal::clearMemoryPool( );
     SgAsmCilFieldRVA::clearMemoryPool( );
     SgAsmCilFile::clearMemoryPool( );
     SgAsmCilGenericParam::clearMemoryPool( );
     SgAsmCilGenericParamConstraint::clearMemoryPool( );
     SgAsmCilImplMap::clearMemoryPool( );
     SgAsmCilInterfaceImpl::clearMemoryPool( );
     SgAsmCilManifestResource::clearMemoryPool( );
     SgAsmCilMemberRef::clearMemoryPool( );
     SgAsmCilMethodDef::clearMemoryPool( );
     SgAsmCilMethodImpl::clearMemoryPool( );
     SgAsmCilMethodSemantics::clearMemoryPool( );
     SgAsmCilMethodSpec::clearMemoryPool( );
     SgAsmCilModule::clearMemoryPool( );
     SgAsmCilModuleRef::clearMemoryPool( );
     SgAsmCilNestedClass::clearMemoryPool( );
     SgAsmCilParam::clearMemoryPool( );
     SgAsmCilProperty::clearMemoryPool( );
     SgAsmCilPropertyMap::clearMemoryPool( );
     SgAsmCilStandAloneSig::clearMemoryPool( );
     SgAsmCilTypeDef::clearMemoryPool( );
     SgAsmCilTypeRef::clearMemoryPool( );
     SgAsmCilTypeSpec::clearMemoryPool( );
     SgAdaParameterList::clearMemoryPool( );
     SgAsmCilMetadata::clearMemoryPool( );
     SgAsmCilMetadataRoot::clearMemoryPool( );
     SgAsmCilDataStream::clearMemoryPool( );
     SgAsmCilMetadataHeap::clearMemoryPool( );
     SgAsmCilUint8Heap::clearMemoryPool( );
     SgAsmCilUint32Heap::clearMemoryPool( );
     SgAsmCliHeader::clearMemoryPool( );
     SgAdaVariantDecl::clearMemoryPool( );
     SgAdaVariantWhenStmt::clearMemoryPool( );
     SgAsmCilAssemblyTable::clearMemoryPool( );
     SgAsmCilAssemblyOSTable::clearMemoryPool( );
     SgAsmCilAssemblyProcessorTable::clearMemoryPool( );
     SgAsmCilAssemblyRefTable::clearMemoryPool( );
     SgAsmCilAssemblyRefOSTable::clearMemoryPool( );
     SgAsmCilAssemblyRefProcessorTable::clearMemoryPool( );
     SgAsmCilClassLayoutTable::clearMemoryPool( );
     SgAsmCilConstantTable::clearMemoryPool( );
     SgAsmCilCustomAttributeTable::clearMemoryPool( );
     SgAsmCilDeclSecurityTable::clearMemoryPool( );
     SgAsmCilEventTable::clearMemoryPool( );
     SgAsmCilEventMapTable::clearMemoryPool( );
     SgAsmCilExportedTypeTable::clearMemoryPool( );
     SgAsmCilFieldTable::clearMemoryPool( );
     SgAsmCilFieldLayoutTable::clearMemoryPool( );
     SgAsmCilFieldMarshalTable::clearMemoryPool( );
     SgAsmCilFieldRVATable::clearMemoryPool( );
     SgAsmCilFileTable::clearMemoryPool( );
     SgAsmCilGenericParamTable::clearMemoryPool( );
     SgAsmCilGenericParamConstraintTable::clearMemoryPool( );
     SgAsmCilImplMapTable::clearMemoryPool( );
     SgAsmCilInterfaceImplTable::clearMemoryPool( );
     SgAsmCilManifestResourceTable::clearMemoryPool( );
     SgAsmCilMemberRefTable::clearMemoryPool( );
     SgAsmCilMethodDefTable::clearMemoryPool( );
     SgAsmCilMethodImplTable::clearMemoryPool( );
     SgAsmCilMethodSemanticsTable::clearMemoryPool( );
     SgAsmCilMethodSpecTable::clearMemoryPool( );
     SgAsmCilModuleTable::clearMemoryPool( );
     SgAsmCilModuleRefTable::clearMemoryPool( );
     SgAsmCilNestedClassTable::clearMemoryPool( );
     SgAsmCilParamTable::clearMemoryPool( );
     SgAsmCilPropertyTable::clearMemoryPool( );
     SgAsmCilPropertyMapTable::clearMemoryPool( );
     SgAsmCilStandAloneSigTable::clearMemoryPool( );
     SgAsmCilTypeDefTable::clearMemoryPool( );
     SgAsmCilTypeRefTable::clearMemoryPool( );
     SgAsmCilTypeSpecTable::clearMemoryPool( );
     SgJvmComposite::clearMemoryPool( );
     SgFortranContinueStmt::clearMemoryPool( );
     SgAsmJvmStackMapTable::clearMemoryPool( );
     SgAsmJvmStackMapFrame::clearMemoryPool( );
     SgAsmJvmStackMapVerificationType::clearMemoryPool( );
     SgAsmJvmBootstrapMethod::clearMemoryPool( );
     SgAsmJvmBootstrapMethods::clearMemoryPool( );
     SgAsmJvmExceptions::clearMemoryPool( );
     SgAsmJvmNestMembers::clearMemoryPool( );
     SgAsmJvmNestHost::clearMemoryPool( );
     SgJovialLabelDeclaration::clearMemoryPool( );
     SgAsmJvmLocalVariableEntry::clearMemoryPool( );
     SgAsmJvmLocalVariableTable::clearMemoryPool( );
     SgAsmJvmLocalVariableTypeEntry::clearMemoryPool( );
     SgAsmJvmLocalVariableTypeTable::clearMemoryPool( );
     SgAsmUserInstruction::clearMemoryPool( );
     SgAsmJvmMethodParameters::clearMemoryPool( );
     SgAsmJvmMethodParametersEntry::clearMemoryPool( );
     SgAsmVoidType::clearMemoryPool( );
     SgAsmPointerType::clearMemoryPool( );
     SgRangeType::clearMemoryPool( );
     SgAsmCilExceptionData::clearMemoryPool( );
     SgAsmCilMethodData::clearMemoryPool( );
     SgTemplateVariableInstantiation::clearMemoryPool( );
     SgReferenceExp::clearMemoryPool( );
     SgTypeRefExp::clearMemoryPool( );
     SgScopedRefExp::clearMemoryPool( );
     SgScopedType::clearMemoryPool( );
     SgTypeSymbol::clearMemoryPool( );
     SgAsmJvmSynthetic::clearMemoryPool( );
     SgAsmJvmDeprecated::clearMemoryPool( );
     SgSignedCharVal::clearMemoryPool( );
     SgAsmCilErrorHeap::clearMemoryPool( );

/* #line 353 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

     
   /* JH (02/03/2006) since the memory pool contain no data anymore, we reset the 
      contents of the listOfMemoryPoolSizes to 0!
   */
     for (int i= 0; i < totalNumberOfIRNodes + 1; ++i)
        {
          listOfMemoryPoolSizes[i] = 0;
        }
   /* JH (03/21/2006) additionally, we need a method, that resets the static 
      data pointers to NULL!
   */
     deleteStaticData();
     deleteStoredAsts();
     return;
   }

void AST_FILE_IO::deleteMemoryPools( ) {

     SgAccessModifier::deleteMemoryPool( );
     SgActualArgumentExpression::deleteMemoryPool( );
     SgAbsOp::deleteMemoryPool( );
     SgAdaAccessType::deleteMemoryPool( );
     SgAdaAcceptStmt::deleteMemoryPool( );
     SgAdaDelayStmt::deleteMemoryPool( );
     SgAdaEntryDecl::deleteMemoryPool( );
     SgAdaExitStmt::deleteMemoryPool( );
     SgAdaDiscreteType::deleteMemoryPool( );
     SgAdaFloatVal::deleteMemoryPool( );
     SgAdaLoopStmt::deleteMemoryPool( );
     SgAdaPackageBody::deleteMemoryPool( );
     SgAdaPackageBodyDecl::deleteMemoryPool( );
     SgAdaPackageSpec::deleteMemoryPool( );
     SgAdaPackageSpecDecl::deleteMemoryPool( );
     SgAdaPackageSymbol::deleteMemoryPool( );
     SgAdaRangeConstraint::deleteMemoryPool( );
     SgAdaRenamingDecl::deleteMemoryPool( );
     SgAdaSubtype::deleteMemoryPool( );
     SgAdaTaskBody::deleteMemoryPool( );
     SgAdaTaskBodyDecl::deleteMemoryPool( );
     SgAdaTaskSpec::deleteMemoryPool( );
     SgAdaTaskSpecDecl::deleteMemoryPool( );
     SgAdaTaskSymbol::deleteMemoryPool( );
     SgAdaTaskRefExp::deleteMemoryPool( );
     SgAdaTaskType::deleteMemoryPool( );
     SgAdaTaskTypeDecl::deleteMemoryPool( );
     SgAdaTypeConstraint::deleteMemoryPool( );
     SgAddOp::deleteMemoryPool( );
     SgAddressOfOp::deleteMemoryPool( );
     SgAggregateInitializer::deleteMemoryPool( );
     SgAliasSymbol::deleteMemoryPool( );
     SgAllocateStatement::deleteMemoryPool( );
     SgAndAssignOp::deleteMemoryPool( );
     SgAndOp::deleteMemoryPool( );
     SgArithmeticIfStatement::deleteMemoryPool( );
     SgArrayType::deleteMemoryPool( );
     SgArrowExp::deleteMemoryPool( );
     SgArrowStarOp::deleteMemoryPool( );
     SgAsmBasicString::deleteMemoryPool( );
     SgAsmBinaryAdd::deleteMemoryPool( );
     SgAsmBinaryAsr::deleteMemoryPool( );
     SgAsmBinaryDivide::deleteMemoryPool( );
     SgAsmBinaryExpression::deleteMemoryPool( );
     SgAsmBinaryLsl::deleteMemoryPool( );
     SgAsmBinaryLsr::deleteMemoryPool( );
     SgAsmBinaryMod::deleteMemoryPool( );
     SgAsmBinaryMsl::deleteMemoryPool( );
     SgAsmBinaryMultiply::deleteMemoryPool( );
     SgAsmBinaryRor::deleteMemoryPool( );
     SgAsmBinarySubtract::deleteMemoryPool( );
     SgAsmBlock::deleteMemoryPool( );
     SgAsmCoffStrtab::deleteMemoryPool( );
     SgAsmCoffSymbol::deleteMemoryPool( );
     SgAsmCoffSymbolList::deleteMemoryPool( );
     SgAsmCoffSymbolTable::deleteMemoryPool( );
     SgAsmCommonSubExpression::deleteMemoryPool( );
     SgAsmControlFlagsExpression::deleteMemoryPool( );
     SgAsmConstantExpression::deleteMemoryPool( );
     SgAsmDOSExtendedHeader::deleteMemoryPool( );
     SgAsmDOSFileHeader::deleteMemoryPool( );
     SgAsmSynthesizedDataStructureDeclaration::deleteMemoryPool( );
     SgAsmSynthesizedDeclaration::deleteMemoryPool( );
     SgAsmDirectRegisterExpression::deleteMemoryPool( );
     SgAsmDwarfAccessDeclaration::deleteMemoryPool( );
     SgAsmDwarfArrayType::deleteMemoryPool( );
     SgAsmDwarfBaseType::deleteMemoryPool( );
     SgAsmDwarfCatchBlock::deleteMemoryPool( );
     SgAsmDwarfClassTemplate::deleteMemoryPool( );
     SgAsmDwarfClassType::deleteMemoryPool( );
     SgAsmDwarfCommonBlock::deleteMemoryPool( );
     SgAsmDwarfCommonInclusion::deleteMemoryPool( );
     SgAsmDwarfCompilationUnit::deleteMemoryPool( );
     SgAsmDwarfCompilationUnitList::deleteMemoryPool( );
     SgAsmDwarfCondition::deleteMemoryPool( );
     SgAsmDwarfConstType::deleteMemoryPool( );
     SgAsmDwarfConstant::deleteMemoryPool( );
     SgAsmDwarfConstruct::deleteMemoryPool( );
     SgAsmDwarfConstructList::deleteMemoryPool( );
     SgAsmDwarfDwarfProcedure::deleteMemoryPool( );
     SgAsmDwarfEntryPoint::deleteMemoryPool( );
     SgAsmDwarfEnumerationType::deleteMemoryPool( );
     SgAsmDwarfEnumerator::deleteMemoryPool( );
     SgAsmDwarfFileType::deleteMemoryPool( );
     SgAsmDwarfFormalParameter::deleteMemoryPool( );
     SgAsmDwarfFormatLabel::deleteMemoryPool( );
     SgAsmDwarfFriend::deleteMemoryPool( );
     SgAsmDwarfFunctionTemplate::deleteMemoryPool( );
     SgAsmDwarfImportedDeclaration::deleteMemoryPool( );
     SgAsmDwarfImportedModule::deleteMemoryPool( );
     SgAsmDwarfImportedUnit::deleteMemoryPool( );
     SgAsmDwarfInformation::deleteMemoryPool( );
     SgAsmDwarfInheritance::deleteMemoryPool( );
     SgAsmDwarfInlinedSubroutine::deleteMemoryPool( );
     SgAsmDwarfInterfaceType::deleteMemoryPool( );
     SgAsmDwarfLabel::deleteMemoryPool( );
     SgAsmDwarfLexicalBlock::deleteMemoryPool( );
     SgAsmDwarfLine::deleteMemoryPool( );
     SgAsmDwarfLineList::deleteMemoryPool( );
     SgAsmDwarfMacro::deleteMemoryPool( );
     SgAsmDwarfMacroList::deleteMemoryPool( );
     SgAsmDwarfMember::deleteMemoryPool( );
     SgAsmDwarfModule::deleteMemoryPool( );
     SgAsmDwarfMutableType::deleteMemoryPool( );
     SgAsmDwarfNamelist::deleteMemoryPool( );
     SgAsmDwarfNamelistItem::deleteMemoryPool( );
     SgAsmDwarfNamespace::deleteMemoryPool( );
     SgAsmDwarfPackedType::deleteMemoryPool( );
     SgAsmDwarfPartialUnit::deleteMemoryPool( );
     SgAsmDwarfPointerType::deleteMemoryPool( );
     SgAsmDwarfPtrToMemberType::deleteMemoryPool( );
     SgAsmDwarfReferenceType::deleteMemoryPool( );
     SgAsmDwarfRestrictType::deleteMemoryPool( );
     SgAsmDwarfSetType::deleteMemoryPool( );
     SgAsmDwarfSharedType::deleteMemoryPool( );
     SgAsmDwarfStringType::deleteMemoryPool( );
     SgAsmDwarfStructureType::deleteMemoryPool( );
     SgAsmDwarfSubprogram::deleteMemoryPool( );
     SgAsmDwarfSubrangeType::deleteMemoryPool( );
     SgAsmDwarfSubroutineType::deleteMemoryPool( );
     SgAsmDwarfTemplateTypeParameter::deleteMemoryPool( );
     SgAsmDwarfTemplateValueParameter::deleteMemoryPool( );
     SgAsmDwarfThrownType::deleteMemoryPool( );
     SgAsmDwarfTryBlock::deleteMemoryPool( );
     SgAsmDwarfTypedef::deleteMemoryPool( );
     SgAsmDwarfUnionType::deleteMemoryPool( );
     SgAsmDwarfUnknownConstruct::deleteMemoryPool( );
     SgAsmDwarfUnspecifiedParameters::deleteMemoryPool( );
     SgAsmDwarfUnspecifiedType::deleteMemoryPool( );
     SgAsmDwarfUpcRelaxedType::deleteMemoryPool( );
     SgAsmDwarfUpcSharedType::deleteMemoryPool( );
     SgAsmDwarfUpcStrictType::deleteMemoryPool( );
     SgAsmDwarfVariable::deleteMemoryPool( );
     SgAsmDwarfVariant::deleteMemoryPool( );
     SgAsmDwarfVariantPart::deleteMemoryPool( );
     SgAsmDwarfVolatileType::deleteMemoryPool( );
     SgAsmDwarfWithStmt::deleteMemoryPool( );
     SgAsmElfDynamicEntry::deleteMemoryPool( );
     SgAsmElfDynamicEntryList::deleteMemoryPool( );
     SgAsmElfDynamicSection::deleteMemoryPool( );
     SgAsmElfEHFrameEntryCI::deleteMemoryPool( );
     SgAsmElfEHFrameEntryCIList::deleteMemoryPool( );
     SgAsmElfEHFrameEntryFD::deleteMemoryPool( );
     SgAsmElfEHFrameEntryFDList::deleteMemoryPool( );
     SgAsmElfEHFrameSection::deleteMemoryPool( );
     SgAsmElfFileHeader::deleteMemoryPool( );
     SgAsmElfNoteEntry::deleteMemoryPool( );
     SgAsmElfNoteEntryList::deleteMemoryPool( );
     SgAsmElfNoteSection::deleteMemoryPool( );
     SgAsmElfRelocEntry::deleteMemoryPool( );
     SgAsmElfRelocEntryList::deleteMemoryPool( );
     SgAsmElfRelocSection::deleteMemoryPool( );
     SgAsmElfSection::deleteMemoryPool( );
     SgAsmElfSectionTable::deleteMemoryPool( );
     SgAsmElfSectionTableEntry::deleteMemoryPool( );
     SgAsmElfSegmentTable::deleteMemoryPool( );
     SgAsmElfSegmentTableEntry::deleteMemoryPool( );
     SgAsmElfSegmentTableEntryList::deleteMemoryPool( );
     SgAsmElfStringSection::deleteMemoryPool( );
     SgAsmElfStrtab::deleteMemoryPool( );
     SgAsmElfSymbol::deleteMemoryPool( );
     SgAsmElfSymbolList::deleteMemoryPool( );
     SgAsmElfSymbolSection::deleteMemoryPool( );
     SgAsmElfSymverDefinedAux::deleteMemoryPool( );
     SgAsmElfSymverDefinedAuxList::deleteMemoryPool( );
     SgAsmElfSymverDefinedEntry::deleteMemoryPool( );
     SgAsmElfSymverDefinedEntryList::deleteMemoryPool( );
     SgAsmElfSymverDefinedSection::deleteMemoryPool( );
     SgAsmElfSymverEntry::deleteMemoryPool( );
     SgAsmElfSymverEntryList::deleteMemoryPool( );
     SgAsmElfSymverNeededAux::deleteMemoryPool( );
     SgAsmElfSymverNeededAuxList::deleteMemoryPool( );
     SgAsmElfSymverNeededEntry::deleteMemoryPool( );
     SgAsmElfSymverNeededEntryList::deleteMemoryPool( );
     SgAsmElfSymverNeededSection::deleteMemoryPool( );
     SgAsmElfSymverSection::deleteMemoryPool( );
     SgAsmExecutableFileFormat::deleteMemoryPool( );
     SgAsmExprListExp::deleteMemoryPool( );
     SgAsmExpression::deleteMemoryPool( );
     SgAsmSynthesizedFieldDeclaration::deleteMemoryPool( );
     SgAsmFloatType::deleteMemoryPool( );
     SgAsmFloatValueExpression::deleteMemoryPool( );
     SgAsmFunction::deleteMemoryPool( );
     SgAsmGenericDLL::deleteMemoryPool( );
     SgAsmGenericDLLList::deleteMemoryPool( );
     SgAsmGenericFile::deleteMemoryPool( );
     SgAsmGenericFileList::deleteMemoryPool( );
     SgAsmGenericFormat::deleteMemoryPool( );
     SgAsmGenericHeader::deleteMemoryPool( );
     SgAsmGenericHeaderList::deleteMemoryPool( );
     SgAsmGenericSection::deleteMemoryPool( );
     SgAsmGenericSectionList::deleteMemoryPool( );
     SgAsmGenericString::deleteMemoryPool( );
     SgAsmGenericStrtab::deleteMemoryPool( );
     SgAsmGenericSymbol::deleteMemoryPool( );
     SgAsmGenericSymbolList::deleteMemoryPool( );
     SgAsmIndirectRegisterExpression::deleteMemoryPool( );
     SgAsmInstruction::deleteMemoryPool( );
     SgAsmIntegerValueExpression::deleteMemoryPool( );
     SgAsmIntegerType::deleteMemoryPool( );
     SgAsmInterpretation::deleteMemoryPool( );
     SgAsmInterpretationList::deleteMemoryPool( );
     SgAsmJvmAttribute::deleteMemoryPool( );
     SgAsmJvmCodeAttribute::deleteMemoryPool( );
     SgAsmJvmMethod::deleteMemoryPool( );
     SgAsmJvmConstantPool::deleteMemoryPool( );
     SgAsmJvmConstantPoolEntry::deleteMemoryPool( );
     SgAsmJvmConstantValue::deleteMemoryPool( );
     SgAsmJvmInstruction::deleteMemoryPool( );
     SgAsmJvmFileHeader::deleteMemoryPool( );
     SgAsmJvmNode::deleteMemoryPool( );
     SgAsmJvmSignature::deleteMemoryPool( );
     SgAsmJvmSourceFile::deleteMemoryPool( );
     SgAsmLEEntryPoint::deleteMemoryPool( );
     SgAsmLEEntryTable::deleteMemoryPool( );
     SgAsmLEFileHeader::deleteMemoryPool( );
     SgAsmLENameTable::deleteMemoryPool( );
     SgAsmLEPageTable::deleteMemoryPool( );
     SgAsmLEPageTableEntry::deleteMemoryPool( );
     SgAsmLERelocTable::deleteMemoryPool( );
     SgAsmLESection::deleteMemoryPool( );
     SgAsmLESectionTable::deleteMemoryPool( );
     SgAsmLESectionTableEntry::deleteMemoryPool( );
     SgAsmM68kInstruction::deleteMemoryPool( );
     SgAsmMemoryReferenceExpression::deleteMemoryPool( );
     SgAsmMipsInstruction::deleteMemoryPool( );
     SgAsmNEEntryPoint::deleteMemoryPool( );
     SgAsmNEEntryTable::deleteMemoryPool( );
     SgAsmNEFileHeader::deleteMemoryPool( );
     SgAsmNEModuleTable::deleteMemoryPool( );
     SgAsmNENameTable::deleteMemoryPool( );
     SgAsmNERelocEntry::deleteMemoryPool( );
     SgAsmNERelocTable::deleteMemoryPool( );
     SgAsmNESection::deleteMemoryPool( );
     SgAsmNESectionTable::deleteMemoryPool( );
     SgAsmNESectionTableEntry::deleteMemoryPool( );
     SgAsmNEStringTable::deleteMemoryPool( );
     SgAsmNode::deleteMemoryPool( );
     SgAsmOp::deleteMemoryPool( );
     SgAsmOperandList::deleteMemoryPool( );
     SgAsmPEExportDirectory::deleteMemoryPool( );
     SgAsmPEExportEntry::deleteMemoryPool( );
     SgAsmPEExportEntryList::deleteMemoryPool( );
     SgAsmPEExportSection::deleteMemoryPool( );
     SgAsmPEFileHeader::deleteMemoryPool( );
     SgAsmPEImportDirectory::deleteMemoryPool( );
     SgAsmPEImportDirectoryList::deleteMemoryPool( );
     SgAsmPEImportItem::deleteMemoryPool( );
     SgAsmPEImportItemList::deleteMemoryPool( );
     SgAsmPEImportSection::deleteMemoryPool( );
     SgAsmPERVASizePair::deleteMemoryPool( );
     SgAsmPERVASizePairList::deleteMemoryPool( );
     SgAsmPESection::deleteMemoryPool( );
     SgAsmPESectionTable::deleteMemoryPool( );
     SgAsmPESectionTableEntry::deleteMemoryPool( );
     SgAsmPEStringSection::deleteMemoryPool( );
     SgAsmPowerpcInstruction::deleteMemoryPool( );
     SgAsmRegisterNames::deleteMemoryPool( );
     SgAsmRegisterReferenceExpression::deleteMemoryPool( );
     SgAsmRiscOperation::deleteMemoryPool( );
     SgAsmScalarType::deleteMemoryPool( );
     SgAsmStatement::deleteMemoryPool( );
     SgAsmStaticData::deleteMemoryPool( );
     SgAsmStmt::deleteMemoryPool( );
     SgAsmStoredString::deleteMemoryPool( );
     SgAsmStringStorage::deleteMemoryPool( );
     SgAsmType::deleteMemoryPool( );
     SgAsmUnaryExpression::deleteMemoryPool( );
     SgAsmUnaryMinus::deleteMemoryPool( );
     SgAsmUnaryPlus::deleteMemoryPool( );
     SgAsmUnaryRrx::deleteMemoryPool( );
     SgAsmUnarySignedExtend::deleteMemoryPool( );
     SgAsmUnaryUnsignedExtend::deleteMemoryPool( );
     SgAsmUnaryTruncate::deleteMemoryPool( );
     SgAsmValueExpression::deleteMemoryPool( );
     SgAsmVectorType::deleteMemoryPool( );
     SgAsmX86Instruction::deleteMemoryPool( );
     SgAsmBinaryAddressSymbol::deleteMemoryPool( );
     SgAsmBinaryDataSymbol::deleteMemoryPool( );
     SgAssertStmt::deleteMemoryPool( );
     SgAssignInitializer::deleteMemoryPool( );
     SgAssignOp::deleteMemoryPool( );
     SgAssignStatement::deleteMemoryPool( );
     SgAssignedGotoStatement::deleteMemoryPool( );
     SgAssociateStatement::deleteMemoryPool( );
     SgAsteriskShapeExp::deleteMemoryPool( );
     SgAtOp::deleteMemoryPool( );
     SgAttribute::deleteMemoryPool( );
     SgAttributeSpecificationStatement::deleteMemoryPool( );
     SgAutoType::deleteMemoryPool( );
     SgAwaitExpression::deleteMemoryPool( );
     SgBackspaceStatement::deleteMemoryPool( );
     SgBaseClass::deleteMemoryPool( );
     SgExpBaseClass::deleteMemoryPool( );
     SgBaseClassModifier::deleteMemoryPool( );
     SgBasicBlock::deleteMemoryPool( );
     SgBidirectionalGraph::deleteMemoryPool( );
     SgBinaryComposite::deleteMemoryPool( );
     SgBinaryOp::deleteMemoryPool( );
     SgBitAndOp::deleteMemoryPool( );
     SgBitAttribute::deleteMemoryPool( );
     SgBitComplementOp::deleteMemoryPool( );
     SgBitEqvOp::deleteMemoryPool( );
     SgBitOrOp::deleteMemoryPool( );
     SgBitXorOp::deleteMemoryPool( );
     SgBlockDataStatement::deleteMemoryPool( );
     SgBoolValExp::deleteMemoryPool( );
     SgBreakStmt::deleteMemoryPool( );
     SgBracedInitializer::deleteMemoryPool( );
     SgC_PreprocessorDirectiveStatement::deleteMemoryPool( );
     SgCaseOptionStmt::deleteMemoryPool( );
     SgCastExp::deleteMemoryPool( );
     SgCatchOptionStmt::deleteMemoryPool( );
     SgCatchStatementSeq::deleteMemoryPool( );
     SgCharVal::deleteMemoryPool( );
     SgChar16Val::deleteMemoryPool( );
     SgChar32Val::deleteMemoryPool( );
     SgChooseExpression::deleteMemoryPool( );
     SgClassDecl_attr::deleteMemoryPool( );
     SgClassDeclaration::deleteMemoryPool( );
     SgClassDefinition::deleteMemoryPool( );
     SgClassNameRefExp::deleteMemoryPool( );
     SgClassSymbol::deleteMemoryPool( );
     SgClassType::deleteMemoryPool( );
     SgClinkageDeclarationStatement::deleteMemoryPool( );
     SgClinkageEndStatement::deleteMemoryPool( );
     SgClinkageStartStatement::deleteMemoryPool( );
     SgCloseStatement::deleteMemoryPool( );
     SgColonShapeExp::deleteMemoryPool( );
     SgCommaOpExp::deleteMemoryPool( );
     SgCommonBlock::deleteMemoryPool( );
     SgCommonBlockObject::deleteMemoryPool( );
     SgCommonSymbol::deleteMemoryPool( );
     SgComplexVal::deleteMemoryPool( );
     SgComprehension::deleteMemoryPool( );
     SgCompoundAssignOp::deleteMemoryPool( );
     SgCompoundInitializer::deleteMemoryPool( );
     SgCompoundLiteralExp::deleteMemoryPool( );
     SgComputedGotoStatement::deleteMemoryPool( );
     SgConcatenationOp::deleteMemoryPool( );
     SgConditionalExp::deleteMemoryPool( );
     SgConjugateOp::deleteMemoryPool( );
     SgConstVolatileModifier::deleteMemoryPool( );
     SgConstructorInitializer::deleteMemoryPool( );
     SgContainsStatement::deleteMemoryPool( );
     SgContinueStmt::deleteMemoryPool( );
     SgCtorInitializerList::deleteMemoryPool( );
     SgDataStatementGroup::deleteMemoryPool( );
     SgDataStatementObject::deleteMemoryPool( );
     SgDataStatementValue::deleteMemoryPool( );
     SgDeadIfDirectiveStatement::deleteMemoryPool( );
     SgDeallocateStatement::deleteMemoryPool( );
     SgDeclarationModifier::deleteMemoryPool( );
     SgDeclarationScope::deleteMemoryPool( );
     SgDeclarationStatement::deleteMemoryPool( );
     SgDeclType::deleteMemoryPool( );
     SgDefaultOptionStmt::deleteMemoryPool( );
     SgDefaultSymbol::deleteMemoryPool( );
     SgDefineDirectiveStatement::deleteMemoryPool( );
     SgDeleteExp::deleteMemoryPool( );
     SgDerivedTypeStatement::deleteMemoryPool( );
     SgDesignatedInitializer::deleteMemoryPool( );
     SgDictionaryComprehension::deleteMemoryPool( );
     SgDictionaryExp::deleteMemoryPool( );
     SgDimensionObject::deleteMemoryPool( );
     SgDirectedGraphEdge::deleteMemoryPool( );
     SgDirectory::deleteMemoryPool( );
     SgDirectoryList::deleteMemoryPool( );
     SgDivAssignOp::deleteMemoryPool( );
     SgDivideOp::deleteMemoryPool( );
     SgDoWhileStmt::deleteMemoryPool( );
     SgDotExp::deleteMemoryPool( );
     SgDotStarOp::deleteMemoryPool( );
     SgDoubleVal::deleteMemoryPool( );
     SgElaboratedTypeModifier::deleteMemoryPool( );
     SgElementwiseOp::deleteMemoryPool( );
     SgElementwiseAddOp::deleteMemoryPool( );
     SgElementwiseDivideOp::deleteMemoryPool( );
     SgElementwiseLeftDivideOp::deleteMemoryPool( );
     SgElementwiseMultiplyOp::deleteMemoryPool( );
     SgElementwisePowerOp::deleteMemoryPool( );
     SgElementwiseSubtractOp::deleteMemoryPool( );
     SgElseDirectiveStatement::deleteMemoryPool( );
     SgElseWhereStatement::deleteMemoryPool( );
     SgElseifDirectiveStatement::deleteMemoryPool( );
     SgEmptyDeclaration::deleteMemoryPool( );
     SgEmptyDirectiveStatement::deleteMemoryPool( );
     SgEndfileStatement::deleteMemoryPool( );
     SgEndifDirectiveStatement::deleteMemoryPool( );
     SgEntryStatement::deleteMemoryPool( );
     SgEnumDeclaration::deleteMemoryPool( );
     SgEnumFieldSymbol::deleteMemoryPool( );
     SgEnumSymbol::deleteMemoryPool( );
     SgEnumType::deleteMemoryPool( );
     SgEnumVal::deleteMemoryPool( );
     SgEqualityOp::deleteMemoryPool( );
     SgEquivalenceStatement::deleteMemoryPool( );
     SgErrorDirectiveStatement::deleteMemoryPool( );
     SgExecStatement::deleteMemoryPool( );
     SgExponentiationOp::deleteMemoryPool( );
     SgExponentiationAssignOp::deleteMemoryPool( );
     SgExprListExp::deleteMemoryPool( );
     SgExprStatement::deleteMemoryPool( );
     SgExpression::deleteMemoryPool( );
     SgExpressionRoot::deleteMemoryPool( );
     SgFile::deleteMemoryPool( );
     SgFileList::deleteMemoryPool( );
     SgFloatVal::deleteMemoryPool( );
     SgFloat128Val::deleteMemoryPool( );
     SgFloat80Val::deleteMemoryPool( );
     SgFoldExpression::deleteMemoryPool( );
     SgFlushStatement::deleteMemoryPool( );
     SgForAllStatement::deleteMemoryPool( );
     SgForInitStatement::deleteMemoryPool( );
     SgForStatement::deleteMemoryPool( );
     SgFormatItem::deleteMemoryPool( );
     SgFormatItemList::deleteMemoryPool( );
     SgFormatStatement::deleteMemoryPool( );
     SgFortranDo::deleteMemoryPool( );
     SgFortranIncludeLine::deleteMemoryPool( );
     SgFortranNonblockedDo::deleteMemoryPool( );
     SgFuncDecl_attr::deleteMemoryPool( );
     SgFunctionCallExp::deleteMemoryPool( );
     SgFunctionDeclaration::deleteMemoryPool( );
     SgFunctionDefinition::deleteMemoryPool( );
     SgFunctionParameterScope::deleteMemoryPool( );
     SgFunctionModifier::deleteMemoryPool( );
     SgFunctionParameterList::deleteMemoryPool( );
     SgFunctionParameterRefExp::deleteMemoryPool( );
     SgFunctionParameterTypeList::deleteMemoryPool( );
     SgFunctionRefExp::deleteMemoryPool( );
     SgFunctionSymbol::deleteMemoryPool( );
     SgFunctionType::deleteMemoryPool( );
     SgFunctionTypeSymbol::deleteMemoryPool( );
     SgFunctionTypeTable::deleteMemoryPool( );
     SgTypeTable::deleteMemoryPool( );
     SgGlobal::deleteMemoryPool( );
     SgGotoStatement::deleteMemoryPool( );
     SgGraph::deleteMemoryPool( );
     SgGraphEdge::deleteMemoryPool( );
     SgGraphEdgeList::deleteMemoryPool( );
     SgGraphNode::deleteMemoryPool( );
     SgGraphNodeList::deleteMemoryPool( );
     SgGreaterOrEqualOp::deleteMemoryPool( );
     SgGreaterThanOp::deleteMemoryPool( );
     SgIOItemExpression::deleteMemoryPool( );
     SgIOStatement::deleteMemoryPool( );
     SgIdentDirectiveStatement::deleteMemoryPool( );
     SgIfDirectiveStatement::deleteMemoryPool( );
     SgIfStmt::deleteMemoryPool( );
     SgIfdefDirectiveStatement::deleteMemoryPool( );
     SgIfndefDirectiveStatement::deleteMemoryPool( );
     SgImageControlStatement::deleteMemoryPool( );
     SgImagPartOp::deleteMemoryPool( );
     SgImplicitStatement::deleteMemoryPool( );
     SgImpliedDo::deleteMemoryPool( );
     SgImportStatement::deleteMemoryPool( );
     SgIncidenceDirectedGraph::deleteMemoryPool( );
     SgIncidenceUndirectedGraph::deleteMemoryPool( );
     SgIncludeDirectiveStatement::deleteMemoryPool( );
     SgIncludeFile::deleteMemoryPool( );
     SgIncludeNextDirectiveStatement::deleteMemoryPool( );
     SgInitializedName::deleteMemoryPool( );
     SgInitializer::deleteMemoryPool( );
     SgInquireStatement::deleteMemoryPool( );
     SgIntKeyedBidirectionalGraph::deleteMemoryPool( );
     SgIntVal::deleteMemoryPool( );
     SgIntegerDivideOp::deleteMemoryPool( );
     SgIntegerDivideAssignOp::deleteMemoryPool( );
     SgInterfaceBody::deleteMemoryPool( );
     SgHeaderFileBody::deleteMemoryPool( );
     SgHeaderFileReport::deleteMemoryPool( );
     SgInterfaceStatement::deleteMemoryPool( );
     SgInterfaceSymbol::deleteMemoryPool( );
     SgIntrinsicSymbol::deleteMemoryPool( );
     SgIsOp::deleteMemoryPool( );
     SgIsNotOp::deleteMemoryPool( );
     SgIorAssignOp::deleteMemoryPool( );
     SgJovialBitType::deleteMemoryPool( );
     SgJovialBitVal::deleteMemoryPool( );
     SgJovialTableType::deleteMemoryPool( );
     SgJovialCompoolStatement::deleteMemoryPool( );
     SgJovialForThenStatement::deleteMemoryPool( );
     SgJovialDefineDeclaration::deleteMemoryPool( );
     SgJovialDirectiveStatement::deleteMemoryPool( );
     SgJovialOverlayDeclaration::deleteMemoryPool( );
     SgJovialPresetPositionExp::deleteMemoryPool( );
     SgJovialTablePresetExp::deleteMemoryPool( );
     SgJovialTableStatement::deleteMemoryPool( );
     SgKeyDatumPair::deleteMemoryPool( );
     SgCudaKernelExecConfig::deleteMemoryPool( );
     SgCudaKernelCallExp::deleteMemoryPool( );
     SgLabelRefExp::deleteMemoryPool( );
     SgLabelStatement::deleteMemoryPool( );
     SgJavaLabelStatement::deleteMemoryPool( );
     SgLabelSymbol::deleteMemoryPool( );
     SgJavaLabelSymbol::deleteMemoryPool( );
     SgLambdaCapture::deleteMemoryPool( );
     SgLambdaCaptureList::deleteMemoryPool( );
     SgLambdaExp::deleteMemoryPool( );
     SgLambdaRefExp::deleteMemoryPool( );
     SgLeftDivideOp::deleteMemoryPool( );
     SgLessOrEqualOp::deleteMemoryPool( );
     SgLessThanOp::deleteMemoryPool( );
     SgLineDirectiveStatement::deleteMemoryPool( );
     SgLinemarkerDirectiveStatement::deleteMemoryPool( );
     SgLinkageModifier::deleteMemoryPool( );
     SgListComprehension::deleteMemoryPool( );
     SgListExp::deleteMemoryPool( );
     SgLocatedNode::deleteMemoryPool( );
     SgLocatedNodeSupport::deleteMemoryPool( );
     SgLongDoubleVal::deleteMemoryPool( );
     SgLongIntVal::deleteMemoryPool( );
     SgLongLongIntVal::deleteMemoryPool( );
     SgLshiftAssignOp::deleteMemoryPool( );
     SgLshiftOp::deleteMemoryPool( );
     SgMagicColonExp::deleteMemoryPool( );
     SgMatrixExp::deleteMemoryPool( );
     SgMatrixTransposeOp::deleteMemoryPool( );
     SgMatlabForStatement::deleteMemoryPool( );
     SgMemberFunctionDeclaration::deleteMemoryPool( );
     SgMemberFunctionRefExp::deleteMemoryPool( );
     SgMemberFunctionSymbol::deleteMemoryPool( );
     SgMemberFunctionType::deleteMemoryPool( );
     SgMembershipOp::deleteMemoryPool( );
     SgMicrosoftAttributeDeclaration::deleteMemoryPool( );
     SgMinusAssignOp::deleteMemoryPool( );
     SgMinusMinusOp::deleteMemoryPool( );
     SgMinusOp::deleteMemoryPool( );
     SgModAssignOp::deleteMemoryPool( );
     SgModOp::deleteMemoryPool( );
     SgModifier::deleteMemoryPool( );
     SgModifierNodes::deleteMemoryPool( );
     SgModifierType::deleteMemoryPool( );
     SgModuleStatement::deleteMemoryPool( );
     SgModuleSymbol::deleteMemoryPool( );
     SgMultAssignOp::deleteMemoryPool( );
     SgMultiplyOp::deleteMemoryPool( );
     SgName::deleteMemoryPool( );
     SgNameGroup::deleteMemoryPool( );
     SgNamedType::deleteMemoryPool( );
     SgNamelistStatement::deleteMemoryPool( );
     SgNamespaceAliasDeclarationStatement::deleteMemoryPool( );
     SgNamespaceDeclarationStatement::deleteMemoryPool( );
     SgNamespaceDefinitionStatement::deleteMemoryPool( );
     SgNamespaceSymbol::deleteMemoryPool( );
     SgNaryOp::deleteMemoryPool( );
     SgNaryBooleanOp::deleteMemoryPool( );
     SgNaryComparisonOp::deleteMemoryPool( );
     SgNewExp::deleteMemoryPool( );
     SgNode::deleteMemoryPool( );
     SgNoexceptOp::deleteMemoryPool( );
     SgNotEqualOp::deleteMemoryPool( );
     SgNotOp::deleteMemoryPool( );
     SgNonMembershipOp::deleteMemoryPool( );
     SgNonrealDecl::deleteMemoryPool( );
     SgNonrealRefExp::deleteMemoryPool( );
     SgNonrealSymbol::deleteMemoryPool( );
     SgNonrealType::deleteMemoryPool( );
     SgNonrealBaseClass::deleteMemoryPool( );
     SgNullExpression::deleteMemoryPool( );
     SgNullptrValExp::deleteMemoryPool( );
     SgNullStatement::deleteMemoryPool( );
     SgNullifyStatement::deleteMemoryPool( );
     SgOmpAtomicStatement::deleteMemoryPool( );
     SgOmpBarrierStatement::deleteMemoryPool( );
     SgOmpCriticalStatement::deleteMemoryPool( );
     SgOmpClauseBodyStatement::deleteMemoryPool( );
     SgOmpBodyStatement::deleteMemoryPool( );
     SgOmpDoStatement::deleteMemoryPool( );
     SgOmpFlushStatement::deleteMemoryPool( );
     SgOmpDeclareSimdStatement::deleteMemoryPool( );
     SgOmpForStatement::deleteMemoryPool( );
     SgOmpForSimdStatement::deleteMemoryPool( );
     SgOmpMasterStatement::deleteMemoryPool( );
     SgOmpOrderedStatement::deleteMemoryPool( );
     SgOmpParallelStatement::deleteMemoryPool( );
     SgOmpSectionStatement::deleteMemoryPool( );
     SgOmpSectionsStatement::deleteMemoryPool( );
     SgOmpSingleStatement::deleteMemoryPool( );
     SgOmpTaskStatement::deleteMemoryPool( );
     SgOmpTaskwaitStatement::deleteMemoryPool( );
     SgOmpThreadprivateStatement::deleteMemoryPool( );
     SgOmpWorkshareStatement::deleteMemoryPool( );
     SgOmpTargetStatement::deleteMemoryPool( );
     SgOmpTargetDataStatement::deleteMemoryPool( );
     SgOmpSimdStatement::deleteMemoryPool( );
     SgOmpClause::deleteMemoryPool( );
     SgOmpBeginClause::deleteMemoryPool( );
     SgOmpCollapseClause::deleteMemoryPool( );
     SgOmpCopyinClause::deleteMemoryPool( );
     SgOmpCopyprivateClause::deleteMemoryPool( );
     SgOmpDefaultClause::deleteMemoryPool( );
     SgOmpEndClause::deleteMemoryPool( );
     SgOmpExpressionClause::deleteMemoryPool( );
     SgOmpFirstprivateClause::deleteMemoryPool( );
     SgOmpIfClause::deleteMemoryPool( );
     SgOmpFinalClause::deleteMemoryPool( );
     SgOmpPriorityClause::deleteMemoryPool( );
     SgOmpDeviceClause::deleteMemoryPool( );
     SgOmpLastprivateClause::deleteMemoryPool( );
     SgOmpNowaitClause::deleteMemoryPool( );
     SgOmpNumThreadsClause::deleteMemoryPool( );
     SgOmpOrderedClause::deleteMemoryPool( );
     SgOmpPrivateClause::deleteMemoryPool( );
     SgOmpReductionClause::deleteMemoryPool( );
     SgOmpScheduleClause::deleteMemoryPool( );
     SgOmpSharedClause::deleteMemoryPool( );
     SgOmpUntiedClause::deleteMemoryPool( );
     SgOmpMergeableClause::deleteMemoryPool( );
     SgOmpVariablesClause::deleteMemoryPool( );
     SgOmpMapClause::deleteMemoryPool( );
     SgOmpSafelenClause::deleteMemoryPool( );
     SgOmpSimdlenClause::deleteMemoryPool( );
     SgOmpLinearClause::deleteMemoryPool( );
     SgOmpUniformClause::deleteMemoryPool( );
     SgOmpAlignedClause::deleteMemoryPool( );
     SgOmpProcBindClause::deleteMemoryPool( );
     SgOmpAtomicClause::deleteMemoryPool( );
     SgOmpInbranchClause::deleteMemoryPool( );
     SgOmpNotinbranchClause::deleteMemoryPool( );
     SgOmpDependClause::deleteMemoryPool( );
     SgOpenclAccessModeModifier::deleteMemoryPool( );
     SgOpenStatement::deleteMemoryPool( );
     SgOptions::deleteMemoryPool( );
     SgOrOp::deleteMemoryPool( );
     SgParameterStatement::deleteMemoryPool( );
     SgPartialFunctionModifierType::deleteMemoryPool( );
     SgPartialFunctionType::deleteMemoryPool( );
     SgPassStatement::deleteMemoryPool( );
     SgPlusAssignOp::deleteMemoryPool( );
     SgPlusPlusOp::deleteMemoryPool( );
     SgPntrArrRefExp::deleteMemoryPool( );
     SgPointerAssignOp::deleteMemoryPool( );
     SgPointerDerefExp::deleteMemoryPool( );
     SgPointerMemberType::deleteMemoryPool( );
     SgPointerType::deleteMemoryPool( );
     SgPowerOp::deleteMemoryPool( );
     SgPragma::deleteMemoryPool( );
     SgPragmaDeclaration::deleteMemoryPool( );
     SgPrintStatement::deleteMemoryPool( );
     SgProcedureHeaderStatement::deleteMemoryPool( );
     SgProgramHeaderStatement::deleteMemoryPool( );
     SgProject::deleteMemoryPool( );
     SgPseudoDestructorRefExp::deleteMemoryPool( );
     SgPythonGlobalStmt::deleteMemoryPool( );
     SgPythonPrintStmt::deleteMemoryPool( );
     SgQualifiedName::deleteMemoryPool( );
     SgQualifiedNameType::deleteMemoryPool( );
     SgRangeExp::deleteMemoryPool( );
     SgRangeBasedForStatement::deleteMemoryPool( );
     SgReadStatement::deleteMemoryPool( );
     SgRealPartOp::deleteMemoryPool( );
     SgRefExp::deleteMemoryPool( );
     SgReferenceType::deleteMemoryPool( );
     SgRemOp::deleteMemoryPool( );
     SgRenamePair::deleteMemoryPool( );
     SgRenameSymbol::deleteMemoryPool( );
     SgReplicationOp::deleteMemoryPool( );
     SgReturnStmt::deleteMemoryPool( );
     SgRewindStatement::deleteMemoryPool( );
     SgRshiftAssignOp::deleteMemoryPool( );
     SgRshiftOp::deleteMemoryPool( );
     SgRvalueReferenceType::deleteMemoryPool( );
     SgJavaUnsignedRshiftAssignOp::deleteMemoryPool( );
     SgJavaUnsignedRshiftOp::deleteMemoryPool( );
     SgScopeOp::deleteMemoryPool( );
     SgScopeStatement::deleteMemoryPool( );
     SgSequenceStatement::deleteMemoryPool( );
     SgSetComprehension::deleteMemoryPool( );
     SgShortVal::deleteMemoryPool( );
     SgSizeOfOp::deleteMemoryPool( );
     SgAlignOfOp::deleteMemoryPool( );
     SgJavaInstanceOfOp::deleteMemoryPool( );
     SgSourceFile::deleteMemoryPool( );
     SgSpaceshipOp::deleteMemoryPool( );
     SgSpawnStmt::deleteMemoryPool( );
     SgSyncAllStatement::deleteMemoryPool( );
     SgSyncImagesStatement::deleteMemoryPool( );
     SgSyncMemoryStatement::deleteMemoryPool( );
     SgSyncTeamStatement::deleteMemoryPool( );
     SgLockStatement::deleteMemoryPool( );
     SgUnlockStatement::deleteMemoryPool( );
     SgJavaThrowStatement::deleteMemoryPool( );
     SgJavaForEachStatement::deleteMemoryPool( );
     SgJavaSynchronizedStatement::deleteMemoryPool( );
     SgJavaParameterizedType::deleteMemoryPool( );
     SgJavaWildcardType::deleteMemoryPool( );
     SgProcessControlStatement::deleteMemoryPool( );
     SgSpecialFunctionModifier::deleteMemoryPool( );
     SgStatement::deleteMemoryPool( );
     SgStaticAssertionDeclaration::deleteMemoryPool( );
     SgStmtDeclarationStatement::deleteMemoryPool( );
     SgStatementExpression::deleteMemoryPool( );
     SgStatementFunctionStatement::deleteMemoryPool( );
     SgStorageModifier::deleteMemoryPool( );
     SgStringConversion::deleteMemoryPool( );
     SgStringKeyedBidirectionalGraph::deleteMemoryPool( );
     SgStringVal::deleteMemoryPool( );
     SgStructureModifier::deleteMemoryPool( );
     SgSubscriptExpression::deleteMemoryPool( );
     SgSubtractOp::deleteMemoryPool( );
     SgSupport::deleteMemoryPool( );
     SgSwitchStatement::deleteMemoryPool( );
     SgSymbol::deleteMemoryPool( );
     SgSymbolTable::deleteMemoryPool( );
     SgTemplateArgument::deleteMemoryPool( );
     SgTemplateArgumentList::deleteMemoryPool( );
     SgTemplateDeclaration::deleteMemoryPool( );
     SgTemplateClassDeclaration::deleteMemoryPool( );
     SgTemplateClassSymbol::deleteMemoryPool( );
     SgTemplateFunctionDeclaration::deleteMemoryPool( );
     SgTemplateFunctionRefExp::deleteMemoryPool( );
     SgTemplateFunctionSymbol::deleteMemoryPool( );
     SgTemplateMemberFunctionDeclaration::deleteMemoryPool( );
     SgTemplateMemberFunctionRefExp::deleteMemoryPool( );
     SgTemplateMemberFunctionSymbol::deleteMemoryPool( );
     SgTemplateTypedefDeclaration::deleteMemoryPool( );
     SgTemplateTypedefSymbol::deleteMemoryPool( );
     SgTemplateVariableDeclaration::deleteMemoryPool( );
     SgTemplateVariableSymbol::deleteMemoryPool( );
     SgTemplateClassDefinition::deleteMemoryPool( );
     SgTemplateFunctionDefinition::deleteMemoryPool( );
     SgTemplateInstantiationDecl::deleteMemoryPool( );
     SgTemplateInstantiationDefn::deleteMemoryPool( );
     SgTemplateInstantiationDirectiveStatement::deleteMemoryPool( );
     SgTemplateInstantiationFunctionDecl::deleteMemoryPool( );
     SgTemplateInstantiationMemberFunctionDecl::deleteMemoryPool( );
     SgTemplateInstantiationTypedefDeclaration::deleteMemoryPool( );
     SgTemplateParameter::deleteMemoryPool( );
     SgTemplateParameterVal::deleteMemoryPool( );
     SgTemplateParameterList::deleteMemoryPool( );
     SgTemplateSymbol::deleteMemoryPool( );
     SgTemplateType::deleteMemoryPool( );
     SgThisExp::deleteMemoryPool( );
     SgTypeTraitBuiltinOperator::deleteMemoryPool( );
     SgSuperExp::deleteMemoryPool( );
     SgThrowOp::deleteMemoryPool( );
     SgToken::deleteMemoryPool( );
     SgTryStmt::deleteMemoryPool( );
     SgTupleExp::deleteMemoryPool( );
     SgType::deleteMemoryPool( );
     SgTypeBool::deleteMemoryPool( );
     SgTypeChar::deleteMemoryPool( );
     SgTypeChar16::deleteMemoryPool( );
     SgTypeChar32::deleteMemoryPool( );
     SgTypeComplex::deleteMemoryPool( );
     SgTypeDefault::deleteMemoryPool( );
     SgTypeExpression::deleteMemoryPool( );
     SgTypeLabel::deleteMemoryPool( );
     SgTypeDouble::deleteMemoryPool( );
     SgTypeEllipse::deleteMemoryPool( );
     SgTypeFixed::deleteMemoryPool( );
     SgTypeFloat::deleteMemoryPool( );
     SgTypeFloat128::deleteMemoryPool( );
     SgTypeFloat80::deleteMemoryPool( );
     SgTypeGlobalVoid::deleteMemoryPool( );
     SgTypeIdOp::deleteMemoryPool( );
     SgTypeImaginary::deleteMemoryPool( );
     SgTypeInt::deleteMemoryPool( );
     SgTypeLong::deleteMemoryPool( );
     SgTypeLongDouble::deleteMemoryPool( );
     SgTypeLongLong::deleteMemoryPool( );
     SgTypeModifier::deleteMemoryPool( );
     SgTypeMatrix::deleteMemoryPool( );
     SgTypeTuple::deleteMemoryPool( );
     SgTypeNullptr::deleteMemoryPool( );
     SgTypeOfType::deleteMemoryPool( );
     SgTypeShort::deleteMemoryPool( );
     SgTypeSigned128bitInteger::deleteMemoryPool( );
     SgTypeSignedChar::deleteMemoryPool( );
     SgTypeSignedInt::deleteMemoryPool( );
     SgTypeSignedLong::deleteMemoryPool( );
     SgTypeSignedLongLong::deleteMemoryPool( );
     SgTypeSignedShort::deleteMemoryPool( );
     SgTypeString::deleteMemoryPool( );
     SgTypeUnknown::deleteMemoryPool( );
     SgTypeUnsigned128bitInteger::deleteMemoryPool( );
     SgTypeUnsignedChar::deleteMemoryPool( );
     SgTypeUnsignedInt::deleteMemoryPool( );
     SgTypeUnsignedLong::deleteMemoryPool( );
     SgTypeUnsignedLongLong::deleteMemoryPool( );
     SgTypeUnsignedShort::deleteMemoryPool( );
     SgTypeVoid::deleteMemoryPool( );
     SgTypeWchar::deleteMemoryPool( );
     SgTypedefDeclaration::deleteMemoryPool( );
     SgTypedefSeq::deleteMemoryPool( );
     SgTypedefSymbol::deleteMemoryPool( );
     SgTypedefType::deleteMemoryPool( );
     SgUPC_AccessModifier::deleteMemoryPool( );
     SgUnaryAddOp::deleteMemoryPool( );
     SgUnaryOp::deleteMemoryPool( );
     SgUndefDirectiveStatement::deleteMemoryPool( );
     SgUndirectedGraphEdge::deleteMemoryPool( );
     SgUnknownArrayOrFunctionReference::deleteMemoryPool( );
     SgUnknownFile::deleteMemoryPool( );
     SgUnparse_Info::deleteMemoryPool( );
     SgUnsignedCharVal::deleteMemoryPool( );
     SgUnsignedIntVal::deleteMemoryPool( );
     SgUnsignedLongLongIntVal::deleteMemoryPool( );
     SgUnsignedLongVal::deleteMemoryPool( );
     SgUnsignedShortVal::deleteMemoryPool( );
     SgUpcBarrierStatement::deleteMemoryPool( );
     SgUpcBlocksizeofExpression::deleteMemoryPool( );
     SgUpcElemsizeofExpression::deleteMemoryPool( );
     SgUpcFenceStatement::deleteMemoryPool( );
     SgUpcForAllStatement::deleteMemoryPool( );
     SgUpcLocalsizeofExpression::deleteMemoryPool( );
     SgUpcMythread::deleteMemoryPool( );
     SgUpcNotifyStatement::deleteMemoryPool( );
     SgUpcThreads::deleteMemoryPool( );
     SgUpcWaitStatement::deleteMemoryPool( );
     SgUseStatement::deleteMemoryPool( );
     SgUserDefinedBinaryOp::deleteMemoryPool( );
     SgUserDefinedUnaryOp::deleteMemoryPool( );
     SgUsingDeclarationStatement::deleteMemoryPool( );
     SgUsingDirectiveStatement::deleteMemoryPool( );
     SgValueExp::deleteMemoryPool( );
     SgVarArgCopyOp::deleteMemoryPool( );
     SgVarArgEndOp::deleteMemoryPool( );
     SgVarArgOp::deleteMemoryPool( );
     SgVarArgStartOneOperandOp::deleteMemoryPool( );
     SgVarArgStartOp::deleteMemoryPool( );
     SgVarRefExp::deleteMemoryPool( );
     SgVariableDeclaration::deleteMemoryPool( );
     SgVariableDefinition::deleteMemoryPool( );
     SgVariableSymbol::deleteMemoryPool( );
     SgVariantExpression::deleteMemoryPool( );
     SgVariantStatement::deleteMemoryPool( );
     SgVoidVal::deleteMemoryPool( );
     SgWaitStatement::deleteMemoryPool( );
     SgWarningDirectiveStatement::deleteMemoryPool( );
     SgWithStatement::deleteMemoryPool( );
     SgWcharVal::deleteMemoryPool( );
     SgWhereStatement::deleteMemoryPool( );
     SgWhileStmt::deleteMemoryPool( );
     SgWriteStatement::deleteMemoryPool( );
     SgXorAssignOp::deleteMemoryPool( );
     SgYieldExpression::deleteMemoryPool( );
     Sg_File_Info::deleteMemoryPool( );
     SgTypeCAFTeam::deleteMemoryPool( );
     SgCAFWithTeamStatement::deleteMemoryPool( );
     SgCAFCoExpression::deleteMemoryPool( );
     SgCallExpression::deleteMemoryPool( );
     SgTypeCrayPointer::deleteMemoryPool( );
     SgJavaImportStatement::deleteMemoryPool( );
     SgJavaPackageDeclaration::deleteMemoryPool( );
     SgJavaPackageStatement::deleteMemoryPool( );
     SgJavaImportStatementList::deleteMemoryPool( );
     SgJavaClassDeclarationList::deleteMemoryPool( );
     SgJavaMemberValuePair::deleteMemoryPool( );
     SgJavaAnnotation::deleteMemoryPool( );
     SgJavaMarkerAnnotation::deleteMemoryPool( );
     SgJavaSingleMemberAnnotation::deleteMemoryPool( );
     SgJavaNormalAnnotation::deleteMemoryPool( );
     SgJavaTypeExpression::deleteMemoryPool( );
     SgJavaQualifiedType::deleteMemoryPool( );
     SgClassExp::deleteMemoryPool( );
     SgJavaUnionType::deleteMemoryPool( );
     SgJavaParameterType::deleteMemoryPool( );
     SgAsyncStmt::deleteMemoryPool( );
     SgFinishStmt::deleteMemoryPool( );
     SgAtStmt::deleteMemoryPool( );
     SgAtomicStmt::deleteMemoryPool( );
     SgWhenStmt::deleteMemoryPool( );
     SgAtExp::deleteMemoryPool( );
     SgFinishExp::deleteMemoryPool( );
     SgHereExp::deleteMemoryPool( );
     SgDotDotExp::deleteMemoryPool( );
     SgAsmNullInstruction::deleteMemoryPool( );
     SgAdaComponentClause::deleteMemoryPool( );
     SgAdaIndexConstraint::deleteMemoryPool( );
     SgAdaModularType::deleteMemoryPool( );
     SgAdaRepresentationClause::deleteMemoryPool( );
     SgAdaFunctionRenamingDecl::deleteMemoryPool( );
     SgAdaSelectStmt::deleteMemoryPool( );
     SgAdaSelectAlternativeStmt::deleteMemoryPool( );
     SgAdaTerminateStmt::deleteMemoryPool( );
     SgAsmAarch32Coprocessor::deleteMemoryPool( );
     SgAdaAttributeClause::deleteMemoryPool( );
     SgAsmBinaryConcat::deleteMemoryPool( );
     SgAsmByteOrder::deleteMemoryPool( );
     SgAdaDerivedType::deleteMemoryPool( );
     SgAdaAttributeExp::deleteMemoryPool( );
     SgAdaEnumRepresentationClause::deleteMemoryPool( );
     SgAsmBinaryPreupdate::deleteMemoryPool( );
     SgAsmBinaryPostupdate::deleteMemoryPool( );
     SgAdaOthersExp::deleteMemoryPool( );
     SgAdaRenamingSymbol::deleteMemoryPool( );
     SgAdaRenamingRefExp::deleteMemoryPool( );
     SgAdaGenericDecl::deleteMemoryPool( );
     SgAdaGenericDefn::deleteMemoryPool( );
     SgAdaFormalType::deleteMemoryPool( );
     SgAdaGenericSymbol::deleteMemoryPool( );
     SgAdaFormalTypeDecl::deleteMemoryPool( );
     SgAdaUnitRefExp::deleteMemoryPool( );
     SgAdaDiscriminatedTypeDecl::deleteMemoryPool( );
     SgAdaDiscriminatedType::deleteMemoryPool( );
     SgAdaDiscriminantConstraint::deleteMemoryPool( );
     SgAdaGenericInstanceDecl::deleteMemoryPool( );
     SgAdaUnscopedBlock::deleteMemoryPool( );
     SgAdaInheritedFunctionSymbol::deleteMemoryPool( );
     SgAdaProtectedBody::deleteMemoryPool( );
     SgAdaProtectedBodyDecl::deleteMemoryPool( );
     SgAdaProtectedSpec::deleteMemoryPool( );
     SgAdaProtectedSpecDecl::deleteMemoryPool( );
     SgAdaProtectedSymbol::deleteMemoryPool( );
     SgAdaProtectedRefExp::deleteMemoryPool( );
     SgAdaProtectedType::deleteMemoryPool( );
     SgAdaProtectedTypeDecl::deleteMemoryPool( );
     SgAdaDigitsConstraint::deleteMemoryPool( );
     SgAdaAncestorInitializer::deleteMemoryPool( );
     SgAdaDeltaConstraint::deleteMemoryPool( );
     SgAdaSubroutineType::deleteMemoryPool( );
     SgAdaGenericInstanceSymbol::deleteMemoryPool( );
     SgAdaFormalPackageDecl::deleteMemoryPool( );
     SgAdaFormalPackageSymbol::deleteMemoryPool( );
     SgAsmJvmAttributeTable::deleteMemoryPool( );
     SgAsmJvmMethodTable::deleteMemoryPool( );
     SgAsmJvmField::deleteMemoryPool( );
     SgAsmJvmFieldTable::deleteMemoryPool( );
     SgAsmJvmExceptionHandler::deleteMemoryPool( );
     SgAsmJvmExceptionTable::deleteMemoryPool( );
     SgAsmJvmClass::deleteMemoryPool( );
     SgAsmJvmLineNumberEntry::deleteMemoryPool( );
     SgAsmJvmLineNumberTable::deleteMemoryPool( );
     SgAsmJvmInnerClassesEntry::deleteMemoryPool( );
     SgAsmJvmInnerClasses::deleteMemoryPool( );
     SgAsmCilInstruction::deleteMemoryPool( );
     SgAsmStackExpression::deleteMemoryPool( );
     SgAsmJvmEnclosingMethod::deleteMemoryPool( );
     SgAdaNullConstraint::deleteMemoryPool( );
     SgAsmJvmModuleMainClass::deleteMemoryPool( );
     SgAsmInstructionList::deleteMemoryPool( );
     SgAsmCilNode::deleteMemoryPool( );
     SgAsmCilAssembly::deleteMemoryPool( );
     SgAsmCilAssemblyOS::deleteMemoryPool( );
     SgAsmCilAssemblyProcessor::deleteMemoryPool( );
     SgAsmCilAssemblyRef::deleteMemoryPool( );
     SgAsmCilAssemblyRefOS::deleteMemoryPool( );
     SgAsmCilAssemblyRefProcessor::deleteMemoryPool( );
     SgAsmCilClassLayout::deleteMemoryPool( );
     SgAsmCilConstant::deleteMemoryPool( );
     SgAsmCilCustomAttribute::deleteMemoryPool( );
     SgAsmCilDeclSecurity::deleteMemoryPool( );
     SgAsmCilEvent::deleteMemoryPool( );
     SgAsmCilEventMap::deleteMemoryPool( );
     SgAsmCilExportedType::deleteMemoryPool( );
     SgAsmCilField::deleteMemoryPool( );
     SgAsmCilFieldLayout::deleteMemoryPool( );
     SgAsmCilFieldMarshal::deleteMemoryPool( );
     SgAsmCilFieldRVA::deleteMemoryPool( );
     SgAsmCilFile::deleteMemoryPool( );
     SgAsmCilGenericParam::deleteMemoryPool( );
     SgAsmCilGenericParamConstraint::deleteMemoryPool( );
     SgAsmCilImplMap::deleteMemoryPool( );
     SgAsmCilInterfaceImpl::deleteMemoryPool( );
     SgAsmCilManifestResource::deleteMemoryPool( );
     SgAsmCilMemberRef::deleteMemoryPool( );
     SgAsmCilMethodDef::deleteMemoryPool( );
     SgAsmCilMethodImpl::deleteMemoryPool( );
     SgAsmCilMethodSemantics::deleteMemoryPool( );
     SgAsmCilMethodSpec::deleteMemoryPool( );
     SgAsmCilModule::deleteMemoryPool( );
     SgAsmCilModuleRef::deleteMemoryPool( );
     SgAsmCilNestedClass::deleteMemoryPool( );
     SgAsmCilParam::deleteMemoryPool( );
     SgAsmCilProperty::deleteMemoryPool( );
     SgAsmCilPropertyMap::deleteMemoryPool( );
     SgAsmCilStandAloneSig::deleteMemoryPool( );
     SgAsmCilTypeDef::deleteMemoryPool( );
     SgAsmCilTypeRef::deleteMemoryPool( );
     SgAsmCilTypeSpec::deleteMemoryPool( );
     SgAdaParameterList::deleteMemoryPool( );
     SgAsmCilMetadata::deleteMemoryPool( );
     SgAsmCilMetadataRoot::deleteMemoryPool( );
     SgAsmCilDataStream::deleteMemoryPool( );
     SgAsmCilMetadataHeap::deleteMemoryPool( );
     SgAsmCilUint8Heap::deleteMemoryPool( );
     SgAsmCilUint32Heap::deleteMemoryPool( );
     SgAsmCliHeader::deleteMemoryPool( );
     SgAdaVariantDecl::deleteMemoryPool( );
     SgAdaVariantWhenStmt::deleteMemoryPool( );
     SgAsmCilAssemblyTable::deleteMemoryPool( );
     SgAsmCilAssemblyOSTable::deleteMemoryPool( );
     SgAsmCilAssemblyProcessorTable::deleteMemoryPool( );
     SgAsmCilAssemblyRefTable::deleteMemoryPool( );
     SgAsmCilAssemblyRefOSTable::deleteMemoryPool( );
     SgAsmCilAssemblyRefProcessorTable::deleteMemoryPool( );
     SgAsmCilClassLayoutTable::deleteMemoryPool( );
     SgAsmCilConstantTable::deleteMemoryPool( );
     SgAsmCilCustomAttributeTable::deleteMemoryPool( );
     SgAsmCilDeclSecurityTable::deleteMemoryPool( );
     SgAsmCilEventTable::deleteMemoryPool( );
     SgAsmCilEventMapTable::deleteMemoryPool( );
     SgAsmCilExportedTypeTable::deleteMemoryPool( );
     SgAsmCilFieldTable::deleteMemoryPool( );
     SgAsmCilFieldLayoutTable::deleteMemoryPool( );
     SgAsmCilFieldMarshalTable::deleteMemoryPool( );
     SgAsmCilFieldRVATable::deleteMemoryPool( );
     SgAsmCilFileTable::deleteMemoryPool( );
     SgAsmCilGenericParamTable::deleteMemoryPool( );
     SgAsmCilGenericParamConstraintTable::deleteMemoryPool( );
     SgAsmCilImplMapTable::deleteMemoryPool( );
     SgAsmCilInterfaceImplTable::deleteMemoryPool( );
     SgAsmCilManifestResourceTable::deleteMemoryPool( );
     SgAsmCilMemberRefTable::deleteMemoryPool( );
     SgAsmCilMethodDefTable::deleteMemoryPool( );
     SgAsmCilMethodImplTable::deleteMemoryPool( );
     SgAsmCilMethodSemanticsTable::deleteMemoryPool( );
     SgAsmCilMethodSpecTable::deleteMemoryPool( );
     SgAsmCilModuleTable::deleteMemoryPool( );
     SgAsmCilModuleRefTable::deleteMemoryPool( );
     SgAsmCilNestedClassTable::deleteMemoryPool( );
     SgAsmCilParamTable::deleteMemoryPool( );
     SgAsmCilPropertyTable::deleteMemoryPool( );
     SgAsmCilPropertyMapTable::deleteMemoryPool( );
     SgAsmCilStandAloneSigTable::deleteMemoryPool( );
     SgAsmCilTypeDefTable::deleteMemoryPool( );
     SgAsmCilTypeRefTable::deleteMemoryPool( );
     SgAsmCilTypeSpecTable::deleteMemoryPool( );
     SgJvmComposite::deleteMemoryPool( );
     SgFortranContinueStmt::deleteMemoryPool( );
     SgAsmJvmStackMapTable::deleteMemoryPool( );
     SgAsmJvmStackMapFrame::deleteMemoryPool( );
     SgAsmJvmStackMapVerificationType::deleteMemoryPool( );
     SgAsmJvmBootstrapMethod::deleteMemoryPool( );
     SgAsmJvmBootstrapMethods::deleteMemoryPool( );
     SgAsmJvmExceptions::deleteMemoryPool( );
     SgAsmJvmNestMembers::deleteMemoryPool( );
     SgAsmJvmNestHost::deleteMemoryPool( );
     SgJovialLabelDeclaration::deleteMemoryPool( );
     SgAsmJvmLocalVariableEntry::deleteMemoryPool( );
     SgAsmJvmLocalVariableTable::deleteMemoryPool( );
     SgAsmJvmLocalVariableTypeEntry::deleteMemoryPool( );
     SgAsmJvmLocalVariableTypeTable::deleteMemoryPool( );
     SgAsmUserInstruction::deleteMemoryPool( );
     SgAsmJvmMethodParameters::deleteMemoryPool( );
     SgAsmJvmMethodParametersEntry::deleteMemoryPool( );
     SgAsmVoidType::deleteMemoryPool( );
     SgAsmPointerType::deleteMemoryPool( );
     SgRangeType::deleteMemoryPool( );
     SgAsmCilExceptionData::deleteMemoryPool( );
     SgAsmCilMethodData::deleteMemoryPool( );
     SgTemplateVariableInstantiation::deleteMemoryPool( );
     SgReferenceExp::deleteMemoryPool( );
     SgTypeRefExp::deleteMemoryPool( );
     SgScopedRefExp::deleteMemoryPool( );
     SgScopedType::deleteMemoryPool( );
     SgTypeSymbol::deleteMemoryPool( );
     SgAsmJvmSynthetic::deleteMemoryPool( );
     SgAsmJvmDeprecated::deleteMemoryPool( );
     SgSignedCharVal::deleteMemoryPool( );
     SgAsmCilErrorHeap::deleteMemoryPool( );

/* #line 373 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

  SgNode::all_pools.clear();

   }

void
AST_FILE_IO :: deleteStaticData ( )
  {
     SgNode::p_globalFunctionTypeTable = NULL ;
     SgNode::p_globalTypeTable = NULL ;
     SgNode::p_globalMangledNameMap.clear();
     SgNode::p_shortMangledNameCache.clear();
     SgNode::p_globalQualifiedNameMapForMapsOfTypes.clear();
     SgSymbolTable::p_force_search_of_base_classes = (bool)(0);
     SgSymbolTable::p_name_qualification_mode = (bool)(0);
     Sg_File_Info::p_fileidtoname_map.clear();
     Sg_File_Info::p_nametofileid_map.clear();
     SgFile::p_skip_unparse_asm_commands = (bool)(0);
     SgFile::p_header_file_unparsing_optimization = (bool)(0);
     SgUnparse_Info::p_forceDefaultConstructorToTriggerError = (bool)(0);
     SgUnparse_Info::p_extern_C_with_braces = (bool)(0);
     SgUnparse_Info::p_previouslyUnparsedStatement = NULL ;
     SgUnparse_Info::p_previousStatementUnparsedFromTokenStream = (bool)(0);
     SgGraph::p_index_counter = (int)(0);
     SgGraphNode::p_index_counter = (int)(0);
     SgGraphEdge::p_index_counter = (int)(0);
     SgTypeUnknown::p_builtin_type = NULL ;
     SgTypeChar::p_builtin_type = NULL ;
     SgTypeSignedChar::p_builtin_type = NULL ;
     SgTypeUnsignedChar::p_builtin_type = NULL ;
     SgTypeShort::p_builtin_type = NULL ;
     SgTypeSignedShort::p_builtin_type = NULL ;
     SgTypeUnsignedShort::p_builtin_type = NULL ;
     SgTypeInt::p_builtin_type = NULL ;
     SgTypeSignedInt::p_builtin_type = NULL ;
     SgTypeUnsignedInt::p_builtin_type = NULL ;
     SgTypeLong::p_builtin_type = NULL ;
     SgTypeSignedLong::p_builtin_type = NULL ;
     SgTypeUnsignedLong::p_builtin_type = NULL ;
     SgTypeVoid::p_builtin_type = NULL ;
     SgTypeGlobalVoid::p_builtin_type = NULL ;
     SgTypeWchar::p_builtin_type = NULL ;
     SgTypeFloat::p_builtin_type = NULL ;
     SgTypeDouble::p_builtin_type = NULL ;
     SgTypeLongLong::p_builtin_type = NULL ;
     SgTypeSignedLongLong::p_builtin_type = NULL ;
     SgTypeUnsignedLongLong::p_builtin_type = NULL ;
     SgTypeSigned128bitInteger::p_builtin_type = NULL ;
     SgTypeUnsigned128bitInteger::p_builtin_type = NULL ;
     SgTypeFloat80::p_builtin_type = NULL ;
     SgTypeLongDouble::p_builtin_type = NULL ;
     SgTypeBool::p_builtin_type = NULL ;
     SgNamedType::p_builtin_type = NULL ;
     SgPartialFunctionModifierType::p_builtin_type = NULL ;
     SgTypeEllipse::p_builtin_type = NULL ;
     SgTypeDefault::p_builtin_type = NULL ;
     SgTypeCAFTeam::p_builtin_type = NULL ;
     SgTypeCrayPointer::p_builtin_type = NULL ;
     SgTypeLabel::p_builtin_type = NULL ;
     SgTypeNullptr::p_builtin_type = NULL ;
     SgTypeMatrix::p_builtin_type = NULL ;
     SgTypeTuple::p_builtin_type = NULL ;
     SgTypeChar16::p_builtin_type = NULL ;
     SgTypeChar32::p_builtin_type = NULL ;
     SgTypeFloat128::p_builtin_type = NULL ;
     SgAdaDiscreteType::p_builtin_type = NULL ;

/* #line 382 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

   /* JH (02/03/2006) since the memory pool contain no data anymore, we reset the 
      contents of the listOfMemoryPoolSizes to 0!
   */
     return;
   }

/* JH (01/03/2006) This mehtods steps through all memory pools and extends it to that amount it 
   will have after the AST was rebuilt. Thereby, we can set the pointers, even if there is no 
   valid data at the address they are pointing to. But it will be! 
*/
void
AST_FILE_IO :: extendMemoryPoolsForRebuildingAST (  )
   {
     assert ( freepointersOfCurrentAstAreSetToGlobalIndices == false );
     assert ( 0 < getTotalNumberOfNodesOfNewAst( ) );

     SgAccessModifier::extendMemoryPoolForFileIO( );
     SgActualArgumentExpression::extendMemoryPoolForFileIO( );
     SgAbsOp::extendMemoryPoolForFileIO( );
     SgAdaAccessType::extendMemoryPoolForFileIO( );
     SgAdaAcceptStmt::extendMemoryPoolForFileIO( );
     SgAdaDelayStmt::extendMemoryPoolForFileIO( );
     SgAdaEntryDecl::extendMemoryPoolForFileIO( );
     SgAdaExitStmt::extendMemoryPoolForFileIO( );
     SgAdaDiscreteType::extendMemoryPoolForFileIO( );
     SgAdaFloatVal::extendMemoryPoolForFileIO( );
     SgAdaLoopStmt::extendMemoryPoolForFileIO( );
     SgAdaPackageBody::extendMemoryPoolForFileIO( );
     SgAdaPackageBodyDecl::extendMemoryPoolForFileIO( );
     SgAdaPackageSpec::extendMemoryPoolForFileIO( );
     SgAdaPackageSpecDecl::extendMemoryPoolForFileIO( );
     SgAdaPackageSymbol::extendMemoryPoolForFileIO( );
     SgAdaRangeConstraint::extendMemoryPoolForFileIO( );
     SgAdaRenamingDecl::extendMemoryPoolForFileIO( );
     SgAdaSubtype::extendMemoryPoolForFileIO( );
     SgAdaTaskBody::extendMemoryPoolForFileIO( );
     SgAdaTaskBodyDecl::extendMemoryPoolForFileIO( );
     SgAdaTaskSpec::extendMemoryPoolForFileIO( );
     SgAdaTaskSpecDecl::extendMemoryPoolForFileIO( );
     SgAdaTaskSymbol::extendMemoryPoolForFileIO( );
     SgAdaTaskRefExp::extendMemoryPoolForFileIO( );
     SgAdaTaskType::extendMemoryPoolForFileIO( );
     SgAdaTaskTypeDecl::extendMemoryPoolForFileIO( );
     SgAdaTypeConstraint::extendMemoryPoolForFileIO( );
     SgAddOp::extendMemoryPoolForFileIO( );
     SgAddressOfOp::extendMemoryPoolForFileIO( );
     SgAggregateInitializer::extendMemoryPoolForFileIO( );
     SgAliasSymbol::extendMemoryPoolForFileIO( );
     SgAllocateStatement::extendMemoryPoolForFileIO( );
     SgAndAssignOp::extendMemoryPoolForFileIO( );
     SgAndOp::extendMemoryPoolForFileIO( );
     SgArithmeticIfStatement::extendMemoryPoolForFileIO( );
     SgArrayType::extendMemoryPoolForFileIO( );
     SgArrowExp::extendMemoryPoolForFileIO( );
     SgArrowStarOp::extendMemoryPoolForFileIO( );
     SgAsmBasicString::extendMemoryPoolForFileIO( );
     SgAsmBinaryAdd::extendMemoryPoolForFileIO( );
     SgAsmBinaryAsr::extendMemoryPoolForFileIO( );
     SgAsmBinaryDivide::extendMemoryPoolForFileIO( );
     SgAsmBinaryExpression::extendMemoryPoolForFileIO( );
     SgAsmBinaryLsl::extendMemoryPoolForFileIO( );
     SgAsmBinaryLsr::extendMemoryPoolForFileIO( );
     SgAsmBinaryMod::extendMemoryPoolForFileIO( );
     SgAsmBinaryMsl::extendMemoryPoolForFileIO( );
     SgAsmBinaryMultiply::extendMemoryPoolForFileIO( );
     SgAsmBinaryRor::extendMemoryPoolForFileIO( );
     SgAsmBinarySubtract::extendMemoryPoolForFileIO( );
     SgAsmBlock::extendMemoryPoolForFileIO( );
     SgAsmCoffStrtab::extendMemoryPoolForFileIO( );
     SgAsmCoffSymbol::extendMemoryPoolForFileIO( );
     SgAsmCoffSymbolList::extendMemoryPoolForFileIO( );
     SgAsmCoffSymbolTable::extendMemoryPoolForFileIO( );
     SgAsmCommonSubExpression::extendMemoryPoolForFileIO( );
     SgAsmControlFlagsExpression::extendMemoryPoolForFileIO( );
     SgAsmConstantExpression::extendMemoryPoolForFileIO( );
     SgAsmDOSExtendedHeader::extendMemoryPoolForFileIO( );
     SgAsmDOSFileHeader::extendMemoryPoolForFileIO( );
     SgAsmSynthesizedDataStructureDeclaration::extendMemoryPoolForFileIO( );
     SgAsmSynthesizedDeclaration::extendMemoryPoolForFileIO( );
     SgAsmDirectRegisterExpression::extendMemoryPoolForFileIO( );
     SgAsmDwarfAccessDeclaration::extendMemoryPoolForFileIO( );
     SgAsmDwarfArrayType::extendMemoryPoolForFileIO( );
     SgAsmDwarfBaseType::extendMemoryPoolForFileIO( );
     SgAsmDwarfCatchBlock::extendMemoryPoolForFileIO( );
     SgAsmDwarfClassTemplate::extendMemoryPoolForFileIO( );
     SgAsmDwarfClassType::extendMemoryPoolForFileIO( );
     SgAsmDwarfCommonBlock::extendMemoryPoolForFileIO( );
     SgAsmDwarfCommonInclusion::extendMemoryPoolForFileIO( );
     SgAsmDwarfCompilationUnit::extendMemoryPoolForFileIO( );
     SgAsmDwarfCompilationUnitList::extendMemoryPoolForFileIO( );
     SgAsmDwarfCondition::extendMemoryPoolForFileIO( );
     SgAsmDwarfConstType::extendMemoryPoolForFileIO( );
     SgAsmDwarfConstant::extendMemoryPoolForFileIO( );
     SgAsmDwarfConstruct::extendMemoryPoolForFileIO( );
     SgAsmDwarfConstructList::extendMemoryPoolForFileIO( );
     SgAsmDwarfDwarfProcedure::extendMemoryPoolForFileIO( );
     SgAsmDwarfEntryPoint::extendMemoryPoolForFileIO( );
     SgAsmDwarfEnumerationType::extendMemoryPoolForFileIO( );
     SgAsmDwarfEnumerator::extendMemoryPoolForFileIO( );
     SgAsmDwarfFileType::extendMemoryPoolForFileIO( );
     SgAsmDwarfFormalParameter::extendMemoryPoolForFileIO( );
     SgAsmDwarfFormatLabel::extendMemoryPoolForFileIO( );
     SgAsmDwarfFriend::extendMemoryPoolForFileIO( );
     SgAsmDwarfFunctionTemplate::extendMemoryPoolForFileIO( );
     SgAsmDwarfImportedDeclaration::extendMemoryPoolForFileIO( );
     SgAsmDwarfImportedModule::extendMemoryPoolForFileIO( );
     SgAsmDwarfImportedUnit::extendMemoryPoolForFileIO( );
     SgAsmDwarfInformation::extendMemoryPoolForFileIO( );
     SgAsmDwarfInheritance::extendMemoryPoolForFileIO( );
     SgAsmDwarfInlinedSubroutine::extendMemoryPoolForFileIO( );
     SgAsmDwarfInterfaceType::extendMemoryPoolForFileIO( );
     SgAsmDwarfLabel::extendMemoryPoolForFileIO( );
     SgAsmDwarfLexicalBlock::extendMemoryPoolForFileIO( );
     SgAsmDwarfLine::extendMemoryPoolForFileIO( );
     SgAsmDwarfLineList::extendMemoryPoolForFileIO( );
     SgAsmDwarfMacro::extendMemoryPoolForFileIO( );
     SgAsmDwarfMacroList::extendMemoryPoolForFileIO( );
     SgAsmDwarfMember::extendMemoryPoolForFileIO( );
     SgAsmDwarfModule::extendMemoryPoolForFileIO( );
     SgAsmDwarfMutableType::extendMemoryPoolForFileIO( );
     SgAsmDwarfNamelist::extendMemoryPoolForFileIO( );
     SgAsmDwarfNamelistItem::extendMemoryPoolForFileIO( );
     SgAsmDwarfNamespace::extendMemoryPoolForFileIO( );
     SgAsmDwarfPackedType::extendMemoryPoolForFileIO( );
     SgAsmDwarfPartialUnit::extendMemoryPoolForFileIO( );
     SgAsmDwarfPointerType::extendMemoryPoolForFileIO( );
     SgAsmDwarfPtrToMemberType::extendMemoryPoolForFileIO( );
     SgAsmDwarfReferenceType::extendMemoryPoolForFileIO( );
     SgAsmDwarfRestrictType::extendMemoryPoolForFileIO( );
     SgAsmDwarfSetType::extendMemoryPoolForFileIO( );
     SgAsmDwarfSharedType::extendMemoryPoolForFileIO( );
     SgAsmDwarfStringType::extendMemoryPoolForFileIO( );
     SgAsmDwarfStructureType::extendMemoryPoolForFileIO( );
     SgAsmDwarfSubprogram::extendMemoryPoolForFileIO( );
     SgAsmDwarfSubrangeType::extendMemoryPoolForFileIO( );
     SgAsmDwarfSubroutineType::extendMemoryPoolForFileIO( );
     SgAsmDwarfTemplateTypeParameter::extendMemoryPoolForFileIO( );
     SgAsmDwarfTemplateValueParameter::extendMemoryPoolForFileIO( );
     SgAsmDwarfThrownType::extendMemoryPoolForFileIO( );
     SgAsmDwarfTryBlock::extendMemoryPoolForFileIO( );
     SgAsmDwarfTypedef::extendMemoryPoolForFileIO( );
     SgAsmDwarfUnionType::extendMemoryPoolForFileIO( );
     SgAsmDwarfUnknownConstruct::extendMemoryPoolForFileIO( );
     SgAsmDwarfUnspecifiedParameters::extendMemoryPoolForFileIO( );
     SgAsmDwarfUnspecifiedType::extendMemoryPoolForFileIO( );
     SgAsmDwarfUpcRelaxedType::extendMemoryPoolForFileIO( );
     SgAsmDwarfUpcSharedType::extendMemoryPoolForFileIO( );
     SgAsmDwarfUpcStrictType::extendMemoryPoolForFileIO( );
     SgAsmDwarfVariable::extendMemoryPoolForFileIO( );
     SgAsmDwarfVariant::extendMemoryPoolForFileIO( );
     SgAsmDwarfVariantPart::extendMemoryPoolForFileIO( );
     SgAsmDwarfVolatileType::extendMemoryPoolForFileIO( );
     SgAsmDwarfWithStmt::extendMemoryPoolForFileIO( );
     SgAsmElfDynamicEntry::extendMemoryPoolForFileIO( );
     SgAsmElfDynamicEntryList::extendMemoryPoolForFileIO( );
     SgAsmElfDynamicSection::extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameEntryCI::extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameEntryCIList::extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameEntryFD::extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameEntryFDList::extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameSection::extendMemoryPoolForFileIO( );
     SgAsmElfFileHeader::extendMemoryPoolForFileIO( );
     SgAsmElfNoteEntry::extendMemoryPoolForFileIO( );
     SgAsmElfNoteEntryList::extendMemoryPoolForFileIO( );
     SgAsmElfNoteSection::extendMemoryPoolForFileIO( );
     SgAsmElfRelocEntry::extendMemoryPoolForFileIO( );
     SgAsmElfRelocEntryList::extendMemoryPoolForFileIO( );
     SgAsmElfRelocSection::extendMemoryPoolForFileIO( );
     SgAsmElfSection::extendMemoryPoolForFileIO( );
     SgAsmElfSectionTable::extendMemoryPoolForFileIO( );
     SgAsmElfSectionTableEntry::extendMemoryPoolForFileIO( );
     SgAsmElfSegmentTable::extendMemoryPoolForFileIO( );
     SgAsmElfSegmentTableEntry::extendMemoryPoolForFileIO( );
     SgAsmElfSegmentTableEntryList::extendMemoryPoolForFileIO( );
     SgAsmElfStringSection::extendMemoryPoolForFileIO( );
     SgAsmElfStrtab::extendMemoryPoolForFileIO( );
     SgAsmElfSymbol::extendMemoryPoolForFileIO( );
     SgAsmElfSymbolList::extendMemoryPoolForFileIO( );
     SgAsmElfSymbolSection::extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedAux::extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedAuxList::extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedEntry::extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedEntryList::extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedSection::extendMemoryPoolForFileIO( );
     SgAsmElfSymverEntry::extendMemoryPoolForFileIO( );
     SgAsmElfSymverEntryList::extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededAux::extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededAuxList::extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededEntry::extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededEntryList::extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededSection::extendMemoryPoolForFileIO( );
     SgAsmElfSymverSection::extendMemoryPoolForFileIO( );
     SgAsmExecutableFileFormat::extendMemoryPoolForFileIO( );
     SgAsmExprListExp::extendMemoryPoolForFileIO( );
     SgAsmExpression::extendMemoryPoolForFileIO( );
     SgAsmSynthesizedFieldDeclaration::extendMemoryPoolForFileIO( );
     SgAsmFloatType::extendMemoryPoolForFileIO( );
     SgAsmFloatValueExpression::extendMemoryPoolForFileIO( );
     SgAsmFunction::extendMemoryPoolForFileIO( );
     SgAsmGenericDLL::extendMemoryPoolForFileIO( );
     SgAsmGenericDLLList::extendMemoryPoolForFileIO( );
     SgAsmGenericFile::extendMemoryPoolForFileIO( );
     SgAsmGenericFileList::extendMemoryPoolForFileIO( );
     SgAsmGenericFormat::extendMemoryPoolForFileIO( );
     SgAsmGenericHeader::extendMemoryPoolForFileIO( );
     SgAsmGenericHeaderList::extendMemoryPoolForFileIO( );
     SgAsmGenericSection::extendMemoryPoolForFileIO( );
     SgAsmGenericSectionList::extendMemoryPoolForFileIO( );
     SgAsmGenericString::extendMemoryPoolForFileIO( );
     SgAsmGenericStrtab::extendMemoryPoolForFileIO( );
     SgAsmGenericSymbol::extendMemoryPoolForFileIO( );
     SgAsmGenericSymbolList::extendMemoryPoolForFileIO( );
     SgAsmIndirectRegisterExpression::extendMemoryPoolForFileIO( );
     SgAsmInstruction::extendMemoryPoolForFileIO( );
     SgAsmIntegerValueExpression::extendMemoryPoolForFileIO( );
     SgAsmIntegerType::extendMemoryPoolForFileIO( );
     SgAsmInterpretation::extendMemoryPoolForFileIO( );
     SgAsmInterpretationList::extendMemoryPoolForFileIO( );
     SgAsmJvmAttribute::extendMemoryPoolForFileIO( );
     SgAsmJvmCodeAttribute::extendMemoryPoolForFileIO( );
     SgAsmJvmMethod::extendMemoryPoolForFileIO( );
     SgAsmJvmConstantPool::extendMemoryPoolForFileIO( );
     SgAsmJvmConstantPoolEntry::extendMemoryPoolForFileIO( );
     SgAsmJvmConstantValue::extendMemoryPoolForFileIO( );
     SgAsmJvmInstruction::extendMemoryPoolForFileIO( );
     SgAsmJvmFileHeader::extendMemoryPoolForFileIO( );
     SgAsmJvmNode::extendMemoryPoolForFileIO( );
     SgAsmJvmSignature::extendMemoryPoolForFileIO( );
     SgAsmJvmSourceFile::extendMemoryPoolForFileIO( );
     SgAsmLEEntryPoint::extendMemoryPoolForFileIO( );
     SgAsmLEEntryTable::extendMemoryPoolForFileIO( );
     SgAsmLEFileHeader::extendMemoryPoolForFileIO( );
     SgAsmLENameTable::extendMemoryPoolForFileIO( );
     SgAsmLEPageTable::extendMemoryPoolForFileIO( );
     SgAsmLEPageTableEntry::extendMemoryPoolForFileIO( );
     SgAsmLERelocTable::extendMemoryPoolForFileIO( );
     SgAsmLESection::extendMemoryPoolForFileIO( );
     SgAsmLESectionTable::extendMemoryPoolForFileIO( );
     SgAsmLESectionTableEntry::extendMemoryPoolForFileIO( );
     SgAsmM68kInstruction::extendMemoryPoolForFileIO( );
     SgAsmMemoryReferenceExpression::extendMemoryPoolForFileIO( );
     SgAsmMipsInstruction::extendMemoryPoolForFileIO( );
     SgAsmNEEntryPoint::extendMemoryPoolForFileIO( );
     SgAsmNEEntryTable::extendMemoryPoolForFileIO( );
     SgAsmNEFileHeader::extendMemoryPoolForFileIO( );
     SgAsmNEModuleTable::extendMemoryPoolForFileIO( );
     SgAsmNENameTable::extendMemoryPoolForFileIO( );
     SgAsmNERelocEntry::extendMemoryPoolForFileIO( );
     SgAsmNERelocTable::extendMemoryPoolForFileIO( );
     SgAsmNESection::extendMemoryPoolForFileIO( );
     SgAsmNESectionTable::extendMemoryPoolForFileIO( );
     SgAsmNESectionTableEntry::extendMemoryPoolForFileIO( );
     SgAsmNEStringTable::extendMemoryPoolForFileIO( );
     SgAsmNode::extendMemoryPoolForFileIO( );
     SgAsmOp::extendMemoryPoolForFileIO( );
     SgAsmOperandList::extendMemoryPoolForFileIO( );
     SgAsmPEExportDirectory::extendMemoryPoolForFileIO( );
     SgAsmPEExportEntry::extendMemoryPoolForFileIO( );
     SgAsmPEExportEntryList::extendMemoryPoolForFileIO( );
     SgAsmPEExportSection::extendMemoryPoolForFileIO( );
     SgAsmPEFileHeader::extendMemoryPoolForFileIO( );
     SgAsmPEImportDirectory::extendMemoryPoolForFileIO( );
     SgAsmPEImportDirectoryList::extendMemoryPoolForFileIO( );
     SgAsmPEImportItem::extendMemoryPoolForFileIO( );
     SgAsmPEImportItemList::extendMemoryPoolForFileIO( );
     SgAsmPEImportSection::extendMemoryPoolForFileIO( );
     SgAsmPERVASizePair::extendMemoryPoolForFileIO( );
     SgAsmPERVASizePairList::extendMemoryPoolForFileIO( );
     SgAsmPESection::extendMemoryPoolForFileIO( );
     SgAsmPESectionTable::extendMemoryPoolForFileIO( );
     SgAsmPESectionTableEntry::extendMemoryPoolForFileIO( );
     SgAsmPEStringSection::extendMemoryPoolForFileIO( );
     SgAsmPowerpcInstruction::extendMemoryPoolForFileIO( );
     SgAsmRegisterNames::extendMemoryPoolForFileIO( );
     SgAsmRegisterReferenceExpression::extendMemoryPoolForFileIO( );
     SgAsmRiscOperation::extendMemoryPoolForFileIO( );
     SgAsmScalarType::extendMemoryPoolForFileIO( );
     SgAsmStatement::extendMemoryPoolForFileIO( );
     SgAsmStaticData::extendMemoryPoolForFileIO( );
     SgAsmStmt::extendMemoryPoolForFileIO( );
     SgAsmStoredString::extendMemoryPoolForFileIO( );
     SgAsmStringStorage::extendMemoryPoolForFileIO( );
     SgAsmType::extendMemoryPoolForFileIO( );
     SgAsmUnaryExpression::extendMemoryPoolForFileIO( );
     SgAsmUnaryMinus::extendMemoryPoolForFileIO( );
     SgAsmUnaryPlus::extendMemoryPoolForFileIO( );
     SgAsmUnaryRrx::extendMemoryPoolForFileIO( );
     SgAsmUnarySignedExtend::extendMemoryPoolForFileIO( );
     SgAsmUnaryUnsignedExtend::extendMemoryPoolForFileIO( );
     SgAsmUnaryTruncate::extendMemoryPoolForFileIO( );
     SgAsmValueExpression::extendMemoryPoolForFileIO( );
     SgAsmVectorType::extendMemoryPoolForFileIO( );
     SgAsmX86Instruction::extendMemoryPoolForFileIO( );
     SgAsmBinaryAddressSymbol::extendMemoryPoolForFileIO( );
     SgAsmBinaryDataSymbol::extendMemoryPoolForFileIO( );
     SgAssertStmt::extendMemoryPoolForFileIO( );
     SgAssignInitializer::extendMemoryPoolForFileIO( );
     SgAssignOp::extendMemoryPoolForFileIO( );
     SgAssignStatement::extendMemoryPoolForFileIO( );
     SgAssignedGotoStatement::extendMemoryPoolForFileIO( );
     SgAssociateStatement::extendMemoryPoolForFileIO( );
     SgAsteriskShapeExp::extendMemoryPoolForFileIO( );
     SgAtOp::extendMemoryPoolForFileIO( );
     SgAttribute::extendMemoryPoolForFileIO( );
     SgAttributeSpecificationStatement::extendMemoryPoolForFileIO( );
     SgAutoType::extendMemoryPoolForFileIO( );
     SgAwaitExpression::extendMemoryPoolForFileIO( );
     SgBackspaceStatement::extendMemoryPoolForFileIO( );
     SgBaseClass::extendMemoryPoolForFileIO( );
     SgExpBaseClass::extendMemoryPoolForFileIO( );
     SgBaseClassModifier::extendMemoryPoolForFileIO( );
     SgBasicBlock::extendMemoryPoolForFileIO( );
     SgBidirectionalGraph::extendMemoryPoolForFileIO( );
     SgBinaryComposite::extendMemoryPoolForFileIO( );
     SgBinaryOp::extendMemoryPoolForFileIO( );
     SgBitAndOp::extendMemoryPoolForFileIO( );
     SgBitAttribute::extendMemoryPoolForFileIO( );
     SgBitComplementOp::extendMemoryPoolForFileIO( );
     SgBitEqvOp::extendMemoryPoolForFileIO( );
     SgBitOrOp::extendMemoryPoolForFileIO( );
     SgBitXorOp::extendMemoryPoolForFileIO( );
     SgBlockDataStatement::extendMemoryPoolForFileIO( );
     SgBoolValExp::extendMemoryPoolForFileIO( );
     SgBreakStmt::extendMemoryPoolForFileIO( );
     SgBracedInitializer::extendMemoryPoolForFileIO( );
     SgC_PreprocessorDirectiveStatement::extendMemoryPoolForFileIO( );
     SgCaseOptionStmt::extendMemoryPoolForFileIO( );
     SgCastExp::extendMemoryPoolForFileIO( );
     SgCatchOptionStmt::extendMemoryPoolForFileIO( );
     SgCatchStatementSeq::extendMemoryPoolForFileIO( );
     SgCharVal::extendMemoryPoolForFileIO( );
     SgChar16Val::extendMemoryPoolForFileIO( );
     SgChar32Val::extendMemoryPoolForFileIO( );
     SgChooseExpression::extendMemoryPoolForFileIO( );
     SgClassDecl_attr::extendMemoryPoolForFileIO( );
     SgClassDeclaration::extendMemoryPoolForFileIO( );
     SgClassDefinition::extendMemoryPoolForFileIO( );
     SgClassNameRefExp::extendMemoryPoolForFileIO( );
     SgClassSymbol::extendMemoryPoolForFileIO( );
     SgClassType::extendMemoryPoolForFileIO( );
     SgClinkageDeclarationStatement::extendMemoryPoolForFileIO( );
     SgClinkageEndStatement::extendMemoryPoolForFileIO( );
     SgClinkageStartStatement::extendMemoryPoolForFileIO( );
     SgCloseStatement::extendMemoryPoolForFileIO( );
     SgColonShapeExp::extendMemoryPoolForFileIO( );
     SgCommaOpExp::extendMemoryPoolForFileIO( );
     SgCommonBlock::extendMemoryPoolForFileIO( );
     SgCommonBlockObject::extendMemoryPoolForFileIO( );
     SgCommonSymbol::extendMemoryPoolForFileIO( );
     SgComplexVal::extendMemoryPoolForFileIO( );
     SgComprehension::extendMemoryPoolForFileIO( );
     SgCompoundAssignOp::extendMemoryPoolForFileIO( );
     SgCompoundInitializer::extendMemoryPoolForFileIO( );
     SgCompoundLiteralExp::extendMemoryPoolForFileIO( );
     SgComputedGotoStatement::extendMemoryPoolForFileIO( );
     SgConcatenationOp::extendMemoryPoolForFileIO( );
     SgConditionalExp::extendMemoryPoolForFileIO( );
     SgConjugateOp::extendMemoryPoolForFileIO( );
     SgConstVolatileModifier::extendMemoryPoolForFileIO( );
     SgConstructorInitializer::extendMemoryPoolForFileIO( );
     SgContainsStatement::extendMemoryPoolForFileIO( );
     SgContinueStmt::extendMemoryPoolForFileIO( );
     SgCtorInitializerList::extendMemoryPoolForFileIO( );
     SgDataStatementGroup::extendMemoryPoolForFileIO( );
     SgDataStatementObject::extendMemoryPoolForFileIO( );
     SgDataStatementValue::extendMemoryPoolForFileIO( );
     SgDeadIfDirectiveStatement::extendMemoryPoolForFileIO( );
     SgDeallocateStatement::extendMemoryPoolForFileIO( );
     SgDeclarationModifier::extendMemoryPoolForFileIO( );
     SgDeclarationScope::extendMemoryPoolForFileIO( );
     SgDeclarationStatement::extendMemoryPoolForFileIO( );
     SgDeclType::extendMemoryPoolForFileIO( );
     SgDefaultOptionStmt::extendMemoryPoolForFileIO( );
     SgDefaultSymbol::extendMemoryPoolForFileIO( );
     SgDefineDirectiveStatement::extendMemoryPoolForFileIO( );
     SgDeleteExp::extendMemoryPoolForFileIO( );
     SgDerivedTypeStatement::extendMemoryPoolForFileIO( );
     SgDesignatedInitializer::extendMemoryPoolForFileIO( );
     SgDictionaryComprehension::extendMemoryPoolForFileIO( );
     SgDictionaryExp::extendMemoryPoolForFileIO( );
     SgDimensionObject::extendMemoryPoolForFileIO( );
     SgDirectedGraphEdge::extendMemoryPoolForFileIO( );
     SgDirectory::extendMemoryPoolForFileIO( );
     SgDirectoryList::extendMemoryPoolForFileIO( );
     SgDivAssignOp::extendMemoryPoolForFileIO( );
     SgDivideOp::extendMemoryPoolForFileIO( );
     SgDoWhileStmt::extendMemoryPoolForFileIO( );
     SgDotExp::extendMemoryPoolForFileIO( );
     SgDotStarOp::extendMemoryPoolForFileIO( );
     SgDoubleVal::extendMemoryPoolForFileIO( );
     SgElaboratedTypeModifier::extendMemoryPoolForFileIO( );
     SgElementwiseOp::extendMemoryPoolForFileIO( );
     SgElementwiseAddOp::extendMemoryPoolForFileIO( );
     SgElementwiseDivideOp::extendMemoryPoolForFileIO( );
     SgElementwiseLeftDivideOp::extendMemoryPoolForFileIO( );
     SgElementwiseMultiplyOp::extendMemoryPoolForFileIO( );
     SgElementwisePowerOp::extendMemoryPoolForFileIO( );
     SgElementwiseSubtractOp::extendMemoryPoolForFileIO( );
     SgElseDirectiveStatement::extendMemoryPoolForFileIO( );
     SgElseWhereStatement::extendMemoryPoolForFileIO( );
     SgElseifDirectiveStatement::extendMemoryPoolForFileIO( );
     SgEmptyDeclaration::extendMemoryPoolForFileIO( );
     SgEmptyDirectiveStatement::extendMemoryPoolForFileIO( );
     SgEndfileStatement::extendMemoryPoolForFileIO( );
     SgEndifDirectiveStatement::extendMemoryPoolForFileIO( );
     SgEntryStatement::extendMemoryPoolForFileIO( );
     SgEnumDeclaration::extendMemoryPoolForFileIO( );
     SgEnumFieldSymbol::extendMemoryPoolForFileIO( );
     SgEnumSymbol::extendMemoryPoolForFileIO( );
     SgEnumType::extendMemoryPoolForFileIO( );
     SgEnumVal::extendMemoryPoolForFileIO( );
     SgEqualityOp::extendMemoryPoolForFileIO( );
     SgEquivalenceStatement::extendMemoryPoolForFileIO( );
     SgErrorDirectiveStatement::extendMemoryPoolForFileIO( );
     SgExecStatement::extendMemoryPoolForFileIO( );
     SgExponentiationOp::extendMemoryPoolForFileIO( );
     SgExponentiationAssignOp::extendMemoryPoolForFileIO( );
     SgExprListExp::extendMemoryPoolForFileIO( );
     SgExprStatement::extendMemoryPoolForFileIO( );
     SgExpression::extendMemoryPoolForFileIO( );
     SgExpressionRoot::extendMemoryPoolForFileIO( );
     SgFile::extendMemoryPoolForFileIO( );
     SgFileList::extendMemoryPoolForFileIO( );
     SgFloatVal::extendMemoryPoolForFileIO( );
     SgFloat128Val::extendMemoryPoolForFileIO( );
     SgFloat80Val::extendMemoryPoolForFileIO( );
     SgFoldExpression::extendMemoryPoolForFileIO( );
     SgFlushStatement::extendMemoryPoolForFileIO( );
     SgForAllStatement::extendMemoryPoolForFileIO( );
     SgForInitStatement::extendMemoryPoolForFileIO( );
     SgForStatement::extendMemoryPoolForFileIO( );
     SgFormatItem::extendMemoryPoolForFileIO( );
     SgFormatItemList::extendMemoryPoolForFileIO( );
     SgFormatStatement::extendMemoryPoolForFileIO( );
     SgFortranDo::extendMemoryPoolForFileIO( );
     SgFortranIncludeLine::extendMemoryPoolForFileIO( );
     SgFortranNonblockedDo::extendMemoryPoolForFileIO( );
     SgFuncDecl_attr::extendMemoryPoolForFileIO( );
     SgFunctionCallExp::extendMemoryPoolForFileIO( );
     SgFunctionDeclaration::extendMemoryPoolForFileIO( );
     SgFunctionDefinition::extendMemoryPoolForFileIO( );
     SgFunctionParameterScope::extendMemoryPoolForFileIO( );
     SgFunctionModifier::extendMemoryPoolForFileIO( );
     SgFunctionParameterList::extendMemoryPoolForFileIO( );
     SgFunctionParameterRefExp::extendMemoryPoolForFileIO( );
     SgFunctionParameterTypeList::extendMemoryPoolForFileIO( );
     SgFunctionRefExp::extendMemoryPoolForFileIO( );
     SgFunctionSymbol::extendMemoryPoolForFileIO( );
     SgFunctionType::extendMemoryPoolForFileIO( );
     SgFunctionTypeSymbol::extendMemoryPoolForFileIO( );
     SgFunctionTypeTable::extendMemoryPoolForFileIO( );
     SgTypeTable::extendMemoryPoolForFileIO( );
     SgGlobal::extendMemoryPoolForFileIO( );
     SgGotoStatement::extendMemoryPoolForFileIO( );
     SgGraph::extendMemoryPoolForFileIO( );
     SgGraphEdge::extendMemoryPoolForFileIO( );
     SgGraphEdgeList::extendMemoryPoolForFileIO( );
     SgGraphNode::extendMemoryPoolForFileIO( );
     SgGraphNodeList::extendMemoryPoolForFileIO( );
     SgGreaterOrEqualOp::extendMemoryPoolForFileIO( );
     SgGreaterThanOp::extendMemoryPoolForFileIO( );
     SgIOItemExpression::extendMemoryPoolForFileIO( );
     SgIOStatement::extendMemoryPoolForFileIO( );
     SgIdentDirectiveStatement::extendMemoryPoolForFileIO( );
     SgIfDirectiveStatement::extendMemoryPoolForFileIO( );
     SgIfStmt::extendMemoryPoolForFileIO( );
     SgIfdefDirectiveStatement::extendMemoryPoolForFileIO( );
     SgIfndefDirectiveStatement::extendMemoryPoolForFileIO( );
     SgImageControlStatement::extendMemoryPoolForFileIO( );
     SgImagPartOp::extendMemoryPoolForFileIO( );
     SgImplicitStatement::extendMemoryPoolForFileIO( );
     SgImpliedDo::extendMemoryPoolForFileIO( );
     SgImportStatement::extendMemoryPoolForFileIO( );
     SgIncidenceDirectedGraph::extendMemoryPoolForFileIO( );
     SgIncidenceUndirectedGraph::extendMemoryPoolForFileIO( );
     SgIncludeDirectiveStatement::extendMemoryPoolForFileIO( );
     SgIncludeFile::extendMemoryPoolForFileIO( );
     SgIncludeNextDirectiveStatement::extendMemoryPoolForFileIO( );
     SgInitializedName::extendMemoryPoolForFileIO( );
     SgInitializer::extendMemoryPoolForFileIO( );
     SgInquireStatement::extendMemoryPoolForFileIO( );
     SgIntKeyedBidirectionalGraph::extendMemoryPoolForFileIO( );
     SgIntVal::extendMemoryPoolForFileIO( );
     SgIntegerDivideOp::extendMemoryPoolForFileIO( );
     SgIntegerDivideAssignOp::extendMemoryPoolForFileIO( );
     SgInterfaceBody::extendMemoryPoolForFileIO( );
     SgHeaderFileBody::extendMemoryPoolForFileIO( );
     SgHeaderFileReport::extendMemoryPoolForFileIO( );
     SgInterfaceStatement::extendMemoryPoolForFileIO( );
     SgInterfaceSymbol::extendMemoryPoolForFileIO( );
     SgIntrinsicSymbol::extendMemoryPoolForFileIO( );
     SgIsOp::extendMemoryPoolForFileIO( );
     SgIsNotOp::extendMemoryPoolForFileIO( );
     SgIorAssignOp::extendMemoryPoolForFileIO( );
     SgJovialBitType::extendMemoryPoolForFileIO( );
     SgJovialBitVal::extendMemoryPoolForFileIO( );
     SgJovialTableType::extendMemoryPoolForFileIO( );
     SgJovialCompoolStatement::extendMemoryPoolForFileIO( );
     SgJovialForThenStatement::extendMemoryPoolForFileIO( );
     SgJovialDefineDeclaration::extendMemoryPoolForFileIO( );
     SgJovialDirectiveStatement::extendMemoryPoolForFileIO( );
     SgJovialOverlayDeclaration::extendMemoryPoolForFileIO( );
     SgJovialPresetPositionExp::extendMemoryPoolForFileIO( );
     SgJovialTablePresetExp::extendMemoryPoolForFileIO( );
     SgJovialTableStatement::extendMemoryPoolForFileIO( );
     SgKeyDatumPair::extendMemoryPoolForFileIO( );
     SgCudaKernelExecConfig::extendMemoryPoolForFileIO( );
     SgCudaKernelCallExp::extendMemoryPoolForFileIO( );
     SgLabelRefExp::extendMemoryPoolForFileIO( );
     SgLabelStatement::extendMemoryPoolForFileIO( );
     SgJavaLabelStatement::extendMemoryPoolForFileIO( );
     SgLabelSymbol::extendMemoryPoolForFileIO( );
     SgJavaLabelSymbol::extendMemoryPoolForFileIO( );
     SgLambdaCapture::extendMemoryPoolForFileIO( );
     SgLambdaCaptureList::extendMemoryPoolForFileIO( );
     SgLambdaExp::extendMemoryPoolForFileIO( );
     SgLambdaRefExp::extendMemoryPoolForFileIO( );
     SgLeftDivideOp::extendMemoryPoolForFileIO( );
     SgLessOrEqualOp::extendMemoryPoolForFileIO( );
     SgLessThanOp::extendMemoryPoolForFileIO( );
     SgLineDirectiveStatement::extendMemoryPoolForFileIO( );
     SgLinemarkerDirectiveStatement::extendMemoryPoolForFileIO( );
     SgLinkageModifier::extendMemoryPoolForFileIO( );
     SgListComprehension::extendMemoryPoolForFileIO( );
     SgListExp::extendMemoryPoolForFileIO( );
     SgLocatedNode::extendMemoryPoolForFileIO( );
     SgLocatedNodeSupport::extendMemoryPoolForFileIO( );
     SgLongDoubleVal::extendMemoryPoolForFileIO( );
     SgLongIntVal::extendMemoryPoolForFileIO( );
     SgLongLongIntVal::extendMemoryPoolForFileIO( );
     SgLshiftAssignOp::extendMemoryPoolForFileIO( );
     SgLshiftOp::extendMemoryPoolForFileIO( );
     SgMagicColonExp::extendMemoryPoolForFileIO( );
     SgMatrixExp::extendMemoryPoolForFileIO( );
     SgMatrixTransposeOp::extendMemoryPoolForFileIO( );
     SgMatlabForStatement::extendMemoryPoolForFileIO( );
     SgMemberFunctionDeclaration::extendMemoryPoolForFileIO( );
     SgMemberFunctionRefExp::extendMemoryPoolForFileIO( );
     SgMemberFunctionSymbol::extendMemoryPoolForFileIO( );
     SgMemberFunctionType::extendMemoryPoolForFileIO( );
     SgMembershipOp::extendMemoryPoolForFileIO( );
     SgMicrosoftAttributeDeclaration::extendMemoryPoolForFileIO( );
     SgMinusAssignOp::extendMemoryPoolForFileIO( );
     SgMinusMinusOp::extendMemoryPoolForFileIO( );
     SgMinusOp::extendMemoryPoolForFileIO( );
     SgModAssignOp::extendMemoryPoolForFileIO( );
     SgModOp::extendMemoryPoolForFileIO( );
     SgModifier::extendMemoryPoolForFileIO( );
     SgModifierNodes::extendMemoryPoolForFileIO( );
     SgModifierType::extendMemoryPoolForFileIO( );
     SgModuleStatement::extendMemoryPoolForFileIO( );
     SgModuleSymbol::extendMemoryPoolForFileIO( );
     SgMultAssignOp::extendMemoryPoolForFileIO( );
     SgMultiplyOp::extendMemoryPoolForFileIO( );
     SgName::extendMemoryPoolForFileIO( );
     SgNameGroup::extendMemoryPoolForFileIO( );
     SgNamedType::extendMemoryPoolForFileIO( );
     SgNamelistStatement::extendMemoryPoolForFileIO( );
     SgNamespaceAliasDeclarationStatement::extendMemoryPoolForFileIO( );
     SgNamespaceDeclarationStatement::extendMemoryPoolForFileIO( );
     SgNamespaceDefinitionStatement::extendMemoryPoolForFileIO( );
     SgNamespaceSymbol::extendMemoryPoolForFileIO( );
     SgNaryOp::extendMemoryPoolForFileIO( );
     SgNaryBooleanOp::extendMemoryPoolForFileIO( );
     SgNaryComparisonOp::extendMemoryPoolForFileIO( );
     SgNewExp::extendMemoryPoolForFileIO( );
     SgNode::extendMemoryPoolForFileIO( );
     SgNoexceptOp::extendMemoryPoolForFileIO( );
     SgNotEqualOp::extendMemoryPoolForFileIO( );
     SgNotOp::extendMemoryPoolForFileIO( );
     SgNonMembershipOp::extendMemoryPoolForFileIO( );
     SgNonrealDecl::extendMemoryPoolForFileIO( );
     SgNonrealRefExp::extendMemoryPoolForFileIO( );
     SgNonrealSymbol::extendMemoryPoolForFileIO( );
     SgNonrealType::extendMemoryPoolForFileIO( );
     SgNonrealBaseClass::extendMemoryPoolForFileIO( );
     SgNullExpression::extendMemoryPoolForFileIO( );
     SgNullptrValExp::extendMemoryPoolForFileIO( );
     SgNullStatement::extendMemoryPoolForFileIO( );
     SgNullifyStatement::extendMemoryPoolForFileIO( );
     SgOmpAtomicStatement::extendMemoryPoolForFileIO( );
     SgOmpBarrierStatement::extendMemoryPoolForFileIO( );
     SgOmpCriticalStatement::extendMemoryPoolForFileIO( );
     SgOmpClauseBodyStatement::extendMemoryPoolForFileIO( );
     SgOmpBodyStatement::extendMemoryPoolForFileIO( );
     SgOmpDoStatement::extendMemoryPoolForFileIO( );
     SgOmpFlushStatement::extendMemoryPoolForFileIO( );
     SgOmpDeclareSimdStatement::extendMemoryPoolForFileIO( );
     SgOmpForStatement::extendMemoryPoolForFileIO( );
     SgOmpForSimdStatement::extendMemoryPoolForFileIO( );
     SgOmpMasterStatement::extendMemoryPoolForFileIO( );
     SgOmpOrderedStatement::extendMemoryPoolForFileIO( );
     SgOmpParallelStatement::extendMemoryPoolForFileIO( );
     SgOmpSectionStatement::extendMemoryPoolForFileIO( );
     SgOmpSectionsStatement::extendMemoryPoolForFileIO( );
     SgOmpSingleStatement::extendMemoryPoolForFileIO( );
     SgOmpTaskStatement::extendMemoryPoolForFileIO( );
     SgOmpTaskwaitStatement::extendMemoryPoolForFileIO( );
     SgOmpThreadprivateStatement::extendMemoryPoolForFileIO( );
     SgOmpWorkshareStatement::extendMemoryPoolForFileIO( );
     SgOmpTargetStatement::extendMemoryPoolForFileIO( );
     SgOmpTargetDataStatement::extendMemoryPoolForFileIO( );
     SgOmpSimdStatement::extendMemoryPoolForFileIO( );
     SgOmpClause::extendMemoryPoolForFileIO( );
     SgOmpBeginClause::extendMemoryPoolForFileIO( );
     SgOmpCollapseClause::extendMemoryPoolForFileIO( );
     SgOmpCopyinClause::extendMemoryPoolForFileIO( );
     SgOmpCopyprivateClause::extendMemoryPoolForFileIO( );
     SgOmpDefaultClause::extendMemoryPoolForFileIO( );
     SgOmpEndClause::extendMemoryPoolForFileIO( );
     SgOmpExpressionClause::extendMemoryPoolForFileIO( );
     SgOmpFirstprivateClause::extendMemoryPoolForFileIO( );
     SgOmpIfClause::extendMemoryPoolForFileIO( );
     SgOmpFinalClause::extendMemoryPoolForFileIO( );
     SgOmpPriorityClause::extendMemoryPoolForFileIO( );
     SgOmpDeviceClause::extendMemoryPoolForFileIO( );
     SgOmpLastprivateClause::extendMemoryPoolForFileIO( );
     SgOmpNowaitClause::extendMemoryPoolForFileIO( );
     SgOmpNumThreadsClause::extendMemoryPoolForFileIO( );
     SgOmpOrderedClause::extendMemoryPoolForFileIO( );
     SgOmpPrivateClause::extendMemoryPoolForFileIO( );
     SgOmpReductionClause::extendMemoryPoolForFileIO( );
     SgOmpScheduleClause::extendMemoryPoolForFileIO( );
     SgOmpSharedClause::extendMemoryPoolForFileIO( );
     SgOmpUntiedClause::extendMemoryPoolForFileIO( );
     SgOmpMergeableClause::extendMemoryPoolForFileIO( );
     SgOmpVariablesClause::extendMemoryPoolForFileIO( );
     SgOmpMapClause::extendMemoryPoolForFileIO( );
     SgOmpSafelenClause::extendMemoryPoolForFileIO( );
     SgOmpSimdlenClause::extendMemoryPoolForFileIO( );
     SgOmpLinearClause::extendMemoryPoolForFileIO( );
     SgOmpUniformClause::extendMemoryPoolForFileIO( );
     SgOmpAlignedClause::extendMemoryPoolForFileIO( );
     SgOmpProcBindClause::extendMemoryPoolForFileIO( );
     SgOmpAtomicClause::extendMemoryPoolForFileIO( );
     SgOmpInbranchClause::extendMemoryPoolForFileIO( );
     SgOmpNotinbranchClause::extendMemoryPoolForFileIO( );
     SgOmpDependClause::extendMemoryPoolForFileIO( );
     SgOpenclAccessModeModifier::extendMemoryPoolForFileIO( );
     SgOpenStatement::extendMemoryPoolForFileIO( );
     SgOptions::extendMemoryPoolForFileIO( );
     SgOrOp::extendMemoryPoolForFileIO( );
     SgParameterStatement::extendMemoryPoolForFileIO( );
     SgPartialFunctionModifierType::extendMemoryPoolForFileIO( );
     SgPartialFunctionType::extendMemoryPoolForFileIO( );
     SgPassStatement::extendMemoryPoolForFileIO( );
     SgPlusAssignOp::extendMemoryPoolForFileIO( );
     SgPlusPlusOp::extendMemoryPoolForFileIO( );
     SgPntrArrRefExp::extendMemoryPoolForFileIO( );
     SgPointerAssignOp::extendMemoryPoolForFileIO( );
     SgPointerDerefExp::extendMemoryPoolForFileIO( );
     SgPointerMemberType::extendMemoryPoolForFileIO( );
     SgPointerType::extendMemoryPoolForFileIO( );
     SgPowerOp::extendMemoryPoolForFileIO( );
     SgPragma::extendMemoryPoolForFileIO( );
     SgPragmaDeclaration::extendMemoryPoolForFileIO( );
     SgPrintStatement::extendMemoryPoolForFileIO( );
     SgProcedureHeaderStatement::extendMemoryPoolForFileIO( );
     SgProgramHeaderStatement::extendMemoryPoolForFileIO( );
     SgProject::extendMemoryPoolForFileIO( );
     SgPseudoDestructorRefExp::extendMemoryPoolForFileIO( );
     SgPythonGlobalStmt::extendMemoryPoolForFileIO( );
     SgPythonPrintStmt::extendMemoryPoolForFileIO( );
     SgQualifiedName::extendMemoryPoolForFileIO( );
     SgQualifiedNameType::extendMemoryPoolForFileIO( );
     SgRangeExp::extendMemoryPoolForFileIO( );
     SgRangeBasedForStatement::extendMemoryPoolForFileIO( );
     SgReadStatement::extendMemoryPoolForFileIO( );
     SgRealPartOp::extendMemoryPoolForFileIO( );
     SgRefExp::extendMemoryPoolForFileIO( );
     SgReferenceType::extendMemoryPoolForFileIO( );
     SgRemOp::extendMemoryPoolForFileIO( );
     SgRenamePair::extendMemoryPoolForFileIO( );
     SgRenameSymbol::extendMemoryPoolForFileIO( );
     SgReplicationOp::extendMemoryPoolForFileIO( );
     SgReturnStmt::extendMemoryPoolForFileIO( );
     SgRewindStatement::extendMemoryPoolForFileIO( );
     SgRshiftAssignOp::extendMemoryPoolForFileIO( );
     SgRshiftOp::extendMemoryPoolForFileIO( );
     SgRvalueReferenceType::extendMemoryPoolForFileIO( );
     SgJavaUnsignedRshiftAssignOp::extendMemoryPoolForFileIO( );
     SgJavaUnsignedRshiftOp::extendMemoryPoolForFileIO( );
     SgScopeOp::extendMemoryPoolForFileIO( );
     SgScopeStatement::extendMemoryPoolForFileIO( );
     SgSequenceStatement::extendMemoryPoolForFileIO( );
     SgSetComprehension::extendMemoryPoolForFileIO( );
     SgShortVal::extendMemoryPoolForFileIO( );
     SgSizeOfOp::extendMemoryPoolForFileIO( );
     SgAlignOfOp::extendMemoryPoolForFileIO( );
     SgJavaInstanceOfOp::extendMemoryPoolForFileIO( );
     SgSourceFile::extendMemoryPoolForFileIO( );
     SgSpaceshipOp::extendMemoryPoolForFileIO( );
     SgSpawnStmt::extendMemoryPoolForFileIO( );
     SgSyncAllStatement::extendMemoryPoolForFileIO( );
     SgSyncImagesStatement::extendMemoryPoolForFileIO( );
     SgSyncMemoryStatement::extendMemoryPoolForFileIO( );
     SgSyncTeamStatement::extendMemoryPoolForFileIO( );
     SgLockStatement::extendMemoryPoolForFileIO( );
     SgUnlockStatement::extendMemoryPoolForFileIO( );
     SgJavaThrowStatement::extendMemoryPoolForFileIO( );
     SgJavaForEachStatement::extendMemoryPoolForFileIO( );
     SgJavaSynchronizedStatement::extendMemoryPoolForFileIO( );
     SgJavaParameterizedType::extendMemoryPoolForFileIO( );
     SgJavaWildcardType::extendMemoryPoolForFileIO( );
     SgProcessControlStatement::extendMemoryPoolForFileIO( );
     SgSpecialFunctionModifier::extendMemoryPoolForFileIO( );
     SgStatement::extendMemoryPoolForFileIO( );
     SgStaticAssertionDeclaration::extendMemoryPoolForFileIO( );
     SgStmtDeclarationStatement::extendMemoryPoolForFileIO( );
     SgStatementExpression::extendMemoryPoolForFileIO( );
     SgStatementFunctionStatement::extendMemoryPoolForFileIO( );
     SgStorageModifier::extendMemoryPoolForFileIO( );
     SgStringConversion::extendMemoryPoolForFileIO( );
     SgStringKeyedBidirectionalGraph::extendMemoryPoolForFileIO( );
     SgStringVal::extendMemoryPoolForFileIO( );
     SgStructureModifier::extendMemoryPoolForFileIO( );
     SgSubscriptExpression::extendMemoryPoolForFileIO( );
     SgSubtractOp::extendMemoryPoolForFileIO( );
     SgSupport::extendMemoryPoolForFileIO( );
     SgSwitchStatement::extendMemoryPoolForFileIO( );
     SgSymbol::extendMemoryPoolForFileIO( );
     SgSymbolTable::extendMemoryPoolForFileIO( );
     SgTemplateArgument::extendMemoryPoolForFileIO( );
     SgTemplateArgumentList::extendMemoryPoolForFileIO( );
     SgTemplateDeclaration::extendMemoryPoolForFileIO( );
     SgTemplateClassDeclaration::extendMemoryPoolForFileIO( );
     SgTemplateClassSymbol::extendMemoryPoolForFileIO( );
     SgTemplateFunctionDeclaration::extendMemoryPoolForFileIO( );
     SgTemplateFunctionRefExp::extendMemoryPoolForFileIO( );
     SgTemplateFunctionSymbol::extendMemoryPoolForFileIO( );
     SgTemplateMemberFunctionDeclaration::extendMemoryPoolForFileIO( );
     SgTemplateMemberFunctionRefExp::extendMemoryPoolForFileIO( );
     SgTemplateMemberFunctionSymbol::extendMemoryPoolForFileIO( );
     SgTemplateTypedefDeclaration::extendMemoryPoolForFileIO( );
     SgTemplateTypedefSymbol::extendMemoryPoolForFileIO( );
     SgTemplateVariableDeclaration::extendMemoryPoolForFileIO( );
     SgTemplateVariableSymbol::extendMemoryPoolForFileIO( );
     SgTemplateClassDefinition::extendMemoryPoolForFileIO( );
     SgTemplateFunctionDefinition::extendMemoryPoolForFileIO( );
     SgTemplateInstantiationDecl::extendMemoryPoolForFileIO( );
     SgTemplateInstantiationDefn::extendMemoryPoolForFileIO( );
     SgTemplateInstantiationDirectiveStatement::extendMemoryPoolForFileIO( );
     SgTemplateInstantiationFunctionDecl::extendMemoryPoolForFileIO( );
     SgTemplateInstantiationMemberFunctionDecl::extendMemoryPoolForFileIO( );
     SgTemplateInstantiationTypedefDeclaration::extendMemoryPoolForFileIO( );
     SgTemplateParameter::extendMemoryPoolForFileIO( );
     SgTemplateParameterVal::extendMemoryPoolForFileIO( );
     SgTemplateParameterList::extendMemoryPoolForFileIO( );
     SgTemplateSymbol::extendMemoryPoolForFileIO( );
     SgTemplateType::extendMemoryPoolForFileIO( );
     SgThisExp::extendMemoryPoolForFileIO( );
     SgTypeTraitBuiltinOperator::extendMemoryPoolForFileIO( );
     SgSuperExp::extendMemoryPoolForFileIO( );
     SgThrowOp::extendMemoryPoolForFileIO( );
     SgToken::extendMemoryPoolForFileIO( );
     SgTryStmt::extendMemoryPoolForFileIO( );
     SgTupleExp::extendMemoryPoolForFileIO( );
     SgType::extendMemoryPoolForFileIO( );
     SgTypeBool::extendMemoryPoolForFileIO( );
     SgTypeChar::extendMemoryPoolForFileIO( );
     SgTypeChar16::extendMemoryPoolForFileIO( );
     SgTypeChar32::extendMemoryPoolForFileIO( );
     SgTypeComplex::extendMemoryPoolForFileIO( );
     SgTypeDefault::extendMemoryPoolForFileIO( );
     SgTypeExpression::extendMemoryPoolForFileIO( );
     SgTypeLabel::extendMemoryPoolForFileIO( );
     SgTypeDouble::extendMemoryPoolForFileIO( );
     SgTypeEllipse::extendMemoryPoolForFileIO( );
     SgTypeFixed::extendMemoryPoolForFileIO( );
     SgTypeFloat::extendMemoryPoolForFileIO( );
     SgTypeFloat128::extendMemoryPoolForFileIO( );
     SgTypeFloat80::extendMemoryPoolForFileIO( );
     SgTypeGlobalVoid::extendMemoryPoolForFileIO( );
     SgTypeIdOp::extendMemoryPoolForFileIO( );
     SgTypeImaginary::extendMemoryPoolForFileIO( );
     SgTypeInt::extendMemoryPoolForFileIO( );
     SgTypeLong::extendMemoryPoolForFileIO( );
     SgTypeLongDouble::extendMemoryPoolForFileIO( );
     SgTypeLongLong::extendMemoryPoolForFileIO( );
     SgTypeModifier::extendMemoryPoolForFileIO( );
     SgTypeMatrix::extendMemoryPoolForFileIO( );
     SgTypeTuple::extendMemoryPoolForFileIO( );
     SgTypeNullptr::extendMemoryPoolForFileIO( );
     SgTypeOfType::extendMemoryPoolForFileIO( );
     SgTypeShort::extendMemoryPoolForFileIO( );
     SgTypeSigned128bitInteger::extendMemoryPoolForFileIO( );
     SgTypeSignedChar::extendMemoryPoolForFileIO( );
     SgTypeSignedInt::extendMemoryPoolForFileIO( );
     SgTypeSignedLong::extendMemoryPoolForFileIO( );
     SgTypeSignedLongLong::extendMemoryPoolForFileIO( );
     SgTypeSignedShort::extendMemoryPoolForFileIO( );
     SgTypeString::extendMemoryPoolForFileIO( );
     SgTypeUnknown::extendMemoryPoolForFileIO( );
     SgTypeUnsigned128bitInteger::extendMemoryPoolForFileIO( );
     SgTypeUnsignedChar::extendMemoryPoolForFileIO( );
     SgTypeUnsignedInt::extendMemoryPoolForFileIO( );
     SgTypeUnsignedLong::extendMemoryPoolForFileIO( );
     SgTypeUnsignedLongLong::extendMemoryPoolForFileIO( );
     SgTypeUnsignedShort::extendMemoryPoolForFileIO( );
     SgTypeVoid::extendMemoryPoolForFileIO( );
     SgTypeWchar::extendMemoryPoolForFileIO( );
     SgTypedefDeclaration::extendMemoryPoolForFileIO( );
     SgTypedefSeq::extendMemoryPoolForFileIO( );
     SgTypedefSymbol::extendMemoryPoolForFileIO( );
     SgTypedefType::extendMemoryPoolForFileIO( );
     SgUPC_AccessModifier::extendMemoryPoolForFileIO( );
     SgUnaryAddOp::extendMemoryPoolForFileIO( );
     SgUnaryOp::extendMemoryPoolForFileIO( );
     SgUndefDirectiveStatement::extendMemoryPoolForFileIO( );
     SgUndirectedGraphEdge::extendMemoryPoolForFileIO( );
     SgUnknownArrayOrFunctionReference::extendMemoryPoolForFileIO( );
     SgUnknownFile::extendMemoryPoolForFileIO( );
     SgUnparse_Info::extendMemoryPoolForFileIO( );
     SgUnsignedCharVal::extendMemoryPoolForFileIO( );
     SgUnsignedIntVal::extendMemoryPoolForFileIO( );
     SgUnsignedLongLongIntVal::extendMemoryPoolForFileIO( );
     SgUnsignedLongVal::extendMemoryPoolForFileIO( );
     SgUnsignedShortVal::extendMemoryPoolForFileIO( );
     SgUpcBarrierStatement::extendMemoryPoolForFileIO( );
     SgUpcBlocksizeofExpression::extendMemoryPoolForFileIO( );
     SgUpcElemsizeofExpression::extendMemoryPoolForFileIO( );
     SgUpcFenceStatement::extendMemoryPoolForFileIO( );
     SgUpcForAllStatement::extendMemoryPoolForFileIO( );
     SgUpcLocalsizeofExpression::extendMemoryPoolForFileIO( );
     SgUpcMythread::extendMemoryPoolForFileIO( );
     SgUpcNotifyStatement::extendMemoryPoolForFileIO( );
     SgUpcThreads::extendMemoryPoolForFileIO( );
     SgUpcWaitStatement::extendMemoryPoolForFileIO( );
     SgUseStatement::extendMemoryPoolForFileIO( );
     SgUserDefinedBinaryOp::extendMemoryPoolForFileIO( );
     SgUserDefinedUnaryOp::extendMemoryPoolForFileIO( );
     SgUsingDeclarationStatement::extendMemoryPoolForFileIO( );
     SgUsingDirectiveStatement::extendMemoryPoolForFileIO( );
     SgValueExp::extendMemoryPoolForFileIO( );
     SgVarArgCopyOp::extendMemoryPoolForFileIO( );
     SgVarArgEndOp::extendMemoryPoolForFileIO( );
     SgVarArgOp::extendMemoryPoolForFileIO( );
     SgVarArgStartOneOperandOp::extendMemoryPoolForFileIO( );
     SgVarArgStartOp::extendMemoryPoolForFileIO( );
     SgVarRefExp::extendMemoryPoolForFileIO( );
     SgVariableDeclaration::extendMemoryPoolForFileIO( );
     SgVariableDefinition::extendMemoryPoolForFileIO( );
     SgVariableSymbol::extendMemoryPoolForFileIO( );
     SgVariantExpression::extendMemoryPoolForFileIO( );
     SgVariantStatement::extendMemoryPoolForFileIO( );
     SgVoidVal::extendMemoryPoolForFileIO( );
     SgWaitStatement::extendMemoryPoolForFileIO( );
     SgWarningDirectiveStatement::extendMemoryPoolForFileIO( );
     SgWithStatement::extendMemoryPoolForFileIO( );
     SgWcharVal::extendMemoryPoolForFileIO( );
     SgWhereStatement::extendMemoryPoolForFileIO( );
     SgWhileStmt::extendMemoryPoolForFileIO( );
     SgWriteStatement::extendMemoryPoolForFileIO( );
     SgXorAssignOp::extendMemoryPoolForFileIO( );
     SgYieldExpression::extendMemoryPoolForFileIO( );
     Sg_File_Info::extendMemoryPoolForFileIO( );
     SgTypeCAFTeam::extendMemoryPoolForFileIO( );
     SgCAFWithTeamStatement::extendMemoryPoolForFileIO( );
     SgCAFCoExpression::extendMemoryPoolForFileIO( );
     SgCallExpression::extendMemoryPoolForFileIO( );
     SgTypeCrayPointer::extendMemoryPoolForFileIO( );
     SgJavaImportStatement::extendMemoryPoolForFileIO( );
     SgJavaPackageDeclaration::extendMemoryPoolForFileIO( );
     SgJavaPackageStatement::extendMemoryPoolForFileIO( );
     SgJavaImportStatementList::extendMemoryPoolForFileIO( );
     SgJavaClassDeclarationList::extendMemoryPoolForFileIO( );
     SgJavaMemberValuePair::extendMemoryPoolForFileIO( );
     SgJavaAnnotation::extendMemoryPoolForFileIO( );
     SgJavaMarkerAnnotation::extendMemoryPoolForFileIO( );
     SgJavaSingleMemberAnnotation::extendMemoryPoolForFileIO( );
     SgJavaNormalAnnotation::extendMemoryPoolForFileIO( );
     SgJavaTypeExpression::extendMemoryPoolForFileIO( );
     SgJavaQualifiedType::extendMemoryPoolForFileIO( );
     SgClassExp::extendMemoryPoolForFileIO( );
     SgJavaUnionType::extendMemoryPoolForFileIO( );
     SgJavaParameterType::extendMemoryPoolForFileIO( );
     SgAsyncStmt::extendMemoryPoolForFileIO( );
     SgFinishStmt::extendMemoryPoolForFileIO( );
     SgAtStmt::extendMemoryPoolForFileIO( );
     SgAtomicStmt::extendMemoryPoolForFileIO( );
     SgWhenStmt::extendMemoryPoolForFileIO( );
     SgAtExp::extendMemoryPoolForFileIO( );
     SgFinishExp::extendMemoryPoolForFileIO( );
     SgHereExp::extendMemoryPoolForFileIO( );
     SgDotDotExp::extendMemoryPoolForFileIO( );
     SgAsmNullInstruction::extendMemoryPoolForFileIO( );
     SgAdaComponentClause::extendMemoryPoolForFileIO( );
     SgAdaIndexConstraint::extendMemoryPoolForFileIO( );
     SgAdaModularType::extendMemoryPoolForFileIO( );
     SgAdaRepresentationClause::extendMemoryPoolForFileIO( );
     SgAdaFunctionRenamingDecl::extendMemoryPoolForFileIO( );
     SgAdaSelectStmt::extendMemoryPoolForFileIO( );
     SgAdaSelectAlternativeStmt::extendMemoryPoolForFileIO( );
     SgAdaTerminateStmt::extendMemoryPoolForFileIO( );
     SgAsmAarch32Coprocessor::extendMemoryPoolForFileIO( );
     SgAdaAttributeClause::extendMemoryPoolForFileIO( );
     SgAsmBinaryConcat::extendMemoryPoolForFileIO( );
     SgAsmByteOrder::extendMemoryPoolForFileIO( );
     SgAdaDerivedType::extendMemoryPoolForFileIO( );
     SgAdaAttributeExp::extendMemoryPoolForFileIO( );
     SgAdaEnumRepresentationClause::extendMemoryPoolForFileIO( );
     SgAsmBinaryPreupdate::extendMemoryPoolForFileIO( );
     SgAsmBinaryPostupdate::extendMemoryPoolForFileIO( );
     SgAdaOthersExp::extendMemoryPoolForFileIO( );
     SgAdaRenamingSymbol::extendMemoryPoolForFileIO( );
     SgAdaRenamingRefExp::extendMemoryPoolForFileIO( );
     SgAdaGenericDecl::extendMemoryPoolForFileIO( );
     SgAdaGenericDefn::extendMemoryPoolForFileIO( );
     SgAdaFormalType::extendMemoryPoolForFileIO( );
     SgAdaGenericSymbol::extendMemoryPoolForFileIO( );
     SgAdaFormalTypeDecl::extendMemoryPoolForFileIO( );
     SgAdaUnitRefExp::extendMemoryPoolForFileIO( );
     SgAdaDiscriminatedTypeDecl::extendMemoryPoolForFileIO( );
     SgAdaDiscriminatedType::extendMemoryPoolForFileIO( );
     SgAdaDiscriminantConstraint::extendMemoryPoolForFileIO( );
     SgAdaGenericInstanceDecl::extendMemoryPoolForFileIO( );
     SgAdaUnscopedBlock::extendMemoryPoolForFileIO( );
     SgAdaInheritedFunctionSymbol::extendMemoryPoolForFileIO( );
     SgAdaProtectedBody::extendMemoryPoolForFileIO( );
     SgAdaProtectedBodyDecl::extendMemoryPoolForFileIO( );
     SgAdaProtectedSpec::extendMemoryPoolForFileIO( );
     SgAdaProtectedSpecDecl::extendMemoryPoolForFileIO( );
     SgAdaProtectedSymbol::extendMemoryPoolForFileIO( );
     SgAdaProtectedRefExp::extendMemoryPoolForFileIO( );
     SgAdaProtectedType::extendMemoryPoolForFileIO( );
     SgAdaProtectedTypeDecl::extendMemoryPoolForFileIO( );
     SgAdaDigitsConstraint::extendMemoryPoolForFileIO( );
     SgAdaAncestorInitializer::extendMemoryPoolForFileIO( );
     SgAdaDeltaConstraint::extendMemoryPoolForFileIO( );
     SgAdaSubroutineType::extendMemoryPoolForFileIO( );
     SgAdaGenericInstanceSymbol::extendMemoryPoolForFileIO( );
     SgAdaFormalPackageDecl::extendMemoryPoolForFileIO( );
     SgAdaFormalPackageSymbol::extendMemoryPoolForFileIO( );
     SgAsmJvmAttributeTable::extendMemoryPoolForFileIO( );
     SgAsmJvmMethodTable::extendMemoryPoolForFileIO( );
     SgAsmJvmField::extendMemoryPoolForFileIO( );
     SgAsmJvmFieldTable::extendMemoryPoolForFileIO( );
     SgAsmJvmExceptionHandler::extendMemoryPoolForFileIO( );
     SgAsmJvmExceptionTable::extendMemoryPoolForFileIO( );
     SgAsmJvmClass::extendMemoryPoolForFileIO( );
     SgAsmJvmLineNumberEntry::extendMemoryPoolForFileIO( );
     SgAsmJvmLineNumberTable::extendMemoryPoolForFileIO( );
     SgAsmJvmInnerClassesEntry::extendMemoryPoolForFileIO( );
     SgAsmJvmInnerClasses::extendMemoryPoolForFileIO( );
     SgAsmCilInstruction::extendMemoryPoolForFileIO( );
     SgAsmStackExpression::extendMemoryPoolForFileIO( );
     SgAsmJvmEnclosingMethod::extendMemoryPoolForFileIO( );
     SgAdaNullConstraint::extendMemoryPoolForFileIO( );
     SgAsmJvmModuleMainClass::extendMemoryPoolForFileIO( );
     SgAsmInstructionList::extendMemoryPoolForFileIO( );
     SgAsmCilNode::extendMemoryPoolForFileIO( );
     SgAsmCilAssembly::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyOS::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyProcessor::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyRef::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyRefOS::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyRefProcessor::extendMemoryPoolForFileIO( );
     SgAsmCilClassLayout::extendMemoryPoolForFileIO( );
     SgAsmCilConstant::extendMemoryPoolForFileIO( );
     SgAsmCilCustomAttribute::extendMemoryPoolForFileIO( );
     SgAsmCilDeclSecurity::extendMemoryPoolForFileIO( );
     SgAsmCilEvent::extendMemoryPoolForFileIO( );
     SgAsmCilEventMap::extendMemoryPoolForFileIO( );
     SgAsmCilExportedType::extendMemoryPoolForFileIO( );
     SgAsmCilField::extendMemoryPoolForFileIO( );
     SgAsmCilFieldLayout::extendMemoryPoolForFileIO( );
     SgAsmCilFieldMarshal::extendMemoryPoolForFileIO( );
     SgAsmCilFieldRVA::extendMemoryPoolForFileIO( );
     SgAsmCilFile::extendMemoryPoolForFileIO( );
     SgAsmCilGenericParam::extendMemoryPoolForFileIO( );
     SgAsmCilGenericParamConstraint::extendMemoryPoolForFileIO( );
     SgAsmCilImplMap::extendMemoryPoolForFileIO( );
     SgAsmCilInterfaceImpl::extendMemoryPoolForFileIO( );
     SgAsmCilManifestResource::extendMemoryPoolForFileIO( );
     SgAsmCilMemberRef::extendMemoryPoolForFileIO( );
     SgAsmCilMethodDef::extendMemoryPoolForFileIO( );
     SgAsmCilMethodImpl::extendMemoryPoolForFileIO( );
     SgAsmCilMethodSemantics::extendMemoryPoolForFileIO( );
     SgAsmCilMethodSpec::extendMemoryPoolForFileIO( );
     SgAsmCilModule::extendMemoryPoolForFileIO( );
     SgAsmCilModuleRef::extendMemoryPoolForFileIO( );
     SgAsmCilNestedClass::extendMemoryPoolForFileIO( );
     SgAsmCilParam::extendMemoryPoolForFileIO( );
     SgAsmCilProperty::extendMemoryPoolForFileIO( );
     SgAsmCilPropertyMap::extendMemoryPoolForFileIO( );
     SgAsmCilStandAloneSig::extendMemoryPoolForFileIO( );
     SgAsmCilTypeDef::extendMemoryPoolForFileIO( );
     SgAsmCilTypeRef::extendMemoryPoolForFileIO( );
     SgAsmCilTypeSpec::extendMemoryPoolForFileIO( );
     SgAdaParameterList::extendMemoryPoolForFileIO( );
     SgAsmCilMetadata::extendMemoryPoolForFileIO( );
     SgAsmCilMetadataRoot::extendMemoryPoolForFileIO( );
     SgAsmCilDataStream::extendMemoryPoolForFileIO( );
     SgAsmCilMetadataHeap::extendMemoryPoolForFileIO( );
     SgAsmCilUint8Heap::extendMemoryPoolForFileIO( );
     SgAsmCilUint32Heap::extendMemoryPoolForFileIO( );
     SgAsmCliHeader::extendMemoryPoolForFileIO( );
     SgAdaVariantDecl::extendMemoryPoolForFileIO( );
     SgAdaVariantWhenStmt::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyTable::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyOSTable::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyProcessorTable::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyRefTable::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyRefOSTable::extendMemoryPoolForFileIO( );
     SgAsmCilAssemblyRefProcessorTable::extendMemoryPoolForFileIO( );
     SgAsmCilClassLayoutTable::extendMemoryPoolForFileIO( );
     SgAsmCilConstantTable::extendMemoryPoolForFileIO( );
     SgAsmCilCustomAttributeTable::extendMemoryPoolForFileIO( );
     SgAsmCilDeclSecurityTable::extendMemoryPoolForFileIO( );
     SgAsmCilEventTable::extendMemoryPoolForFileIO( );
     SgAsmCilEventMapTable::extendMemoryPoolForFileIO( );
     SgAsmCilExportedTypeTable::extendMemoryPoolForFileIO( );
     SgAsmCilFieldTable::extendMemoryPoolForFileIO( );
     SgAsmCilFieldLayoutTable::extendMemoryPoolForFileIO( );
     SgAsmCilFieldMarshalTable::extendMemoryPoolForFileIO( );
     SgAsmCilFieldRVATable::extendMemoryPoolForFileIO( );
     SgAsmCilFileTable::extendMemoryPoolForFileIO( );
     SgAsmCilGenericParamTable::extendMemoryPoolForFileIO( );
     SgAsmCilGenericParamConstraintTable::extendMemoryPoolForFileIO( );
     SgAsmCilImplMapTable::extendMemoryPoolForFileIO( );
     SgAsmCilInterfaceImplTable::extendMemoryPoolForFileIO( );
     SgAsmCilManifestResourceTable::extendMemoryPoolForFileIO( );
     SgAsmCilMemberRefTable::extendMemoryPoolForFileIO( );
     SgAsmCilMethodDefTable::extendMemoryPoolForFileIO( );
     SgAsmCilMethodImplTable::extendMemoryPoolForFileIO( );
     SgAsmCilMethodSemanticsTable::extendMemoryPoolForFileIO( );
     SgAsmCilMethodSpecTable::extendMemoryPoolForFileIO( );
     SgAsmCilModuleTable::extendMemoryPoolForFileIO( );
     SgAsmCilModuleRefTable::extendMemoryPoolForFileIO( );
     SgAsmCilNestedClassTable::extendMemoryPoolForFileIO( );
     SgAsmCilParamTable::extendMemoryPoolForFileIO( );
     SgAsmCilPropertyTable::extendMemoryPoolForFileIO( );
     SgAsmCilPropertyMapTable::extendMemoryPoolForFileIO( );
     SgAsmCilStandAloneSigTable::extendMemoryPoolForFileIO( );
     SgAsmCilTypeDefTable::extendMemoryPoolForFileIO( );
     SgAsmCilTypeRefTable::extendMemoryPoolForFileIO( );
     SgAsmCilTypeSpecTable::extendMemoryPoolForFileIO( );
     SgJvmComposite::extendMemoryPoolForFileIO( );
     SgFortranContinueStmt::extendMemoryPoolForFileIO( );
     SgAsmJvmStackMapTable::extendMemoryPoolForFileIO( );
     SgAsmJvmStackMapFrame::extendMemoryPoolForFileIO( );
     SgAsmJvmStackMapVerificationType::extendMemoryPoolForFileIO( );
     SgAsmJvmBootstrapMethod::extendMemoryPoolForFileIO( );
     SgAsmJvmBootstrapMethods::extendMemoryPoolForFileIO( );
     SgAsmJvmExceptions::extendMemoryPoolForFileIO( );
     SgAsmJvmNestMembers::extendMemoryPoolForFileIO( );
     SgAsmJvmNestHost::extendMemoryPoolForFileIO( );
     SgJovialLabelDeclaration::extendMemoryPoolForFileIO( );
     SgAsmJvmLocalVariableEntry::extendMemoryPoolForFileIO( );
     SgAsmJvmLocalVariableTable::extendMemoryPoolForFileIO( );
     SgAsmJvmLocalVariableTypeEntry::extendMemoryPoolForFileIO( );
     SgAsmJvmLocalVariableTypeTable::extendMemoryPoolForFileIO( );
     SgAsmUserInstruction::extendMemoryPoolForFileIO( );
     SgAsmJvmMethodParameters::extendMemoryPoolForFileIO( );
     SgAsmJvmMethodParametersEntry::extendMemoryPoolForFileIO( );
     SgAsmVoidType::extendMemoryPoolForFileIO( );
     SgAsmPointerType::extendMemoryPoolForFileIO( );
     SgRangeType::extendMemoryPoolForFileIO( );
     SgAsmCilExceptionData::extendMemoryPoolForFileIO( );
     SgAsmCilMethodData::extendMemoryPoolForFileIO( );
     SgTemplateVariableInstantiation::extendMemoryPoolForFileIO( );
     SgReferenceExp::extendMemoryPoolForFileIO( );
     SgTypeRefExp::extendMemoryPoolForFileIO( );
     SgScopedRefExp::extendMemoryPoolForFileIO( );
     SgScopedType::extendMemoryPoolForFileIO( );
     SgTypeSymbol::extendMemoryPoolForFileIO( );
     SgAsmJvmSynthetic::extendMemoryPoolForFileIO( );
     SgAsmJvmDeprecated::extendMemoryPoolForFileIO( );
     SgSignedCharVal::extendMemoryPoolForFileIO( );
     SgAsmCilErrorHeap::extendMemoryPoolForFileIO( );

/* #line 400 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
  
     return;
   }


int 
AST_FILE_IO::getNumberOfAsts ()
   {
     return vectorOfASTs.size();
   }


void
AST_FILE_IO::addNewAst (AstData* newAst)
   {
     vectorOfASTs.push_back(newAst);
     actualRebuildAst = newAst;
     return;
   }


void
AST_FILE_IO::printFileMaps ()
   {
      std::map<int,std::string> :: iterator Iter1 = Sg_File_Info::p_fileidtoname_map.begin();
      for ( ; Iter1 != Sg_File_Info::p_fileidtoname_map.end(); ++Iter1)
         {
           std::cout << Iter1->first << " " << Iter1->second << std::endl;
         }
      std::map<std::string,int> :: iterator Iter2 = Sg_File_Info::p_nametofileid_map.begin();
      for ( ; Iter2 != Sg_File_Info::p_nametofileid_map.end(); ++Iter2)
         {
           std::cout << Iter2->first << " " << Iter2->second << std::endl;
         }
   }



void
AST_FILE_IO::deleteStoredAsts ()
   {
     std::vector<AstData*>::iterator astIterator = vectorOfASTs.begin(); 
     for ( ; astIterator != vectorOfASTs.end(); ++astIterator)
         {
           delete (*astIterator);
         }
     vectorOfASTs.clear();
     return;
   }



void
AST_FILE_IO::setStaticDataOfAst (AstData *astInPool)
   {
     assert (astInPool->get_AstIndex() < (int)vectorOfASTs.size());
     astInPool->setStaticDataMembersOfIRNodes();
     return;
   }




void 
AST_FILE_IO::printListOfPoolSizes ()
   {
     std::cout << "Memory pool size of SgAccessModifier: " <<  listOfMemoryPoolSizes[V_SgAccessModifier] << std::endl; 
     std::cout << "Memory pool size of SgActualArgumentExpression: " <<  listOfMemoryPoolSizes[V_SgActualArgumentExpression] << std::endl; 
     std::cout << "Memory pool size of SgAbsOp: " <<  listOfMemoryPoolSizes[V_SgAbsOp] << std::endl; 
     std::cout << "Memory pool size of SgAdaAccessType: " <<  listOfMemoryPoolSizes[V_SgAdaAccessType] << std::endl; 
     std::cout << "Memory pool size of SgAdaAcceptStmt: " <<  listOfMemoryPoolSizes[V_SgAdaAcceptStmt] << std::endl; 
     std::cout << "Memory pool size of SgAdaDelayStmt: " <<  listOfMemoryPoolSizes[V_SgAdaDelayStmt] << std::endl; 
     std::cout << "Memory pool size of SgAdaEntryDecl: " <<  listOfMemoryPoolSizes[V_SgAdaEntryDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaExitStmt: " <<  listOfMemoryPoolSizes[V_SgAdaExitStmt] << std::endl; 
     std::cout << "Memory pool size of SgAdaDiscreteType: " <<  listOfMemoryPoolSizes[V_SgAdaDiscreteType] << std::endl; 
     std::cout << "Memory pool size of SgAdaFloatVal: " <<  listOfMemoryPoolSizes[V_SgAdaFloatVal] << std::endl; 
     std::cout << "Memory pool size of SgAdaLoopStmt: " <<  listOfMemoryPoolSizes[V_SgAdaLoopStmt] << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageBody: " <<  listOfMemoryPoolSizes[V_SgAdaPackageBody] << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageBodyDecl: " <<  listOfMemoryPoolSizes[V_SgAdaPackageBodyDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageSpec: " <<  listOfMemoryPoolSizes[V_SgAdaPackageSpec] << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageSpecDecl: " <<  listOfMemoryPoolSizes[V_SgAdaPackageSpecDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageSymbol: " <<  listOfMemoryPoolSizes[V_SgAdaPackageSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAdaRangeConstraint: " <<  listOfMemoryPoolSizes[V_SgAdaRangeConstraint] << std::endl; 
     std::cout << "Memory pool size of SgAdaRenamingDecl: " <<  listOfMemoryPoolSizes[V_SgAdaRenamingDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaSubtype: " <<  listOfMemoryPoolSizes[V_SgAdaSubtype] << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskBody: " <<  listOfMemoryPoolSizes[V_SgAdaTaskBody] << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskBodyDecl: " <<  listOfMemoryPoolSizes[V_SgAdaTaskBodyDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskSpec: " <<  listOfMemoryPoolSizes[V_SgAdaTaskSpec] << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskSpecDecl: " <<  listOfMemoryPoolSizes[V_SgAdaTaskSpecDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskSymbol: " <<  listOfMemoryPoolSizes[V_SgAdaTaskSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskRefExp: " <<  listOfMemoryPoolSizes[V_SgAdaTaskRefExp] << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskType: " <<  listOfMemoryPoolSizes[V_SgAdaTaskType] << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskTypeDecl: " <<  listOfMemoryPoolSizes[V_SgAdaTaskTypeDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaTypeConstraint: " <<  listOfMemoryPoolSizes[V_SgAdaTypeConstraint] << std::endl; 
     std::cout << "Memory pool size of SgAddOp: " <<  listOfMemoryPoolSizes[V_SgAddOp] << std::endl; 
     std::cout << "Memory pool size of SgAddressOfOp: " <<  listOfMemoryPoolSizes[V_SgAddressOfOp] << std::endl; 
     std::cout << "Memory pool size of SgAggregateInitializer: " <<  listOfMemoryPoolSizes[V_SgAggregateInitializer] << std::endl; 
     std::cout << "Memory pool size of SgAliasSymbol: " <<  listOfMemoryPoolSizes[V_SgAliasSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAllocateStatement: " <<  listOfMemoryPoolSizes[V_SgAllocateStatement] << std::endl; 
     std::cout << "Memory pool size of SgAndAssignOp: " <<  listOfMemoryPoolSizes[V_SgAndAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgAndOp: " <<  listOfMemoryPoolSizes[V_SgAndOp] << std::endl; 
     std::cout << "Memory pool size of SgArithmeticIfStatement: " <<  listOfMemoryPoolSizes[V_SgArithmeticIfStatement] << std::endl; 
     std::cout << "Memory pool size of SgArrayType: " <<  listOfMemoryPoolSizes[V_SgArrayType] << std::endl; 
     std::cout << "Memory pool size of SgArrowExp: " <<  listOfMemoryPoolSizes[V_SgArrowExp] << std::endl; 
     std::cout << "Memory pool size of SgArrowStarOp: " <<  listOfMemoryPoolSizes[V_SgArrowStarOp] << std::endl; 
     std::cout << "Memory pool size of SgAsmBasicString: " <<  listOfMemoryPoolSizes[V_SgAsmBasicString] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAdd: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryAdd] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAsr: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryAsr] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryDivide: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryDivide] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryExpression: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryLsl: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryLsl] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryLsr: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryLsr] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMod: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryMod] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMsl: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryMsl] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMultiply: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryMultiply] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryRor: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryRor] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinarySubtract: " <<  listOfMemoryPoolSizes[V_SgAsmBinarySubtract] << std::endl; 
     std::cout << "Memory pool size of SgAsmBlock: " <<  listOfMemoryPoolSizes[V_SgAsmBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffStrtab: " <<  listOfMemoryPoolSizes[V_SgAsmCoffStrtab] << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmCoffSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbolList: " <<  listOfMemoryPoolSizes[V_SgAsmCoffSymbolList] << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbolTable: " <<  listOfMemoryPoolSizes[V_SgAsmCoffSymbolTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCommonSubExpression: " <<  listOfMemoryPoolSizes[V_SgAsmCommonSubExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmControlFlagsExpression: " <<  listOfMemoryPoolSizes[V_SgAsmControlFlagsExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmConstantExpression: " <<  listOfMemoryPoolSizes[V_SgAsmConstantExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmDOSExtendedHeader: " <<  listOfMemoryPoolSizes[V_SgAsmDOSExtendedHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmDOSFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmDOSFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmSynthesizedDataStructureDeclaration: " <<  listOfMemoryPoolSizes[V_SgAsmSynthesizedDataStructureDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgAsmSynthesizedDeclaration: " <<  listOfMemoryPoolSizes[V_SgAsmSynthesizedDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgAsmDirectRegisterExpression: " <<  listOfMemoryPoolSizes[V_SgAsmDirectRegisterExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfAccessDeclaration: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfAccessDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfArrayType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfArrayType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfBaseType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfBaseType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCatchBlock: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCatchBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfClassTemplate: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfClassTemplate] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfClassType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfClassType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCommonBlock: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCommonBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCommonInclusion: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCommonInclusion] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCompilationUnit: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCompilationUnit] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCompilationUnitList: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCompilationUnitList] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCondition: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCondition] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfConstType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstant: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfConstant] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstruct: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfConstruct] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstructList: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfConstructList] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfDwarfProcedure: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfDwarfProcedure] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEntryPoint: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfEntryPoint] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEnumerationType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfEnumerationType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEnumerator: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfEnumerator] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFileType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFileType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFormalParameter: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFormalParameter] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFormatLabel: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFormatLabel] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFriend: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFriend] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFunctionTemplate: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFunctionTemplate] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedDeclaration: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfImportedDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedModule: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfImportedModule] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedUnit: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfImportedUnit] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInformation: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfInformation] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInheritance: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfInheritance] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInlinedSubroutine: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfInlinedSubroutine] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInterfaceType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfInterfaceType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLabel: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfLabel] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLexicalBlock: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfLexicalBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLine: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfLine] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLineList: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfLineList] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMacro: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfMacro] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMacroList: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfMacroList] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMember: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfMember] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfModule: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfModule] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMutableType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfMutableType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamelist: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfNamelist] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamelistItem: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfNamelistItem] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamespace: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfNamespace] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPackedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfPackedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPartialUnit: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfPartialUnit] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPointerType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfPointerType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPtrToMemberType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfPtrToMemberType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfReferenceType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfReferenceType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfRestrictType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfRestrictType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSetType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSetType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSharedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSharedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfStringType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfStringType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfStructureType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfStructureType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubprogram: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSubprogram] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubrangeType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSubrangeType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubroutineType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSubroutineType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTemplateTypeParameter: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfTemplateTypeParameter] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTemplateValueParameter: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfTemplateValueParameter] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfThrownType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfThrownType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTryBlock: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfTryBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTypedef: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfTypedef] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnionType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUnionType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnknownConstruct: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUnknownConstruct] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnspecifiedParameters: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUnspecifiedParameters] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnspecifiedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUnspecifiedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcRelaxedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUpcRelaxedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcSharedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUpcSharedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcStrictType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUpcStrictType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariable: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfVariable] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariant: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfVariant] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariantPart: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfVariantPart] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVolatileType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfVolatileType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfWithStmt: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfWithStmt] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfDynamicEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfDynamicEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfDynamicSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryCI: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameEntryCI] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryCIList: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameEntryCIList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryFD: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameEntryFD] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryFDList: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameEntryFDList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmElfFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfNoteEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfNoteEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfNoteSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfRelocEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfRelocEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfRelocSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSectionTable: " <<  listOfMemoryPoolSizes[V_SgAsmElfSectionTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSectionTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSectionTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTable: " <<  listOfMemoryPoolSizes[V_SgAsmElfSegmentTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSegmentTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTableEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSegmentTableEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfStringSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfStringSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfStrtab: " <<  listOfMemoryPoolSizes[V_SgAsmElfStrtab] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbolList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymbolList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbolSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymbolSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedAux: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedAux] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedAuxList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedAuxList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededAux: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededAux] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededAuxList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededAuxList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmExecutableFileFormat: " <<  listOfMemoryPoolSizes[V_SgAsmExecutableFileFormat] << std::endl; 
     std::cout << "Memory pool size of SgAsmExprListExp: " <<  listOfMemoryPoolSizes[V_SgAsmExprListExp] << std::endl; 
     std::cout << "Memory pool size of SgAsmExpression: " <<  listOfMemoryPoolSizes[V_SgAsmExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmSynthesizedFieldDeclaration: " <<  listOfMemoryPoolSizes[V_SgAsmSynthesizedFieldDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgAsmFloatType: " <<  listOfMemoryPoolSizes[V_SgAsmFloatType] << std::endl; 
     std::cout << "Memory pool size of SgAsmFloatValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmFloatValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmFunction: " <<  listOfMemoryPoolSizes[V_SgAsmFunction] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericDLL: " <<  listOfMemoryPoolSizes[V_SgAsmGenericDLL] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericDLLList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericDLLList] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFile: " <<  listOfMemoryPoolSizes[V_SgAsmGenericFile] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFileList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericFileList] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFormat: " <<  listOfMemoryPoolSizes[V_SgAsmGenericFormat] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericHeader: " <<  listOfMemoryPoolSizes[V_SgAsmGenericHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericHeaderList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericHeaderList] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSection: " <<  listOfMemoryPoolSizes[V_SgAsmGenericSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSectionList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericSectionList] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericString: " <<  listOfMemoryPoolSizes[V_SgAsmGenericString] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericStrtab: " <<  listOfMemoryPoolSizes[V_SgAsmGenericStrtab] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmGenericSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSymbolList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericSymbolList] << std::endl; 
     std::cout << "Memory pool size of SgAsmIndirectRegisterExpression: " <<  listOfMemoryPoolSizes[V_SgAsmIndirectRegisterExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmIntegerValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmIntegerValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmIntegerType: " <<  listOfMemoryPoolSizes[V_SgAsmIntegerType] << std::endl; 
     std::cout << "Memory pool size of SgAsmInterpretation: " <<  listOfMemoryPoolSizes[V_SgAsmInterpretation] << std::endl; 
     std::cout << "Memory pool size of SgAsmInterpretationList: " <<  listOfMemoryPoolSizes[V_SgAsmInterpretationList] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmAttribute: " <<  listOfMemoryPoolSizes[V_SgAsmJvmAttribute] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmCodeAttribute: " <<  listOfMemoryPoolSizes[V_SgAsmJvmCodeAttribute] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmMethod: " <<  listOfMemoryPoolSizes[V_SgAsmJvmMethod] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmConstantPool: " <<  listOfMemoryPoolSizes[V_SgAsmJvmConstantPool] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmConstantPoolEntry: " <<  listOfMemoryPoolSizes[V_SgAsmJvmConstantPoolEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmConstantValue: " <<  listOfMemoryPoolSizes[V_SgAsmJvmConstantValue] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmJvmInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmJvmFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmNode: " <<  listOfMemoryPoolSizes[V_SgAsmJvmNode] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmSignature: " <<  listOfMemoryPoolSizes[V_SgAsmJvmSignature] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmSourceFile: " <<  listOfMemoryPoolSizes[V_SgAsmJvmSourceFile] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEEntryPoint: " <<  listOfMemoryPoolSizes[V_SgAsmLEEntryPoint] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEEntryTable: " <<  listOfMemoryPoolSizes[V_SgAsmLEEntryTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmLEFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmLENameTable: " <<  listOfMemoryPoolSizes[V_SgAsmLENameTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEPageTable: " <<  listOfMemoryPoolSizes[V_SgAsmLEPageTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEPageTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmLEPageTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmLERelocTable: " <<  listOfMemoryPoolSizes[V_SgAsmLERelocTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLESection: " <<  listOfMemoryPoolSizes[V_SgAsmLESection] << std::endl; 
     std::cout << "Memory pool size of SgAsmLESectionTable: " <<  listOfMemoryPoolSizes[V_SgAsmLESectionTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLESectionTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmLESectionTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmM68kInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmM68kInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmMemoryReferenceExpression: " <<  listOfMemoryPoolSizes[V_SgAsmMemoryReferenceExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmMipsInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmMipsInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEEntryPoint: " <<  listOfMemoryPoolSizes[V_SgAsmNEEntryPoint] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEEntryTable: " <<  listOfMemoryPoolSizes[V_SgAsmNEEntryTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmNEFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEModuleTable: " <<  listOfMemoryPoolSizes[V_SgAsmNEModuleTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNENameTable: " <<  listOfMemoryPoolSizes[V_SgAsmNENameTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNERelocEntry: " <<  listOfMemoryPoolSizes[V_SgAsmNERelocEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmNERelocTable: " <<  listOfMemoryPoolSizes[V_SgAsmNERelocTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNESection: " <<  listOfMemoryPoolSizes[V_SgAsmNESection] << std::endl; 
     std::cout << "Memory pool size of SgAsmNESectionTable: " <<  listOfMemoryPoolSizes[V_SgAsmNESectionTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNESectionTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmNESectionTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEStringTable: " <<  listOfMemoryPoolSizes[V_SgAsmNEStringTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNode: " <<  listOfMemoryPoolSizes[V_SgAsmNode] << std::endl; 
     std::cout << "Memory pool size of SgAsmOp: " <<  listOfMemoryPoolSizes[V_SgAsmOp] << std::endl; 
     std::cout << "Memory pool size of SgAsmOperandList: " <<  listOfMemoryPoolSizes[V_SgAsmOperandList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportDirectory: " <<  listOfMemoryPoolSizes[V_SgAsmPEExportDirectory] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportEntry: " <<  listOfMemoryPoolSizes[V_SgAsmPEExportEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmPEExportEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportSection: " <<  listOfMemoryPoolSizes[V_SgAsmPEExportSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmPEFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportDirectory: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportDirectory] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportDirectoryList: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportDirectoryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportItem: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportItem] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportItemList: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportItemList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportSection: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmPERVASizePair: " <<  listOfMemoryPoolSizes[V_SgAsmPERVASizePair] << std::endl; 
     std::cout << "Memory pool size of SgAsmPERVASizePairList: " <<  listOfMemoryPoolSizes[V_SgAsmPERVASizePairList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPESection: " <<  listOfMemoryPoolSizes[V_SgAsmPESection] << std::endl; 
     std::cout << "Memory pool size of SgAsmPESectionTable: " <<  listOfMemoryPoolSizes[V_SgAsmPESectionTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmPESectionTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmPESectionTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEStringSection: " <<  listOfMemoryPoolSizes[V_SgAsmPEStringSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmPowerpcInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmPowerpcInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmRegisterNames: " <<  listOfMemoryPoolSizes[V_SgAsmRegisterNames] << std::endl; 
     std::cout << "Memory pool size of SgAsmRegisterReferenceExpression: " <<  listOfMemoryPoolSizes[V_SgAsmRegisterReferenceExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmRiscOperation: " <<  listOfMemoryPoolSizes[V_SgAsmRiscOperation] << std::endl; 
     std::cout << "Memory pool size of SgAsmScalarType: " <<  listOfMemoryPoolSizes[V_SgAsmScalarType] << std::endl; 
     std::cout << "Memory pool size of SgAsmStatement: " <<  listOfMemoryPoolSizes[V_SgAsmStatement] << std::endl; 
     std::cout << "Memory pool size of SgAsmStaticData: " <<  listOfMemoryPoolSizes[V_SgAsmStaticData] << std::endl; 
     std::cout << "Memory pool size of SgAsmStmt: " <<  listOfMemoryPoolSizes[V_SgAsmStmt] << std::endl; 
     std::cout << "Memory pool size of SgAsmStoredString: " <<  listOfMemoryPoolSizes[V_SgAsmStoredString] << std::endl; 
     std::cout << "Memory pool size of SgAsmStringStorage: " <<  listOfMemoryPoolSizes[V_SgAsmStringStorage] << std::endl; 
     std::cout << "Memory pool size of SgAsmType: " <<  listOfMemoryPoolSizes[V_SgAsmType] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryExpression: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryMinus: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryMinus] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryPlus: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryPlus] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryRrx: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryRrx] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnarySignedExtend: " <<  listOfMemoryPoolSizes[V_SgAsmUnarySignedExtend] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryUnsignedExtend: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryUnsignedExtend] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryTruncate: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryTruncate] << std::endl; 
     std::cout << "Memory pool size of SgAsmValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmVectorType: " <<  listOfMemoryPoolSizes[V_SgAsmVectorType] << std::endl; 
     std::cout << "Memory pool size of SgAsmX86Instruction: " <<  listOfMemoryPoolSizes[V_SgAsmX86Instruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAddressSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryAddressSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryDataSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryDataSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAssertStmt: " <<  listOfMemoryPoolSizes[V_SgAssertStmt] << std::endl; 
     std::cout << "Memory pool size of SgAssignInitializer: " <<  listOfMemoryPoolSizes[V_SgAssignInitializer] << std::endl; 
     std::cout << "Memory pool size of SgAssignOp: " <<  listOfMemoryPoolSizes[V_SgAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgAssignStatement: " <<  listOfMemoryPoolSizes[V_SgAssignStatement] << std::endl; 
     std::cout << "Memory pool size of SgAssignedGotoStatement: " <<  listOfMemoryPoolSizes[V_SgAssignedGotoStatement] << std::endl; 
     std::cout << "Memory pool size of SgAssociateStatement: " <<  listOfMemoryPoolSizes[V_SgAssociateStatement] << std::endl; 
     std::cout << "Memory pool size of SgAsteriskShapeExp: " <<  listOfMemoryPoolSizes[V_SgAsteriskShapeExp] << std::endl; 
     std::cout << "Memory pool size of SgAtOp: " <<  listOfMemoryPoolSizes[V_SgAtOp] << std::endl; 
     std::cout << "Memory pool size of SgAttribute: " <<  listOfMemoryPoolSizes[V_SgAttribute] << std::endl; 
     std::cout << "Memory pool size of SgAttributeSpecificationStatement: " <<  listOfMemoryPoolSizes[V_SgAttributeSpecificationStatement] << std::endl; 
     std::cout << "Memory pool size of SgAutoType: " <<  listOfMemoryPoolSizes[V_SgAutoType] << std::endl; 
     std::cout << "Memory pool size of SgAwaitExpression: " <<  listOfMemoryPoolSizes[V_SgAwaitExpression] << std::endl; 
     std::cout << "Memory pool size of SgBackspaceStatement: " <<  listOfMemoryPoolSizes[V_SgBackspaceStatement] << std::endl; 
     std::cout << "Memory pool size of SgBaseClass: " <<  listOfMemoryPoolSizes[V_SgBaseClass] << std::endl; 
     std::cout << "Memory pool size of SgExpBaseClass: " <<  listOfMemoryPoolSizes[V_SgExpBaseClass] << std::endl; 
     std::cout << "Memory pool size of SgBaseClassModifier: " <<  listOfMemoryPoolSizes[V_SgBaseClassModifier] << std::endl; 
     std::cout << "Memory pool size of SgBasicBlock: " <<  listOfMemoryPoolSizes[V_SgBasicBlock] << std::endl; 
     std::cout << "Memory pool size of SgBidirectionalGraph: " <<  listOfMemoryPoolSizes[V_SgBidirectionalGraph] << std::endl; 
     std::cout << "Memory pool size of SgBinaryComposite: " <<  listOfMemoryPoolSizes[V_SgBinaryComposite] << std::endl; 
     std::cout << "Memory pool size of SgBinaryOp: " <<  listOfMemoryPoolSizes[V_SgBinaryOp] << std::endl; 
     std::cout << "Memory pool size of SgBitAndOp: " <<  listOfMemoryPoolSizes[V_SgBitAndOp] << std::endl; 
     std::cout << "Memory pool size of SgBitAttribute: " <<  listOfMemoryPoolSizes[V_SgBitAttribute] << std::endl; 
     std::cout << "Memory pool size of SgBitComplementOp: " <<  listOfMemoryPoolSizes[V_SgBitComplementOp] << std::endl; 
     std::cout << "Memory pool size of SgBitEqvOp: " <<  listOfMemoryPoolSizes[V_SgBitEqvOp] << std::endl; 
     std::cout << "Memory pool size of SgBitOrOp: " <<  listOfMemoryPoolSizes[V_SgBitOrOp] << std::endl; 
     std::cout << "Memory pool size of SgBitXorOp: " <<  listOfMemoryPoolSizes[V_SgBitXorOp] << std::endl; 
     std::cout << "Memory pool size of SgBlockDataStatement: " <<  listOfMemoryPoolSizes[V_SgBlockDataStatement] << std::endl; 
     std::cout << "Memory pool size of SgBoolValExp: " <<  listOfMemoryPoolSizes[V_SgBoolValExp] << std::endl; 
     std::cout << "Memory pool size of SgBreakStmt: " <<  listOfMemoryPoolSizes[V_SgBreakStmt] << std::endl; 
     std::cout << "Memory pool size of SgBracedInitializer: " <<  listOfMemoryPoolSizes[V_SgBracedInitializer] << std::endl; 
     std::cout << "Memory pool size of SgC_PreprocessorDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgC_PreprocessorDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgCaseOptionStmt: " <<  listOfMemoryPoolSizes[V_SgCaseOptionStmt] << std::endl; 
     std::cout << "Memory pool size of SgCastExp: " <<  listOfMemoryPoolSizes[V_SgCastExp] << std::endl; 
     std::cout << "Memory pool size of SgCatchOptionStmt: " <<  listOfMemoryPoolSizes[V_SgCatchOptionStmt] << std::endl; 
     std::cout << "Memory pool size of SgCatchStatementSeq: " <<  listOfMemoryPoolSizes[V_SgCatchStatementSeq] << std::endl; 
     std::cout << "Memory pool size of SgCharVal: " <<  listOfMemoryPoolSizes[V_SgCharVal] << std::endl; 
     std::cout << "Memory pool size of SgChar16Val: " <<  listOfMemoryPoolSizes[V_SgChar16Val] << std::endl; 
     std::cout << "Memory pool size of SgChar32Val: " <<  listOfMemoryPoolSizes[V_SgChar32Val] << std::endl; 
     std::cout << "Memory pool size of SgChooseExpression: " <<  listOfMemoryPoolSizes[V_SgChooseExpression] << std::endl; 
     std::cout << "Memory pool size of SgClassDecl_attr: " <<  listOfMemoryPoolSizes[V_SgClassDecl_attr] << std::endl; 
     std::cout << "Memory pool size of SgClassDeclaration: " <<  listOfMemoryPoolSizes[V_SgClassDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgClassDefinition: " <<  listOfMemoryPoolSizes[V_SgClassDefinition] << std::endl; 
     std::cout << "Memory pool size of SgClassNameRefExp: " <<  listOfMemoryPoolSizes[V_SgClassNameRefExp] << std::endl; 
     std::cout << "Memory pool size of SgClassSymbol: " <<  listOfMemoryPoolSizes[V_SgClassSymbol] << std::endl; 
     std::cout << "Memory pool size of SgClassType: " <<  listOfMemoryPoolSizes[V_SgClassType] << std::endl; 
     std::cout << "Memory pool size of SgClinkageDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgClinkageDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgClinkageEndStatement: " <<  listOfMemoryPoolSizes[V_SgClinkageEndStatement] << std::endl; 
     std::cout << "Memory pool size of SgClinkageStartStatement: " <<  listOfMemoryPoolSizes[V_SgClinkageStartStatement] << std::endl; 
     std::cout << "Memory pool size of SgCloseStatement: " <<  listOfMemoryPoolSizes[V_SgCloseStatement] << std::endl; 
     std::cout << "Memory pool size of SgColonShapeExp: " <<  listOfMemoryPoolSizes[V_SgColonShapeExp] << std::endl; 
     std::cout << "Memory pool size of SgCommaOpExp: " <<  listOfMemoryPoolSizes[V_SgCommaOpExp] << std::endl; 
     std::cout << "Memory pool size of SgCommonBlock: " <<  listOfMemoryPoolSizes[V_SgCommonBlock] << std::endl; 
     std::cout << "Memory pool size of SgCommonBlockObject: " <<  listOfMemoryPoolSizes[V_SgCommonBlockObject] << std::endl; 
     std::cout << "Memory pool size of SgCommonSymbol: " <<  listOfMemoryPoolSizes[V_SgCommonSymbol] << std::endl; 
     std::cout << "Memory pool size of SgComplexVal: " <<  listOfMemoryPoolSizes[V_SgComplexVal] << std::endl; 
     std::cout << "Memory pool size of SgComprehension: " <<  listOfMemoryPoolSizes[V_SgComprehension] << std::endl; 
     std::cout << "Memory pool size of SgCompoundAssignOp: " <<  listOfMemoryPoolSizes[V_SgCompoundAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgCompoundInitializer: " <<  listOfMemoryPoolSizes[V_SgCompoundInitializer] << std::endl; 
     std::cout << "Memory pool size of SgCompoundLiteralExp: " <<  listOfMemoryPoolSizes[V_SgCompoundLiteralExp] << std::endl; 
     std::cout << "Memory pool size of SgComputedGotoStatement: " <<  listOfMemoryPoolSizes[V_SgComputedGotoStatement] << std::endl; 
     std::cout << "Memory pool size of SgConcatenationOp: " <<  listOfMemoryPoolSizes[V_SgConcatenationOp] << std::endl; 
     std::cout << "Memory pool size of SgConditionalExp: " <<  listOfMemoryPoolSizes[V_SgConditionalExp] << std::endl; 
     std::cout << "Memory pool size of SgConjugateOp: " <<  listOfMemoryPoolSizes[V_SgConjugateOp] << std::endl; 
     std::cout << "Memory pool size of SgConstVolatileModifier: " <<  listOfMemoryPoolSizes[V_SgConstVolatileModifier] << std::endl; 
     std::cout << "Memory pool size of SgConstructorInitializer: " <<  listOfMemoryPoolSizes[V_SgConstructorInitializer] << std::endl; 
     std::cout << "Memory pool size of SgContainsStatement: " <<  listOfMemoryPoolSizes[V_SgContainsStatement] << std::endl; 
     std::cout << "Memory pool size of SgContinueStmt: " <<  listOfMemoryPoolSizes[V_SgContinueStmt] << std::endl; 
     std::cout << "Memory pool size of SgCtorInitializerList: " <<  listOfMemoryPoolSizes[V_SgCtorInitializerList] << std::endl; 
     std::cout << "Memory pool size of SgDataStatementGroup: " <<  listOfMemoryPoolSizes[V_SgDataStatementGroup] << std::endl; 
     std::cout << "Memory pool size of SgDataStatementObject: " <<  listOfMemoryPoolSizes[V_SgDataStatementObject] << std::endl; 
     std::cout << "Memory pool size of SgDataStatementValue: " <<  listOfMemoryPoolSizes[V_SgDataStatementValue] << std::endl; 
     std::cout << "Memory pool size of SgDeadIfDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgDeadIfDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgDeallocateStatement: " <<  listOfMemoryPoolSizes[V_SgDeallocateStatement] << std::endl; 
     std::cout << "Memory pool size of SgDeclarationModifier: " <<  listOfMemoryPoolSizes[V_SgDeclarationModifier] << std::endl; 
     std::cout << "Memory pool size of SgDeclarationScope: " <<  listOfMemoryPoolSizes[V_SgDeclarationScope] << std::endl; 
     std::cout << "Memory pool size of SgDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgDeclType: " <<  listOfMemoryPoolSizes[V_SgDeclType] << std::endl; 
     std::cout << "Memory pool size of SgDefaultOptionStmt: " <<  listOfMemoryPoolSizes[V_SgDefaultOptionStmt] << std::endl; 
     std::cout << "Memory pool size of SgDefaultSymbol: " <<  listOfMemoryPoolSizes[V_SgDefaultSymbol] << std::endl; 
     std::cout << "Memory pool size of SgDefineDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgDefineDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgDeleteExp: " <<  listOfMemoryPoolSizes[V_SgDeleteExp] << std::endl; 
     std::cout << "Memory pool size of SgDerivedTypeStatement: " <<  listOfMemoryPoolSizes[V_SgDerivedTypeStatement] << std::endl; 
     std::cout << "Memory pool size of SgDesignatedInitializer: " <<  listOfMemoryPoolSizes[V_SgDesignatedInitializer] << std::endl; 
     std::cout << "Memory pool size of SgDictionaryComprehension: " <<  listOfMemoryPoolSizes[V_SgDictionaryComprehension] << std::endl; 
     std::cout << "Memory pool size of SgDictionaryExp: " <<  listOfMemoryPoolSizes[V_SgDictionaryExp] << std::endl; 
     std::cout << "Memory pool size of SgDimensionObject: " <<  listOfMemoryPoolSizes[V_SgDimensionObject] << std::endl; 
     std::cout << "Memory pool size of SgDirectedGraphEdge: " <<  listOfMemoryPoolSizes[V_SgDirectedGraphEdge] << std::endl; 
     std::cout << "Memory pool size of SgDirectory: " <<  listOfMemoryPoolSizes[V_SgDirectory] << std::endl; 
     std::cout << "Memory pool size of SgDirectoryList: " <<  listOfMemoryPoolSizes[V_SgDirectoryList] << std::endl; 
     std::cout << "Memory pool size of SgDivAssignOp: " <<  listOfMemoryPoolSizes[V_SgDivAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgDivideOp: " <<  listOfMemoryPoolSizes[V_SgDivideOp] << std::endl; 
     std::cout << "Memory pool size of SgDoWhileStmt: " <<  listOfMemoryPoolSizes[V_SgDoWhileStmt] << std::endl; 
     std::cout << "Memory pool size of SgDotExp: " <<  listOfMemoryPoolSizes[V_SgDotExp] << std::endl; 
     std::cout << "Memory pool size of SgDotStarOp: " <<  listOfMemoryPoolSizes[V_SgDotStarOp] << std::endl; 
     std::cout << "Memory pool size of SgDoubleVal: " <<  listOfMemoryPoolSizes[V_SgDoubleVal] << std::endl; 
     std::cout << "Memory pool size of SgElaboratedTypeModifier: " <<  listOfMemoryPoolSizes[V_SgElaboratedTypeModifier] << std::endl; 
     std::cout << "Memory pool size of SgElementwiseOp: " <<  listOfMemoryPoolSizes[V_SgElementwiseOp] << std::endl; 
     std::cout << "Memory pool size of SgElementwiseAddOp: " <<  listOfMemoryPoolSizes[V_SgElementwiseAddOp] << std::endl; 
     std::cout << "Memory pool size of SgElementwiseDivideOp: " <<  listOfMemoryPoolSizes[V_SgElementwiseDivideOp] << std::endl; 
     std::cout << "Memory pool size of SgElementwiseLeftDivideOp: " <<  listOfMemoryPoolSizes[V_SgElementwiseLeftDivideOp] << std::endl; 
     std::cout << "Memory pool size of SgElementwiseMultiplyOp: " <<  listOfMemoryPoolSizes[V_SgElementwiseMultiplyOp] << std::endl; 
     std::cout << "Memory pool size of SgElementwisePowerOp: " <<  listOfMemoryPoolSizes[V_SgElementwisePowerOp] << std::endl; 
     std::cout << "Memory pool size of SgElementwiseSubtractOp: " <<  listOfMemoryPoolSizes[V_SgElementwiseSubtractOp] << std::endl; 
     std::cout << "Memory pool size of SgElseDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgElseDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgElseWhereStatement: " <<  listOfMemoryPoolSizes[V_SgElseWhereStatement] << std::endl; 
     std::cout << "Memory pool size of SgElseifDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgElseifDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgEmptyDeclaration: " <<  listOfMemoryPoolSizes[V_SgEmptyDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgEmptyDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgEmptyDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgEndfileStatement: " <<  listOfMemoryPoolSizes[V_SgEndfileStatement] << std::endl; 
     std::cout << "Memory pool size of SgEndifDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgEndifDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgEntryStatement: " <<  listOfMemoryPoolSizes[V_SgEntryStatement] << std::endl; 
     std::cout << "Memory pool size of SgEnumDeclaration: " <<  listOfMemoryPoolSizes[V_SgEnumDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgEnumFieldSymbol: " <<  listOfMemoryPoolSizes[V_SgEnumFieldSymbol] << std::endl; 
     std::cout << "Memory pool size of SgEnumSymbol: " <<  listOfMemoryPoolSizes[V_SgEnumSymbol] << std::endl; 
     std::cout << "Memory pool size of SgEnumType: " <<  listOfMemoryPoolSizes[V_SgEnumType] << std::endl; 
     std::cout << "Memory pool size of SgEnumVal: " <<  listOfMemoryPoolSizes[V_SgEnumVal] << std::endl; 
     std::cout << "Memory pool size of SgEqualityOp: " <<  listOfMemoryPoolSizes[V_SgEqualityOp] << std::endl; 
     std::cout << "Memory pool size of SgEquivalenceStatement: " <<  listOfMemoryPoolSizes[V_SgEquivalenceStatement] << std::endl; 
     std::cout << "Memory pool size of SgErrorDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgErrorDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgExecStatement: " <<  listOfMemoryPoolSizes[V_SgExecStatement] << std::endl; 
     std::cout << "Memory pool size of SgExponentiationOp: " <<  listOfMemoryPoolSizes[V_SgExponentiationOp] << std::endl; 
     std::cout << "Memory pool size of SgExponentiationAssignOp: " <<  listOfMemoryPoolSizes[V_SgExponentiationAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgExprListExp: " <<  listOfMemoryPoolSizes[V_SgExprListExp] << std::endl; 
     std::cout << "Memory pool size of SgExprStatement: " <<  listOfMemoryPoolSizes[V_SgExprStatement] << std::endl; 
     std::cout << "Memory pool size of SgExpression: " <<  listOfMemoryPoolSizes[V_SgExpression] << std::endl; 
     std::cout << "Memory pool size of SgExpressionRoot: " <<  listOfMemoryPoolSizes[V_SgExpressionRoot] << std::endl; 
     std::cout << "Memory pool size of SgFile: " <<  listOfMemoryPoolSizes[V_SgFile] << std::endl; 
     std::cout << "Memory pool size of SgFileList: " <<  listOfMemoryPoolSizes[V_SgFileList] << std::endl; 
     std::cout << "Memory pool size of SgFloatVal: " <<  listOfMemoryPoolSizes[V_SgFloatVal] << std::endl; 
     std::cout << "Memory pool size of SgFloat128Val: " <<  listOfMemoryPoolSizes[V_SgFloat128Val] << std::endl; 
     std::cout << "Memory pool size of SgFloat80Val: " <<  listOfMemoryPoolSizes[V_SgFloat80Val] << std::endl; 
     std::cout << "Memory pool size of SgFoldExpression: " <<  listOfMemoryPoolSizes[V_SgFoldExpression] << std::endl; 
     std::cout << "Memory pool size of SgFlushStatement: " <<  listOfMemoryPoolSizes[V_SgFlushStatement] << std::endl; 
     std::cout << "Memory pool size of SgForAllStatement: " <<  listOfMemoryPoolSizes[V_SgForAllStatement] << std::endl; 
     std::cout << "Memory pool size of SgForInitStatement: " <<  listOfMemoryPoolSizes[V_SgForInitStatement] << std::endl; 
     std::cout << "Memory pool size of SgForStatement: " <<  listOfMemoryPoolSizes[V_SgForStatement] << std::endl; 
     std::cout << "Memory pool size of SgFormatItem: " <<  listOfMemoryPoolSizes[V_SgFormatItem] << std::endl; 
     std::cout << "Memory pool size of SgFormatItemList: " <<  listOfMemoryPoolSizes[V_SgFormatItemList] << std::endl; 
     std::cout << "Memory pool size of SgFormatStatement: " <<  listOfMemoryPoolSizes[V_SgFormatStatement] << std::endl; 
     std::cout << "Memory pool size of SgFortranDo: " <<  listOfMemoryPoolSizes[V_SgFortranDo] << std::endl; 
     std::cout << "Memory pool size of SgFortranIncludeLine: " <<  listOfMemoryPoolSizes[V_SgFortranIncludeLine] << std::endl; 
     std::cout << "Memory pool size of SgFortranNonblockedDo: " <<  listOfMemoryPoolSizes[V_SgFortranNonblockedDo] << std::endl; 
     std::cout << "Memory pool size of SgFuncDecl_attr: " <<  listOfMemoryPoolSizes[V_SgFuncDecl_attr] << std::endl; 
     std::cout << "Memory pool size of SgFunctionCallExp: " <<  listOfMemoryPoolSizes[V_SgFunctionCallExp] << std::endl; 
     std::cout << "Memory pool size of SgFunctionDeclaration: " <<  listOfMemoryPoolSizes[V_SgFunctionDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgFunctionDefinition: " <<  listOfMemoryPoolSizes[V_SgFunctionDefinition] << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterScope: " <<  listOfMemoryPoolSizes[V_SgFunctionParameterScope] << std::endl; 
     std::cout << "Memory pool size of SgFunctionModifier: " <<  listOfMemoryPoolSizes[V_SgFunctionModifier] << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterList: " <<  listOfMemoryPoolSizes[V_SgFunctionParameterList] << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterRefExp: " <<  listOfMemoryPoolSizes[V_SgFunctionParameterRefExp] << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterTypeList: " <<  listOfMemoryPoolSizes[V_SgFunctionParameterTypeList] << std::endl; 
     std::cout << "Memory pool size of SgFunctionRefExp: " <<  listOfMemoryPoolSizes[V_SgFunctionRefExp] << std::endl; 
     std::cout << "Memory pool size of SgFunctionSymbol: " <<  listOfMemoryPoolSizes[V_SgFunctionSymbol] << std::endl; 
     std::cout << "Memory pool size of SgFunctionType: " <<  listOfMemoryPoolSizes[V_SgFunctionType] << std::endl; 
     std::cout << "Memory pool size of SgFunctionTypeSymbol: " <<  listOfMemoryPoolSizes[V_SgFunctionTypeSymbol] << std::endl; 
     std::cout << "Memory pool size of SgFunctionTypeTable: " <<  listOfMemoryPoolSizes[V_SgFunctionTypeTable] << std::endl; 
     std::cout << "Memory pool size of SgTypeTable: " <<  listOfMemoryPoolSizes[V_SgTypeTable] << std::endl; 
     std::cout << "Memory pool size of SgGlobal: " <<  listOfMemoryPoolSizes[V_SgGlobal] << std::endl; 
     std::cout << "Memory pool size of SgGotoStatement: " <<  listOfMemoryPoolSizes[V_SgGotoStatement] << std::endl; 
     std::cout << "Memory pool size of SgGraph: " <<  listOfMemoryPoolSizes[V_SgGraph] << std::endl; 
     std::cout << "Memory pool size of SgGraphEdge: " <<  listOfMemoryPoolSizes[V_SgGraphEdge] << std::endl; 
     std::cout << "Memory pool size of SgGraphEdgeList: " <<  listOfMemoryPoolSizes[V_SgGraphEdgeList] << std::endl; 
     std::cout << "Memory pool size of SgGraphNode: " <<  listOfMemoryPoolSizes[V_SgGraphNode] << std::endl; 
     std::cout << "Memory pool size of SgGraphNodeList: " <<  listOfMemoryPoolSizes[V_SgGraphNodeList] << std::endl; 
     std::cout << "Memory pool size of SgGreaterOrEqualOp: " <<  listOfMemoryPoolSizes[V_SgGreaterOrEqualOp] << std::endl; 
     std::cout << "Memory pool size of SgGreaterThanOp: " <<  listOfMemoryPoolSizes[V_SgGreaterThanOp] << std::endl; 
     std::cout << "Memory pool size of SgIOItemExpression: " <<  listOfMemoryPoolSizes[V_SgIOItemExpression] << std::endl; 
     std::cout << "Memory pool size of SgIOStatement: " <<  listOfMemoryPoolSizes[V_SgIOStatement] << std::endl; 
     std::cout << "Memory pool size of SgIdentDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIdentDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgIfDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIfDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgIfStmt: " <<  listOfMemoryPoolSizes[V_SgIfStmt] << std::endl; 
     std::cout << "Memory pool size of SgIfdefDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIfdefDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgIfndefDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIfndefDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgImageControlStatement: " <<  listOfMemoryPoolSizes[V_SgImageControlStatement] << std::endl; 
     std::cout << "Memory pool size of SgImagPartOp: " <<  listOfMemoryPoolSizes[V_SgImagPartOp] << std::endl; 
     std::cout << "Memory pool size of SgImplicitStatement: " <<  listOfMemoryPoolSizes[V_SgImplicitStatement] << std::endl; 
     std::cout << "Memory pool size of SgImpliedDo: " <<  listOfMemoryPoolSizes[V_SgImpliedDo] << std::endl; 
     std::cout << "Memory pool size of SgImportStatement: " <<  listOfMemoryPoolSizes[V_SgImportStatement] << std::endl; 
     std::cout << "Memory pool size of SgIncidenceDirectedGraph: " <<  listOfMemoryPoolSizes[V_SgIncidenceDirectedGraph] << std::endl; 
     std::cout << "Memory pool size of SgIncidenceUndirectedGraph: " <<  listOfMemoryPoolSizes[V_SgIncidenceUndirectedGraph] << std::endl; 
     std::cout << "Memory pool size of SgIncludeDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIncludeDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgIncludeFile: " <<  listOfMemoryPoolSizes[V_SgIncludeFile] << std::endl; 
     std::cout << "Memory pool size of SgIncludeNextDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIncludeNextDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgInitializedName: " <<  listOfMemoryPoolSizes[V_SgInitializedName] << std::endl; 
     std::cout << "Memory pool size of SgInitializer: " <<  listOfMemoryPoolSizes[V_SgInitializer] << std::endl; 
     std::cout << "Memory pool size of SgInquireStatement: " <<  listOfMemoryPoolSizes[V_SgInquireStatement] << std::endl; 
     std::cout << "Memory pool size of SgIntKeyedBidirectionalGraph: " <<  listOfMemoryPoolSizes[V_SgIntKeyedBidirectionalGraph] << std::endl; 
     std::cout << "Memory pool size of SgIntVal: " <<  listOfMemoryPoolSizes[V_SgIntVal] << std::endl; 
     std::cout << "Memory pool size of SgIntegerDivideOp: " <<  listOfMemoryPoolSizes[V_SgIntegerDivideOp] << std::endl; 
     std::cout << "Memory pool size of SgIntegerDivideAssignOp: " <<  listOfMemoryPoolSizes[V_SgIntegerDivideAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgInterfaceBody: " <<  listOfMemoryPoolSizes[V_SgInterfaceBody] << std::endl; 
     std::cout << "Memory pool size of SgHeaderFileBody: " <<  listOfMemoryPoolSizes[V_SgHeaderFileBody] << std::endl; 
     std::cout << "Memory pool size of SgHeaderFileReport: " <<  listOfMemoryPoolSizes[V_SgHeaderFileReport] << std::endl; 
     std::cout << "Memory pool size of SgInterfaceStatement: " <<  listOfMemoryPoolSizes[V_SgInterfaceStatement] << std::endl; 
     std::cout << "Memory pool size of SgInterfaceSymbol: " <<  listOfMemoryPoolSizes[V_SgInterfaceSymbol] << std::endl; 
     std::cout << "Memory pool size of SgIntrinsicSymbol: " <<  listOfMemoryPoolSizes[V_SgIntrinsicSymbol] << std::endl; 
     std::cout << "Memory pool size of SgIsOp: " <<  listOfMemoryPoolSizes[V_SgIsOp] << std::endl; 
     std::cout << "Memory pool size of SgIsNotOp: " <<  listOfMemoryPoolSizes[V_SgIsNotOp] << std::endl; 
     std::cout << "Memory pool size of SgIorAssignOp: " <<  listOfMemoryPoolSizes[V_SgIorAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgJovialBitType: " <<  listOfMemoryPoolSizes[V_SgJovialBitType] << std::endl; 
     std::cout << "Memory pool size of SgJovialBitVal: " <<  listOfMemoryPoolSizes[V_SgJovialBitVal] << std::endl; 
     std::cout << "Memory pool size of SgJovialTableType: " <<  listOfMemoryPoolSizes[V_SgJovialTableType] << std::endl; 
     std::cout << "Memory pool size of SgJovialCompoolStatement: " <<  listOfMemoryPoolSizes[V_SgJovialCompoolStatement] << std::endl; 
     std::cout << "Memory pool size of SgJovialForThenStatement: " <<  listOfMemoryPoolSizes[V_SgJovialForThenStatement] << std::endl; 
     std::cout << "Memory pool size of SgJovialDefineDeclaration: " <<  listOfMemoryPoolSizes[V_SgJovialDefineDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgJovialDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgJovialDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgJovialOverlayDeclaration: " <<  listOfMemoryPoolSizes[V_SgJovialOverlayDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgJovialPresetPositionExp: " <<  listOfMemoryPoolSizes[V_SgJovialPresetPositionExp] << std::endl; 
     std::cout << "Memory pool size of SgJovialTablePresetExp: " <<  listOfMemoryPoolSizes[V_SgJovialTablePresetExp] << std::endl; 
     std::cout << "Memory pool size of SgJovialTableStatement: " <<  listOfMemoryPoolSizes[V_SgJovialTableStatement] << std::endl; 
     std::cout << "Memory pool size of SgKeyDatumPair: " <<  listOfMemoryPoolSizes[V_SgKeyDatumPair] << std::endl; 
     std::cout << "Memory pool size of SgCudaKernelExecConfig: " <<  listOfMemoryPoolSizes[V_SgCudaKernelExecConfig] << std::endl; 
     std::cout << "Memory pool size of SgCudaKernelCallExp: " <<  listOfMemoryPoolSizes[V_SgCudaKernelCallExp] << std::endl; 
     std::cout << "Memory pool size of SgLabelRefExp: " <<  listOfMemoryPoolSizes[V_SgLabelRefExp] << std::endl; 
     std::cout << "Memory pool size of SgLabelStatement: " <<  listOfMemoryPoolSizes[V_SgLabelStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaLabelStatement: " <<  listOfMemoryPoolSizes[V_SgJavaLabelStatement] << std::endl; 
     std::cout << "Memory pool size of SgLabelSymbol: " <<  listOfMemoryPoolSizes[V_SgLabelSymbol] << std::endl; 
     std::cout << "Memory pool size of SgJavaLabelSymbol: " <<  listOfMemoryPoolSizes[V_SgJavaLabelSymbol] << std::endl; 
     std::cout << "Memory pool size of SgLambdaCapture: " <<  listOfMemoryPoolSizes[V_SgLambdaCapture] << std::endl; 
     std::cout << "Memory pool size of SgLambdaCaptureList: " <<  listOfMemoryPoolSizes[V_SgLambdaCaptureList] << std::endl; 
     std::cout << "Memory pool size of SgLambdaExp: " <<  listOfMemoryPoolSizes[V_SgLambdaExp] << std::endl; 
     std::cout << "Memory pool size of SgLambdaRefExp: " <<  listOfMemoryPoolSizes[V_SgLambdaRefExp] << std::endl; 
     std::cout << "Memory pool size of SgLeftDivideOp: " <<  listOfMemoryPoolSizes[V_SgLeftDivideOp] << std::endl; 
     std::cout << "Memory pool size of SgLessOrEqualOp: " <<  listOfMemoryPoolSizes[V_SgLessOrEqualOp] << std::endl; 
     std::cout << "Memory pool size of SgLessThanOp: " <<  listOfMemoryPoolSizes[V_SgLessThanOp] << std::endl; 
     std::cout << "Memory pool size of SgLineDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgLineDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgLinemarkerDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgLinemarkerDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgLinkageModifier: " <<  listOfMemoryPoolSizes[V_SgLinkageModifier] << std::endl; 
     std::cout << "Memory pool size of SgListComprehension: " <<  listOfMemoryPoolSizes[V_SgListComprehension] << std::endl; 
     std::cout << "Memory pool size of SgListExp: " <<  listOfMemoryPoolSizes[V_SgListExp] << std::endl; 
     std::cout << "Memory pool size of SgLocatedNode: " <<  listOfMemoryPoolSizes[V_SgLocatedNode] << std::endl; 
     std::cout << "Memory pool size of SgLocatedNodeSupport: " <<  listOfMemoryPoolSizes[V_SgLocatedNodeSupport] << std::endl; 
     std::cout << "Memory pool size of SgLongDoubleVal: " <<  listOfMemoryPoolSizes[V_SgLongDoubleVal] << std::endl; 
     std::cout << "Memory pool size of SgLongIntVal: " <<  listOfMemoryPoolSizes[V_SgLongIntVal] << std::endl; 
     std::cout << "Memory pool size of SgLongLongIntVal: " <<  listOfMemoryPoolSizes[V_SgLongLongIntVal] << std::endl; 
     std::cout << "Memory pool size of SgLshiftAssignOp: " <<  listOfMemoryPoolSizes[V_SgLshiftAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgLshiftOp: " <<  listOfMemoryPoolSizes[V_SgLshiftOp] << std::endl; 
     std::cout << "Memory pool size of SgMagicColonExp: " <<  listOfMemoryPoolSizes[V_SgMagicColonExp] << std::endl; 
     std::cout << "Memory pool size of SgMatrixExp: " <<  listOfMemoryPoolSizes[V_SgMatrixExp] << std::endl; 
     std::cout << "Memory pool size of SgMatrixTransposeOp: " <<  listOfMemoryPoolSizes[V_SgMatrixTransposeOp] << std::endl; 
     std::cout << "Memory pool size of SgMatlabForStatement: " <<  listOfMemoryPoolSizes[V_SgMatlabForStatement] << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionDeclaration: " <<  listOfMemoryPoolSizes[V_SgMemberFunctionDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionRefExp: " <<  listOfMemoryPoolSizes[V_SgMemberFunctionRefExp] << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionSymbol: " <<  listOfMemoryPoolSizes[V_SgMemberFunctionSymbol] << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionType: " <<  listOfMemoryPoolSizes[V_SgMemberFunctionType] << std::endl; 
     std::cout << "Memory pool size of SgMembershipOp: " <<  listOfMemoryPoolSizes[V_SgMembershipOp] << std::endl; 
     std::cout << "Memory pool size of SgMicrosoftAttributeDeclaration: " <<  listOfMemoryPoolSizes[V_SgMicrosoftAttributeDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgMinusAssignOp: " <<  listOfMemoryPoolSizes[V_SgMinusAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgMinusMinusOp: " <<  listOfMemoryPoolSizes[V_SgMinusMinusOp] << std::endl; 
     std::cout << "Memory pool size of SgMinusOp: " <<  listOfMemoryPoolSizes[V_SgMinusOp] << std::endl; 
     std::cout << "Memory pool size of SgModAssignOp: " <<  listOfMemoryPoolSizes[V_SgModAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgModOp: " <<  listOfMemoryPoolSizes[V_SgModOp] << std::endl; 
     std::cout << "Memory pool size of SgModifier: " <<  listOfMemoryPoolSizes[V_SgModifier] << std::endl; 
     std::cout << "Memory pool size of SgModifierNodes: " <<  listOfMemoryPoolSizes[V_SgModifierNodes] << std::endl; 
     std::cout << "Memory pool size of SgModifierType: " <<  listOfMemoryPoolSizes[V_SgModifierType] << std::endl; 
     std::cout << "Memory pool size of SgModuleStatement: " <<  listOfMemoryPoolSizes[V_SgModuleStatement] << std::endl; 
     std::cout << "Memory pool size of SgModuleSymbol: " <<  listOfMemoryPoolSizes[V_SgModuleSymbol] << std::endl; 
     std::cout << "Memory pool size of SgMultAssignOp: " <<  listOfMemoryPoolSizes[V_SgMultAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgMultiplyOp: " <<  listOfMemoryPoolSizes[V_SgMultiplyOp] << std::endl; 
     std::cout << "Memory pool size of SgName: " <<  listOfMemoryPoolSizes[V_SgName] << std::endl; 
     std::cout << "Memory pool size of SgNameGroup: " <<  listOfMemoryPoolSizes[V_SgNameGroup] << std::endl; 
     std::cout << "Memory pool size of SgNamedType: " <<  listOfMemoryPoolSizes[V_SgNamedType] << std::endl; 
     std::cout << "Memory pool size of SgNamelistStatement: " <<  listOfMemoryPoolSizes[V_SgNamelistStatement] << std::endl; 
     std::cout << "Memory pool size of SgNamespaceAliasDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgNamespaceAliasDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgNamespaceDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgNamespaceDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgNamespaceDefinitionStatement: " <<  listOfMemoryPoolSizes[V_SgNamespaceDefinitionStatement] << std::endl; 
     std::cout << "Memory pool size of SgNamespaceSymbol: " <<  listOfMemoryPoolSizes[V_SgNamespaceSymbol] << std::endl; 
     std::cout << "Memory pool size of SgNaryOp: " <<  listOfMemoryPoolSizes[V_SgNaryOp] << std::endl; 
     std::cout << "Memory pool size of SgNaryBooleanOp: " <<  listOfMemoryPoolSizes[V_SgNaryBooleanOp] << std::endl; 
     std::cout << "Memory pool size of SgNaryComparisonOp: " <<  listOfMemoryPoolSizes[V_SgNaryComparisonOp] << std::endl; 
     std::cout << "Memory pool size of SgNewExp: " <<  listOfMemoryPoolSizes[V_SgNewExp] << std::endl; 
     std::cout << "Memory pool size of SgNode: " <<  listOfMemoryPoolSizes[V_SgNode] << std::endl; 
     std::cout << "Memory pool size of SgNoexceptOp: " <<  listOfMemoryPoolSizes[V_SgNoexceptOp] << std::endl; 
     std::cout << "Memory pool size of SgNotEqualOp: " <<  listOfMemoryPoolSizes[V_SgNotEqualOp] << std::endl; 
     std::cout << "Memory pool size of SgNotOp: " <<  listOfMemoryPoolSizes[V_SgNotOp] << std::endl; 
     std::cout << "Memory pool size of SgNonMembershipOp: " <<  listOfMemoryPoolSizes[V_SgNonMembershipOp] << std::endl; 
     std::cout << "Memory pool size of SgNonrealDecl: " <<  listOfMemoryPoolSizes[V_SgNonrealDecl] << std::endl; 
     std::cout << "Memory pool size of SgNonrealRefExp: " <<  listOfMemoryPoolSizes[V_SgNonrealRefExp] << std::endl; 
     std::cout << "Memory pool size of SgNonrealSymbol: " <<  listOfMemoryPoolSizes[V_SgNonrealSymbol] << std::endl; 
     std::cout << "Memory pool size of SgNonrealType: " <<  listOfMemoryPoolSizes[V_SgNonrealType] << std::endl; 
     std::cout << "Memory pool size of SgNonrealBaseClass: " <<  listOfMemoryPoolSizes[V_SgNonrealBaseClass] << std::endl; 
     std::cout << "Memory pool size of SgNullExpression: " <<  listOfMemoryPoolSizes[V_SgNullExpression] << std::endl; 
     std::cout << "Memory pool size of SgNullptrValExp: " <<  listOfMemoryPoolSizes[V_SgNullptrValExp] << std::endl; 
     std::cout << "Memory pool size of SgNullStatement: " <<  listOfMemoryPoolSizes[V_SgNullStatement] << std::endl; 
     std::cout << "Memory pool size of SgNullifyStatement: " <<  listOfMemoryPoolSizes[V_SgNullifyStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpAtomicStatement: " <<  listOfMemoryPoolSizes[V_SgOmpAtomicStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpBarrierStatement: " <<  listOfMemoryPoolSizes[V_SgOmpBarrierStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpCriticalStatement: " <<  listOfMemoryPoolSizes[V_SgOmpCriticalStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpClauseBodyStatement: " <<  listOfMemoryPoolSizes[V_SgOmpClauseBodyStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpBodyStatement: " <<  listOfMemoryPoolSizes[V_SgOmpBodyStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpDoStatement: " <<  listOfMemoryPoolSizes[V_SgOmpDoStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpFlushStatement: " <<  listOfMemoryPoolSizes[V_SgOmpFlushStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpDeclareSimdStatement: " <<  listOfMemoryPoolSizes[V_SgOmpDeclareSimdStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpForStatement: " <<  listOfMemoryPoolSizes[V_SgOmpForStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpForSimdStatement: " <<  listOfMemoryPoolSizes[V_SgOmpForSimdStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpMasterStatement: " <<  listOfMemoryPoolSizes[V_SgOmpMasterStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpOrderedStatement: " <<  listOfMemoryPoolSizes[V_SgOmpOrderedStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpParallelStatement: " <<  listOfMemoryPoolSizes[V_SgOmpParallelStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpSectionStatement: " <<  listOfMemoryPoolSizes[V_SgOmpSectionStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpSectionsStatement: " <<  listOfMemoryPoolSizes[V_SgOmpSectionsStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpSingleStatement: " <<  listOfMemoryPoolSizes[V_SgOmpSingleStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpTaskStatement: " <<  listOfMemoryPoolSizes[V_SgOmpTaskStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpTaskwaitStatement: " <<  listOfMemoryPoolSizes[V_SgOmpTaskwaitStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpThreadprivateStatement: " <<  listOfMemoryPoolSizes[V_SgOmpThreadprivateStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpWorkshareStatement: " <<  listOfMemoryPoolSizes[V_SgOmpWorkshareStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpTargetStatement: " <<  listOfMemoryPoolSizes[V_SgOmpTargetStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpTargetDataStatement: " <<  listOfMemoryPoolSizes[V_SgOmpTargetDataStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpSimdStatement: " <<  listOfMemoryPoolSizes[V_SgOmpSimdStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpClause: " <<  listOfMemoryPoolSizes[V_SgOmpClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpBeginClause: " <<  listOfMemoryPoolSizes[V_SgOmpBeginClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpCollapseClause: " <<  listOfMemoryPoolSizes[V_SgOmpCollapseClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpCopyinClause: " <<  listOfMemoryPoolSizes[V_SgOmpCopyinClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpCopyprivateClause: " <<  listOfMemoryPoolSizes[V_SgOmpCopyprivateClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpDefaultClause: " <<  listOfMemoryPoolSizes[V_SgOmpDefaultClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpEndClause: " <<  listOfMemoryPoolSizes[V_SgOmpEndClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpExpressionClause: " <<  listOfMemoryPoolSizes[V_SgOmpExpressionClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpFirstprivateClause: " <<  listOfMemoryPoolSizes[V_SgOmpFirstprivateClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpIfClause: " <<  listOfMemoryPoolSizes[V_SgOmpIfClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpFinalClause: " <<  listOfMemoryPoolSizes[V_SgOmpFinalClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpPriorityClause: " <<  listOfMemoryPoolSizes[V_SgOmpPriorityClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpDeviceClause: " <<  listOfMemoryPoolSizes[V_SgOmpDeviceClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpLastprivateClause: " <<  listOfMemoryPoolSizes[V_SgOmpLastprivateClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpNowaitClause: " <<  listOfMemoryPoolSizes[V_SgOmpNowaitClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpNumThreadsClause: " <<  listOfMemoryPoolSizes[V_SgOmpNumThreadsClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpOrderedClause: " <<  listOfMemoryPoolSizes[V_SgOmpOrderedClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpPrivateClause: " <<  listOfMemoryPoolSizes[V_SgOmpPrivateClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpReductionClause: " <<  listOfMemoryPoolSizes[V_SgOmpReductionClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpScheduleClause: " <<  listOfMemoryPoolSizes[V_SgOmpScheduleClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpSharedClause: " <<  listOfMemoryPoolSizes[V_SgOmpSharedClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpUntiedClause: " <<  listOfMemoryPoolSizes[V_SgOmpUntiedClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpMergeableClause: " <<  listOfMemoryPoolSizes[V_SgOmpMergeableClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpVariablesClause: " <<  listOfMemoryPoolSizes[V_SgOmpVariablesClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpMapClause: " <<  listOfMemoryPoolSizes[V_SgOmpMapClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpSafelenClause: " <<  listOfMemoryPoolSizes[V_SgOmpSafelenClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpSimdlenClause: " <<  listOfMemoryPoolSizes[V_SgOmpSimdlenClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpLinearClause: " <<  listOfMemoryPoolSizes[V_SgOmpLinearClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpUniformClause: " <<  listOfMemoryPoolSizes[V_SgOmpUniformClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpAlignedClause: " <<  listOfMemoryPoolSizes[V_SgOmpAlignedClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpProcBindClause: " <<  listOfMemoryPoolSizes[V_SgOmpProcBindClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpAtomicClause: " <<  listOfMemoryPoolSizes[V_SgOmpAtomicClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpInbranchClause: " <<  listOfMemoryPoolSizes[V_SgOmpInbranchClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpNotinbranchClause: " <<  listOfMemoryPoolSizes[V_SgOmpNotinbranchClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpDependClause: " <<  listOfMemoryPoolSizes[V_SgOmpDependClause] << std::endl; 
     std::cout << "Memory pool size of SgOpenclAccessModeModifier: " <<  listOfMemoryPoolSizes[V_SgOpenclAccessModeModifier] << std::endl; 
     std::cout << "Memory pool size of SgOpenStatement: " <<  listOfMemoryPoolSizes[V_SgOpenStatement] << std::endl; 
     std::cout << "Memory pool size of SgOptions: " <<  listOfMemoryPoolSizes[V_SgOptions] << std::endl; 
     std::cout << "Memory pool size of SgOrOp: " <<  listOfMemoryPoolSizes[V_SgOrOp] << std::endl; 
     std::cout << "Memory pool size of SgParameterStatement: " <<  listOfMemoryPoolSizes[V_SgParameterStatement] << std::endl; 
     std::cout << "Memory pool size of SgPartialFunctionModifierType: " <<  listOfMemoryPoolSizes[V_SgPartialFunctionModifierType] << std::endl; 
     std::cout << "Memory pool size of SgPartialFunctionType: " <<  listOfMemoryPoolSizes[V_SgPartialFunctionType] << std::endl; 
     std::cout << "Memory pool size of SgPassStatement: " <<  listOfMemoryPoolSizes[V_SgPassStatement] << std::endl; 
     std::cout << "Memory pool size of SgPlusAssignOp: " <<  listOfMemoryPoolSizes[V_SgPlusAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgPlusPlusOp: " <<  listOfMemoryPoolSizes[V_SgPlusPlusOp] << std::endl; 
     std::cout << "Memory pool size of SgPntrArrRefExp: " <<  listOfMemoryPoolSizes[V_SgPntrArrRefExp] << std::endl; 
     std::cout << "Memory pool size of SgPointerAssignOp: " <<  listOfMemoryPoolSizes[V_SgPointerAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgPointerDerefExp: " <<  listOfMemoryPoolSizes[V_SgPointerDerefExp] << std::endl; 
     std::cout << "Memory pool size of SgPointerMemberType: " <<  listOfMemoryPoolSizes[V_SgPointerMemberType] << std::endl; 
     std::cout << "Memory pool size of SgPointerType: " <<  listOfMemoryPoolSizes[V_SgPointerType] << std::endl; 
     std::cout << "Memory pool size of SgPowerOp: " <<  listOfMemoryPoolSizes[V_SgPowerOp] << std::endl; 
     std::cout << "Memory pool size of SgPragma: " <<  listOfMemoryPoolSizes[V_SgPragma] << std::endl; 
     std::cout << "Memory pool size of SgPragmaDeclaration: " <<  listOfMemoryPoolSizes[V_SgPragmaDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgPrintStatement: " <<  listOfMemoryPoolSizes[V_SgPrintStatement] << std::endl; 
     std::cout << "Memory pool size of SgProcedureHeaderStatement: " <<  listOfMemoryPoolSizes[V_SgProcedureHeaderStatement] << std::endl; 
     std::cout << "Memory pool size of SgProgramHeaderStatement: " <<  listOfMemoryPoolSizes[V_SgProgramHeaderStatement] << std::endl; 
     std::cout << "Memory pool size of SgProject: " <<  listOfMemoryPoolSizes[V_SgProject] << std::endl; 
     std::cout << "Memory pool size of SgPseudoDestructorRefExp: " <<  listOfMemoryPoolSizes[V_SgPseudoDestructorRefExp] << std::endl; 
     std::cout << "Memory pool size of SgPythonGlobalStmt: " <<  listOfMemoryPoolSizes[V_SgPythonGlobalStmt] << std::endl; 
     std::cout << "Memory pool size of SgPythonPrintStmt: " <<  listOfMemoryPoolSizes[V_SgPythonPrintStmt] << std::endl; 
     std::cout << "Memory pool size of SgQualifiedName: " <<  listOfMemoryPoolSizes[V_SgQualifiedName] << std::endl; 
     std::cout << "Memory pool size of SgQualifiedNameType: " <<  listOfMemoryPoolSizes[V_SgQualifiedNameType] << std::endl; 
     std::cout << "Memory pool size of SgRangeExp: " <<  listOfMemoryPoolSizes[V_SgRangeExp] << std::endl; 
     std::cout << "Memory pool size of SgRangeBasedForStatement: " <<  listOfMemoryPoolSizes[V_SgRangeBasedForStatement] << std::endl; 
     std::cout << "Memory pool size of SgReadStatement: " <<  listOfMemoryPoolSizes[V_SgReadStatement] << std::endl; 
     std::cout << "Memory pool size of SgRealPartOp: " <<  listOfMemoryPoolSizes[V_SgRealPartOp] << std::endl; 
     std::cout << "Memory pool size of SgRefExp: " <<  listOfMemoryPoolSizes[V_SgRefExp] << std::endl; 
     std::cout << "Memory pool size of SgReferenceType: " <<  listOfMemoryPoolSizes[V_SgReferenceType] << std::endl; 
     std::cout << "Memory pool size of SgRemOp: " <<  listOfMemoryPoolSizes[V_SgRemOp] << std::endl; 
     std::cout << "Memory pool size of SgRenamePair: " <<  listOfMemoryPoolSizes[V_SgRenamePair] << std::endl; 
     std::cout << "Memory pool size of SgRenameSymbol: " <<  listOfMemoryPoolSizes[V_SgRenameSymbol] << std::endl; 
     std::cout << "Memory pool size of SgReplicationOp: " <<  listOfMemoryPoolSizes[V_SgReplicationOp] << std::endl; 
     std::cout << "Memory pool size of SgReturnStmt: " <<  listOfMemoryPoolSizes[V_SgReturnStmt] << std::endl; 
     std::cout << "Memory pool size of SgRewindStatement: " <<  listOfMemoryPoolSizes[V_SgRewindStatement] << std::endl; 
     std::cout << "Memory pool size of SgRshiftAssignOp: " <<  listOfMemoryPoolSizes[V_SgRshiftAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgRshiftOp: " <<  listOfMemoryPoolSizes[V_SgRshiftOp] << std::endl; 
     std::cout << "Memory pool size of SgRvalueReferenceType: " <<  listOfMemoryPoolSizes[V_SgRvalueReferenceType] << std::endl; 
     std::cout << "Memory pool size of SgJavaUnsignedRshiftAssignOp: " <<  listOfMemoryPoolSizes[V_SgJavaUnsignedRshiftAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgJavaUnsignedRshiftOp: " <<  listOfMemoryPoolSizes[V_SgJavaUnsignedRshiftOp] << std::endl; 
     std::cout << "Memory pool size of SgScopeOp: " <<  listOfMemoryPoolSizes[V_SgScopeOp] << std::endl; 
     std::cout << "Memory pool size of SgScopeStatement: " <<  listOfMemoryPoolSizes[V_SgScopeStatement] << std::endl; 
     std::cout << "Memory pool size of SgSequenceStatement: " <<  listOfMemoryPoolSizes[V_SgSequenceStatement] << std::endl; 
     std::cout << "Memory pool size of SgSetComprehension: " <<  listOfMemoryPoolSizes[V_SgSetComprehension] << std::endl; 
     std::cout << "Memory pool size of SgShortVal: " <<  listOfMemoryPoolSizes[V_SgShortVal] << std::endl; 
     std::cout << "Memory pool size of SgSizeOfOp: " <<  listOfMemoryPoolSizes[V_SgSizeOfOp] << std::endl; 
     std::cout << "Memory pool size of SgAlignOfOp: " <<  listOfMemoryPoolSizes[V_SgAlignOfOp] << std::endl; 
     std::cout << "Memory pool size of SgJavaInstanceOfOp: " <<  listOfMemoryPoolSizes[V_SgJavaInstanceOfOp] << std::endl; 
     std::cout << "Memory pool size of SgSourceFile: " <<  listOfMemoryPoolSizes[V_SgSourceFile] << std::endl; 
     std::cout << "Memory pool size of SgSpaceshipOp: " <<  listOfMemoryPoolSizes[V_SgSpaceshipOp] << std::endl; 
     std::cout << "Memory pool size of SgSpawnStmt: " <<  listOfMemoryPoolSizes[V_SgSpawnStmt] << std::endl; 
     std::cout << "Memory pool size of SgSyncAllStatement: " <<  listOfMemoryPoolSizes[V_SgSyncAllStatement] << std::endl; 
     std::cout << "Memory pool size of SgSyncImagesStatement: " <<  listOfMemoryPoolSizes[V_SgSyncImagesStatement] << std::endl; 
     std::cout << "Memory pool size of SgSyncMemoryStatement: " <<  listOfMemoryPoolSizes[V_SgSyncMemoryStatement] << std::endl; 
     std::cout << "Memory pool size of SgSyncTeamStatement: " <<  listOfMemoryPoolSizes[V_SgSyncTeamStatement] << std::endl; 
     std::cout << "Memory pool size of SgLockStatement: " <<  listOfMemoryPoolSizes[V_SgLockStatement] << std::endl; 
     std::cout << "Memory pool size of SgUnlockStatement: " <<  listOfMemoryPoolSizes[V_SgUnlockStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaThrowStatement: " <<  listOfMemoryPoolSizes[V_SgJavaThrowStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaForEachStatement: " <<  listOfMemoryPoolSizes[V_SgJavaForEachStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaSynchronizedStatement: " <<  listOfMemoryPoolSizes[V_SgJavaSynchronizedStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaParameterizedType: " <<  listOfMemoryPoolSizes[V_SgJavaParameterizedType] << std::endl; 
     std::cout << "Memory pool size of SgJavaWildcardType: " <<  listOfMemoryPoolSizes[V_SgJavaWildcardType] << std::endl; 
     std::cout << "Memory pool size of SgProcessControlStatement: " <<  listOfMemoryPoolSizes[V_SgProcessControlStatement] << std::endl; 
     std::cout << "Memory pool size of SgSpecialFunctionModifier: " <<  listOfMemoryPoolSizes[V_SgSpecialFunctionModifier] << std::endl; 
     std::cout << "Memory pool size of SgStatement: " <<  listOfMemoryPoolSizes[V_SgStatement] << std::endl; 
     std::cout << "Memory pool size of SgStaticAssertionDeclaration: " <<  listOfMemoryPoolSizes[V_SgStaticAssertionDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgStmtDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgStmtDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgStatementExpression: " <<  listOfMemoryPoolSizes[V_SgStatementExpression] << std::endl; 
     std::cout << "Memory pool size of SgStatementFunctionStatement: " <<  listOfMemoryPoolSizes[V_SgStatementFunctionStatement] << std::endl; 
     std::cout << "Memory pool size of SgStorageModifier: " <<  listOfMemoryPoolSizes[V_SgStorageModifier] << std::endl; 
     std::cout << "Memory pool size of SgStringConversion: " <<  listOfMemoryPoolSizes[V_SgStringConversion] << std::endl; 
     std::cout << "Memory pool size of SgStringKeyedBidirectionalGraph: " <<  listOfMemoryPoolSizes[V_SgStringKeyedBidirectionalGraph] << std::endl; 
     std::cout << "Memory pool size of SgStringVal: " <<  listOfMemoryPoolSizes[V_SgStringVal] << std::endl; 
     std::cout << "Memory pool size of SgStructureModifier: " <<  listOfMemoryPoolSizes[V_SgStructureModifier] << std::endl; 
     std::cout << "Memory pool size of SgSubscriptExpression: " <<  listOfMemoryPoolSizes[V_SgSubscriptExpression] << std::endl; 
     std::cout << "Memory pool size of SgSubtractOp: " <<  listOfMemoryPoolSizes[V_SgSubtractOp] << std::endl; 
     std::cout << "Memory pool size of SgSupport: " <<  listOfMemoryPoolSizes[V_SgSupport] << std::endl; 
     std::cout << "Memory pool size of SgSwitchStatement: " <<  listOfMemoryPoolSizes[V_SgSwitchStatement] << std::endl; 
     std::cout << "Memory pool size of SgSymbol: " <<  listOfMemoryPoolSizes[V_SgSymbol] << std::endl; 
     std::cout << "Memory pool size of SgSymbolTable: " <<  listOfMemoryPoolSizes[V_SgSymbolTable] << std::endl; 
     std::cout << "Memory pool size of SgTemplateArgument: " <<  listOfMemoryPoolSizes[V_SgTemplateArgument] << std::endl; 
     std::cout << "Memory pool size of SgTemplateArgumentList: " <<  listOfMemoryPoolSizes[V_SgTemplateArgumentList] << std::endl; 
     std::cout << "Memory pool size of SgTemplateDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateClassDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassSymbol: " <<  listOfMemoryPoolSizes[V_SgTemplateClassSymbol] << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateFunctionDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionRefExp: " <<  listOfMemoryPoolSizes[V_SgTemplateFunctionRefExp] << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionSymbol: " <<  listOfMemoryPoolSizes[V_SgTemplateFunctionSymbol] << std::endl; 
     std::cout << "Memory pool size of SgTemplateMemberFunctionDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateMemberFunctionDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateMemberFunctionRefExp: " <<  listOfMemoryPoolSizes[V_SgTemplateMemberFunctionRefExp] << std::endl; 
     std::cout << "Memory pool size of SgTemplateMemberFunctionSymbol: " <<  listOfMemoryPoolSizes[V_SgTemplateMemberFunctionSymbol] << std::endl; 
     std::cout << "Memory pool size of SgTemplateTypedefDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateTypedefDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateTypedefSymbol: " <<  listOfMemoryPoolSizes[V_SgTemplateTypedefSymbol] << std::endl; 
     std::cout << "Memory pool size of SgTemplateVariableDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateVariableDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateVariableSymbol: " <<  listOfMemoryPoolSizes[V_SgTemplateVariableSymbol] << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassDefinition: " <<  listOfMemoryPoolSizes[V_SgTemplateClassDefinition] << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionDefinition: " <<  listOfMemoryPoolSizes[V_SgTemplateFunctionDefinition] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDecl: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationDecl] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDefn: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationDefn] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationFunctionDecl: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationFunctionDecl] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationMemberFunctionDecl: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationMemberFunctionDecl] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationTypedefDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationTypedefDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameter: " <<  listOfMemoryPoolSizes[V_SgTemplateParameter] << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameterVal: " <<  listOfMemoryPoolSizes[V_SgTemplateParameterVal] << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameterList: " <<  listOfMemoryPoolSizes[V_SgTemplateParameterList] << std::endl; 
     std::cout << "Memory pool size of SgTemplateSymbol: " <<  listOfMemoryPoolSizes[V_SgTemplateSymbol] << std::endl; 
     std::cout << "Memory pool size of SgTemplateType: " <<  listOfMemoryPoolSizes[V_SgTemplateType] << std::endl; 
     std::cout << "Memory pool size of SgThisExp: " <<  listOfMemoryPoolSizes[V_SgThisExp] << std::endl; 
     std::cout << "Memory pool size of SgTypeTraitBuiltinOperator: " <<  listOfMemoryPoolSizes[V_SgTypeTraitBuiltinOperator] << std::endl; 
     std::cout << "Memory pool size of SgSuperExp: " <<  listOfMemoryPoolSizes[V_SgSuperExp] << std::endl; 
     std::cout << "Memory pool size of SgThrowOp: " <<  listOfMemoryPoolSizes[V_SgThrowOp] << std::endl; 
     std::cout << "Memory pool size of SgToken: " <<  listOfMemoryPoolSizes[V_SgToken] << std::endl; 
     std::cout << "Memory pool size of SgTryStmt: " <<  listOfMemoryPoolSizes[V_SgTryStmt] << std::endl; 
     std::cout << "Memory pool size of SgTupleExp: " <<  listOfMemoryPoolSizes[V_SgTupleExp] << std::endl; 
     std::cout << "Memory pool size of SgType: " <<  listOfMemoryPoolSizes[V_SgType] << std::endl; 
     std::cout << "Memory pool size of SgTypeBool: " <<  listOfMemoryPoolSizes[V_SgTypeBool] << std::endl; 
     std::cout << "Memory pool size of SgTypeChar: " <<  listOfMemoryPoolSizes[V_SgTypeChar] << std::endl; 
     std::cout << "Memory pool size of SgTypeChar16: " <<  listOfMemoryPoolSizes[V_SgTypeChar16] << std::endl; 
     std::cout << "Memory pool size of SgTypeChar32: " <<  listOfMemoryPoolSizes[V_SgTypeChar32] << std::endl; 
     std::cout << "Memory pool size of SgTypeComplex: " <<  listOfMemoryPoolSizes[V_SgTypeComplex] << std::endl; 
     std::cout << "Memory pool size of SgTypeDefault: " <<  listOfMemoryPoolSizes[V_SgTypeDefault] << std::endl; 
     std::cout << "Memory pool size of SgTypeExpression: " <<  listOfMemoryPoolSizes[V_SgTypeExpression] << std::endl; 
     std::cout << "Memory pool size of SgTypeLabel: " <<  listOfMemoryPoolSizes[V_SgTypeLabel] << std::endl; 
     std::cout << "Memory pool size of SgTypeDouble: " <<  listOfMemoryPoolSizes[V_SgTypeDouble] << std::endl; 
     std::cout << "Memory pool size of SgTypeEllipse: " <<  listOfMemoryPoolSizes[V_SgTypeEllipse] << std::endl; 
     std::cout << "Memory pool size of SgTypeFixed: " <<  listOfMemoryPoolSizes[V_SgTypeFixed] << std::endl; 
     std::cout << "Memory pool size of SgTypeFloat: " <<  listOfMemoryPoolSizes[V_SgTypeFloat] << std::endl; 
     std::cout << "Memory pool size of SgTypeFloat128: " <<  listOfMemoryPoolSizes[V_SgTypeFloat128] << std::endl; 
     std::cout << "Memory pool size of SgTypeFloat80: " <<  listOfMemoryPoolSizes[V_SgTypeFloat80] << std::endl; 
     std::cout << "Memory pool size of SgTypeGlobalVoid: " <<  listOfMemoryPoolSizes[V_SgTypeGlobalVoid] << std::endl; 
     std::cout << "Memory pool size of SgTypeIdOp: " <<  listOfMemoryPoolSizes[V_SgTypeIdOp] << std::endl; 
     std::cout << "Memory pool size of SgTypeImaginary: " <<  listOfMemoryPoolSizes[V_SgTypeImaginary] << std::endl; 
     std::cout << "Memory pool size of SgTypeInt: " <<  listOfMemoryPoolSizes[V_SgTypeInt] << std::endl; 
     std::cout << "Memory pool size of SgTypeLong: " <<  listOfMemoryPoolSizes[V_SgTypeLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeLongDouble: " <<  listOfMemoryPoolSizes[V_SgTypeLongDouble] << std::endl; 
     std::cout << "Memory pool size of SgTypeLongLong: " <<  listOfMemoryPoolSizes[V_SgTypeLongLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeModifier: " <<  listOfMemoryPoolSizes[V_SgTypeModifier] << std::endl; 
     std::cout << "Memory pool size of SgTypeMatrix: " <<  listOfMemoryPoolSizes[V_SgTypeMatrix] << std::endl; 
     std::cout << "Memory pool size of SgTypeTuple: " <<  listOfMemoryPoolSizes[V_SgTypeTuple] << std::endl; 
     std::cout << "Memory pool size of SgTypeNullptr: " <<  listOfMemoryPoolSizes[V_SgTypeNullptr] << std::endl; 
     std::cout << "Memory pool size of SgTypeOfType: " <<  listOfMemoryPoolSizes[V_SgTypeOfType] << std::endl; 
     std::cout << "Memory pool size of SgTypeShort: " <<  listOfMemoryPoolSizes[V_SgTypeShort] << std::endl; 
     std::cout << "Memory pool size of SgTypeSigned128bitInteger: " <<  listOfMemoryPoolSizes[V_SgTypeSigned128bitInteger] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedChar: " <<  listOfMemoryPoolSizes[V_SgTypeSignedChar] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedInt: " <<  listOfMemoryPoolSizes[V_SgTypeSignedInt] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedLong: " <<  listOfMemoryPoolSizes[V_SgTypeSignedLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedLongLong: " <<  listOfMemoryPoolSizes[V_SgTypeSignedLongLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedShort: " <<  listOfMemoryPoolSizes[V_SgTypeSignedShort] << std::endl; 
     std::cout << "Memory pool size of SgTypeString: " <<  listOfMemoryPoolSizes[V_SgTypeString] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnknown: " <<  listOfMemoryPoolSizes[V_SgTypeUnknown] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsigned128bitInteger: " <<  listOfMemoryPoolSizes[V_SgTypeUnsigned128bitInteger] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedChar: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedChar] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedInt: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedInt] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedLong: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedLongLong: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedLongLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedShort: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedShort] << std::endl; 
     std::cout << "Memory pool size of SgTypeVoid: " <<  listOfMemoryPoolSizes[V_SgTypeVoid] << std::endl; 
     std::cout << "Memory pool size of SgTypeWchar: " <<  listOfMemoryPoolSizes[V_SgTypeWchar] << std::endl; 
     std::cout << "Memory pool size of SgTypedefDeclaration: " <<  listOfMemoryPoolSizes[V_SgTypedefDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTypedefSeq: " <<  listOfMemoryPoolSizes[V_SgTypedefSeq] << std::endl; 
     std::cout << "Memory pool size of SgTypedefSymbol: " <<  listOfMemoryPoolSizes[V_SgTypedefSymbol] << std::endl; 
     std::cout << "Memory pool size of SgTypedefType: " <<  listOfMemoryPoolSizes[V_SgTypedefType] << std::endl; 
     std::cout << "Memory pool size of SgUPC_AccessModifier: " <<  listOfMemoryPoolSizes[V_SgUPC_AccessModifier] << std::endl; 
     std::cout << "Memory pool size of SgUnaryAddOp: " <<  listOfMemoryPoolSizes[V_SgUnaryAddOp] << std::endl; 
     std::cout << "Memory pool size of SgUnaryOp: " <<  listOfMemoryPoolSizes[V_SgUnaryOp] << std::endl; 
     std::cout << "Memory pool size of SgUndefDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgUndefDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgUndirectedGraphEdge: " <<  listOfMemoryPoolSizes[V_SgUndirectedGraphEdge] << std::endl; 
     std::cout << "Memory pool size of SgUnknownArrayOrFunctionReference: " <<  listOfMemoryPoolSizes[V_SgUnknownArrayOrFunctionReference] << std::endl; 
     std::cout << "Memory pool size of SgUnknownFile: " <<  listOfMemoryPoolSizes[V_SgUnknownFile] << std::endl; 
     std::cout << "Memory pool size of SgUnparse_Info: " <<  listOfMemoryPoolSizes[V_SgUnparse_Info] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedCharVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedCharVal] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedIntVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedIntVal] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedLongLongIntVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedLongLongIntVal] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedLongVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedLongVal] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedShortVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedShortVal] << std::endl; 
     std::cout << "Memory pool size of SgUpcBarrierStatement: " <<  listOfMemoryPoolSizes[V_SgUpcBarrierStatement] << std::endl; 
     std::cout << "Memory pool size of SgUpcBlocksizeofExpression: " <<  listOfMemoryPoolSizes[V_SgUpcBlocksizeofExpression] << std::endl; 
     std::cout << "Memory pool size of SgUpcElemsizeofExpression: " <<  listOfMemoryPoolSizes[V_SgUpcElemsizeofExpression] << std::endl; 
     std::cout << "Memory pool size of SgUpcFenceStatement: " <<  listOfMemoryPoolSizes[V_SgUpcFenceStatement] << std::endl; 
     std::cout << "Memory pool size of SgUpcForAllStatement: " <<  listOfMemoryPoolSizes[V_SgUpcForAllStatement] << std::endl; 
     std::cout << "Memory pool size of SgUpcLocalsizeofExpression: " <<  listOfMemoryPoolSizes[V_SgUpcLocalsizeofExpression] << std::endl; 
     std::cout << "Memory pool size of SgUpcMythread: " <<  listOfMemoryPoolSizes[V_SgUpcMythread] << std::endl; 
     std::cout << "Memory pool size of SgUpcNotifyStatement: " <<  listOfMemoryPoolSizes[V_SgUpcNotifyStatement] << std::endl; 
     std::cout << "Memory pool size of SgUpcThreads: " <<  listOfMemoryPoolSizes[V_SgUpcThreads] << std::endl; 
     std::cout << "Memory pool size of SgUpcWaitStatement: " <<  listOfMemoryPoolSizes[V_SgUpcWaitStatement] << std::endl; 
     std::cout << "Memory pool size of SgUseStatement: " <<  listOfMemoryPoolSizes[V_SgUseStatement] << std::endl; 
     std::cout << "Memory pool size of SgUserDefinedBinaryOp: " <<  listOfMemoryPoolSizes[V_SgUserDefinedBinaryOp] << std::endl; 
     std::cout << "Memory pool size of SgUserDefinedUnaryOp: " <<  listOfMemoryPoolSizes[V_SgUserDefinedUnaryOp] << std::endl; 
     std::cout << "Memory pool size of SgUsingDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgUsingDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgUsingDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgUsingDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgValueExp: " <<  listOfMemoryPoolSizes[V_SgValueExp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgCopyOp: " <<  listOfMemoryPoolSizes[V_SgVarArgCopyOp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgEndOp: " <<  listOfMemoryPoolSizes[V_SgVarArgEndOp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgOp: " <<  listOfMemoryPoolSizes[V_SgVarArgOp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgStartOneOperandOp: " <<  listOfMemoryPoolSizes[V_SgVarArgStartOneOperandOp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgStartOp: " <<  listOfMemoryPoolSizes[V_SgVarArgStartOp] << std::endl; 
     std::cout << "Memory pool size of SgVarRefExp: " <<  listOfMemoryPoolSizes[V_SgVarRefExp] << std::endl; 
     std::cout << "Memory pool size of SgVariableDeclaration: " <<  listOfMemoryPoolSizes[V_SgVariableDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgVariableDefinition: " <<  listOfMemoryPoolSizes[V_SgVariableDefinition] << std::endl; 
     std::cout << "Memory pool size of SgVariableSymbol: " <<  listOfMemoryPoolSizes[V_SgVariableSymbol] << std::endl; 
     std::cout << "Memory pool size of SgVariantExpression: " <<  listOfMemoryPoolSizes[V_SgVariantExpression] << std::endl; 
     std::cout << "Memory pool size of SgVariantStatement: " <<  listOfMemoryPoolSizes[V_SgVariantStatement] << std::endl; 
     std::cout << "Memory pool size of SgVoidVal: " <<  listOfMemoryPoolSizes[V_SgVoidVal] << std::endl; 
     std::cout << "Memory pool size of SgWaitStatement: " <<  listOfMemoryPoolSizes[V_SgWaitStatement] << std::endl; 
     std::cout << "Memory pool size of SgWarningDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgWarningDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgWithStatement: " <<  listOfMemoryPoolSizes[V_SgWithStatement] << std::endl; 
     std::cout << "Memory pool size of SgWcharVal: " <<  listOfMemoryPoolSizes[V_SgWcharVal] << std::endl; 
     std::cout << "Memory pool size of SgWhereStatement: " <<  listOfMemoryPoolSizes[V_SgWhereStatement] << std::endl; 
     std::cout << "Memory pool size of SgWhileStmt: " <<  listOfMemoryPoolSizes[V_SgWhileStmt] << std::endl; 
     std::cout << "Memory pool size of SgWriteStatement: " <<  listOfMemoryPoolSizes[V_SgWriteStatement] << std::endl; 
     std::cout << "Memory pool size of SgXorAssignOp: " <<  listOfMemoryPoolSizes[V_SgXorAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgYieldExpression: " <<  listOfMemoryPoolSizes[V_SgYieldExpression] << std::endl; 
     std::cout << "Memory pool size of Sg_File_Info: " <<  listOfMemoryPoolSizes[V_Sg_File_Info] << std::endl; 
     std::cout << "Memory pool size of SgTypeCAFTeam: " <<  listOfMemoryPoolSizes[V_SgTypeCAFTeam] << std::endl; 
     std::cout << "Memory pool size of SgCAFWithTeamStatement: " <<  listOfMemoryPoolSizes[V_SgCAFWithTeamStatement] << std::endl; 
     std::cout << "Memory pool size of SgCAFCoExpression: " <<  listOfMemoryPoolSizes[V_SgCAFCoExpression] << std::endl; 
     std::cout << "Memory pool size of SgCallExpression: " <<  listOfMemoryPoolSizes[V_SgCallExpression] << std::endl; 
     std::cout << "Memory pool size of SgTypeCrayPointer: " <<  listOfMemoryPoolSizes[V_SgTypeCrayPointer] << std::endl; 
     std::cout << "Memory pool size of SgJavaImportStatement: " <<  listOfMemoryPoolSizes[V_SgJavaImportStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaPackageDeclaration: " <<  listOfMemoryPoolSizes[V_SgJavaPackageDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgJavaPackageStatement: " <<  listOfMemoryPoolSizes[V_SgJavaPackageStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaImportStatementList: " <<  listOfMemoryPoolSizes[V_SgJavaImportStatementList] << std::endl; 
     std::cout << "Memory pool size of SgJavaClassDeclarationList: " <<  listOfMemoryPoolSizes[V_SgJavaClassDeclarationList] << std::endl; 
     std::cout << "Memory pool size of SgJavaMemberValuePair: " <<  listOfMemoryPoolSizes[V_SgJavaMemberValuePair] << std::endl; 
     std::cout << "Memory pool size of SgJavaAnnotation: " <<  listOfMemoryPoolSizes[V_SgJavaAnnotation] << std::endl; 
     std::cout << "Memory pool size of SgJavaMarkerAnnotation: " <<  listOfMemoryPoolSizes[V_SgJavaMarkerAnnotation] << std::endl; 
     std::cout << "Memory pool size of SgJavaSingleMemberAnnotation: " <<  listOfMemoryPoolSizes[V_SgJavaSingleMemberAnnotation] << std::endl; 
     std::cout << "Memory pool size of SgJavaNormalAnnotation: " <<  listOfMemoryPoolSizes[V_SgJavaNormalAnnotation] << std::endl; 
     std::cout << "Memory pool size of SgJavaTypeExpression: " <<  listOfMemoryPoolSizes[V_SgJavaTypeExpression] << std::endl; 
     std::cout << "Memory pool size of SgJavaQualifiedType: " <<  listOfMemoryPoolSizes[V_SgJavaQualifiedType] << std::endl; 
     std::cout << "Memory pool size of SgClassExp: " <<  listOfMemoryPoolSizes[V_SgClassExp] << std::endl; 
     std::cout << "Memory pool size of SgJavaUnionType: " <<  listOfMemoryPoolSizes[V_SgJavaUnionType] << std::endl; 
     std::cout << "Memory pool size of SgJavaParameterType: " <<  listOfMemoryPoolSizes[V_SgJavaParameterType] << std::endl; 
     std::cout << "Memory pool size of SgAsyncStmt: " <<  listOfMemoryPoolSizes[V_SgAsyncStmt] << std::endl; 
     std::cout << "Memory pool size of SgFinishStmt: " <<  listOfMemoryPoolSizes[V_SgFinishStmt] << std::endl; 
     std::cout << "Memory pool size of SgAtStmt: " <<  listOfMemoryPoolSizes[V_SgAtStmt] << std::endl; 
     std::cout << "Memory pool size of SgAtomicStmt: " <<  listOfMemoryPoolSizes[V_SgAtomicStmt] << std::endl; 
     std::cout << "Memory pool size of SgWhenStmt: " <<  listOfMemoryPoolSizes[V_SgWhenStmt] << std::endl; 
     std::cout << "Memory pool size of SgAtExp: " <<  listOfMemoryPoolSizes[V_SgAtExp] << std::endl; 
     std::cout << "Memory pool size of SgFinishExp: " <<  listOfMemoryPoolSizes[V_SgFinishExp] << std::endl; 
     std::cout << "Memory pool size of SgHereExp: " <<  listOfMemoryPoolSizes[V_SgHereExp] << std::endl; 
     std::cout << "Memory pool size of SgDotDotExp: " <<  listOfMemoryPoolSizes[V_SgDotDotExp] << std::endl; 
     std::cout << "Memory pool size of SgAsmNullInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmNullInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAdaComponentClause: " <<  listOfMemoryPoolSizes[V_SgAdaComponentClause] << std::endl; 
     std::cout << "Memory pool size of SgAdaIndexConstraint: " <<  listOfMemoryPoolSizes[V_SgAdaIndexConstraint] << std::endl; 
     std::cout << "Memory pool size of SgAdaModularType: " <<  listOfMemoryPoolSizes[V_SgAdaModularType] << std::endl; 
     std::cout << "Memory pool size of SgAdaRepresentationClause: " <<  listOfMemoryPoolSizes[V_SgAdaRepresentationClause] << std::endl; 
     std::cout << "Memory pool size of SgAdaFunctionRenamingDecl: " <<  listOfMemoryPoolSizes[V_SgAdaFunctionRenamingDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaSelectStmt: " <<  listOfMemoryPoolSizes[V_SgAdaSelectStmt] << std::endl; 
     std::cout << "Memory pool size of SgAdaSelectAlternativeStmt: " <<  listOfMemoryPoolSizes[V_SgAdaSelectAlternativeStmt] << std::endl; 
     std::cout << "Memory pool size of SgAdaTerminateStmt: " <<  listOfMemoryPoolSizes[V_SgAdaTerminateStmt] << std::endl; 
     std::cout << "Memory pool size of SgAsmAarch32Coprocessor: " <<  listOfMemoryPoolSizes[V_SgAsmAarch32Coprocessor] << std::endl; 
     std::cout << "Memory pool size of SgAdaAttributeClause: " <<  listOfMemoryPoolSizes[V_SgAdaAttributeClause] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryConcat: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryConcat] << std::endl; 
     std::cout << "Memory pool size of SgAsmByteOrder: " <<  listOfMemoryPoolSizes[V_SgAsmByteOrder] << std::endl; 
     std::cout << "Memory pool size of SgAdaDerivedType: " <<  listOfMemoryPoolSizes[V_SgAdaDerivedType] << std::endl; 
     std::cout << "Memory pool size of SgAdaAttributeExp: " <<  listOfMemoryPoolSizes[V_SgAdaAttributeExp] << std::endl; 
     std::cout << "Memory pool size of SgAdaEnumRepresentationClause: " <<  listOfMemoryPoolSizes[V_SgAdaEnumRepresentationClause] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryPreupdate: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryPreupdate] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryPostupdate: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryPostupdate] << std::endl; 
     std::cout << "Memory pool size of SgAdaOthersExp: " <<  listOfMemoryPoolSizes[V_SgAdaOthersExp] << std::endl; 
     std::cout << "Memory pool size of SgAdaRenamingSymbol: " <<  listOfMemoryPoolSizes[V_SgAdaRenamingSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAdaRenamingRefExp: " <<  listOfMemoryPoolSizes[V_SgAdaRenamingRefExp] << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericDecl: " <<  listOfMemoryPoolSizes[V_SgAdaGenericDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericDefn: " <<  listOfMemoryPoolSizes[V_SgAdaGenericDefn] << std::endl; 
     std::cout << "Memory pool size of SgAdaFormalType: " <<  listOfMemoryPoolSizes[V_SgAdaFormalType] << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericSymbol: " <<  listOfMemoryPoolSizes[V_SgAdaGenericSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAdaFormalTypeDecl: " <<  listOfMemoryPoolSizes[V_SgAdaFormalTypeDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaUnitRefExp: " <<  listOfMemoryPoolSizes[V_SgAdaUnitRefExp] << std::endl; 
     std::cout << "Memory pool size of SgAdaDiscriminatedTypeDecl: " <<  listOfMemoryPoolSizes[V_SgAdaDiscriminatedTypeDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaDiscriminatedType: " <<  listOfMemoryPoolSizes[V_SgAdaDiscriminatedType] << std::endl; 
     std::cout << "Memory pool size of SgAdaDiscriminantConstraint: " <<  listOfMemoryPoolSizes[V_SgAdaDiscriminantConstraint] << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericInstanceDecl: " <<  listOfMemoryPoolSizes[V_SgAdaGenericInstanceDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaUnscopedBlock: " <<  listOfMemoryPoolSizes[V_SgAdaUnscopedBlock] << std::endl; 
     std::cout << "Memory pool size of SgAdaInheritedFunctionSymbol: " <<  listOfMemoryPoolSizes[V_SgAdaInheritedFunctionSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedBody: " <<  listOfMemoryPoolSizes[V_SgAdaProtectedBody] << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedBodyDecl: " <<  listOfMemoryPoolSizes[V_SgAdaProtectedBodyDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedSpec: " <<  listOfMemoryPoolSizes[V_SgAdaProtectedSpec] << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedSpecDecl: " <<  listOfMemoryPoolSizes[V_SgAdaProtectedSpecDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedSymbol: " <<  listOfMemoryPoolSizes[V_SgAdaProtectedSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedRefExp: " <<  listOfMemoryPoolSizes[V_SgAdaProtectedRefExp] << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedType: " <<  listOfMemoryPoolSizes[V_SgAdaProtectedType] << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedTypeDecl: " <<  listOfMemoryPoolSizes[V_SgAdaProtectedTypeDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaDigitsConstraint: " <<  listOfMemoryPoolSizes[V_SgAdaDigitsConstraint] << std::endl; 
     std::cout << "Memory pool size of SgAdaAncestorInitializer: " <<  listOfMemoryPoolSizes[V_SgAdaAncestorInitializer] << std::endl; 
     std::cout << "Memory pool size of SgAdaDeltaConstraint: " <<  listOfMemoryPoolSizes[V_SgAdaDeltaConstraint] << std::endl; 
     std::cout << "Memory pool size of SgAdaSubroutineType: " <<  listOfMemoryPoolSizes[V_SgAdaSubroutineType] << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericInstanceSymbol: " <<  listOfMemoryPoolSizes[V_SgAdaGenericInstanceSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAdaFormalPackageDecl: " <<  listOfMemoryPoolSizes[V_SgAdaFormalPackageDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaFormalPackageSymbol: " <<  listOfMemoryPoolSizes[V_SgAdaFormalPackageSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmAttributeTable: " <<  listOfMemoryPoolSizes[V_SgAsmJvmAttributeTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmMethodTable: " <<  listOfMemoryPoolSizes[V_SgAsmJvmMethodTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmField: " <<  listOfMemoryPoolSizes[V_SgAsmJvmField] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmFieldTable: " <<  listOfMemoryPoolSizes[V_SgAsmJvmFieldTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmExceptionHandler: " <<  listOfMemoryPoolSizes[V_SgAsmJvmExceptionHandler] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmExceptionTable: " <<  listOfMemoryPoolSizes[V_SgAsmJvmExceptionTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmClass: " <<  listOfMemoryPoolSizes[V_SgAsmJvmClass] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLineNumberEntry: " <<  listOfMemoryPoolSizes[V_SgAsmJvmLineNumberEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLineNumberTable: " <<  listOfMemoryPoolSizes[V_SgAsmJvmLineNumberTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmInnerClassesEntry: " <<  listOfMemoryPoolSizes[V_SgAsmJvmInnerClassesEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmInnerClasses: " <<  listOfMemoryPoolSizes[V_SgAsmJvmInnerClasses] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmCilInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmStackExpression: " <<  listOfMemoryPoolSizes[V_SgAsmStackExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmEnclosingMethod: " <<  listOfMemoryPoolSizes[V_SgAsmJvmEnclosingMethod] << std::endl; 
     std::cout << "Memory pool size of SgAdaNullConstraint: " <<  listOfMemoryPoolSizes[V_SgAdaNullConstraint] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmModuleMainClass: " <<  listOfMemoryPoolSizes[V_SgAsmJvmModuleMainClass] << std::endl; 
     std::cout << "Memory pool size of SgAsmInstructionList: " <<  listOfMemoryPoolSizes[V_SgAsmInstructionList] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilNode: " <<  listOfMemoryPoolSizes[V_SgAsmCilNode] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssembly: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssembly] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyOS: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyOS] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyProcessor: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyProcessor] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRef: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyRef] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefOS: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyRefOS] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefProcessor: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyRefProcessor] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilClassLayout: " <<  listOfMemoryPoolSizes[V_SgAsmCilClassLayout] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilConstant: " <<  listOfMemoryPoolSizes[V_SgAsmCilConstant] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilCustomAttribute: " <<  listOfMemoryPoolSizes[V_SgAsmCilCustomAttribute] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilDeclSecurity: " <<  listOfMemoryPoolSizes[V_SgAsmCilDeclSecurity] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilEvent: " <<  listOfMemoryPoolSizes[V_SgAsmCilEvent] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilEventMap: " <<  listOfMemoryPoolSizes[V_SgAsmCilEventMap] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilExportedType: " <<  listOfMemoryPoolSizes[V_SgAsmCilExportedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilField: " <<  listOfMemoryPoolSizes[V_SgAsmCilField] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldLayout: " <<  listOfMemoryPoolSizes[V_SgAsmCilFieldLayout] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldMarshal: " <<  listOfMemoryPoolSizes[V_SgAsmCilFieldMarshal] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldRVA: " <<  listOfMemoryPoolSizes[V_SgAsmCilFieldRVA] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFile: " <<  listOfMemoryPoolSizes[V_SgAsmCilFile] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilGenericParam: " <<  listOfMemoryPoolSizes[V_SgAsmCilGenericParam] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilGenericParamConstraint: " <<  listOfMemoryPoolSizes[V_SgAsmCilGenericParamConstraint] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilImplMap: " <<  listOfMemoryPoolSizes[V_SgAsmCilImplMap] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilInterfaceImpl: " <<  listOfMemoryPoolSizes[V_SgAsmCilInterfaceImpl] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilManifestResource: " <<  listOfMemoryPoolSizes[V_SgAsmCilManifestResource] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMemberRef: " <<  listOfMemoryPoolSizes[V_SgAsmCilMemberRef] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodDef: " <<  listOfMemoryPoolSizes[V_SgAsmCilMethodDef] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodImpl: " <<  listOfMemoryPoolSizes[V_SgAsmCilMethodImpl] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodSemantics: " <<  listOfMemoryPoolSizes[V_SgAsmCilMethodSemantics] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodSpec: " <<  listOfMemoryPoolSizes[V_SgAsmCilMethodSpec] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilModule: " <<  listOfMemoryPoolSizes[V_SgAsmCilModule] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilModuleRef: " <<  listOfMemoryPoolSizes[V_SgAsmCilModuleRef] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilNestedClass: " <<  listOfMemoryPoolSizes[V_SgAsmCilNestedClass] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilParam: " <<  listOfMemoryPoolSizes[V_SgAsmCilParam] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilProperty: " <<  listOfMemoryPoolSizes[V_SgAsmCilProperty] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilPropertyMap: " <<  listOfMemoryPoolSizes[V_SgAsmCilPropertyMap] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilStandAloneSig: " <<  listOfMemoryPoolSizes[V_SgAsmCilStandAloneSig] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeDef: " <<  listOfMemoryPoolSizes[V_SgAsmCilTypeDef] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeRef: " <<  listOfMemoryPoolSizes[V_SgAsmCilTypeRef] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeSpec: " <<  listOfMemoryPoolSizes[V_SgAsmCilTypeSpec] << std::endl; 
     std::cout << "Memory pool size of SgAdaParameterList: " <<  listOfMemoryPoolSizes[V_SgAdaParameterList] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMetadata: " <<  listOfMemoryPoolSizes[V_SgAsmCilMetadata] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMetadataRoot: " <<  listOfMemoryPoolSizes[V_SgAsmCilMetadataRoot] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilDataStream: " <<  listOfMemoryPoolSizes[V_SgAsmCilDataStream] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMetadataHeap: " <<  listOfMemoryPoolSizes[V_SgAsmCilMetadataHeap] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilUint8Heap: " <<  listOfMemoryPoolSizes[V_SgAsmCilUint8Heap] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilUint32Heap: " <<  listOfMemoryPoolSizes[V_SgAsmCilUint32Heap] << std::endl; 
     std::cout << "Memory pool size of SgAsmCliHeader: " <<  listOfMemoryPoolSizes[V_SgAsmCliHeader] << std::endl; 
     std::cout << "Memory pool size of SgAdaVariantDecl: " <<  listOfMemoryPoolSizes[V_SgAdaVariantDecl] << std::endl; 
     std::cout << "Memory pool size of SgAdaVariantWhenStmt: " <<  listOfMemoryPoolSizes[V_SgAdaVariantWhenStmt] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyOSTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyOSTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyProcessorTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyProcessorTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyRefTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefOSTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyRefOSTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefProcessorTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilAssemblyRefProcessorTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilClassLayoutTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilClassLayoutTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilConstantTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilConstantTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilCustomAttributeTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilCustomAttributeTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilDeclSecurityTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilDeclSecurityTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilEventTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilEventTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilEventMapTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilEventMapTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilExportedTypeTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilExportedTypeTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilFieldTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldLayoutTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilFieldLayoutTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldMarshalTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilFieldMarshalTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldRVATable: " <<  listOfMemoryPoolSizes[V_SgAsmCilFieldRVATable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFileTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilFileTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilGenericParamTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilGenericParamTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilGenericParamConstraintTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilGenericParamConstraintTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilImplMapTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilImplMapTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilInterfaceImplTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilInterfaceImplTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilManifestResourceTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilManifestResourceTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMemberRefTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilMemberRefTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodDefTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilMethodDefTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodImplTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilMethodImplTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodSemanticsTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilMethodSemanticsTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodSpecTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilMethodSpecTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilModuleTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilModuleTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilModuleRefTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilModuleRefTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilNestedClassTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilNestedClassTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilParamTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilParamTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilPropertyTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilPropertyTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilPropertyMapTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilPropertyMapTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilStandAloneSigTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilStandAloneSigTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeDefTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilTypeDefTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeRefTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilTypeRefTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeSpecTable: " <<  listOfMemoryPoolSizes[V_SgAsmCilTypeSpecTable] << std::endl; 
     std::cout << "Memory pool size of SgJvmComposite: " <<  listOfMemoryPoolSizes[V_SgJvmComposite] << std::endl; 
     std::cout << "Memory pool size of SgFortranContinueStmt: " <<  listOfMemoryPoolSizes[V_SgFortranContinueStmt] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmStackMapTable: " <<  listOfMemoryPoolSizes[V_SgAsmJvmStackMapTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmStackMapFrame: " <<  listOfMemoryPoolSizes[V_SgAsmJvmStackMapFrame] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmStackMapVerificationType: " <<  listOfMemoryPoolSizes[V_SgAsmJvmStackMapVerificationType] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmBootstrapMethod: " <<  listOfMemoryPoolSizes[V_SgAsmJvmBootstrapMethod] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmBootstrapMethods: " <<  listOfMemoryPoolSizes[V_SgAsmJvmBootstrapMethods] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmExceptions: " <<  listOfMemoryPoolSizes[V_SgAsmJvmExceptions] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmNestMembers: " <<  listOfMemoryPoolSizes[V_SgAsmJvmNestMembers] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmNestHost: " <<  listOfMemoryPoolSizes[V_SgAsmJvmNestHost] << std::endl; 
     std::cout << "Memory pool size of SgJovialLabelDeclaration: " <<  listOfMemoryPoolSizes[V_SgJovialLabelDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLocalVariableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmJvmLocalVariableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLocalVariableTable: " <<  listOfMemoryPoolSizes[V_SgAsmJvmLocalVariableTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLocalVariableTypeEntry: " <<  listOfMemoryPoolSizes[V_SgAsmJvmLocalVariableTypeEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLocalVariableTypeTable: " <<  listOfMemoryPoolSizes[V_SgAsmJvmLocalVariableTypeTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmUserInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmUserInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmMethodParameters: " <<  listOfMemoryPoolSizes[V_SgAsmJvmMethodParameters] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmMethodParametersEntry: " <<  listOfMemoryPoolSizes[V_SgAsmJvmMethodParametersEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmVoidType: " <<  listOfMemoryPoolSizes[V_SgAsmVoidType] << std::endl; 
     std::cout << "Memory pool size of SgAsmPointerType: " <<  listOfMemoryPoolSizes[V_SgAsmPointerType] << std::endl; 
     std::cout << "Memory pool size of SgRangeType: " <<  listOfMemoryPoolSizes[V_SgRangeType] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilExceptionData: " <<  listOfMemoryPoolSizes[V_SgAsmCilExceptionData] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodData: " <<  listOfMemoryPoolSizes[V_SgAsmCilMethodData] << std::endl; 
     std::cout << "Memory pool size of SgTemplateVariableInstantiation: " <<  listOfMemoryPoolSizes[V_SgTemplateVariableInstantiation] << std::endl; 
     std::cout << "Memory pool size of SgReferenceExp: " <<  listOfMemoryPoolSizes[V_SgReferenceExp] << std::endl; 
     std::cout << "Memory pool size of SgTypeRefExp: " <<  listOfMemoryPoolSizes[V_SgTypeRefExp] << std::endl; 
     std::cout << "Memory pool size of SgScopedRefExp: " <<  listOfMemoryPoolSizes[V_SgScopedRefExp] << std::endl; 
     std::cout << "Memory pool size of SgScopedType: " <<  listOfMemoryPoolSizes[V_SgScopedType] << std::endl; 
     std::cout << "Memory pool size of SgTypeSymbol: " <<  listOfMemoryPoolSizes[V_SgTypeSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmSynthetic: " <<  listOfMemoryPoolSizes[V_SgAsmJvmSynthetic] << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmDeprecated: " <<  listOfMemoryPoolSizes[V_SgAsmJvmDeprecated] << std::endl; 
     std::cout << "Memory pool size of SgSignedCharVal: " <<  listOfMemoryPoolSizes[V_SgSignedCharVal] << std::endl; 
     std::cout << "Memory pool size of SgAsmCilErrorHeap: " <<  listOfMemoryPoolSizes[V_SgAsmCilErrorHeap] << std::endl; 

/* #line 467 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
     std::cout << " Total number of IR nodes in contained in the memory pools: "  
               << listOfMemoryPoolSizes[totalNumberOfIRNodes] << std::endl << std::endl;
     return;
   }


void 
AST_FILE_IO::printListOfPoolSizesOfAst (int index)
   {
     std::cout << "Memory pool size of SgAccessModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAccessModifier) << std::endl; 
     std::cout << "Memory pool size of SgActualArgumentExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgActualArgumentExpression) << std::endl; 
     std::cout << "Memory pool size of SgAbsOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAbsOp) << std::endl; 
     std::cout << "Memory pool size of SgAdaAccessType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaAccessType) << std::endl; 
     std::cout << "Memory pool size of SgAdaAcceptStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaAcceptStmt) << std::endl; 
     std::cout << "Memory pool size of SgAdaDelayStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaDelayStmt) << std::endl; 
     std::cout << "Memory pool size of SgAdaEntryDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaEntryDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaExitStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaExitStmt) << std::endl; 
     std::cout << "Memory pool size of SgAdaDiscreteType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaDiscreteType) << std::endl; 
     std::cout << "Memory pool size of SgAdaFloatVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaFloatVal) << std::endl; 
     std::cout << "Memory pool size of SgAdaLoopStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaLoopStmt) << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageBody: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaPackageBody) << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageBodyDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaPackageBodyDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageSpec: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaPackageSpec) << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageSpecDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaPackageSpecDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaPackageSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaPackageSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAdaRangeConstraint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaRangeConstraint) << std::endl; 
     std::cout << "Memory pool size of SgAdaRenamingDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaRenamingDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaSubtype: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaSubtype) << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskBody: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTaskBody) << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskBodyDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTaskBodyDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskSpec: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTaskSpec) << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskSpecDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTaskSpecDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTaskSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTaskRefExp) << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTaskType) << std::endl; 
     std::cout << "Memory pool size of SgAdaTaskTypeDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTaskTypeDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaTypeConstraint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTypeConstraint) << std::endl; 
     std::cout << "Memory pool size of SgAddOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAddOp) << std::endl; 
     std::cout << "Memory pool size of SgAddressOfOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAddressOfOp) << std::endl; 
     std::cout << "Memory pool size of SgAggregateInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAggregateInitializer) << std::endl; 
     std::cout << "Memory pool size of SgAliasSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAliasSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAllocateStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAllocateStatement) << std::endl; 
     std::cout << "Memory pool size of SgAndAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAndAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgAndOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAndOp) << std::endl; 
     std::cout << "Memory pool size of SgArithmeticIfStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgArithmeticIfStatement) << std::endl; 
     std::cout << "Memory pool size of SgArrayType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgArrayType) << std::endl; 
     std::cout << "Memory pool size of SgArrowExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgArrowExp) << std::endl; 
     std::cout << "Memory pool size of SgArrowStarOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgArrowStarOp) << std::endl; 
     std::cout << "Memory pool size of SgAsmBasicString: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBasicString) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAdd: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryAdd) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAsr: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryAsr) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryDivide: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryDivide) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryLsl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryLsl) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryLsr: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryLsr) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMod: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryMod) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMsl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryMsl) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMultiply: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryMultiply) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryRor: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryRor) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinarySubtract: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinarySubtract) << std::endl; 
     std::cout << "Memory pool size of SgAsmBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffStrtab: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCoffStrtab) << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCoffSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbolList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCoffSymbolList) << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbolTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCoffSymbolTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCommonSubExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCommonSubExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmControlFlagsExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmControlFlagsExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmConstantExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmConstantExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmDOSExtendedHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDOSExtendedHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmDOSFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDOSFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmSynthesizedDataStructureDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmSynthesizedDataStructureDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgAsmSynthesizedDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmSynthesizedDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgAsmDirectRegisterExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDirectRegisterExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfAccessDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfAccessDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfArrayType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfArrayType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfBaseType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfBaseType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCatchBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCatchBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfClassTemplate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfClassTemplate) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfClassType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfClassType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCommonBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCommonBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCommonInclusion: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCommonInclusion) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCompilationUnit: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCompilationUnit) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCompilationUnitList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCompilationUnitList) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCondition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCondition) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfConstType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstant: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfConstant) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstruct: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfConstruct) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstructList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfConstructList) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfDwarfProcedure: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfDwarfProcedure) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEntryPoint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfEntryPoint) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEnumerationType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfEnumerationType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEnumerator: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfEnumerator) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFileType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFileType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFormalParameter: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFormalParameter) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFormatLabel: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFormatLabel) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFriend: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFriend) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFunctionTemplate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFunctionTemplate) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfImportedDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedModule: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfImportedModule) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedUnit: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfImportedUnit) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInformation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfInformation) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInheritance: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfInheritance) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInlinedSubroutine: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfInlinedSubroutine) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInterfaceType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfInterfaceType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLabel: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfLabel) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLexicalBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfLexicalBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLine: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfLine) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLineList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfLineList) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMacro: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfMacro) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMacroList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfMacroList) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMember: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfMember) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfModule: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfModule) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMutableType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfMutableType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamelist: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfNamelist) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamelistItem: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfNamelistItem) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamespace: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfNamespace) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPackedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfPackedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPartialUnit: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfPartialUnit) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPointerType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfPointerType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPtrToMemberType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfPtrToMemberType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfReferenceType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfReferenceType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfRestrictType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfRestrictType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSetType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSetType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSharedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSharedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfStringType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfStringType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfStructureType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfStructureType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubprogram: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSubprogram) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubrangeType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSubrangeType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubroutineType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSubroutineType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTemplateTypeParameter: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfTemplateTypeParameter) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTemplateValueParameter: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfTemplateValueParameter) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfThrownType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfThrownType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTryBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfTryBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTypedef: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfTypedef) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnionType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUnionType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnknownConstruct: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUnknownConstruct) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnspecifiedParameters: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUnspecifiedParameters) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnspecifiedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUnspecifiedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcRelaxedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUpcRelaxedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcSharedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUpcSharedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcStrictType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUpcStrictType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfVariable) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariant: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfVariant) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariantPart: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfVariantPart) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVolatileType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfVolatileType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfWithStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfWithStmt) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfDynamicEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfDynamicEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfDynamicSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryCI: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameEntryCI) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryCIList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameEntryCIList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryFD: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameEntryFD) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryFDList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameEntryFDList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfNoteEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfNoteEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfNoteSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfRelocEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfRelocEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfRelocSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSectionTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSectionTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSectionTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSectionTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSegmentTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSegmentTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTableEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSegmentTableEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfStringSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfStringSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfStrtab: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfStrtab) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbolList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymbolList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbolSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymbolSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedAux: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedAux) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedAuxList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedAuxList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededAux: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededAux) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededAuxList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededAuxList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmExecutableFileFormat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmExecutableFileFormat) << std::endl; 
     std::cout << "Memory pool size of SgAsmExprListExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmExprListExp) << std::endl; 
     std::cout << "Memory pool size of SgAsmExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmSynthesizedFieldDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmSynthesizedFieldDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgAsmFloatType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmFloatType) << std::endl; 
     std::cout << "Memory pool size of SgAsmFloatValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmFloatValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmFunction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmFunction) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericDLL: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericDLL) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericDLLList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericDLLList) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericFile) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFileList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericFileList) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFormat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericFormat) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericHeaderList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericHeaderList) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSectionList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericSectionList) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericString: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericString) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericStrtab: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericStrtab) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSymbolList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericSymbolList) << std::endl; 
     std::cout << "Memory pool size of SgAsmIndirectRegisterExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmIndirectRegisterExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmIntegerValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmIntegerValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmIntegerType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmIntegerType) << std::endl; 
     std::cout << "Memory pool size of SgAsmInterpretation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmInterpretation) << std::endl; 
     std::cout << "Memory pool size of SgAsmInterpretationList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmInterpretationList) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmAttribute: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmAttribute) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmCodeAttribute: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmCodeAttribute) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmMethod: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmMethod) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmConstantPool: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmConstantPool) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmConstantPoolEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmConstantPoolEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmConstantValue: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmConstantValue) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmNode) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmSignature: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmSignature) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmSourceFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmSourceFile) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEEntryPoint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEEntryPoint) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEEntryTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEEntryTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmLENameTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLENameTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEPageTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEPageTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEPageTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEPageTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmLERelocTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLERelocTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLESection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLESection) << std::endl; 
     std::cout << "Memory pool size of SgAsmLESectionTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLESectionTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLESectionTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLESectionTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmM68kInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmM68kInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmMemoryReferenceExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmMemoryReferenceExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmMipsInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmMipsInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEEntryPoint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEEntryPoint) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEEntryTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEEntryTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEModuleTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEModuleTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNENameTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNENameTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNERelocEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNERelocEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmNERelocTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNERelocTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNESection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNESection) << std::endl; 
     std::cout << "Memory pool size of SgAsmNESectionTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNESectionTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNESectionTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNESectionTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEStringTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEStringTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNode) << std::endl; 
     std::cout << "Memory pool size of SgAsmOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmOp) << std::endl; 
     std::cout << "Memory pool size of SgAsmOperandList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmOperandList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportDirectory: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEExportDirectory) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEExportEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEExportEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEExportSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportDirectory: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportDirectory) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportDirectoryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportDirectoryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportItem: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportItem) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportItemList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportItemList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmPERVASizePair: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPERVASizePair) << std::endl; 
     std::cout << "Memory pool size of SgAsmPERVASizePairList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPERVASizePairList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPESection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPESection) << std::endl; 
     std::cout << "Memory pool size of SgAsmPESectionTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPESectionTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmPESectionTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPESectionTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEStringSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEStringSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmPowerpcInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPowerpcInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmRegisterNames: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmRegisterNames) << std::endl; 
     std::cout << "Memory pool size of SgAsmRegisterReferenceExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmRegisterReferenceExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmRiscOperation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmRiscOperation) << std::endl; 
     std::cout << "Memory pool size of SgAsmScalarType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmScalarType) << std::endl; 
     std::cout << "Memory pool size of SgAsmStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStatement) << std::endl; 
     std::cout << "Memory pool size of SgAsmStaticData: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStaticData) << std::endl; 
     std::cout << "Memory pool size of SgAsmStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStmt) << std::endl; 
     std::cout << "Memory pool size of SgAsmStoredString: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStoredString) << std::endl; 
     std::cout << "Memory pool size of SgAsmStringStorage: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStringStorage) << std::endl; 
     std::cout << "Memory pool size of SgAsmType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmType) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryMinus: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryMinus) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryPlus: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryPlus) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryRrx: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryRrx) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnarySignedExtend: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnarySignedExtend) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryUnsignedExtend: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryUnsignedExtend) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryTruncate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryTruncate) << std::endl; 
     std::cout << "Memory pool size of SgAsmValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmVectorType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmVectorType) << std::endl; 
     std::cout << "Memory pool size of SgAsmX86Instruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmX86Instruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAddressSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryAddressSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryDataSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryDataSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAssertStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssertStmt) << std::endl; 
     std::cout << "Memory pool size of SgAssignInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssignInitializer) << std::endl; 
     std::cout << "Memory pool size of SgAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgAssignStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssignStatement) << std::endl; 
     std::cout << "Memory pool size of SgAssignedGotoStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssignedGotoStatement) << std::endl; 
     std::cout << "Memory pool size of SgAssociateStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssociateStatement) << std::endl; 
     std::cout << "Memory pool size of SgAsteriskShapeExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsteriskShapeExp) << std::endl; 
     std::cout << "Memory pool size of SgAtOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAtOp) << std::endl; 
     std::cout << "Memory pool size of SgAttribute: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAttribute) << std::endl; 
     std::cout << "Memory pool size of SgAttributeSpecificationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAttributeSpecificationStatement) << std::endl; 
     std::cout << "Memory pool size of SgAutoType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAutoType) << std::endl; 
     std::cout << "Memory pool size of SgAwaitExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAwaitExpression) << std::endl; 
     std::cout << "Memory pool size of SgBackspaceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBackspaceStatement) << std::endl; 
     std::cout << "Memory pool size of SgBaseClass: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBaseClass) << std::endl; 
     std::cout << "Memory pool size of SgExpBaseClass: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExpBaseClass) << std::endl; 
     std::cout << "Memory pool size of SgBaseClassModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBaseClassModifier) << std::endl; 
     std::cout << "Memory pool size of SgBasicBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBasicBlock) << std::endl; 
     std::cout << "Memory pool size of SgBidirectionalGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBidirectionalGraph) << std::endl; 
     std::cout << "Memory pool size of SgBinaryComposite: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBinaryComposite) << std::endl; 
     std::cout << "Memory pool size of SgBinaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBinaryOp) << std::endl; 
     std::cout << "Memory pool size of SgBitAndOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitAndOp) << std::endl; 
     std::cout << "Memory pool size of SgBitAttribute: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitAttribute) << std::endl; 
     std::cout << "Memory pool size of SgBitComplementOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitComplementOp) << std::endl; 
     std::cout << "Memory pool size of SgBitEqvOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitEqvOp) << std::endl; 
     std::cout << "Memory pool size of SgBitOrOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitOrOp) << std::endl; 
     std::cout << "Memory pool size of SgBitXorOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitXorOp) << std::endl; 
     std::cout << "Memory pool size of SgBlockDataStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBlockDataStatement) << std::endl; 
     std::cout << "Memory pool size of SgBoolValExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBoolValExp) << std::endl; 
     std::cout << "Memory pool size of SgBreakStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBreakStmt) << std::endl; 
     std::cout << "Memory pool size of SgBracedInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBracedInitializer) << std::endl; 
     std::cout << "Memory pool size of SgC_PreprocessorDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgC_PreprocessorDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgCaseOptionStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCaseOptionStmt) << std::endl; 
     std::cout << "Memory pool size of SgCastExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCastExp) << std::endl; 
     std::cout << "Memory pool size of SgCatchOptionStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCatchOptionStmt) << std::endl; 
     std::cout << "Memory pool size of SgCatchStatementSeq: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCatchStatementSeq) << std::endl; 
     std::cout << "Memory pool size of SgCharVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCharVal) << std::endl; 
     std::cout << "Memory pool size of SgChar16Val: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgChar16Val) << std::endl; 
     std::cout << "Memory pool size of SgChar32Val: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgChar32Val) << std::endl; 
     std::cout << "Memory pool size of SgChooseExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgChooseExpression) << std::endl; 
     std::cout << "Memory pool size of SgClassDecl_attr: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassDecl_attr) << std::endl; 
     std::cout << "Memory pool size of SgClassDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgClassDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassDefinition) << std::endl; 
     std::cout << "Memory pool size of SgClassNameRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassNameRefExp) << std::endl; 
     std::cout << "Memory pool size of SgClassSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassSymbol) << std::endl; 
     std::cout << "Memory pool size of SgClassType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassType) << std::endl; 
     std::cout << "Memory pool size of SgClinkageDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClinkageDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgClinkageEndStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClinkageEndStatement) << std::endl; 
     std::cout << "Memory pool size of SgClinkageStartStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClinkageStartStatement) << std::endl; 
     std::cout << "Memory pool size of SgCloseStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCloseStatement) << std::endl; 
     std::cout << "Memory pool size of SgColonShapeExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgColonShapeExp) << std::endl; 
     std::cout << "Memory pool size of SgCommaOpExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCommaOpExp) << std::endl; 
     std::cout << "Memory pool size of SgCommonBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCommonBlock) << std::endl; 
     std::cout << "Memory pool size of SgCommonBlockObject: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCommonBlockObject) << std::endl; 
     std::cout << "Memory pool size of SgCommonSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCommonSymbol) << std::endl; 
     std::cout << "Memory pool size of SgComplexVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgComplexVal) << std::endl; 
     std::cout << "Memory pool size of SgComprehension: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgComprehension) << std::endl; 
     std::cout << "Memory pool size of SgCompoundAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCompoundAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgCompoundInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCompoundInitializer) << std::endl; 
     std::cout << "Memory pool size of SgCompoundLiteralExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCompoundLiteralExp) << std::endl; 
     std::cout << "Memory pool size of SgComputedGotoStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgComputedGotoStatement) << std::endl; 
     std::cout << "Memory pool size of SgConcatenationOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConcatenationOp) << std::endl; 
     std::cout << "Memory pool size of SgConditionalExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConditionalExp) << std::endl; 
     std::cout << "Memory pool size of SgConjugateOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConjugateOp) << std::endl; 
     std::cout << "Memory pool size of SgConstVolatileModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConstVolatileModifier) << std::endl; 
     std::cout << "Memory pool size of SgConstructorInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConstructorInitializer) << std::endl; 
     std::cout << "Memory pool size of SgContainsStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgContainsStatement) << std::endl; 
     std::cout << "Memory pool size of SgContinueStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgContinueStmt) << std::endl; 
     std::cout << "Memory pool size of SgCtorInitializerList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCtorInitializerList) << std::endl; 
     std::cout << "Memory pool size of SgDataStatementGroup: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDataStatementGroup) << std::endl; 
     std::cout << "Memory pool size of SgDataStatementObject: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDataStatementObject) << std::endl; 
     std::cout << "Memory pool size of SgDataStatementValue: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDataStatementValue) << std::endl; 
     std::cout << "Memory pool size of SgDeadIfDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeadIfDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgDeallocateStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeallocateStatement) << std::endl; 
     std::cout << "Memory pool size of SgDeclarationModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeclarationModifier) << std::endl; 
     std::cout << "Memory pool size of SgDeclarationScope: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeclarationScope) << std::endl; 
     std::cout << "Memory pool size of SgDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgDeclType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeclType) << std::endl; 
     std::cout << "Memory pool size of SgDefaultOptionStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDefaultOptionStmt) << std::endl; 
     std::cout << "Memory pool size of SgDefaultSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDefaultSymbol) << std::endl; 
     std::cout << "Memory pool size of SgDefineDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDefineDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgDeleteExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeleteExp) << std::endl; 
     std::cout << "Memory pool size of SgDerivedTypeStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDerivedTypeStatement) << std::endl; 
     std::cout << "Memory pool size of SgDesignatedInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDesignatedInitializer) << std::endl; 
     std::cout << "Memory pool size of SgDictionaryComprehension: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDictionaryComprehension) << std::endl; 
     std::cout << "Memory pool size of SgDictionaryExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDictionaryExp) << std::endl; 
     std::cout << "Memory pool size of SgDimensionObject: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDimensionObject) << std::endl; 
     std::cout << "Memory pool size of SgDirectedGraphEdge: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDirectedGraphEdge) << std::endl; 
     std::cout << "Memory pool size of SgDirectory: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDirectory) << std::endl; 
     std::cout << "Memory pool size of SgDirectoryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDirectoryList) << std::endl; 
     std::cout << "Memory pool size of SgDivAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDivAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgDivideOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDivideOp) << std::endl; 
     std::cout << "Memory pool size of SgDoWhileStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDoWhileStmt) << std::endl; 
     std::cout << "Memory pool size of SgDotExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDotExp) << std::endl; 
     std::cout << "Memory pool size of SgDotStarOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDotStarOp) << std::endl; 
     std::cout << "Memory pool size of SgDoubleVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDoubleVal) << std::endl; 
     std::cout << "Memory pool size of SgElaboratedTypeModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElaboratedTypeModifier) << std::endl; 
     std::cout << "Memory pool size of SgElementwiseOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElementwiseOp) << std::endl; 
     std::cout << "Memory pool size of SgElementwiseAddOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElementwiseAddOp) << std::endl; 
     std::cout << "Memory pool size of SgElementwiseDivideOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElementwiseDivideOp) << std::endl; 
     std::cout << "Memory pool size of SgElementwiseLeftDivideOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElementwiseLeftDivideOp) << std::endl; 
     std::cout << "Memory pool size of SgElementwiseMultiplyOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElementwiseMultiplyOp) << std::endl; 
     std::cout << "Memory pool size of SgElementwisePowerOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElementwisePowerOp) << std::endl; 
     std::cout << "Memory pool size of SgElementwiseSubtractOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElementwiseSubtractOp) << std::endl; 
     std::cout << "Memory pool size of SgElseDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElseDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgElseWhereStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElseWhereStatement) << std::endl; 
     std::cout << "Memory pool size of SgElseifDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElseifDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgEmptyDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEmptyDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgEmptyDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEmptyDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgEndfileStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEndfileStatement) << std::endl; 
     std::cout << "Memory pool size of SgEndifDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEndifDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgEntryStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEntryStatement) << std::endl; 
     std::cout << "Memory pool size of SgEnumDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgEnumFieldSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumFieldSymbol) << std::endl; 
     std::cout << "Memory pool size of SgEnumSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumSymbol) << std::endl; 
     std::cout << "Memory pool size of SgEnumType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumType) << std::endl; 
     std::cout << "Memory pool size of SgEnumVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumVal) << std::endl; 
     std::cout << "Memory pool size of SgEqualityOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEqualityOp) << std::endl; 
     std::cout << "Memory pool size of SgEquivalenceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEquivalenceStatement) << std::endl; 
     std::cout << "Memory pool size of SgErrorDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgErrorDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgExecStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExecStatement) << std::endl; 
     std::cout << "Memory pool size of SgExponentiationOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExponentiationOp) << std::endl; 
     std::cout << "Memory pool size of SgExponentiationAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExponentiationAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgExprListExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExprListExp) << std::endl; 
     std::cout << "Memory pool size of SgExprStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExprStatement) << std::endl; 
     std::cout << "Memory pool size of SgExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExpression) << std::endl; 
     std::cout << "Memory pool size of SgExpressionRoot: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExpressionRoot) << std::endl; 
     std::cout << "Memory pool size of SgFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFile) << std::endl; 
     std::cout << "Memory pool size of SgFileList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFileList) << std::endl; 
     std::cout << "Memory pool size of SgFloatVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFloatVal) << std::endl; 
     std::cout << "Memory pool size of SgFloat128Val: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFloat128Val) << std::endl; 
     std::cout << "Memory pool size of SgFloat80Val: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFloat80Val) << std::endl; 
     std::cout << "Memory pool size of SgFoldExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFoldExpression) << std::endl; 
     std::cout << "Memory pool size of SgFlushStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFlushStatement) << std::endl; 
     std::cout << "Memory pool size of SgForAllStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgForAllStatement) << std::endl; 
     std::cout << "Memory pool size of SgForInitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgForInitStatement) << std::endl; 
     std::cout << "Memory pool size of SgForStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgForStatement) << std::endl; 
     std::cout << "Memory pool size of SgFormatItem: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFormatItem) << std::endl; 
     std::cout << "Memory pool size of SgFormatItemList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFormatItemList) << std::endl; 
     std::cout << "Memory pool size of SgFormatStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFormatStatement) << std::endl; 
     std::cout << "Memory pool size of SgFortranDo: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFortranDo) << std::endl; 
     std::cout << "Memory pool size of SgFortranIncludeLine: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFortranIncludeLine) << std::endl; 
     std::cout << "Memory pool size of SgFortranNonblockedDo: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFortranNonblockedDo) << std::endl; 
     std::cout << "Memory pool size of SgFuncDecl_attr: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFuncDecl_attr) << std::endl; 
     std::cout << "Memory pool size of SgFunctionCallExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionCallExp) << std::endl; 
     std::cout << "Memory pool size of SgFunctionDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgFunctionDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionDefinition) << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterScope: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionParameterScope) << std::endl; 
     std::cout << "Memory pool size of SgFunctionModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionModifier) << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionParameterList) << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionParameterRefExp) << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterTypeList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionParameterTypeList) << std::endl; 
     std::cout << "Memory pool size of SgFunctionRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionRefExp) << std::endl; 
     std::cout << "Memory pool size of SgFunctionSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionSymbol) << std::endl; 
     std::cout << "Memory pool size of SgFunctionType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionType) << std::endl; 
     std::cout << "Memory pool size of SgFunctionTypeSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionTypeSymbol) << std::endl; 
     std::cout << "Memory pool size of SgFunctionTypeTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionTypeTable) << std::endl; 
     std::cout << "Memory pool size of SgTypeTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeTable) << std::endl; 
     std::cout << "Memory pool size of SgGlobal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGlobal) << std::endl; 
     std::cout << "Memory pool size of SgGotoStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGotoStatement) << std::endl; 
     std::cout << "Memory pool size of SgGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraph) << std::endl; 
     std::cout << "Memory pool size of SgGraphEdge: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraphEdge) << std::endl; 
     std::cout << "Memory pool size of SgGraphEdgeList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraphEdgeList) << std::endl; 
     std::cout << "Memory pool size of SgGraphNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraphNode) << std::endl; 
     std::cout << "Memory pool size of SgGraphNodeList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraphNodeList) << std::endl; 
     std::cout << "Memory pool size of SgGreaterOrEqualOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGreaterOrEqualOp) << std::endl; 
     std::cout << "Memory pool size of SgGreaterThanOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGreaterThanOp) << std::endl; 
     std::cout << "Memory pool size of SgIOItemExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIOItemExpression) << std::endl; 
     std::cout << "Memory pool size of SgIOStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIOStatement) << std::endl; 
     std::cout << "Memory pool size of SgIdentDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIdentDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgIfDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIfDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgIfStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIfStmt) << std::endl; 
     std::cout << "Memory pool size of SgIfdefDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIfdefDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgIfndefDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIfndefDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgImageControlStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgImageControlStatement) << std::endl; 
     std::cout << "Memory pool size of SgImagPartOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgImagPartOp) << std::endl; 
     std::cout << "Memory pool size of SgImplicitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgImplicitStatement) << std::endl; 
     std::cout << "Memory pool size of SgImpliedDo: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgImpliedDo) << std::endl; 
     std::cout << "Memory pool size of SgImportStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgImportStatement) << std::endl; 
     std::cout << "Memory pool size of SgIncidenceDirectedGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIncidenceDirectedGraph) << std::endl; 
     std::cout << "Memory pool size of SgIncidenceUndirectedGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIncidenceUndirectedGraph) << std::endl; 
     std::cout << "Memory pool size of SgIncludeDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIncludeDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgIncludeFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIncludeFile) << std::endl; 
     std::cout << "Memory pool size of SgIncludeNextDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIncludeNextDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgInitializedName: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInitializedName) << std::endl; 
     std::cout << "Memory pool size of SgInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInitializer) << std::endl; 
     std::cout << "Memory pool size of SgInquireStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInquireStatement) << std::endl; 
     std::cout << "Memory pool size of SgIntKeyedBidirectionalGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntKeyedBidirectionalGraph) << std::endl; 
     std::cout << "Memory pool size of SgIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntVal) << std::endl; 
     std::cout << "Memory pool size of SgIntegerDivideOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntegerDivideOp) << std::endl; 
     std::cout << "Memory pool size of SgIntegerDivideAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntegerDivideAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgInterfaceBody: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInterfaceBody) << std::endl; 
     std::cout << "Memory pool size of SgHeaderFileBody: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgHeaderFileBody) << std::endl; 
     std::cout << "Memory pool size of SgHeaderFileReport: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgHeaderFileReport) << std::endl; 
     std::cout << "Memory pool size of SgInterfaceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInterfaceStatement) << std::endl; 
     std::cout << "Memory pool size of SgInterfaceSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInterfaceSymbol) << std::endl; 
     std::cout << "Memory pool size of SgIntrinsicSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntrinsicSymbol) << std::endl; 
     std::cout << "Memory pool size of SgIsOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIsOp) << std::endl; 
     std::cout << "Memory pool size of SgIsNotOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIsNotOp) << std::endl; 
     std::cout << "Memory pool size of SgIorAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIorAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgJovialBitType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialBitType) << std::endl; 
     std::cout << "Memory pool size of SgJovialBitVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialBitVal) << std::endl; 
     std::cout << "Memory pool size of SgJovialTableType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialTableType) << std::endl; 
     std::cout << "Memory pool size of SgJovialCompoolStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialCompoolStatement) << std::endl; 
     std::cout << "Memory pool size of SgJovialForThenStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialForThenStatement) << std::endl; 
     std::cout << "Memory pool size of SgJovialDefineDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialDefineDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgJovialDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgJovialOverlayDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialOverlayDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgJovialPresetPositionExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialPresetPositionExp) << std::endl; 
     std::cout << "Memory pool size of SgJovialTablePresetExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialTablePresetExp) << std::endl; 
     std::cout << "Memory pool size of SgJovialTableStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialTableStatement) << std::endl; 
     std::cout << "Memory pool size of SgKeyDatumPair: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgKeyDatumPair) << std::endl; 
     std::cout << "Memory pool size of SgCudaKernelExecConfig: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCudaKernelExecConfig) << std::endl; 
     std::cout << "Memory pool size of SgCudaKernelCallExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCudaKernelCallExp) << std::endl; 
     std::cout << "Memory pool size of SgLabelRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLabelRefExp) << std::endl; 
     std::cout << "Memory pool size of SgLabelStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLabelStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaLabelStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaLabelStatement) << std::endl; 
     std::cout << "Memory pool size of SgLabelSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLabelSymbol) << std::endl; 
     std::cout << "Memory pool size of SgJavaLabelSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaLabelSymbol) << std::endl; 
     std::cout << "Memory pool size of SgLambdaCapture: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLambdaCapture) << std::endl; 
     std::cout << "Memory pool size of SgLambdaCaptureList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLambdaCaptureList) << std::endl; 
     std::cout << "Memory pool size of SgLambdaExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLambdaExp) << std::endl; 
     std::cout << "Memory pool size of SgLambdaRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLambdaRefExp) << std::endl; 
     std::cout << "Memory pool size of SgLeftDivideOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLeftDivideOp) << std::endl; 
     std::cout << "Memory pool size of SgLessOrEqualOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLessOrEqualOp) << std::endl; 
     std::cout << "Memory pool size of SgLessThanOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLessThanOp) << std::endl; 
     std::cout << "Memory pool size of SgLineDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLineDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgLinemarkerDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLinemarkerDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgLinkageModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLinkageModifier) << std::endl; 
     std::cout << "Memory pool size of SgListComprehension: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgListComprehension) << std::endl; 
     std::cout << "Memory pool size of SgListExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgListExp) << std::endl; 
     std::cout << "Memory pool size of SgLocatedNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLocatedNode) << std::endl; 
     std::cout << "Memory pool size of SgLocatedNodeSupport: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLocatedNodeSupport) << std::endl; 
     std::cout << "Memory pool size of SgLongDoubleVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLongDoubleVal) << std::endl; 
     std::cout << "Memory pool size of SgLongIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLongIntVal) << std::endl; 
     std::cout << "Memory pool size of SgLongLongIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLongLongIntVal) << std::endl; 
     std::cout << "Memory pool size of SgLshiftAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLshiftAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgLshiftOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLshiftOp) << std::endl; 
     std::cout << "Memory pool size of SgMagicColonExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMagicColonExp) << std::endl; 
     std::cout << "Memory pool size of SgMatrixExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMatrixExp) << std::endl; 
     std::cout << "Memory pool size of SgMatrixTransposeOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMatrixTransposeOp) << std::endl; 
     std::cout << "Memory pool size of SgMatlabForStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMatlabForStatement) << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMemberFunctionDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMemberFunctionRefExp) << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMemberFunctionSymbol) << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMemberFunctionType) << std::endl; 
     std::cout << "Memory pool size of SgMembershipOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMembershipOp) << std::endl; 
     std::cout << "Memory pool size of SgMicrosoftAttributeDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMicrosoftAttributeDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgMinusAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMinusAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgMinusMinusOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMinusMinusOp) << std::endl; 
     std::cout << "Memory pool size of SgMinusOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMinusOp) << std::endl; 
     std::cout << "Memory pool size of SgModAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgModOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModOp) << std::endl; 
     std::cout << "Memory pool size of SgModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModifier) << std::endl; 
     std::cout << "Memory pool size of SgModifierNodes: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModifierNodes) << std::endl; 
     std::cout << "Memory pool size of SgModifierType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModifierType) << std::endl; 
     std::cout << "Memory pool size of SgModuleStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModuleStatement) << std::endl; 
     std::cout << "Memory pool size of SgModuleSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModuleSymbol) << std::endl; 
     std::cout << "Memory pool size of SgMultAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMultAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgMultiplyOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMultiplyOp) << std::endl; 
     std::cout << "Memory pool size of SgName: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgName) << std::endl; 
     std::cout << "Memory pool size of SgNameGroup: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNameGroup) << std::endl; 
     std::cout << "Memory pool size of SgNamedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamedType) << std::endl; 
     std::cout << "Memory pool size of SgNamelistStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamelistStatement) << std::endl; 
     std::cout << "Memory pool size of SgNamespaceAliasDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamespaceAliasDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgNamespaceDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamespaceDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgNamespaceDefinitionStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamespaceDefinitionStatement) << std::endl; 
     std::cout << "Memory pool size of SgNamespaceSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamespaceSymbol) << std::endl; 
     std::cout << "Memory pool size of SgNaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNaryOp) << std::endl; 
     std::cout << "Memory pool size of SgNaryBooleanOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNaryBooleanOp) << std::endl; 
     std::cout << "Memory pool size of SgNaryComparisonOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNaryComparisonOp) << std::endl; 
     std::cout << "Memory pool size of SgNewExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNewExp) << std::endl; 
     std::cout << "Memory pool size of SgNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNode) << std::endl; 
     std::cout << "Memory pool size of SgNoexceptOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNoexceptOp) << std::endl; 
     std::cout << "Memory pool size of SgNotEqualOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNotEqualOp) << std::endl; 
     std::cout << "Memory pool size of SgNotOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNotOp) << std::endl; 
     std::cout << "Memory pool size of SgNonMembershipOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNonMembershipOp) << std::endl; 
     std::cout << "Memory pool size of SgNonrealDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNonrealDecl) << std::endl; 
     std::cout << "Memory pool size of SgNonrealRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNonrealRefExp) << std::endl; 
     std::cout << "Memory pool size of SgNonrealSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNonrealSymbol) << std::endl; 
     std::cout << "Memory pool size of SgNonrealType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNonrealType) << std::endl; 
     std::cout << "Memory pool size of SgNonrealBaseClass: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNonrealBaseClass) << std::endl; 
     std::cout << "Memory pool size of SgNullExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNullExpression) << std::endl; 
     std::cout << "Memory pool size of SgNullptrValExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNullptrValExp) << std::endl; 
     std::cout << "Memory pool size of SgNullStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNullStatement) << std::endl; 
     std::cout << "Memory pool size of SgNullifyStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNullifyStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpAtomicStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpAtomicStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpBarrierStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpBarrierStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpCriticalStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpCriticalStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpClauseBodyStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpClauseBodyStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpBodyStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpBodyStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpDoStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpDoStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpFlushStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpFlushStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpDeclareSimdStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpDeclareSimdStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpForStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpForStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpForSimdStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpForSimdStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpMasterStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpMasterStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpOrderedStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpOrderedStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpParallelStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpParallelStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpSectionStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSectionStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpSectionsStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSectionsStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpSingleStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSingleStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpTaskStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpTaskStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpTaskwaitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpTaskwaitStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpThreadprivateStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpThreadprivateStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpWorkshareStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpWorkshareStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpTargetStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpTargetStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpTargetDataStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpTargetDataStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpSimdStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSimdStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpBeginClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpBeginClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpCollapseClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpCollapseClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpCopyinClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpCopyinClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpCopyprivateClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpCopyprivateClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpDefaultClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpDefaultClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpEndClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpEndClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpExpressionClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpExpressionClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpFirstprivateClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpFirstprivateClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpIfClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpIfClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpFinalClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpFinalClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpPriorityClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpPriorityClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpDeviceClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpDeviceClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpLastprivateClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpLastprivateClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpNowaitClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpNowaitClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpNumThreadsClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpNumThreadsClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpOrderedClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpOrderedClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpPrivateClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpPrivateClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpReductionClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpReductionClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpScheduleClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpScheduleClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpSharedClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSharedClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpUntiedClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpUntiedClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpMergeableClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpMergeableClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpVariablesClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpVariablesClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpMapClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpMapClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpSafelenClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSafelenClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpSimdlenClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSimdlenClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpLinearClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpLinearClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpUniformClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpUniformClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpAlignedClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpAlignedClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpProcBindClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpProcBindClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpAtomicClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpAtomicClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpInbranchClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpInbranchClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpNotinbranchClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpNotinbranchClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpDependClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpDependClause) << std::endl; 
     std::cout << "Memory pool size of SgOpenclAccessModeModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOpenclAccessModeModifier) << std::endl; 
     std::cout << "Memory pool size of SgOpenStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOpenStatement) << std::endl; 
     std::cout << "Memory pool size of SgOptions: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOptions) << std::endl; 
     std::cout << "Memory pool size of SgOrOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOrOp) << std::endl; 
     std::cout << "Memory pool size of SgParameterStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgParameterStatement) << std::endl; 
     std::cout << "Memory pool size of SgPartialFunctionModifierType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPartialFunctionModifierType) << std::endl; 
     std::cout << "Memory pool size of SgPartialFunctionType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPartialFunctionType) << std::endl; 
     std::cout << "Memory pool size of SgPassStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPassStatement) << std::endl; 
     std::cout << "Memory pool size of SgPlusAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPlusAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgPlusPlusOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPlusPlusOp) << std::endl; 
     std::cout << "Memory pool size of SgPntrArrRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPntrArrRefExp) << std::endl; 
     std::cout << "Memory pool size of SgPointerAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPointerAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgPointerDerefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPointerDerefExp) << std::endl; 
     std::cout << "Memory pool size of SgPointerMemberType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPointerMemberType) << std::endl; 
     std::cout << "Memory pool size of SgPointerType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPointerType) << std::endl; 
     std::cout << "Memory pool size of SgPowerOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPowerOp) << std::endl; 
     std::cout << "Memory pool size of SgPragma: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPragma) << std::endl; 
     std::cout << "Memory pool size of SgPragmaDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPragmaDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgPrintStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPrintStatement) << std::endl; 
     std::cout << "Memory pool size of SgProcedureHeaderStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgProcedureHeaderStatement) << std::endl; 
     std::cout << "Memory pool size of SgProgramHeaderStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgProgramHeaderStatement) << std::endl; 
     std::cout << "Memory pool size of SgProject: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgProject) << std::endl; 
     std::cout << "Memory pool size of SgPseudoDestructorRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPseudoDestructorRefExp) << std::endl; 
     std::cout << "Memory pool size of SgPythonGlobalStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPythonGlobalStmt) << std::endl; 
     std::cout << "Memory pool size of SgPythonPrintStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPythonPrintStmt) << std::endl; 
     std::cout << "Memory pool size of SgQualifiedName: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgQualifiedName) << std::endl; 
     std::cout << "Memory pool size of SgQualifiedNameType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgQualifiedNameType) << std::endl; 
     std::cout << "Memory pool size of SgRangeExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRangeExp) << std::endl; 
     std::cout << "Memory pool size of SgRangeBasedForStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRangeBasedForStatement) << std::endl; 
     std::cout << "Memory pool size of SgReadStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgReadStatement) << std::endl; 
     std::cout << "Memory pool size of SgRealPartOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRealPartOp) << std::endl; 
     std::cout << "Memory pool size of SgRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRefExp) << std::endl; 
     std::cout << "Memory pool size of SgReferenceType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgReferenceType) << std::endl; 
     std::cout << "Memory pool size of SgRemOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRemOp) << std::endl; 
     std::cout << "Memory pool size of SgRenamePair: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRenamePair) << std::endl; 
     std::cout << "Memory pool size of SgRenameSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRenameSymbol) << std::endl; 
     std::cout << "Memory pool size of SgReplicationOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgReplicationOp) << std::endl; 
     std::cout << "Memory pool size of SgReturnStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgReturnStmt) << std::endl; 
     std::cout << "Memory pool size of SgRewindStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRewindStatement) << std::endl; 
     std::cout << "Memory pool size of SgRshiftAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRshiftAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgRshiftOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRshiftOp) << std::endl; 
     std::cout << "Memory pool size of SgRvalueReferenceType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRvalueReferenceType) << std::endl; 
     std::cout << "Memory pool size of SgJavaUnsignedRshiftAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaUnsignedRshiftAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgJavaUnsignedRshiftOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaUnsignedRshiftOp) << std::endl; 
     std::cout << "Memory pool size of SgScopeOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgScopeOp) << std::endl; 
     std::cout << "Memory pool size of SgScopeStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgScopeStatement) << std::endl; 
     std::cout << "Memory pool size of SgSequenceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSequenceStatement) << std::endl; 
     std::cout << "Memory pool size of SgSetComprehension: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSetComprehension) << std::endl; 
     std::cout << "Memory pool size of SgShortVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgShortVal) << std::endl; 
     std::cout << "Memory pool size of SgSizeOfOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSizeOfOp) << std::endl; 
     std::cout << "Memory pool size of SgAlignOfOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAlignOfOp) << std::endl; 
     std::cout << "Memory pool size of SgJavaInstanceOfOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaInstanceOfOp) << std::endl; 
     std::cout << "Memory pool size of SgSourceFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSourceFile) << std::endl; 
     std::cout << "Memory pool size of SgSpaceshipOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSpaceshipOp) << std::endl; 
     std::cout << "Memory pool size of SgSpawnStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSpawnStmt) << std::endl; 
     std::cout << "Memory pool size of SgSyncAllStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSyncAllStatement) << std::endl; 
     std::cout << "Memory pool size of SgSyncImagesStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSyncImagesStatement) << std::endl; 
     std::cout << "Memory pool size of SgSyncMemoryStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSyncMemoryStatement) << std::endl; 
     std::cout << "Memory pool size of SgSyncTeamStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSyncTeamStatement) << std::endl; 
     std::cout << "Memory pool size of SgLockStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLockStatement) << std::endl; 
     std::cout << "Memory pool size of SgUnlockStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnlockStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaThrowStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaThrowStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaForEachStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaForEachStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaSynchronizedStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaSynchronizedStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaParameterizedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaParameterizedType) << std::endl; 
     std::cout << "Memory pool size of SgJavaWildcardType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaWildcardType) << std::endl; 
     std::cout << "Memory pool size of SgProcessControlStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgProcessControlStatement) << std::endl; 
     std::cout << "Memory pool size of SgSpecialFunctionModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSpecialFunctionModifier) << std::endl; 
     std::cout << "Memory pool size of SgStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStatement) << std::endl; 
     std::cout << "Memory pool size of SgStaticAssertionDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStaticAssertionDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgStmtDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStmtDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgStatementExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStatementExpression) << std::endl; 
     std::cout << "Memory pool size of SgStatementFunctionStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStatementFunctionStatement) << std::endl; 
     std::cout << "Memory pool size of SgStorageModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStorageModifier) << std::endl; 
     std::cout << "Memory pool size of SgStringConversion: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStringConversion) << std::endl; 
     std::cout << "Memory pool size of SgStringKeyedBidirectionalGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStringKeyedBidirectionalGraph) << std::endl; 
     std::cout << "Memory pool size of SgStringVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStringVal) << std::endl; 
     std::cout << "Memory pool size of SgStructureModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStructureModifier) << std::endl; 
     std::cout << "Memory pool size of SgSubscriptExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSubscriptExpression) << std::endl; 
     std::cout << "Memory pool size of SgSubtractOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSubtractOp) << std::endl; 
     std::cout << "Memory pool size of SgSupport: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSupport) << std::endl; 
     std::cout << "Memory pool size of SgSwitchStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSwitchStatement) << std::endl; 
     std::cout << "Memory pool size of SgSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSymbol) << std::endl; 
     std::cout << "Memory pool size of SgSymbolTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSymbolTable) << std::endl; 
     std::cout << "Memory pool size of SgTemplateArgument: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateArgument) << std::endl; 
     std::cout << "Memory pool size of SgTemplateArgumentList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateArgumentList) << std::endl; 
     std::cout << "Memory pool size of SgTemplateDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateClassDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateClassSymbol) << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateFunctionDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateFunctionRefExp) << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateFunctionSymbol) << std::endl; 
     std::cout << "Memory pool size of SgTemplateMemberFunctionDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateMemberFunctionDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateMemberFunctionRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateMemberFunctionRefExp) << std::endl; 
     std::cout << "Memory pool size of SgTemplateMemberFunctionSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateMemberFunctionSymbol) << std::endl; 
     std::cout << "Memory pool size of SgTemplateTypedefDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateTypedefDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateTypedefSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateTypedefSymbol) << std::endl; 
     std::cout << "Memory pool size of SgTemplateVariableDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateVariableDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateVariableSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateVariableSymbol) << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateClassDefinition) << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateFunctionDefinition) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationDecl) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDefn: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationDefn) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationFunctionDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationFunctionDecl) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationMemberFunctionDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationMemberFunctionDecl) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationTypedefDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationTypedefDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameter: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateParameter) << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameterVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateParameterVal) << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameterList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateParameterList) << std::endl; 
     std::cout << "Memory pool size of SgTemplateSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateSymbol) << std::endl; 
     std::cout << "Memory pool size of SgTemplateType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateType) << std::endl; 
     std::cout << "Memory pool size of SgThisExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgThisExp) << std::endl; 
     std::cout << "Memory pool size of SgTypeTraitBuiltinOperator: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeTraitBuiltinOperator) << std::endl; 
     std::cout << "Memory pool size of SgSuperExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSuperExp) << std::endl; 
     std::cout << "Memory pool size of SgThrowOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgThrowOp) << std::endl; 
     std::cout << "Memory pool size of SgToken: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgToken) << std::endl; 
     std::cout << "Memory pool size of SgTryStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTryStmt) << std::endl; 
     std::cout << "Memory pool size of SgTupleExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTupleExp) << std::endl; 
     std::cout << "Memory pool size of SgType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgType) << std::endl; 
     std::cout << "Memory pool size of SgTypeBool: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeBool) << std::endl; 
     std::cout << "Memory pool size of SgTypeChar: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeChar) << std::endl; 
     std::cout << "Memory pool size of SgTypeChar16: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeChar16) << std::endl; 
     std::cout << "Memory pool size of SgTypeChar32: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeChar32) << std::endl; 
     std::cout << "Memory pool size of SgTypeComplex: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeComplex) << std::endl; 
     std::cout << "Memory pool size of SgTypeDefault: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeDefault) << std::endl; 
     std::cout << "Memory pool size of SgTypeExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeExpression) << std::endl; 
     std::cout << "Memory pool size of SgTypeLabel: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeLabel) << std::endl; 
     std::cout << "Memory pool size of SgTypeDouble: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeDouble) << std::endl; 
     std::cout << "Memory pool size of SgTypeEllipse: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeEllipse) << std::endl; 
     std::cout << "Memory pool size of SgTypeFixed: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeFixed) << std::endl; 
     std::cout << "Memory pool size of SgTypeFloat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeFloat) << std::endl; 
     std::cout << "Memory pool size of SgTypeFloat128: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeFloat128) << std::endl; 
     std::cout << "Memory pool size of SgTypeFloat80: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeFloat80) << std::endl; 
     std::cout << "Memory pool size of SgTypeGlobalVoid: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeGlobalVoid) << std::endl; 
     std::cout << "Memory pool size of SgTypeIdOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeIdOp) << std::endl; 
     std::cout << "Memory pool size of SgTypeImaginary: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeImaginary) << std::endl; 
     std::cout << "Memory pool size of SgTypeInt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeInt) << std::endl; 
     std::cout << "Memory pool size of SgTypeLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeLongDouble: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeLongDouble) << std::endl; 
     std::cout << "Memory pool size of SgTypeLongLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeLongLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeModifier) << std::endl; 
     std::cout << "Memory pool size of SgTypeMatrix: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeMatrix) << std::endl; 
     std::cout << "Memory pool size of SgTypeTuple: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeTuple) << std::endl; 
     std::cout << "Memory pool size of SgTypeNullptr: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeNullptr) << std::endl; 
     std::cout << "Memory pool size of SgTypeOfType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeOfType) << std::endl; 
     std::cout << "Memory pool size of SgTypeShort: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeShort) << std::endl; 
     std::cout << "Memory pool size of SgTypeSigned128bitInteger: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSigned128bitInteger) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedChar: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedChar) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedInt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedInt) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedLongLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedLongLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedShort: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedShort) << std::endl; 
     std::cout << "Memory pool size of SgTypeString: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeString) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnknown: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnknown) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsigned128bitInteger: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsigned128bitInteger) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedChar: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedChar) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedInt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedInt) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedLongLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedLongLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedShort: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedShort) << std::endl; 
     std::cout << "Memory pool size of SgTypeVoid: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeVoid) << std::endl; 
     std::cout << "Memory pool size of SgTypeWchar: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeWchar) << std::endl; 
     std::cout << "Memory pool size of SgTypedefDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypedefDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTypedefSeq: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypedefSeq) << std::endl; 
     std::cout << "Memory pool size of SgTypedefSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypedefSymbol) << std::endl; 
     std::cout << "Memory pool size of SgTypedefType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypedefType) << std::endl; 
     std::cout << "Memory pool size of SgUPC_AccessModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUPC_AccessModifier) << std::endl; 
     std::cout << "Memory pool size of SgUnaryAddOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnaryAddOp) << std::endl; 
     std::cout << "Memory pool size of SgUnaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnaryOp) << std::endl; 
     std::cout << "Memory pool size of SgUndefDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUndefDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgUndirectedGraphEdge: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUndirectedGraphEdge) << std::endl; 
     std::cout << "Memory pool size of SgUnknownArrayOrFunctionReference: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnknownArrayOrFunctionReference) << std::endl; 
     std::cout << "Memory pool size of SgUnknownFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnknownFile) << std::endl; 
     std::cout << "Memory pool size of SgUnparse_Info: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnparse_Info) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedCharVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedCharVal) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedIntVal) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedLongLongIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedLongLongIntVal) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedLongVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedLongVal) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedShortVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedShortVal) << std::endl; 
     std::cout << "Memory pool size of SgUpcBarrierStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcBarrierStatement) << std::endl; 
     std::cout << "Memory pool size of SgUpcBlocksizeofExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcBlocksizeofExpression) << std::endl; 
     std::cout << "Memory pool size of SgUpcElemsizeofExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcElemsizeofExpression) << std::endl; 
     std::cout << "Memory pool size of SgUpcFenceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcFenceStatement) << std::endl; 
     std::cout << "Memory pool size of SgUpcForAllStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcForAllStatement) << std::endl; 
     std::cout << "Memory pool size of SgUpcLocalsizeofExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcLocalsizeofExpression) << std::endl; 
     std::cout << "Memory pool size of SgUpcMythread: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcMythread) << std::endl; 
     std::cout << "Memory pool size of SgUpcNotifyStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcNotifyStatement) << std::endl; 
     std::cout << "Memory pool size of SgUpcThreads: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcThreads) << std::endl; 
     std::cout << "Memory pool size of SgUpcWaitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcWaitStatement) << std::endl; 
     std::cout << "Memory pool size of SgUseStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUseStatement) << std::endl; 
     std::cout << "Memory pool size of SgUserDefinedBinaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUserDefinedBinaryOp) << std::endl; 
     std::cout << "Memory pool size of SgUserDefinedUnaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUserDefinedUnaryOp) << std::endl; 
     std::cout << "Memory pool size of SgUsingDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUsingDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgUsingDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUsingDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgValueExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgValueExp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgCopyOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgCopyOp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgEndOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgEndOp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgOp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgStartOneOperandOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgStartOneOperandOp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgStartOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgStartOp) << std::endl; 
     std::cout << "Memory pool size of SgVarRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarRefExp) << std::endl; 
     std::cout << "Memory pool size of SgVariableDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariableDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgVariableDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariableDefinition) << std::endl; 
     std::cout << "Memory pool size of SgVariableSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariableSymbol) << std::endl; 
     std::cout << "Memory pool size of SgVariantExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariantExpression) << std::endl; 
     std::cout << "Memory pool size of SgVariantStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariantStatement) << std::endl; 
     std::cout << "Memory pool size of SgVoidVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVoidVal) << std::endl; 
     std::cout << "Memory pool size of SgWaitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWaitStatement) << std::endl; 
     std::cout << "Memory pool size of SgWarningDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWarningDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgWithStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWithStatement) << std::endl; 
     std::cout << "Memory pool size of SgWcharVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWcharVal) << std::endl; 
     std::cout << "Memory pool size of SgWhereStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWhereStatement) << std::endl; 
     std::cout << "Memory pool size of SgWhileStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWhileStmt) << std::endl; 
     std::cout << "Memory pool size of SgWriteStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWriteStatement) << std::endl; 
     std::cout << "Memory pool size of SgXorAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgXorAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgYieldExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgYieldExpression) << std::endl; 
     std::cout << "Memory pool size of Sg_File_Info: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_Sg_File_Info) << std::endl; 
     std::cout << "Memory pool size of SgTypeCAFTeam: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeCAFTeam) << std::endl; 
     std::cout << "Memory pool size of SgCAFWithTeamStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCAFWithTeamStatement) << std::endl; 
     std::cout << "Memory pool size of SgCAFCoExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCAFCoExpression) << std::endl; 
     std::cout << "Memory pool size of SgCallExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCallExpression) << std::endl; 
     std::cout << "Memory pool size of SgTypeCrayPointer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeCrayPointer) << std::endl; 
     std::cout << "Memory pool size of SgJavaImportStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaImportStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaPackageDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaPackageDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgJavaPackageStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaPackageStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaImportStatementList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaImportStatementList) << std::endl; 
     std::cout << "Memory pool size of SgJavaClassDeclarationList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaClassDeclarationList) << std::endl; 
     std::cout << "Memory pool size of SgJavaMemberValuePair: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaMemberValuePair) << std::endl; 
     std::cout << "Memory pool size of SgJavaAnnotation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaAnnotation) << std::endl; 
     std::cout << "Memory pool size of SgJavaMarkerAnnotation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaMarkerAnnotation) << std::endl; 
     std::cout << "Memory pool size of SgJavaSingleMemberAnnotation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaSingleMemberAnnotation) << std::endl; 
     std::cout << "Memory pool size of SgJavaNormalAnnotation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaNormalAnnotation) << std::endl; 
     std::cout << "Memory pool size of SgJavaTypeExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaTypeExpression) << std::endl; 
     std::cout << "Memory pool size of SgJavaQualifiedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaQualifiedType) << std::endl; 
     std::cout << "Memory pool size of SgClassExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassExp) << std::endl; 
     std::cout << "Memory pool size of SgJavaUnionType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaUnionType) << std::endl; 
     std::cout << "Memory pool size of SgJavaParameterType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaParameterType) << std::endl; 
     std::cout << "Memory pool size of SgAsyncStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsyncStmt) << std::endl; 
     std::cout << "Memory pool size of SgFinishStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFinishStmt) << std::endl; 
     std::cout << "Memory pool size of SgAtStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAtStmt) << std::endl; 
     std::cout << "Memory pool size of SgAtomicStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAtomicStmt) << std::endl; 
     std::cout << "Memory pool size of SgWhenStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWhenStmt) << std::endl; 
     std::cout << "Memory pool size of SgAtExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAtExp) << std::endl; 
     std::cout << "Memory pool size of SgFinishExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFinishExp) << std::endl; 
     std::cout << "Memory pool size of SgHereExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgHereExp) << std::endl; 
     std::cout << "Memory pool size of SgDotDotExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDotDotExp) << std::endl; 
     std::cout << "Memory pool size of SgAsmNullInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNullInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAdaComponentClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaComponentClause) << std::endl; 
     std::cout << "Memory pool size of SgAdaIndexConstraint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaIndexConstraint) << std::endl; 
     std::cout << "Memory pool size of SgAdaModularType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaModularType) << std::endl; 
     std::cout << "Memory pool size of SgAdaRepresentationClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaRepresentationClause) << std::endl; 
     std::cout << "Memory pool size of SgAdaFunctionRenamingDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaFunctionRenamingDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaSelectStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaSelectStmt) << std::endl; 
     std::cout << "Memory pool size of SgAdaSelectAlternativeStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaSelectAlternativeStmt) << std::endl; 
     std::cout << "Memory pool size of SgAdaTerminateStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaTerminateStmt) << std::endl; 
     std::cout << "Memory pool size of SgAsmAarch32Coprocessor: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmAarch32Coprocessor) << std::endl; 
     std::cout << "Memory pool size of SgAdaAttributeClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaAttributeClause) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryConcat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryConcat) << std::endl; 
     std::cout << "Memory pool size of SgAsmByteOrder: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmByteOrder) << std::endl; 
     std::cout << "Memory pool size of SgAdaDerivedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaDerivedType) << std::endl; 
     std::cout << "Memory pool size of SgAdaAttributeExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaAttributeExp) << std::endl; 
     std::cout << "Memory pool size of SgAdaEnumRepresentationClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaEnumRepresentationClause) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryPreupdate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryPreupdate) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryPostupdate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryPostupdate) << std::endl; 
     std::cout << "Memory pool size of SgAdaOthersExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaOthersExp) << std::endl; 
     std::cout << "Memory pool size of SgAdaRenamingSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaRenamingSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAdaRenamingRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaRenamingRefExp) << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaGenericDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericDefn: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaGenericDefn) << std::endl; 
     std::cout << "Memory pool size of SgAdaFormalType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaFormalType) << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaGenericSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAdaFormalTypeDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaFormalTypeDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaUnitRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaUnitRefExp) << std::endl; 
     std::cout << "Memory pool size of SgAdaDiscriminatedTypeDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaDiscriminatedTypeDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaDiscriminatedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaDiscriminatedType) << std::endl; 
     std::cout << "Memory pool size of SgAdaDiscriminantConstraint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaDiscriminantConstraint) << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericInstanceDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaGenericInstanceDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaUnscopedBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaUnscopedBlock) << std::endl; 
     std::cout << "Memory pool size of SgAdaInheritedFunctionSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaInheritedFunctionSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedBody: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaProtectedBody) << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedBodyDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaProtectedBodyDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedSpec: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaProtectedSpec) << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedSpecDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaProtectedSpecDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaProtectedSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaProtectedRefExp) << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaProtectedType) << std::endl; 
     std::cout << "Memory pool size of SgAdaProtectedTypeDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaProtectedTypeDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaDigitsConstraint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaDigitsConstraint) << std::endl; 
     std::cout << "Memory pool size of SgAdaAncestorInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaAncestorInitializer) << std::endl; 
     std::cout << "Memory pool size of SgAdaDeltaConstraint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaDeltaConstraint) << std::endl; 
     std::cout << "Memory pool size of SgAdaSubroutineType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaSubroutineType) << std::endl; 
     std::cout << "Memory pool size of SgAdaGenericInstanceSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaGenericInstanceSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAdaFormalPackageDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaFormalPackageDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaFormalPackageSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaFormalPackageSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmAttributeTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmAttributeTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmMethodTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmMethodTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmField: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmField) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmFieldTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmFieldTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmExceptionHandler: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmExceptionHandler) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmExceptionTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmExceptionTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmClass: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmClass) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLineNumberEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmLineNumberEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLineNumberTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmLineNumberTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmInnerClassesEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmInnerClassesEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmInnerClasses: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmInnerClasses) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmStackExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStackExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmEnclosingMethod: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmEnclosingMethod) << std::endl; 
     std::cout << "Memory pool size of SgAdaNullConstraint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaNullConstraint) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmModuleMainClass: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmModuleMainClass) << std::endl; 
     std::cout << "Memory pool size of SgAsmInstructionList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmInstructionList) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilNode) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssembly: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssembly) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyOS: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyOS) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyProcessor: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyProcessor) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRef: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyRef) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefOS: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyRefOS) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefProcessor: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyRefProcessor) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilClassLayout: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilClassLayout) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilConstant: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilConstant) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilCustomAttribute: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilCustomAttribute) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilDeclSecurity: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilDeclSecurity) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilEvent: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilEvent) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilEventMap: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilEventMap) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilExportedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilExportedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilField: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilField) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldLayout: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilFieldLayout) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldMarshal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilFieldMarshal) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldRVA: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilFieldRVA) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilFile) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilGenericParam: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilGenericParam) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilGenericParamConstraint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilGenericParamConstraint) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilImplMap: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilImplMap) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilInterfaceImpl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilInterfaceImpl) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilManifestResource: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilManifestResource) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMemberRef: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMemberRef) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodDef: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMethodDef) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodImpl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMethodImpl) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodSemantics: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMethodSemantics) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodSpec: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMethodSpec) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilModule: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilModule) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilModuleRef: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilModuleRef) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilNestedClass: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilNestedClass) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilParam: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilParam) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilProperty: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilProperty) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilPropertyMap: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilPropertyMap) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilStandAloneSig: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilStandAloneSig) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeDef: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilTypeDef) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeRef: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilTypeRef) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeSpec: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilTypeSpec) << std::endl; 
     std::cout << "Memory pool size of SgAdaParameterList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaParameterList) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMetadata: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMetadata) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMetadataRoot: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMetadataRoot) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilDataStream: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilDataStream) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMetadataHeap: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMetadataHeap) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilUint8Heap: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilUint8Heap) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilUint32Heap: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilUint32Heap) << std::endl; 
     std::cout << "Memory pool size of SgAsmCliHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCliHeader) << std::endl; 
     std::cout << "Memory pool size of SgAdaVariantDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaVariantDecl) << std::endl; 
     std::cout << "Memory pool size of SgAdaVariantWhenStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAdaVariantWhenStmt) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyOSTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyOSTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyProcessorTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyProcessorTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyRefTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefOSTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyRefOSTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilAssemblyRefProcessorTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilAssemblyRefProcessorTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilClassLayoutTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilClassLayoutTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilConstantTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilConstantTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilCustomAttributeTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilCustomAttributeTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilDeclSecurityTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilDeclSecurityTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilEventTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilEventTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilEventMapTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilEventMapTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilExportedTypeTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilExportedTypeTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilFieldTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldLayoutTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilFieldLayoutTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldMarshalTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilFieldMarshalTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFieldRVATable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilFieldRVATable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilFileTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilFileTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilGenericParamTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilGenericParamTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilGenericParamConstraintTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilGenericParamConstraintTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilImplMapTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilImplMapTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilInterfaceImplTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilInterfaceImplTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilManifestResourceTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilManifestResourceTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMemberRefTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMemberRefTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodDefTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMethodDefTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodImplTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMethodImplTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodSemanticsTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMethodSemanticsTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodSpecTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMethodSpecTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilModuleTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilModuleTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilModuleRefTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilModuleRefTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilNestedClassTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilNestedClassTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilParamTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilParamTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilPropertyTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilPropertyTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilPropertyMapTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilPropertyMapTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilStandAloneSigTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilStandAloneSigTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeDefTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilTypeDefTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeRefTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilTypeRefTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilTypeSpecTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilTypeSpecTable) << std::endl; 
     std::cout << "Memory pool size of SgJvmComposite: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJvmComposite) << std::endl; 
     std::cout << "Memory pool size of SgFortranContinueStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFortranContinueStmt) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmStackMapTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmStackMapTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmStackMapFrame: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmStackMapFrame) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmStackMapVerificationType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmStackMapVerificationType) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmBootstrapMethod: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmBootstrapMethod) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmBootstrapMethods: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmBootstrapMethods) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmExceptions: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmExceptions) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmNestMembers: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmNestMembers) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmNestHost: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmNestHost) << std::endl; 
     std::cout << "Memory pool size of SgJovialLabelDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJovialLabelDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLocalVariableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmLocalVariableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLocalVariableTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmLocalVariableTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLocalVariableTypeEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmLocalVariableTypeEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmLocalVariableTypeTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmLocalVariableTypeTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmUserInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUserInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmMethodParameters: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmMethodParameters) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmMethodParametersEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmMethodParametersEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmVoidType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmVoidType) << std::endl; 
     std::cout << "Memory pool size of SgAsmPointerType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPointerType) << std::endl; 
     std::cout << "Memory pool size of SgRangeType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRangeType) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilExceptionData: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilExceptionData) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilMethodData: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilMethodData) << std::endl; 
     std::cout << "Memory pool size of SgTemplateVariableInstantiation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateVariableInstantiation) << std::endl; 
     std::cout << "Memory pool size of SgReferenceExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgReferenceExp) << std::endl; 
     std::cout << "Memory pool size of SgTypeRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeRefExp) << std::endl; 
     std::cout << "Memory pool size of SgScopedRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgScopedRefExp) << std::endl; 
     std::cout << "Memory pool size of SgScopedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgScopedType) << std::endl; 
     std::cout << "Memory pool size of SgTypeSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmSynthetic: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmSynthetic) << std::endl; 
     std::cout << "Memory pool size of SgAsmJvmDeprecated: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmJvmDeprecated) << std::endl; 
     std::cout << "Memory pool size of SgSignedCharVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSignedCharVal) << std::endl; 
     std::cout << "Memory pool size of SgAsmCilErrorHeap: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCilErrorHeap) << std::endl; 

/* #line 477 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
     std::cout << " Total number of IR nodes in contained in the memory pools: "  
               << vectorOfASTs[index]->getTotalNumberOfASTIRNodes() << std::endl << std::endl;
     return;
   }


AstData* 
AST_FILE_IO::getAst (int index)
   {
     assert( index <= (int)vectorOfASTs.size() );
     return vectorOfASTs[index];
   }


AstData* 
AST_FILE_IO::getAstWithRoot (SgProject* root)
   {
     std::vector<AstSpecificDataManagingClass*>:: iterator astIter = vectorOfASTs.begin();
     while ( astIter != vectorOfASTs.end() && (*astIter)->getRootOfAst() != root )
        {
          astIter++;
        }
     assert( astIter!= vectorOfASTs.end() );
     return *astIter;
   }


/* JW (06/21/2006) Refactored this to have a write-to-stream function so
 * stringstreams can be used */
void
AST_FILE_IO :: writeASTToStream ( std::ostream& out) {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile():");
 
     assert ( freepointersOfCurrentAstAreSetToGlobalIndices == true );
     assert ( 0 < getTotalNumberOfNodesOfAstInMemoryPool() );
     std::string startString = "ROSE_AST_BINARY_START";
     out.write ( startString.c_str(), startString.size() );

  // 1. Write the accumulatedPoolSizesOfAstInMemoryPool 
     AstDataStorageClass staticTemp;
     staticTemp.pickOutIRNodeData(actualRebuildAst);
     
     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() raw file write part 1 (memory pool data):"); 
     out.write ( (char*)(&staticTemp) , sizeof(AstDataStorageClass) );
     }
     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() raw file write part 2 (easy storage data):");
     AstDataStorageClass::writeEasyStorageDataToFile(out);
     }
     
  // 1.a Introducing a marker to check the right position in the file     

     std::string markString = "#########";
     out.write ( markString.c_str(), markString.size() );

  // 2. Initialize the StorageClass and write

  // DQ (9/3/2015): Fixed size and unsigned-ness of type.
  // int sizeOfActualPool   = 0;
     unsigned long sizeOfActualPool  = 0 ; 
  // DQ (9/3/2015): Fixed unsigned-ness of type.
     unsigned long storageClassIndex = 0;

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() raw file write part 3 (rest of AST data):");

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAccessModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAccessModifierStorageClass* storageArray = new SgAccessModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAccessModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAccessModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgActualArgumentExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgActualArgumentExpressionStorageClass* storageArray = new SgActualArgumentExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgActualArgumentExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgActualArgumentExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgActualArgumentExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAbsOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAbsOpStorageClass* storageArray = new SgAbsOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAbsOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAbsOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAbsOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaAccessType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAccessTypeStorageClass* storageArray = new SgAdaAccessTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaAccessType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaAccessTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaAccessTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaAcceptStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAcceptStmtStorageClass* storageArray = new SgAdaAcceptStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaAcceptStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaAcceptStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaAcceptStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaDelayStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDelayStmtStorageClass* storageArray = new SgAdaDelayStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaDelayStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaDelayStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaDelayStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaEntryDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaEntryDeclStorageClass* storageArray = new SgAdaEntryDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaEntryDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaEntryDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaEntryDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaExitStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaExitStmtStorageClass* storageArray = new SgAdaExitStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaExitStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaExitStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaExitStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaDiscreteType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDiscreteTypeStorageClass* storageArray = new SgAdaDiscreteTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaDiscreteType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaDiscreteTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaDiscreteTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaFloatVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFloatValStorageClass* storageArray = new SgAdaFloatValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaFloatVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaFloatValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaFloatValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaLoopStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaLoopStmtStorageClass* storageArray = new SgAdaLoopStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaLoopStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaLoopStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaLoopStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaPackageBody ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageBodyStorageClass* storageArray = new SgAdaPackageBodyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaPackageBody::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaPackageBodyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaPackageBodyStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaPackageBodyDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageBodyDeclStorageClass* storageArray = new SgAdaPackageBodyDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaPackageBodyDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaPackageBodyDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaPackageBodyDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaPackageSpec ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageSpecStorageClass* storageArray = new SgAdaPackageSpecStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaPackageSpec::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaPackageSpecStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaPackageSpecStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaPackageSpecDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageSpecDeclStorageClass* storageArray = new SgAdaPackageSpecDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaPackageSpecDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaPackageSpecDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaPackageSpecDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaPackageSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaPackageSymbolStorageClass* storageArray = new SgAdaPackageSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaPackageSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaPackageSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaPackageSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaRangeConstraint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRangeConstraintStorageClass* storageArray = new SgAdaRangeConstraintStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaRangeConstraint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaRangeConstraintStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaRangeConstraintStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaRenamingDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRenamingDeclStorageClass* storageArray = new SgAdaRenamingDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaRenamingDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaRenamingDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaRenamingDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaSubtype ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaSubtypeStorageClass* storageArray = new SgAdaSubtypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaSubtype::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaSubtypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaSubtypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTaskBody ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskBodyStorageClass* storageArray = new SgAdaTaskBodyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTaskBody::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTaskBodyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTaskBodyStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTaskBodyDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskBodyDeclStorageClass* storageArray = new SgAdaTaskBodyDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTaskBodyDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTaskBodyDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTaskBodyDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTaskSpec ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskSpecStorageClass* storageArray = new SgAdaTaskSpecStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTaskSpec::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTaskSpecStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTaskSpecStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTaskSpecDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskSpecDeclStorageClass* storageArray = new SgAdaTaskSpecDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTaskSpecDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTaskSpecDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTaskSpecDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTaskSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskSymbolStorageClass* storageArray = new SgAdaTaskSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTaskSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTaskSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTaskSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTaskRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskRefExpStorageClass* storageArray = new SgAdaTaskRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTaskRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTaskRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTaskRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTaskType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskTypeStorageClass* storageArray = new SgAdaTaskTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTaskType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTaskTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTaskTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTaskTypeDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTaskTypeDeclStorageClass* storageArray = new SgAdaTaskTypeDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTaskTypeDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTaskTypeDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTaskTypeDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTypeConstraint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTypeConstraintStorageClass* storageArray = new SgAdaTypeConstraintStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTypeConstraint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTypeConstraintStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTypeConstraintStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAddOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAddOpStorageClass* storageArray = new SgAddOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAddOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAddOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAddOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAddressOfOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAddressOfOpStorageClass* storageArray = new SgAddressOfOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAddressOfOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAddressOfOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAddressOfOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAggregateInitializer ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAggregateInitializerStorageClass* storageArray = new SgAggregateInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAggregateInitializer::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAggregateInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAggregateInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAliasSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAliasSymbolStorageClass* storageArray = new SgAliasSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAliasSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAliasSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAliasSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAllocateStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAllocateStatementStorageClass* storageArray = new SgAllocateStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAllocateStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAllocateStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAllocateStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAndAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAndAssignOpStorageClass* storageArray = new SgAndAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAndAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAndAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAndAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAndOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAndOpStorageClass* storageArray = new SgAndOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAndOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAndOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAndOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgArithmeticIfStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArithmeticIfStatementStorageClass* storageArray = new SgArithmeticIfStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgArithmeticIfStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgArithmeticIfStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgArithmeticIfStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgArrayType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrayTypeStorageClass* storageArray = new SgArrayTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgArrayType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgArrayTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgArrayTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgArrowExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrowExpStorageClass* storageArray = new SgArrowExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgArrowExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgArrowExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgArrowExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgArrowStarOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrowStarOpStorageClass* storageArray = new SgArrowStarOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgArrowStarOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgArrowStarOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgArrowStarOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBasicString ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBasicStringStorageClass* storageArray = new SgAsmBasicStringStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBasicString::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBasicStringStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBasicStringStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryAdd ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddStorageClass* storageArray = new SgAsmBinaryAddStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryAdd::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryAddStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryAddStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryAsr ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAsrStorageClass* storageArray = new SgAsmBinaryAsrStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryAsr::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryAsrStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryAsrStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryDivide ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryDivideStorageClass* storageArray = new SgAsmBinaryDivideStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryDivide::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryDivideStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryDivideStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryExpressionStorageClass* storageArray = new SgAsmBinaryExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryLsl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryLslStorageClass* storageArray = new SgAsmBinaryLslStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryLsl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryLslStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryLslStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryLsr ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryLsrStorageClass* storageArray = new SgAsmBinaryLsrStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryLsr::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryLsrStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryLsrStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryMod ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryModStorageClass* storageArray = new SgAsmBinaryModStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryMod::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryModStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryModStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryMsl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryMslStorageClass* storageArray = new SgAsmBinaryMslStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryMsl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryMslStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryMslStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryMultiply ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryMultiplyStorageClass* storageArray = new SgAsmBinaryMultiplyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryMultiply::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryMultiplyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryMultiplyStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryRor ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryRorStorageClass* storageArray = new SgAsmBinaryRorStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryRor::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryRorStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryRorStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinarySubtract ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinarySubtractStorageClass* storageArray = new SgAsmBinarySubtractStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinarySubtract::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinarySubtractStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinarySubtractStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBlock ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBlockStorageClass* storageArray = new SgAsmBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBlock::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCoffStrtab ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffStrtabStorageClass* storageArray = new SgAsmCoffStrtabStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCoffStrtab::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCoffStrtabStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCoffStrtabStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCoffSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolStorageClass* storageArray = new SgAsmCoffSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCoffSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCoffSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCoffSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCoffSymbolList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolListStorageClass* storageArray = new SgAsmCoffSymbolListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCoffSymbolList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCoffSymbolListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCoffSymbolListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCoffSymbolTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolTableStorageClass* storageArray = new SgAsmCoffSymbolTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCoffSymbolTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCoffSymbolTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCoffSymbolTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCommonSubExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCommonSubExpressionStorageClass* storageArray = new SgAsmCommonSubExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCommonSubExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCommonSubExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCommonSubExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmControlFlagsExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmControlFlagsExpressionStorageClass* storageArray = new SgAsmControlFlagsExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmControlFlagsExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmControlFlagsExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmControlFlagsExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmConstantExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmConstantExpressionStorageClass* storageArray = new SgAsmConstantExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmConstantExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmConstantExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmConstantExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDOSExtendedHeader ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDOSExtendedHeaderStorageClass* storageArray = new SgAsmDOSExtendedHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDOSExtendedHeader::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDOSExtendedHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDOSExtendedHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDOSFileHeader ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDOSFileHeaderStorageClass* storageArray = new SgAsmDOSFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDOSFileHeader::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDOSFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDOSFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmSynthesizedDataStructureDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmSynthesizedDataStructureDeclarationStorageClass* storageArray = new SgAsmSynthesizedDataStructureDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmSynthesizedDataStructureDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmSynthesizedDataStructureDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmSynthesizedDataStructureDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmSynthesizedDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmSynthesizedDeclarationStorageClass* storageArray = new SgAsmSynthesizedDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmSynthesizedDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmSynthesizedDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmSynthesizedDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDirectRegisterExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDirectRegisterExpressionStorageClass* storageArray = new SgAsmDirectRegisterExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDirectRegisterExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDirectRegisterExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDirectRegisterExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfAccessDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfAccessDeclarationStorageClass* storageArray = new SgAsmDwarfAccessDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfAccessDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfAccessDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfAccessDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfArrayType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfArrayTypeStorageClass* storageArray = new SgAsmDwarfArrayTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfArrayType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfArrayTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfArrayTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfBaseType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfBaseTypeStorageClass* storageArray = new SgAsmDwarfBaseTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfBaseType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfBaseTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfBaseTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCatchBlock ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCatchBlockStorageClass* storageArray = new SgAsmDwarfCatchBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCatchBlock::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCatchBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCatchBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfClassTemplate ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfClassTemplateStorageClass* storageArray = new SgAsmDwarfClassTemplateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfClassTemplate::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfClassTemplateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfClassTemplateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfClassType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfClassTypeStorageClass* storageArray = new SgAsmDwarfClassTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfClassType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfClassTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfClassTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCommonBlock ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCommonBlockStorageClass* storageArray = new SgAsmDwarfCommonBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCommonBlock::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCommonBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCommonBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCommonInclusion ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCommonInclusionStorageClass* storageArray = new SgAsmDwarfCommonInclusionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCommonInclusion::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCommonInclusionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCommonInclusionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCompilationUnit ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCompilationUnitStorageClass* storageArray = new SgAsmDwarfCompilationUnitStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCompilationUnit::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCompilationUnitStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCompilationUnitStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCompilationUnitList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCompilationUnitListStorageClass* storageArray = new SgAsmDwarfCompilationUnitListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCompilationUnitList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCompilationUnitListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCompilationUnitListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCondition ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConditionStorageClass* storageArray = new SgAsmDwarfConditionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCondition::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConditionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConditionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfConstType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstTypeStorageClass* storageArray = new SgAsmDwarfConstTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfConstType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConstTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConstTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfConstant ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstantStorageClass* storageArray = new SgAsmDwarfConstantStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfConstant::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConstantStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConstantStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfConstruct ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstructStorageClass* storageArray = new SgAsmDwarfConstructStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfConstruct::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConstructStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConstructStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfConstructList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstructListStorageClass* storageArray = new SgAsmDwarfConstructListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfConstructList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConstructListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConstructListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfDwarfProcedure ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfDwarfProcedureStorageClass* storageArray = new SgAsmDwarfDwarfProcedureStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfDwarfProcedure::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfDwarfProcedureStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfDwarfProcedureStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfEntryPoint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEntryPointStorageClass* storageArray = new SgAsmDwarfEntryPointStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfEntryPoint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfEntryPointStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfEntryPointStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfEnumerationType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEnumerationTypeStorageClass* storageArray = new SgAsmDwarfEnumerationTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfEnumerationType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfEnumerationTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfEnumerationTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfEnumerator ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEnumeratorStorageClass* storageArray = new SgAsmDwarfEnumeratorStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfEnumerator::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfEnumeratorStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfEnumeratorStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFileType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFileTypeStorageClass* storageArray = new SgAsmDwarfFileTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFileType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFileTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFileTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFormalParameter ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFormalParameterStorageClass* storageArray = new SgAsmDwarfFormalParameterStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFormalParameter::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFormalParameterStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFormalParameterStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFormatLabel ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFormatLabelStorageClass* storageArray = new SgAsmDwarfFormatLabelStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFormatLabel::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFormatLabelStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFormatLabelStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFriend ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFriendStorageClass* storageArray = new SgAsmDwarfFriendStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFriend::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFriendStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFriendStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFunctionTemplate ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFunctionTemplateStorageClass* storageArray = new SgAsmDwarfFunctionTemplateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFunctionTemplate::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFunctionTemplateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFunctionTemplateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfImportedDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedDeclarationStorageClass* storageArray = new SgAsmDwarfImportedDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfImportedDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfImportedDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfImportedDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfImportedModule ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedModuleStorageClass* storageArray = new SgAsmDwarfImportedModuleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfImportedModule::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfImportedModuleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfImportedModuleStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfImportedUnit ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedUnitStorageClass* storageArray = new SgAsmDwarfImportedUnitStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfImportedUnit::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfImportedUnitStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfImportedUnitStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfInformation ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInformationStorageClass* storageArray = new SgAsmDwarfInformationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfInformation::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfInformationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfInheritance ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInheritanceStorageClass* storageArray = new SgAsmDwarfInheritanceStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfInheritance::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfInheritanceStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfInheritanceStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfInlinedSubroutine ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInlinedSubroutineStorageClass* storageArray = new SgAsmDwarfInlinedSubroutineStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfInlinedSubroutine::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfInlinedSubroutineStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfInlinedSubroutineStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfInterfaceType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInterfaceTypeStorageClass* storageArray = new SgAsmDwarfInterfaceTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfInterfaceType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfInterfaceTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfInterfaceTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfLabel ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLabelStorageClass* storageArray = new SgAsmDwarfLabelStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfLabel::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfLabelStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfLabelStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfLexicalBlock ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLexicalBlockStorageClass* storageArray = new SgAsmDwarfLexicalBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfLexicalBlock::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfLexicalBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfLexicalBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfLine ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLineStorageClass* storageArray = new SgAsmDwarfLineStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfLine::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfLineStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfLineList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLineListStorageClass* storageArray = new SgAsmDwarfLineListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfLineList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfLineListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfLineListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfMacro ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMacroStorageClass* storageArray = new SgAsmDwarfMacroStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfMacro::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfMacroStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfMacroStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfMacroList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMacroListStorageClass* storageArray = new SgAsmDwarfMacroListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfMacroList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfMacroListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfMacroListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfMember ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMemberStorageClass* storageArray = new SgAsmDwarfMemberStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfMember::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfMemberStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfMemberStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfModule ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfModuleStorageClass* storageArray = new SgAsmDwarfModuleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfModule::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfModuleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfModuleStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfMutableType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMutableTypeStorageClass* storageArray = new SgAsmDwarfMutableTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfMutableType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfMutableTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfMutableTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfNamelist ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamelistStorageClass* storageArray = new SgAsmDwarfNamelistStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfNamelist::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfNamelistStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfNamelistStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfNamelistItem ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamelistItemStorageClass* storageArray = new SgAsmDwarfNamelistItemStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfNamelistItem::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfNamelistItemStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfNamelistItemStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfNamespace ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamespaceStorageClass* storageArray = new SgAsmDwarfNamespaceStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfNamespace::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfNamespaceStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfNamespaceStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfPackedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPackedTypeStorageClass* storageArray = new SgAsmDwarfPackedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfPackedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfPackedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfPackedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfPartialUnit ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPartialUnitStorageClass* storageArray = new SgAsmDwarfPartialUnitStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfPartialUnit::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfPartialUnitStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfPartialUnitStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfPointerType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPointerTypeStorageClass* storageArray = new SgAsmDwarfPointerTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfPointerType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfPointerTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfPointerTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfPtrToMemberType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPtrToMemberTypeStorageClass* storageArray = new SgAsmDwarfPtrToMemberTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfPtrToMemberType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfPtrToMemberTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfPtrToMemberTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfReferenceType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfReferenceTypeStorageClass* storageArray = new SgAsmDwarfReferenceTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfReferenceType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfReferenceTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfReferenceTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfRestrictType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfRestrictTypeStorageClass* storageArray = new SgAsmDwarfRestrictTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfRestrictType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfRestrictTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfRestrictTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSetType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSetTypeStorageClass* storageArray = new SgAsmDwarfSetTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSetType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSetTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSetTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSharedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSharedTypeStorageClass* storageArray = new SgAsmDwarfSharedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSharedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSharedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSharedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfStringType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfStringTypeStorageClass* storageArray = new SgAsmDwarfStringTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfStringType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfStringTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfStringTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfStructureType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfStructureTypeStorageClass* storageArray = new SgAsmDwarfStructureTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfStructureType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfStructureTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfStructureTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSubprogram ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubprogramStorageClass* storageArray = new SgAsmDwarfSubprogramStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSubprogram::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSubprogramStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSubprogramStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSubrangeType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubrangeTypeStorageClass* storageArray = new SgAsmDwarfSubrangeTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSubrangeType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSubrangeTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSubrangeTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSubroutineType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubroutineTypeStorageClass* storageArray = new SgAsmDwarfSubroutineTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSubroutineType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSubroutineTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSubroutineTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfTemplateTypeParameter ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTemplateTypeParameterStorageClass* storageArray = new SgAsmDwarfTemplateTypeParameterStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfTemplateTypeParameter::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfTemplateTypeParameterStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfTemplateTypeParameterStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfTemplateValueParameter ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTemplateValueParameterStorageClass* storageArray = new SgAsmDwarfTemplateValueParameterStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfTemplateValueParameter::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfTemplateValueParameterStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfTemplateValueParameterStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfThrownType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfThrownTypeStorageClass* storageArray = new SgAsmDwarfThrownTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfThrownType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfThrownTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfThrownTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfTryBlock ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTryBlockStorageClass* storageArray = new SgAsmDwarfTryBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfTryBlock::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfTryBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfTryBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfTypedef ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTypedefStorageClass* storageArray = new SgAsmDwarfTypedefStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfTypedef::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfTypedefStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfTypedefStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUnionType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnionTypeStorageClass* storageArray = new SgAsmDwarfUnionTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUnionType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUnionTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUnionTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUnknownConstruct ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnknownConstructStorageClass* storageArray = new SgAsmDwarfUnknownConstructStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUnknownConstruct::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUnknownConstructStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUnknownConstructStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUnspecifiedParameters ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnspecifiedParametersStorageClass* storageArray = new SgAsmDwarfUnspecifiedParametersStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUnspecifiedParameters::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUnspecifiedParametersStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUnspecifiedParametersStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUnspecifiedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnspecifiedTypeStorageClass* storageArray = new SgAsmDwarfUnspecifiedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUnspecifiedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUnspecifiedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUnspecifiedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUpcRelaxedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcRelaxedTypeStorageClass* storageArray = new SgAsmDwarfUpcRelaxedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUpcRelaxedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUpcRelaxedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUpcRelaxedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUpcSharedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcSharedTypeStorageClass* storageArray = new SgAsmDwarfUpcSharedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUpcSharedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUpcSharedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUpcSharedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUpcStrictType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcStrictTypeStorageClass* storageArray = new SgAsmDwarfUpcStrictTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUpcStrictType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUpcStrictTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUpcStrictTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfVariable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariableStorageClass* storageArray = new SgAsmDwarfVariableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfVariable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfVariableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfVariableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfVariant ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariantStorageClass* storageArray = new SgAsmDwarfVariantStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfVariant::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfVariantStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfVariantStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfVariantPart ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariantPartStorageClass* storageArray = new SgAsmDwarfVariantPartStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfVariantPart::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfVariantPartStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfVariantPartStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfVolatileType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVolatileTypeStorageClass* storageArray = new SgAsmDwarfVolatileTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfVolatileType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfVolatileTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfVolatileTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfWithStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfWithStmtStorageClass* storageArray = new SgAsmDwarfWithStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfWithStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfWithStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfWithStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfDynamicEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicEntryStorageClass* storageArray = new SgAsmElfDynamicEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfDynamicEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfDynamicEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfDynamicEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfDynamicEntryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicEntryListStorageClass* storageArray = new SgAsmElfDynamicEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfDynamicEntryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfDynamicEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfDynamicEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfDynamicSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicSectionStorageClass* storageArray = new SgAsmElfDynamicSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfDynamicSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfDynamicSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfDynamicSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameEntryCI ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryCIStorageClass* storageArray = new SgAsmElfEHFrameEntryCIStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameEntryCI::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameEntryCIStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameEntryCIStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameEntryCIList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryCIListStorageClass* storageArray = new SgAsmElfEHFrameEntryCIListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameEntryCIList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameEntryCIListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameEntryCIListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameEntryFD ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryFDStorageClass* storageArray = new SgAsmElfEHFrameEntryFDStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameEntryFD::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameEntryFDStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameEntryFDStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameEntryFDList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryFDListStorageClass* storageArray = new SgAsmElfEHFrameEntryFDListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameEntryFDList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameEntryFDListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameEntryFDListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameSectionStorageClass* storageArray = new SgAsmElfEHFrameSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfFileHeader ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfFileHeaderStorageClass* storageArray = new SgAsmElfFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfFileHeader::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfNoteEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteEntryStorageClass* storageArray = new SgAsmElfNoteEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfNoteEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfNoteEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfNoteEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfNoteEntryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteEntryListStorageClass* storageArray = new SgAsmElfNoteEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfNoteEntryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfNoteEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfNoteEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfNoteSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteSectionStorageClass* storageArray = new SgAsmElfNoteSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfNoteSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfNoteSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfNoteSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfRelocEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocEntryStorageClass* storageArray = new SgAsmElfRelocEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfRelocEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfRelocEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfRelocEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfRelocEntryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocEntryListStorageClass* storageArray = new SgAsmElfRelocEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfRelocEntryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfRelocEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfRelocEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfRelocSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocSectionStorageClass* storageArray = new SgAsmElfRelocSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfRelocSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfRelocSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfRelocSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionStorageClass* storageArray = new SgAsmElfSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSectionTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionTableStorageClass* storageArray = new SgAsmElfSectionTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSectionTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSectionTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSectionTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSectionTableEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionTableEntryStorageClass* storageArray = new SgAsmElfSectionTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSectionTableEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSectionTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSectionTableEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSegmentTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableStorageClass* storageArray = new SgAsmElfSegmentTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSegmentTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSegmentTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSegmentTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSegmentTableEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableEntryStorageClass* storageArray = new SgAsmElfSegmentTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSegmentTableEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSegmentTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSegmentTableEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSegmentTableEntryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableEntryListStorageClass* storageArray = new SgAsmElfSegmentTableEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSegmentTableEntryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSegmentTableEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSegmentTableEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfStringSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfStringSectionStorageClass* storageArray = new SgAsmElfStringSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfStringSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfStringSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfStringSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfStrtab ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfStrtabStorageClass* storageArray = new SgAsmElfStrtabStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfStrtab::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfStrtabStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfStrtabStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolStorageClass* storageArray = new SgAsmElfSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymbolList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolListStorageClass* storageArray = new SgAsmElfSymbolListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymbolList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymbolListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymbolListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymbolSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolSectionStorageClass* storageArray = new SgAsmElfSymbolSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymbolSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymbolSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymbolSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedAux ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedAuxStorageClass* storageArray = new SgAsmElfSymverDefinedAuxStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedAux::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedAuxStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedAuxList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedAuxListStorageClass* storageArray = new SgAsmElfSymverDefinedAuxListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedAuxList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedAuxListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverDefinedAuxListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedEntryStorageClass* storageArray = new SgAsmElfSymverDefinedEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedEntryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedEntryListStorageClass* storageArray = new SgAsmElfSymverDefinedEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedEntryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverDefinedEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedSectionStorageClass* storageArray = new SgAsmElfSymverDefinedSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverDefinedSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverEntryStorageClass* storageArray = new SgAsmElfSymverEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverEntryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverEntryListStorageClass* storageArray = new SgAsmElfSymverEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverEntryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededAux ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededAuxStorageClass* storageArray = new SgAsmElfSymverNeededAuxStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededAux::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededAuxStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededAuxList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededAuxListStorageClass* storageArray = new SgAsmElfSymverNeededAuxListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededAuxList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededAuxListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverNeededAuxListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededEntryStorageClass* storageArray = new SgAsmElfSymverNeededEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededEntryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededEntryListStorageClass* storageArray = new SgAsmElfSymverNeededEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededEntryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverNeededEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededSectionStorageClass* storageArray = new SgAsmElfSymverNeededSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverNeededSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverSectionStorageClass* storageArray = new SgAsmElfSymverSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmExecutableFileFormat ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExecutableFileFormatStorageClass* storageArray = new SgAsmExecutableFileFormatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmExecutableFileFormat::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmExecutableFileFormatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmExprListExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExprListExpStorageClass* storageArray = new SgAsmExprListExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmExprListExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmExprListExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmExprListExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExpressionStorageClass* storageArray = new SgAsmExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmSynthesizedFieldDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmSynthesizedFieldDeclarationStorageClass* storageArray = new SgAsmSynthesizedFieldDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmSynthesizedFieldDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmSynthesizedFieldDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmSynthesizedFieldDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmFloatType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmFloatTypeStorageClass* storageArray = new SgAsmFloatTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmFloatType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmFloatTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmFloatValueExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmFloatValueExpressionStorageClass* storageArray = new SgAsmFloatValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmFloatValueExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmFloatValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmFloatValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmFunction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmFunctionStorageClass* storageArray = new SgAsmFunctionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmFunction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmFunctionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmFunctionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericDLL ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericDLLStorageClass* storageArray = new SgAsmGenericDLLStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericDLL::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericDLLStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericDLLStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericDLLList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericDLLListStorageClass* storageArray = new SgAsmGenericDLLListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericDLLList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericDLLListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericDLLListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericFile ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFileStorageClass* storageArray = new SgAsmGenericFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericFile::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericFileStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericFileList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFileListStorageClass* storageArray = new SgAsmGenericFileListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericFileList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericFileListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericFileListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericFormat ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFormatStorageClass* storageArray = new SgAsmGenericFormatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericFormat::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericFormatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericHeader ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericHeaderStorageClass* storageArray = new SgAsmGenericHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericHeader::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericHeaderList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericHeaderListStorageClass* storageArray = new SgAsmGenericHeaderListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericHeaderList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericHeaderListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericHeaderListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSectionStorageClass* storageArray = new SgAsmGenericSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericSectionList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSectionListStorageClass* storageArray = new SgAsmGenericSectionListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericSectionList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericSectionListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericSectionListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericString ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericStringStorageClass* storageArray = new SgAsmGenericStringStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericString::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericStringStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericStrtab ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericStrtabStorageClass* storageArray = new SgAsmGenericStrtabStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericStrtab::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericStrtabStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericStrtabStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSymbolStorageClass* storageArray = new SgAsmGenericSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericSymbolList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSymbolListStorageClass* storageArray = new SgAsmGenericSymbolListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericSymbolList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericSymbolListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericSymbolListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmIndirectRegisterExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmIndirectRegisterExpressionStorageClass* storageArray = new SgAsmIndirectRegisterExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmIndirectRegisterExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmIndirectRegisterExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmIndirectRegisterExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmInstruction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInstructionStorageClass* storageArray = new SgAsmInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmInstruction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmIntegerValueExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmIntegerValueExpressionStorageClass* storageArray = new SgAsmIntegerValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmIntegerValueExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmIntegerValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmIntegerValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmIntegerType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmIntegerTypeStorageClass* storageArray = new SgAsmIntegerTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmIntegerType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmIntegerTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmInterpretation ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInterpretationStorageClass* storageArray = new SgAsmInterpretationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmInterpretation::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmInterpretationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmInterpretationList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInterpretationListStorageClass* storageArray = new SgAsmInterpretationListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmInterpretationList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmInterpretationListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmInterpretationListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmAttribute ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmAttributeStorageClass* storageArray = new SgAsmJvmAttributeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmAttribute::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmAttributeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmCodeAttribute ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmCodeAttributeStorageClass* storageArray = new SgAsmJvmCodeAttributeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmCodeAttribute::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmCodeAttributeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmCodeAttributeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmMethod ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmMethodStorageClass* storageArray = new SgAsmJvmMethodStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmMethod::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmMethodStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmConstantPool ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmConstantPoolStorageClass* storageArray = new SgAsmJvmConstantPoolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmConstantPool::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmConstantPoolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmConstantPoolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmConstantPoolEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmConstantPoolEntryStorageClass* storageArray = new SgAsmJvmConstantPoolEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmConstantPoolEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmConstantPoolEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmConstantPoolEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmConstantValue ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmConstantValueStorageClass* storageArray = new SgAsmJvmConstantValueStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmConstantValue::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmConstantValueStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmInstruction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmInstructionStorageClass* storageArray = new SgAsmJvmInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmInstruction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmFileHeader ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmFileHeaderStorageClass* storageArray = new SgAsmJvmFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmFileHeader::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmNode ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmNodeStorageClass* storageArray = new SgAsmJvmNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmNode::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmSignature ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmSignatureStorageClass* storageArray = new SgAsmJvmSignatureStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmSignature::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmSignatureStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmSourceFile ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmSourceFileStorageClass* storageArray = new SgAsmJvmSourceFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmSourceFile::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmSourceFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEEntryPoint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEEntryPointStorageClass* storageArray = new SgAsmLEEntryPointStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEEntryPoint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEEntryPointStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLEEntryPointStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEEntryTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEEntryTableStorageClass* storageArray = new SgAsmLEEntryTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEEntryTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEEntryTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLEEntryTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEFileHeader ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEFileHeaderStorageClass* storageArray = new SgAsmLEFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEFileHeader::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLEFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLENameTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLENameTableStorageClass* storageArray = new SgAsmLENameTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLENameTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLENameTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLENameTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEPageTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEPageTableStorageClass* storageArray = new SgAsmLEPageTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEPageTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEPageTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLEPageTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEPageTableEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEPageTableEntryStorageClass* storageArray = new SgAsmLEPageTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEPageTableEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEPageTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLERelocTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLERelocTableStorageClass* storageArray = new SgAsmLERelocTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLERelocTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLERelocTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLERelocTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLESection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionStorageClass* storageArray = new SgAsmLESectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLESection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLESectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLESectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLESectionTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionTableStorageClass* storageArray = new SgAsmLESectionTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLESectionTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLESectionTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLESectionTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLESectionTableEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionTableEntryStorageClass* storageArray = new SgAsmLESectionTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLESectionTableEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLESectionTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmM68kInstruction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmM68kInstructionStorageClass* storageArray = new SgAsmM68kInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmM68kInstruction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmM68kInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmM68kInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmMemoryReferenceExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmMemoryReferenceExpressionStorageClass* storageArray = new SgAsmMemoryReferenceExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmMemoryReferenceExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmMemoryReferenceExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmMemoryReferenceExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmMipsInstruction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmMipsInstructionStorageClass* storageArray = new SgAsmMipsInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmMipsInstruction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmMipsInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmMipsInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEEntryPoint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEEntryPointStorageClass* storageArray = new SgAsmNEEntryPointStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEEntryPoint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEEntryPointStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEEntryTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEEntryTableStorageClass* storageArray = new SgAsmNEEntryTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEEntryTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEEntryTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNEEntryTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEFileHeader ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEFileHeaderStorageClass* storageArray = new SgAsmNEFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEFileHeader::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNEFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEModuleTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEModuleTableStorageClass* storageArray = new SgAsmNEModuleTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEModuleTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEModuleTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNEModuleTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNENameTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNENameTableStorageClass* storageArray = new SgAsmNENameTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNENameTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNENameTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNENameTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNERelocEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNERelocEntryStorageClass* storageArray = new SgAsmNERelocEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNERelocEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNERelocEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNERelocTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNERelocTableStorageClass* storageArray = new SgAsmNERelocTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNERelocTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNERelocTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNERelocTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNESection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionStorageClass* storageArray = new SgAsmNESectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNESection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNESectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNESectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNESectionTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionTableStorageClass* storageArray = new SgAsmNESectionTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNESectionTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNESectionTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNESectionTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNESectionTableEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionTableEntryStorageClass* storageArray = new SgAsmNESectionTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNESectionTableEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNESectionTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEStringTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEStringTableStorageClass* storageArray = new SgAsmNEStringTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEStringTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEStringTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNEStringTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNode ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNodeStorageClass* storageArray = new SgAsmNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNode::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmOpStorageClass* storageArray = new SgAsmOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmOperandList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmOperandListStorageClass* storageArray = new SgAsmOperandListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmOperandList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmOperandListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmOperandListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEExportDirectory ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportDirectoryStorageClass* storageArray = new SgAsmPEExportDirectoryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEExportDirectory::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEExportDirectoryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEExportEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportEntryStorageClass* storageArray = new SgAsmPEExportEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEExportEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEExportEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEExportEntryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportEntryListStorageClass* storageArray = new SgAsmPEExportEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEExportEntryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEExportEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEExportEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEExportSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportSectionStorageClass* storageArray = new SgAsmPEExportSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEExportSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEExportSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEExportSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEFileHeader ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEFileHeaderStorageClass* storageArray = new SgAsmPEFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEFileHeader::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportDirectory ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportDirectoryStorageClass* storageArray = new SgAsmPEImportDirectoryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportDirectory::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportDirectoryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportDirectoryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportDirectoryListStorageClass* storageArray = new SgAsmPEImportDirectoryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportDirectoryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportDirectoryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEImportDirectoryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportItem ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportItemStorageClass* storageArray = new SgAsmPEImportItemStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportItem::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportItemStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportItemList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportItemListStorageClass* storageArray = new SgAsmPEImportItemListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportItemList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportItemListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEImportItemListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportSectionStorageClass* storageArray = new SgAsmPEImportSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEImportSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPERVASizePair ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPERVASizePairStorageClass* storageArray = new SgAsmPERVASizePairStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPERVASizePair::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPERVASizePairStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPERVASizePairList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPERVASizePairListStorageClass* storageArray = new SgAsmPERVASizePairListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPERVASizePairList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPERVASizePairListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPERVASizePairListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPESection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionStorageClass* storageArray = new SgAsmPESectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPESection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPESectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPESectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPESectionTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionTableStorageClass* storageArray = new SgAsmPESectionTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPESectionTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPESectionTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPESectionTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPESectionTableEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionTableEntryStorageClass* storageArray = new SgAsmPESectionTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPESectionTableEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPESectionTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPESectionTableEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEStringSection ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEStringSectionStorageClass* storageArray = new SgAsmPEStringSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEStringSection::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEStringSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEStringSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPowerpcInstruction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPowerpcInstructionStorageClass* storageArray = new SgAsmPowerpcInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPowerpcInstruction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPowerpcInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPowerpcInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmRegisterNames ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmRegisterNamesStorageClass* storageArray = new SgAsmRegisterNamesStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmRegisterNames::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmRegisterNamesStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmRegisterNamesStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmRegisterReferenceExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmRegisterReferenceExpressionStorageClass* storageArray = new SgAsmRegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmRegisterReferenceExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmRegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmRegisterReferenceExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmRiscOperation ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmRiscOperationStorageClass* storageArray = new SgAsmRiscOperationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmRiscOperation::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmRiscOperationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmRiscOperationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmScalarType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmScalarTypeStorageClass* storageArray = new SgAsmScalarTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmScalarType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmScalarTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStatementStorageClass* storageArray = new SgAsmStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStaticData ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStaticDataStorageClass* storageArray = new SgAsmStaticDataStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStaticData::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStaticDataStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStaticDataStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStmtStorageClass* storageArray = new SgAsmStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStoredString ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStoredStringStorageClass* storageArray = new SgAsmStoredStringStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStoredString::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStoredStringStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStringStorage ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStringStorageStorageClass* storageArray = new SgAsmStringStorageStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStringStorage::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStringStorageStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStringStorageStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeStorageClass* storageArray = new SgAsmTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryExpressionStorageClass* storageArray = new SgAsmUnaryExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryMinus ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryMinusStorageClass* storageArray = new SgAsmUnaryMinusStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryMinus::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryMinusStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryMinusStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryPlus ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryPlusStorageClass* storageArray = new SgAsmUnaryPlusStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryPlus::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryPlusStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryPlusStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryRrx ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryRrxStorageClass* storageArray = new SgAsmUnaryRrxStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryRrx::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryRrxStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryRrxStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnarySignedExtend ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnarySignedExtendStorageClass* storageArray = new SgAsmUnarySignedExtendStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnarySignedExtend::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnarySignedExtendStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnarySignedExtendStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryUnsignedExtend ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryUnsignedExtendStorageClass* storageArray = new SgAsmUnaryUnsignedExtendStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryUnsignedExtend::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryUnsignedExtendStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryUnsignedExtendStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryTruncate ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryTruncateStorageClass* storageArray = new SgAsmUnaryTruncateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryTruncate::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryTruncateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryTruncateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmValueExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmValueExpressionStorageClass* storageArray = new SgAsmValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmValueExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmVectorType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmVectorTypeStorageClass* storageArray = new SgAsmVectorTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmVectorType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmVectorTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmX86Instruction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmX86InstructionStorageClass* storageArray = new SgAsmX86InstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmX86Instruction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmX86InstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmX86InstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryAddressSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddressSymbolStorageClass* storageArray = new SgAsmBinaryAddressSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryAddressSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryAddressSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryAddressSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryDataSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryDataSymbolStorageClass* storageArray = new SgAsmBinaryDataSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryDataSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryDataSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryDataSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssertStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssertStmtStorageClass* storageArray = new SgAssertStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssertStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssertStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssertStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssignInitializer ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignInitializerStorageClass* storageArray = new SgAssignInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssignInitializer::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssignInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssignInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignOpStorageClass* storageArray = new SgAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssignStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignStatementStorageClass* storageArray = new SgAssignStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssignStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssignStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssignStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssignedGotoStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignedGotoStatementStorageClass* storageArray = new SgAssignedGotoStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssignedGotoStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssignedGotoStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssignedGotoStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssociateStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssociateStatementStorageClass* storageArray = new SgAssociateStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssociateStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssociateStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssociateStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsteriskShapeExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsteriskShapeExpStorageClass* storageArray = new SgAsteriskShapeExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsteriskShapeExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsteriskShapeExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsteriskShapeExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAtOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAtOpStorageClass* storageArray = new SgAtOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAtOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAtOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAtOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAttribute ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAttributeStorageClass* storageArray = new SgAttributeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAttribute::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAttributeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAttributeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAttributeSpecificationStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAttributeSpecificationStatementStorageClass* storageArray = new SgAttributeSpecificationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAttributeSpecificationStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAttributeSpecificationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAttributeSpecificationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAutoType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAutoTypeStorageClass* storageArray = new SgAutoTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAutoType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAutoTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAutoTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAwaitExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAwaitExpressionStorageClass* storageArray = new SgAwaitExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAwaitExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAwaitExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAwaitExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBackspaceStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBackspaceStatementStorageClass* storageArray = new SgBackspaceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBackspaceStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBackspaceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBackspaceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBaseClass ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBaseClassStorageClass* storageArray = new SgBaseClassStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBaseClass::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBaseClassStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExpBaseClass ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpBaseClassStorageClass* storageArray = new SgExpBaseClassStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExpBaseClass::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExpBaseClassStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBaseClassModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBaseClassModifierStorageClass* storageArray = new SgBaseClassModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBaseClassModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBaseClassModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBaseClassModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBasicBlock ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBasicBlockStorageClass* storageArray = new SgBasicBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBasicBlock::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBasicBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBasicBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBidirectionalGraph ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBidirectionalGraphStorageClass* storageArray = new SgBidirectionalGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBidirectionalGraph::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBidirectionalGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBinaryComposite ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBinaryCompositeStorageClass* storageArray = new SgBinaryCompositeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBinaryComposite::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBinaryCompositeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBinaryCompositeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBinaryOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBinaryOpStorageClass* storageArray = new SgBinaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBinaryOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBinaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBinaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitAndOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitAndOpStorageClass* storageArray = new SgBitAndOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitAndOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitAndOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitAndOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitAttribute ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitAttributeStorageClass* storageArray = new SgBitAttributeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitAttribute::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitAttributeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitAttributeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitComplementOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitComplementOpStorageClass* storageArray = new SgBitComplementOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitComplementOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitComplementOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitComplementOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitEqvOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitEqvOpStorageClass* storageArray = new SgBitEqvOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitEqvOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitEqvOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitEqvOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitOrOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitOrOpStorageClass* storageArray = new SgBitOrOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitOrOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitOrOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitOrOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitXorOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitXorOpStorageClass* storageArray = new SgBitXorOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitXorOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitXorOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitXorOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBlockDataStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBlockDataStatementStorageClass* storageArray = new SgBlockDataStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBlockDataStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBlockDataStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBlockDataStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBoolValExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBoolValExpStorageClass* storageArray = new SgBoolValExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBoolValExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBoolValExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBoolValExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBreakStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBreakStmtStorageClass* storageArray = new SgBreakStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBreakStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBreakStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBreakStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBracedInitializer ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBracedInitializerStorageClass* storageArray = new SgBracedInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBracedInitializer::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBracedInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBracedInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgC_PreprocessorDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgC_PreprocessorDirectiveStatementStorageClass* storageArray = new SgC_PreprocessorDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgC_PreprocessorDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgC_PreprocessorDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgC_PreprocessorDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCaseOptionStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCaseOptionStmtStorageClass* storageArray = new SgCaseOptionStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCaseOptionStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCaseOptionStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCaseOptionStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCastExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCastExpStorageClass* storageArray = new SgCastExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCastExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCastExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCastExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCatchOptionStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCatchOptionStmtStorageClass* storageArray = new SgCatchOptionStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCatchOptionStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCatchOptionStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCatchOptionStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCatchStatementSeq ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCatchStatementSeqStorageClass* storageArray = new SgCatchStatementSeqStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCatchStatementSeq::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCatchStatementSeqStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCatchStatementSeqStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCharVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCharValStorageClass* storageArray = new SgCharValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCharVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCharValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCharValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgChar16Val ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgChar16ValStorageClass* storageArray = new SgChar16ValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgChar16Val::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgChar16ValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgChar16ValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgChar32Val ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgChar32ValStorageClass* storageArray = new SgChar32ValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgChar32Val::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgChar32ValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgChar32ValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgChooseExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgChooseExpressionStorageClass* storageArray = new SgChooseExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgChooseExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgChooseExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgChooseExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassDecl_attr ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDecl_attrStorageClass* storageArray = new SgClassDecl_attrStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassDecl_attr::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassDecl_attrStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassDecl_attrStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDeclarationStorageClass* storageArray = new SgClassDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassDefinition ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDefinitionStorageClass* storageArray = new SgClassDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassDefinition::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassNameRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassNameRefExpStorageClass* storageArray = new SgClassNameRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassNameRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassNameRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassNameRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassSymbolStorageClass* storageArray = new SgClassSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassTypeStorageClass* storageArray = new SgClassTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClinkageDeclarationStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageDeclarationStatementStorageClass* storageArray = new SgClinkageDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClinkageDeclarationStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClinkageDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClinkageDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClinkageEndStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageEndStatementStorageClass* storageArray = new SgClinkageEndStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClinkageEndStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClinkageEndStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClinkageEndStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClinkageStartStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageStartStatementStorageClass* storageArray = new SgClinkageStartStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClinkageStartStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClinkageStartStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClinkageStartStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCloseStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCloseStatementStorageClass* storageArray = new SgCloseStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCloseStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCloseStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCloseStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgColonShapeExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgColonShapeExpStorageClass* storageArray = new SgColonShapeExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgColonShapeExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgColonShapeExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgColonShapeExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCommaOpExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommaOpExpStorageClass* storageArray = new SgCommaOpExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCommaOpExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCommaOpExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCommaOpExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCommonBlock ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonBlockStorageClass* storageArray = new SgCommonBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCommonBlock::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCommonBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCommonBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCommonBlockObject ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonBlockObjectStorageClass* storageArray = new SgCommonBlockObjectStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCommonBlockObject::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCommonBlockObjectStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCommonBlockObjectStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCommonSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonSymbolStorageClass* storageArray = new SgCommonSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCommonSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCommonSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCommonSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgComplexVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComplexValStorageClass* storageArray = new SgComplexValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgComplexVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgComplexValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgComplexValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgComprehension ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComprehensionStorageClass* storageArray = new SgComprehensionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgComprehension::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgComprehensionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgComprehensionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCompoundAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundAssignOpStorageClass* storageArray = new SgCompoundAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCompoundAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCompoundAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCompoundAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCompoundInitializer ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundInitializerStorageClass* storageArray = new SgCompoundInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCompoundInitializer::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCompoundInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCompoundInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCompoundLiteralExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundLiteralExpStorageClass* storageArray = new SgCompoundLiteralExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCompoundLiteralExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCompoundLiteralExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCompoundLiteralExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgComputedGotoStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComputedGotoStatementStorageClass* storageArray = new SgComputedGotoStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgComputedGotoStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgComputedGotoStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgComputedGotoStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConcatenationOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConcatenationOpStorageClass* storageArray = new SgConcatenationOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConcatenationOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConcatenationOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgConcatenationOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConditionalExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConditionalExpStorageClass* storageArray = new SgConditionalExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConditionalExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConditionalExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgConditionalExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConjugateOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConjugateOpStorageClass* storageArray = new SgConjugateOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConjugateOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConjugateOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgConjugateOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConstVolatileModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConstVolatileModifierStorageClass* storageArray = new SgConstVolatileModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConstVolatileModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConstVolatileModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConstructorInitializer ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConstructorInitializerStorageClass* storageArray = new SgConstructorInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConstructorInitializer::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConstructorInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgConstructorInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgContainsStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgContainsStatementStorageClass* storageArray = new SgContainsStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgContainsStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgContainsStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgContainsStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgContinueStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgContinueStmtStorageClass* storageArray = new SgContinueStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgContinueStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgContinueStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgContinueStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCtorInitializerList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCtorInitializerListStorageClass* storageArray = new SgCtorInitializerListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCtorInitializerList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCtorInitializerListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCtorInitializerListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDataStatementGroup ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementGroupStorageClass* storageArray = new SgDataStatementGroupStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDataStatementGroup::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDataStatementGroupStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDataStatementGroupStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDataStatementObject ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementObjectStorageClass* storageArray = new SgDataStatementObjectStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDataStatementObject::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDataStatementObjectStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDataStatementValue ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementValueStorageClass* storageArray = new SgDataStatementValueStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDataStatementValue::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDataStatementValueStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeadIfDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeadIfDirectiveStatementStorageClass* storageArray = new SgDeadIfDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeadIfDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeadIfDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeadIfDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeallocateStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeallocateStatementStorageClass* storageArray = new SgDeallocateStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeallocateStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeallocateStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeallocateStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeclarationModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationModifierStorageClass* storageArray = new SgDeclarationModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeclarationModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeclarationModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeclarationScope ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationScopeStorageClass* storageArray = new SgDeclarationScopeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeclarationScope::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeclarationScopeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeclarationScopeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeclarationStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationStatementStorageClass* storageArray = new SgDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeclarationStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeclType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclTypeStorageClass* storageArray = new SgDeclTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeclType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeclTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeclTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDefaultOptionStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefaultOptionStmtStorageClass* storageArray = new SgDefaultOptionStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDefaultOptionStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDefaultOptionStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDefaultOptionStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDefaultSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefaultSymbolStorageClass* storageArray = new SgDefaultSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDefaultSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDefaultSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDefaultSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDefineDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefineDirectiveStatementStorageClass* storageArray = new SgDefineDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDefineDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDefineDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDefineDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeleteExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeleteExpStorageClass* storageArray = new SgDeleteExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeleteExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeleteExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeleteExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDerivedTypeStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDerivedTypeStatementStorageClass* storageArray = new SgDerivedTypeStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDerivedTypeStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDerivedTypeStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDerivedTypeStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDesignatedInitializer ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDesignatedInitializerStorageClass* storageArray = new SgDesignatedInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDesignatedInitializer::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDesignatedInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDesignatedInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDictionaryComprehension ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDictionaryComprehensionStorageClass* storageArray = new SgDictionaryComprehensionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDictionaryComprehension::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDictionaryComprehensionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDictionaryComprehensionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDictionaryExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDictionaryExpStorageClass* storageArray = new SgDictionaryExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDictionaryExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDictionaryExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDictionaryExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDimensionObject ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDimensionObjectStorageClass* storageArray = new SgDimensionObjectStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDimensionObject::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDimensionObjectStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDirectedGraphEdge ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectedGraphEdgeStorageClass* storageArray = new SgDirectedGraphEdgeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDirectedGraphEdge::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDirectedGraphEdgeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDirectedGraphEdgeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDirectory ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectoryStorageClass* storageArray = new SgDirectoryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDirectory::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDirectoryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDirectoryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDirectoryList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectoryListStorageClass* storageArray = new SgDirectoryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDirectoryList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDirectoryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDirectoryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDivAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDivAssignOpStorageClass* storageArray = new SgDivAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDivAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDivAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDivAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDivideOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDivideOpStorageClass* storageArray = new SgDivideOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDivideOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDivideOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDivideOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDoWhileStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDoWhileStmtStorageClass* storageArray = new SgDoWhileStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDoWhileStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDoWhileStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDoWhileStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDotExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotExpStorageClass* storageArray = new SgDotExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDotExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDotExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDotExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDotStarOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotStarOpStorageClass* storageArray = new SgDotStarOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDotStarOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDotStarOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDotStarOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDoubleVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDoubleValStorageClass* storageArray = new SgDoubleValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDoubleVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDoubleValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDoubleValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElaboratedTypeModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElaboratedTypeModifierStorageClass* storageArray = new SgElaboratedTypeModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElaboratedTypeModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElaboratedTypeModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElementwiseOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseOpStorageClass* storageArray = new SgElementwiseOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElementwiseOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElementwiseOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElementwiseOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElementwiseAddOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseAddOpStorageClass* storageArray = new SgElementwiseAddOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElementwiseAddOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElementwiseAddOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElementwiseAddOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElementwiseDivideOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseDivideOpStorageClass* storageArray = new SgElementwiseDivideOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElementwiseDivideOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElementwiseDivideOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElementwiseDivideOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElementwiseLeftDivideOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseLeftDivideOpStorageClass* storageArray = new SgElementwiseLeftDivideOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElementwiseLeftDivideOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElementwiseLeftDivideOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElementwiseLeftDivideOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElementwiseMultiplyOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseMultiplyOpStorageClass* storageArray = new SgElementwiseMultiplyOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElementwiseMultiplyOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElementwiseMultiplyOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElementwiseMultiplyOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElementwisePowerOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwisePowerOpStorageClass* storageArray = new SgElementwisePowerOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElementwisePowerOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElementwisePowerOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElementwisePowerOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElementwiseSubtractOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElementwiseSubtractOpStorageClass* storageArray = new SgElementwiseSubtractOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElementwiseSubtractOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElementwiseSubtractOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElementwiseSubtractOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElseDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseDirectiveStatementStorageClass* storageArray = new SgElseDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElseDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElseDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElseDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElseWhereStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseWhereStatementStorageClass* storageArray = new SgElseWhereStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElseWhereStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElseWhereStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElseWhereStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElseifDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseifDirectiveStatementStorageClass* storageArray = new SgElseifDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElseifDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElseifDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElseifDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEmptyDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEmptyDeclarationStorageClass* storageArray = new SgEmptyDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEmptyDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEmptyDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEmptyDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEmptyDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEmptyDirectiveStatementStorageClass* storageArray = new SgEmptyDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEmptyDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEmptyDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEmptyDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEndfileStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEndfileStatementStorageClass* storageArray = new SgEndfileStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEndfileStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEndfileStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEndfileStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEndifDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEndifDirectiveStatementStorageClass* storageArray = new SgEndifDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEndifDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEndifDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEndifDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEntryStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEntryStatementStorageClass* storageArray = new SgEntryStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEntryStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEntryStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEntryStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumDeclarationStorageClass* storageArray = new SgEnumDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumFieldSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumFieldSymbolStorageClass* storageArray = new SgEnumFieldSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumFieldSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumFieldSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumFieldSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumSymbolStorageClass* storageArray = new SgEnumSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumTypeStorageClass* storageArray = new SgEnumTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumValStorageClass* storageArray = new SgEnumValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEqualityOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEqualityOpStorageClass* storageArray = new SgEqualityOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEqualityOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEqualityOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEqualityOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEquivalenceStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEquivalenceStatementStorageClass* storageArray = new SgEquivalenceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEquivalenceStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEquivalenceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEquivalenceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgErrorDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgErrorDirectiveStatementStorageClass* storageArray = new SgErrorDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgErrorDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgErrorDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgErrorDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExecStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExecStatementStorageClass* storageArray = new SgExecStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExecStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExecStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExecStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExponentiationOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExponentiationOpStorageClass* storageArray = new SgExponentiationOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExponentiationOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExponentiationOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExponentiationOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExponentiationAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExponentiationAssignOpStorageClass* storageArray = new SgExponentiationAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExponentiationAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExponentiationAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExponentiationAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExprListExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExprListExpStorageClass* storageArray = new SgExprListExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExprListExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExprListExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExprListExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExprStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExprStatementStorageClass* storageArray = new SgExprStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExprStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExprStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExprStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpressionStorageClass* storageArray = new SgExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExpressionRoot ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpressionRootStorageClass* storageArray = new SgExpressionRootStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExpressionRoot::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExpressionRootStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExpressionRootStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFile ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFileStorageClass* storageArray = new SgFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFile::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFileStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFileList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFileListStorageClass* storageArray = new SgFileListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFileList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFileListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFileListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFloatVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFloatValStorageClass* storageArray = new SgFloatValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFloatVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFloatValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFloatValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFloat128Val ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFloat128ValStorageClass* storageArray = new SgFloat128ValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFloat128Val::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFloat128ValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFloat128ValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFloat80Val ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFloat80ValStorageClass* storageArray = new SgFloat80ValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFloat80Val::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFloat80ValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFloat80ValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFoldExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFoldExpressionStorageClass* storageArray = new SgFoldExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFoldExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFoldExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFoldExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFlushStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFlushStatementStorageClass* storageArray = new SgFlushStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFlushStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFlushStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFlushStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgForAllStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForAllStatementStorageClass* storageArray = new SgForAllStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgForAllStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgForAllStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgForAllStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgForInitStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForInitStatementStorageClass* storageArray = new SgForInitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgForInitStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgForInitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgForInitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgForStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForStatementStorageClass* storageArray = new SgForStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgForStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgForStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgForStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFormatItem ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatItemStorageClass* storageArray = new SgFormatItemStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFormatItem::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFormatItemStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFormatItemList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatItemListStorageClass* storageArray = new SgFormatItemListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFormatItemList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFormatItemListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFormatItemListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFormatStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatStatementStorageClass* storageArray = new SgFormatStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFormatStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFormatStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFormatStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFortranDo ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranDoStorageClass* storageArray = new SgFortranDoStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFortranDo::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFortranDoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFortranDoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFortranIncludeLine ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranIncludeLineStorageClass* storageArray = new SgFortranIncludeLineStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFortranIncludeLine::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFortranIncludeLineStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFortranIncludeLineStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFortranNonblockedDo ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranNonblockedDoStorageClass* storageArray = new SgFortranNonblockedDoStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFortranNonblockedDo::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFortranNonblockedDoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFortranNonblockedDoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFuncDecl_attr ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFuncDecl_attrStorageClass* storageArray = new SgFuncDecl_attrStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFuncDecl_attr::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFuncDecl_attrStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFuncDecl_attrStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionCallExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionCallExpStorageClass* storageArray = new SgFunctionCallExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionCallExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionCallExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionCallExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionDeclarationStorageClass* storageArray = new SgFunctionDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionDefinition ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionDefinitionStorageClass* storageArray = new SgFunctionDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionDefinition::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionParameterScope ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterScopeStorageClass* storageArray = new SgFunctionParameterScopeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionParameterScope::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionParameterScopeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionParameterScopeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionModifierStorageClass* storageArray = new SgFunctionModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionParameterList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterListStorageClass* storageArray = new SgFunctionParameterListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionParameterList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionParameterListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionParameterListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionParameterRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterRefExpStorageClass* storageArray = new SgFunctionParameterRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionParameterRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionParameterRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionParameterRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionParameterTypeList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterTypeListStorageClass* storageArray = new SgFunctionParameterTypeListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionParameterTypeList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionParameterTypeListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionParameterTypeListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionRefExpStorageClass* storageArray = new SgFunctionRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionSymbolStorageClass* storageArray = new SgFunctionSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeStorageClass* storageArray = new SgFunctionTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionTypeSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeSymbolStorageClass* storageArray = new SgFunctionTypeSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionTypeSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionTypeSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionTypeSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionTypeTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeTableStorageClass* storageArray = new SgFunctionTypeTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionTypeTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionTypeTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionTypeTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeTableStorageClass* storageArray = new SgTypeTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGlobal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGlobalStorageClass* storageArray = new SgGlobalStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGlobal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGlobalStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGlobalStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGotoStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGotoStatementStorageClass* storageArray = new SgGotoStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGotoStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGotoStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGotoStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraph ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphStorageClass* storageArray = new SgGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraph::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraphEdge ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphEdgeStorageClass* storageArray = new SgGraphEdgeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraphEdge::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphEdgeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGraphEdgeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraphEdgeList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphEdgeListStorageClass* storageArray = new SgGraphEdgeListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraphEdgeList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphEdgeListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraphNode ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphNodeStorageClass* storageArray = new SgGraphNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraphNode::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGraphNodeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraphNodeList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphNodeListStorageClass* storageArray = new SgGraphNodeListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraphNodeList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphNodeListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGreaterOrEqualOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGreaterOrEqualOpStorageClass* storageArray = new SgGreaterOrEqualOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGreaterOrEqualOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGreaterOrEqualOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGreaterOrEqualOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGreaterThanOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGreaterThanOpStorageClass* storageArray = new SgGreaterThanOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGreaterThanOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGreaterThanOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGreaterThanOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIOItemExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIOItemExpressionStorageClass* storageArray = new SgIOItemExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIOItemExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIOItemExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIOItemExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIOStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIOStatementStorageClass* storageArray = new SgIOStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIOStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIOStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIOStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIdentDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIdentDirectiveStatementStorageClass* storageArray = new SgIdentDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIdentDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIdentDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIdentDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIfDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfDirectiveStatementStorageClass* storageArray = new SgIfDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIfDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIfDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIfDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIfStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfStmtStorageClass* storageArray = new SgIfStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIfStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIfStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIfStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIfdefDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfdefDirectiveStatementStorageClass* storageArray = new SgIfdefDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIfdefDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIfdefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIfdefDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIfndefDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfndefDirectiveStatementStorageClass* storageArray = new SgIfndefDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIfndefDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIfndefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIfndefDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgImageControlStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImageControlStatementStorageClass* storageArray = new SgImageControlStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgImageControlStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgImageControlStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgImageControlStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgImagPartOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImagPartOpStorageClass* storageArray = new SgImagPartOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgImagPartOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgImagPartOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgImagPartOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgImplicitStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImplicitStatementStorageClass* storageArray = new SgImplicitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgImplicitStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgImplicitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgImplicitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgImpliedDo ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImpliedDoStorageClass* storageArray = new SgImpliedDoStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgImpliedDo::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgImpliedDoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgImpliedDoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgImportStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImportStatementStorageClass* storageArray = new SgImportStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgImportStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgImportStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgImportStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIncidenceDirectedGraph ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncidenceDirectedGraphStorageClass* storageArray = new SgIncidenceDirectedGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIncidenceDirectedGraph::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIncidenceDirectedGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIncidenceDirectedGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIncidenceUndirectedGraph ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncidenceUndirectedGraphStorageClass* storageArray = new SgIncidenceUndirectedGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIncidenceUndirectedGraph::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIncidenceUndirectedGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIncidenceUndirectedGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIncludeDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeDirectiveStatementStorageClass* storageArray = new SgIncludeDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIncludeDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIncludeDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIncludeDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIncludeFile ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeFileStorageClass* storageArray = new SgIncludeFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIncludeFile::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIncludeFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIncludeFileStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIncludeNextDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeNextDirectiveStatementStorageClass* storageArray = new SgIncludeNextDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIncludeNextDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIncludeNextDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIncludeNextDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInitializedName ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInitializedNameStorageClass* storageArray = new SgInitializedNameStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInitializedName::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInitializedNameStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInitializedNameStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInitializer ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInitializerStorageClass* storageArray = new SgInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInitializer::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInquireStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInquireStatementStorageClass* storageArray = new SgInquireStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInquireStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInquireStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInquireStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntKeyedBidirectionalGraph ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntKeyedBidirectionalGraphStorageClass* storageArray = new SgIntKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntKeyedBidirectionalGraph::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntKeyedBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntKeyedBidirectionalGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntValStorageClass* storageArray = new SgIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntegerDivideOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntegerDivideOpStorageClass* storageArray = new SgIntegerDivideOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntegerDivideOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntegerDivideOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntegerDivideOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntegerDivideAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntegerDivideAssignOpStorageClass* storageArray = new SgIntegerDivideAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntegerDivideAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntegerDivideAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntegerDivideAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInterfaceBody ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceBodyStorageClass* storageArray = new SgInterfaceBodyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInterfaceBody::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInterfaceBodyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInterfaceBodyStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgHeaderFileBody ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgHeaderFileBodyStorageClass* storageArray = new SgHeaderFileBodyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgHeaderFileBody::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgHeaderFileBodyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgHeaderFileBodyStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgHeaderFileReport ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgHeaderFileReportStorageClass* storageArray = new SgHeaderFileReportStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgHeaderFileReport::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgHeaderFileReportStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgHeaderFileReportStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInterfaceStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceStatementStorageClass* storageArray = new SgInterfaceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInterfaceStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInterfaceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInterfaceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInterfaceSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceSymbolStorageClass* storageArray = new SgInterfaceSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInterfaceSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInterfaceSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInterfaceSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntrinsicSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntrinsicSymbolStorageClass* storageArray = new SgIntrinsicSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntrinsicSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntrinsicSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntrinsicSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIsOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIsOpStorageClass* storageArray = new SgIsOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIsOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIsOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIsOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIsNotOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIsNotOpStorageClass* storageArray = new SgIsNotOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIsNotOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIsNotOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIsNotOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIorAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIorAssignOpStorageClass* storageArray = new SgIorAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIorAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIorAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIorAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialBitType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialBitTypeStorageClass* storageArray = new SgJovialBitTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialBitType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialBitTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialBitTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialBitVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialBitValStorageClass* storageArray = new SgJovialBitValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialBitVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialBitValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialBitValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialTableType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialTableTypeStorageClass* storageArray = new SgJovialTableTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialTableType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialTableTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialTableTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialCompoolStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialCompoolStatementStorageClass* storageArray = new SgJovialCompoolStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialCompoolStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialCompoolStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialCompoolStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialForThenStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialForThenStatementStorageClass* storageArray = new SgJovialForThenStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialForThenStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialForThenStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialForThenStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialDefineDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialDefineDeclarationStorageClass* storageArray = new SgJovialDefineDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialDefineDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialDefineDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialDefineDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialDirectiveStatementStorageClass* storageArray = new SgJovialDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialOverlayDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialOverlayDeclarationStorageClass* storageArray = new SgJovialOverlayDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialOverlayDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialOverlayDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialOverlayDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialPresetPositionExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialPresetPositionExpStorageClass* storageArray = new SgJovialPresetPositionExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialPresetPositionExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialPresetPositionExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialPresetPositionExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialTablePresetExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialTablePresetExpStorageClass* storageArray = new SgJovialTablePresetExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialTablePresetExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialTablePresetExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialTablePresetExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialTableStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialTableStatementStorageClass* storageArray = new SgJovialTableStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialTableStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialTableStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialTableStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgKeyDatumPair ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgKeyDatumPairStorageClass* storageArray = new SgKeyDatumPairStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgKeyDatumPair::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgKeyDatumPairStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgKeyDatumPairStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCudaKernelExecConfig ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCudaKernelExecConfigStorageClass* storageArray = new SgCudaKernelExecConfigStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCudaKernelExecConfig::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCudaKernelExecConfigStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCudaKernelExecConfigStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCudaKernelCallExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCudaKernelCallExpStorageClass* storageArray = new SgCudaKernelCallExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCudaKernelCallExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCudaKernelCallExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCudaKernelCallExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLabelRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelRefExpStorageClass* storageArray = new SgLabelRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLabelRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLabelRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLabelRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLabelStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelStatementStorageClass* storageArray = new SgLabelStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLabelStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLabelStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLabelStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaLabelStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaLabelStatementStorageClass* storageArray = new SgJavaLabelStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaLabelStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaLabelStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaLabelStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLabelSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelSymbolStorageClass* storageArray = new SgLabelSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLabelSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLabelSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLabelSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaLabelSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaLabelSymbolStorageClass* storageArray = new SgJavaLabelSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaLabelSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaLabelSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaLabelSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLambdaCapture ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaCaptureStorageClass* storageArray = new SgLambdaCaptureStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLambdaCapture::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLambdaCaptureStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLambdaCaptureStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLambdaCaptureList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaCaptureListStorageClass* storageArray = new SgLambdaCaptureListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLambdaCaptureList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLambdaCaptureListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLambdaCaptureListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLambdaExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaExpStorageClass* storageArray = new SgLambdaExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLambdaExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLambdaExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLambdaExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLambdaRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaRefExpStorageClass* storageArray = new SgLambdaRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLambdaRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLambdaRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLambdaRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLeftDivideOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLeftDivideOpStorageClass* storageArray = new SgLeftDivideOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLeftDivideOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLeftDivideOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLeftDivideOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLessOrEqualOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLessOrEqualOpStorageClass* storageArray = new SgLessOrEqualOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLessOrEqualOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLessOrEqualOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLessOrEqualOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLessThanOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLessThanOpStorageClass* storageArray = new SgLessThanOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLessThanOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLessThanOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLessThanOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLineDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLineDirectiveStatementStorageClass* storageArray = new SgLineDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLineDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLineDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLineDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLinemarkerDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLinemarkerDirectiveStatementStorageClass* storageArray = new SgLinemarkerDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLinemarkerDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLinemarkerDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLinemarkerDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLinkageModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLinkageModifierStorageClass* storageArray = new SgLinkageModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLinkageModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLinkageModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgListComprehension ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgListComprehensionStorageClass* storageArray = new SgListComprehensionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgListComprehension::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgListComprehensionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgListComprehensionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgListExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgListExpStorageClass* storageArray = new SgListExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgListExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgListExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgListExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLocatedNode ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLocatedNodeStorageClass* storageArray = new SgLocatedNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLocatedNode::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLocatedNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLocatedNodeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLocatedNodeSupport ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLocatedNodeSupportStorageClass* storageArray = new SgLocatedNodeSupportStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLocatedNodeSupport::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLocatedNodeSupportStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLocatedNodeSupportStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLongDoubleVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongDoubleValStorageClass* storageArray = new SgLongDoubleValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLongDoubleVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLongDoubleValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLongDoubleValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLongIntVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongIntValStorageClass* storageArray = new SgLongIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLongIntVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLongIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLongIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLongLongIntVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongLongIntValStorageClass* storageArray = new SgLongLongIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLongLongIntVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLongLongIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLongLongIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLshiftAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLshiftAssignOpStorageClass* storageArray = new SgLshiftAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLshiftAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLshiftAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLshiftAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLshiftOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLshiftOpStorageClass* storageArray = new SgLshiftOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLshiftOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLshiftOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLshiftOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMagicColonExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMagicColonExpStorageClass* storageArray = new SgMagicColonExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMagicColonExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMagicColonExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMagicColonExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMatrixExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMatrixExpStorageClass* storageArray = new SgMatrixExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMatrixExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMatrixExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMatrixExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMatrixTransposeOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMatrixTransposeOpStorageClass* storageArray = new SgMatrixTransposeOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMatrixTransposeOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMatrixTransposeOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMatrixTransposeOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMatlabForStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMatlabForStatementStorageClass* storageArray = new SgMatlabForStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMatlabForStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMatlabForStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMatlabForStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMemberFunctionDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionDeclarationStorageClass* storageArray = new SgMemberFunctionDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMemberFunctionDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMemberFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMemberFunctionDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMemberFunctionRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionRefExpStorageClass* storageArray = new SgMemberFunctionRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMemberFunctionRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMemberFunctionRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMemberFunctionRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMemberFunctionSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionSymbolStorageClass* storageArray = new SgMemberFunctionSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMemberFunctionSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMemberFunctionSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMemberFunctionSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMemberFunctionType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionTypeStorageClass* storageArray = new SgMemberFunctionTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMemberFunctionType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMemberFunctionTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMemberFunctionTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMembershipOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMembershipOpStorageClass* storageArray = new SgMembershipOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMembershipOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMembershipOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMembershipOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMicrosoftAttributeDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMicrosoftAttributeDeclarationStorageClass* storageArray = new SgMicrosoftAttributeDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMicrosoftAttributeDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMicrosoftAttributeDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMicrosoftAttributeDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMinusAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusAssignOpStorageClass* storageArray = new SgMinusAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMinusAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMinusAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMinusAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMinusMinusOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusMinusOpStorageClass* storageArray = new SgMinusMinusOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMinusMinusOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMinusMinusOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMinusMinusOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMinusOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusOpStorageClass* storageArray = new SgMinusOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMinusOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMinusOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMinusOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModAssignOpStorageClass* storageArray = new SgModAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModOpStorageClass* storageArray = new SgModOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierStorageClass* storageArray = new SgModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModifierNodes ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierNodesStorageClass* storageArray = new SgModifierNodesStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModifierNodes::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModifierNodesStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModifierNodesStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModifierType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierTypeStorageClass* storageArray = new SgModifierTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModifierType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModifierTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModifierTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModuleStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModuleStatementStorageClass* storageArray = new SgModuleStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModuleStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModuleStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModuleStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModuleSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModuleSymbolStorageClass* storageArray = new SgModuleSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModuleSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModuleSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModuleSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMultAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMultAssignOpStorageClass* storageArray = new SgMultAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMultAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMultAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMultAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMultiplyOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMultiplyOpStorageClass* storageArray = new SgMultiplyOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMultiplyOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMultiplyOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMultiplyOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgName ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNameStorageClass* storageArray = new SgNameStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgName::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNameStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNameGroup ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNameGroupStorageClass* storageArray = new SgNameGroupStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNameGroup::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNameGroupStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNameGroupStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamedTypeStorageClass* storageArray = new SgNamedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamelistStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamelistStatementStorageClass* storageArray = new SgNamelistStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamelistStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamelistStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamelistStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamespaceAliasDeclarationStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceAliasDeclarationStatementStorageClass* storageArray = new SgNamespaceAliasDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamespaceAliasDeclarationStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamespaceAliasDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamespaceAliasDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamespaceDeclarationStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceDeclarationStatementStorageClass* storageArray = new SgNamespaceDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamespaceDeclarationStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamespaceDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamespaceDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamespaceDefinitionStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceDefinitionStatementStorageClass* storageArray = new SgNamespaceDefinitionStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamespaceDefinitionStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamespaceDefinitionStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamespaceDefinitionStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamespaceSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceSymbolStorageClass* storageArray = new SgNamespaceSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamespaceSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamespaceSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamespaceSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNaryOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryOpStorageClass* storageArray = new SgNaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNaryOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNaryBooleanOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryBooleanOpStorageClass* storageArray = new SgNaryBooleanOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNaryBooleanOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNaryBooleanOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNaryBooleanOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNaryComparisonOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryComparisonOpStorageClass* storageArray = new SgNaryComparisonOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNaryComparisonOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNaryComparisonOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNaryComparisonOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNewExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNewExpStorageClass* storageArray = new SgNewExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNewExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNewExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNewExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNode ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNodeStorageClass* storageArray = new SgNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNode::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNoexceptOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNoexceptOpStorageClass* storageArray = new SgNoexceptOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNoexceptOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNoexceptOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNoexceptOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNotEqualOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNotEqualOpStorageClass* storageArray = new SgNotEqualOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNotEqualOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNotEqualOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNotEqualOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNotOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNotOpStorageClass* storageArray = new SgNotOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNotOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNotOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNotOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNonMembershipOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonMembershipOpStorageClass* storageArray = new SgNonMembershipOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNonMembershipOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNonMembershipOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNonMembershipOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNonrealDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealDeclStorageClass* storageArray = new SgNonrealDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNonrealDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNonrealDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNonrealDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNonrealRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealRefExpStorageClass* storageArray = new SgNonrealRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNonrealRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNonrealRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNonrealRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNonrealSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealSymbolStorageClass* storageArray = new SgNonrealSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNonrealSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNonrealSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNonrealSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNonrealType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealTypeStorageClass* storageArray = new SgNonrealTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNonrealType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNonrealTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNonrealTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNonrealBaseClass ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonrealBaseClassStorageClass* storageArray = new SgNonrealBaseClassStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNonrealBaseClass::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNonrealBaseClassStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNullExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullExpressionStorageClass* storageArray = new SgNullExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNullExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNullExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNullExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNullptrValExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullptrValExpStorageClass* storageArray = new SgNullptrValExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNullptrValExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNullptrValExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNullptrValExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNullStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullStatementStorageClass* storageArray = new SgNullStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNullStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNullStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNullStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNullifyStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullifyStatementStorageClass* storageArray = new SgNullifyStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNullifyStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNullifyStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNullifyStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpAtomicStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpAtomicStatementStorageClass* storageArray = new SgOmpAtomicStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpAtomicStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpAtomicStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpAtomicStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpBarrierStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBarrierStatementStorageClass* storageArray = new SgOmpBarrierStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpBarrierStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpBarrierStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpBarrierStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpCriticalStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCriticalStatementStorageClass* storageArray = new SgOmpCriticalStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpCriticalStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpCriticalStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpCriticalStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpClauseBodyStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpClauseBodyStatementStorageClass* storageArray = new SgOmpClauseBodyStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpClauseBodyStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpClauseBodyStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpClauseBodyStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpBodyStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBodyStatementStorageClass* storageArray = new SgOmpBodyStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpBodyStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpBodyStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpBodyStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpDoStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDoStatementStorageClass* storageArray = new SgOmpDoStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpDoStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpDoStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpDoStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpFlushStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFlushStatementStorageClass* storageArray = new SgOmpFlushStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpFlushStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpFlushStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpFlushStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpDeclareSimdStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDeclareSimdStatementStorageClass* storageArray = new SgOmpDeclareSimdStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpDeclareSimdStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpDeclareSimdStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpDeclareSimdStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpForStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpForStatementStorageClass* storageArray = new SgOmpForStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpForStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpForStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpForStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpForSimdStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpForSimdStatementStorageClass* storageArray = new SgOmpForSimdStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpForSimdStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpForSimdStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpForSimdStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpMasterStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpMasterStatementStorageClass* storageArray = new SgOmpMasterStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpMasterStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpMasterStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpMasterStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpOrderedStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpOrderedStatementStorageClass* storageArray = new SgOmpOrderedStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpOrderedStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpOrderedStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpOrderedStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpParallelStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpParallelStatementStorageClass* storageArray = new SgOmpParallelStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpParallelStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpParallelStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpParallelStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSectionStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSectionStatementStorageClass* storageArray = new SgOmpSectionStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSectionStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSectionStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSectionStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSectionsStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSectionsStatementStorageClass* storageArray = new SgOmpSectionsStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSectionsStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSectionsStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSectionsStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSingleStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSingleStatementStorageClass* storageArray = new SgOmpSingleStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSingleStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSingleStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSingleStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpTaskStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTaskStatementStorageClass* storageArray = new SgOmpTaskStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpTaskStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpTaskStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpTaskStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpTaskwaitStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTaskwaitStatementStorageClass* storageArray = new SgOmpTaskwaitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpTaskwaitStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpTaskwaitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpTaskwaitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpThreadprivateStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpThreadprivateStatementStorageClass* storageArray = new SgOmpThreadprivateStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpThreadprivateStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpThreadprivateStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpThreadprivateStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpWorkshareStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpWorkshareStatementStorageClass* storageArray = new SgOmpWorkshareStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpWorkshareStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpWorkshareStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpWorkshareStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpTargetStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTargetStatementStorageClass* storageArray = new SgOmpTargetStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpTargetStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpTargetStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpTargetStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpTargetDataStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTargetDataStatementStorageClass* storageArray = new SgOmpTargetDataStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpTargetDataStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpTargetDataStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpTargetDataStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSimdStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSimdStatementStorageClass* storageArray = new SgOmpSimdStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSimdStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSimdStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSimdStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpClauseStorageClass* storageArray = new SgOmpClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpBeginClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBeginClauseStorageClass* storageArray = new SgOmpBeginClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpBeginClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpBeginClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpBeginClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpCollapseClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCollapseClauseStorageClass* storageArray = new SgOmpCollapseClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpCollapseClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpCollapseClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpCollapseClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpCopyinClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCopyinClauseStorageClass* storageArray = new SgOmpCopyinClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpCopyinClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpCopyinClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpCopyinClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpCopyprivateClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCopyprivateClauseStorageClass* storageArray = new SgOmpCopyprivateClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpCopyprivateClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpCopyprivateClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpCopyprivateClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpDefaultClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDefaultClauseStorageClass* storageArray = new SgOmpDefaultClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpDefaultClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpDefaultClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpDefaultClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpEndClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpEndClauseStorageClass* storageArray = new SgOmpEndClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpEndClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpEndClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpEndClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpExpressionClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpExpressionClauseStorageClass* storageArray = new SgOmpExpressionClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpExpressionClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpExpressionClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpExpressionClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpFirstprivateClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFirstprivateClauseStorageClass* storageArray = new SgOmpFirstprivateClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpFirstprivateClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpFirstprivateClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpFirstprivateClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpIfClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpIfClauseStorageClass* storageArray = new SgOmpIfClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpIfClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpIfClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpIfClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpFinalClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFinalClauseStorageClass* storageArray = new SgOmpFinalClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpFinalClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpFinalClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpFinalClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpPriorityClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpPriorityClauseStorageClass* storageArray = new SgOmpPriorityClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpPriorityClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpPriorityClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpPriorityClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpDeviceClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDeviceClauseStorageClass* storageArray = new SgOmpDeviceClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpDeviceClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpDeviceClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpDeviceClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpLastprivateClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpLastprivateClauseStorageClass* storageArray = new SgOmpLastprivateClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpLastprivateClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpLastprivateClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpLastprivateClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpNowaitClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNowaitClauseStorageClass* storageArray = new SgOmpNowaitClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpNowaitClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpNowaitClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpNowaitClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpNumThreadsClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNumThreadsClauseStorageClass* storageArray = new SgOmpNumThreadsClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpNumThreadsClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpNumThreadsClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpNumThreadsClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpOrderedClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpOrderedClauseStorageClass* storageArray = new SgOmpOrderedClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpOrderedClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpOrderedClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpOrderedClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpPrivateClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpPrivateClauseStorageClass* storageArray = new SgOmpPrivateClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpPrivateClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpPrivateClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpPrivateClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpReductionClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpReductionClauseStorageClass* storageArray = new SgOmpReductionClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpReductionClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpReductionClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpReductionClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpScheduleClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpScheduleClauseStorageClass* storageArray = new SgOmpScheduleClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpScheduleClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpScheduleClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpScheduleClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSharedClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSharedClauseStorageClass* storageArray = new SgOmpSharedClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSharedClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSharedClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSharedClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpUntiedClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpUntiedClauseStorageClass* storageArray = new SgOmpUntiedClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpUntiedClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpUntiedClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpUntiedClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpMergeableClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpMergeableClauseStorageClass* storageArray = new SgOmpMergeableClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpMergeableClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpMergeableClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpMergeableClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpVariablesClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpVariablesClauseStorageClass* storageArray = new SgOmpVariablesClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpVariablesClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpVariablesClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpVariablesClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpMapClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpMapClauseStorageClass* storageArray = new SgOmpMapClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpMapClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpMapClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpMapClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSafelenClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSafelenClauseStorageClass* storageArray = new SgOmpSafelenClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSafelenClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSafelenClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSafelenClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSimdlenClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSimdlenClauseStorageClass* storageArray = new SgOmpSimdlenClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSimdlenClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSimdlenClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSimdlenClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpLinearClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpLinearClauseStorageClass* storageArray = new SgOmpLinearClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpLinearClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpLinearClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpLinearClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpUniformClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpUniformClauseStorageClass* storageArray = new SgOmpUniformClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpUniformClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpUniformClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpUniformClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpAlignedClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpAlignedClauseStorageClass* storageArray = new SgOmpAlignedClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpAlignedClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpAlignedClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpAlignedClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpProcBindClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpProcBindClauseStorageClass* storageArray = new SgOmpProcBindClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpProcBindClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpProcBindClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpProcBindClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpAtomicClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpAtomicClauseStorageClass* storageArray = new SgOmpAtomicClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpAtomicClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpAtomicClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpAtomicClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpInbranchClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpInbranchClauseStorageClass* storageArray = new SgOmpInbranchClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpInbranchClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpInbranchClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpInbranchClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpNotinbranchClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNotinbranchClauseStorageClass* storageArray = new SgOmpNotinbranchClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpNotinbranchClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpNotinbranchClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpNotinbranchClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpDependClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDependClauseStorageClass* storageArray = new SgOmpDependClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpDependClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpDependClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpDependClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOpenclAccessModeModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOpenclAccessModeModifierStorageClass* storageArray = new SgOpenclAccessModeModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOpenclAccessModeModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOpenclAccessModeModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOpenStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOpenStatementStorageClass* storageArray = new SgOpenStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOpenStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOpenStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOpenStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOptions ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOptionsStorageClass* storageArray = new SgOptionsStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOptions::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOptionsStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOrOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOrOpStorageClass* storageArray = new SgOrOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOrOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOrOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOrOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgParameterStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgParameterStatementStorageClass* storageArray = new SgParameterStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgParameterStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgParameterStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgParameterStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPartialFunctionModifierType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPartialFunctionModifierTypeStorageClass* storageArray = new SgPartialFunctionModifierTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPartialFunctionModifierType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPartialFunctionModifierTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPartialFunctionModifierTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPartialFunctionType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPartialFunctionTypeStorageClass* storageArray = new SgPartialFunctionTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPartialFunctionType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPartialFunctionTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPartialFunctionTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPassStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPassStatementStorageClass* storageArray = new SgPassStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPassStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPassStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPassStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPlusAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPlusAssignOpStorageClass* storageArray = new SgPlusAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPlusAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPlusAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPlusAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPlusPlusOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPlusPlusOpStorageClass* storageArray = new SgPlusPlusOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPlusPlusOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPlusPlusOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPlusPlusOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPntrArrRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPntrArrRefExpStorageClass* storageArray = new SgPntrArrRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPntrArrRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPntrArrRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPntrArrRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPointerAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerAssignOpStorageClass* storageArray = new SgPointerAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPointerAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPointerAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPointerAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPointerDerefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerDerefExpStorageClass* storageArray = new SgPointerDerefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPointerDerefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPointerDerefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPointerDerefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPointerMemberType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerMemberTypeStorageClass* storageArray = new SgPointerMemberTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPointerMemberType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPointerMemberTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPointerMemberTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPointerType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerTypeStorageClass* storageArray = new SgPointerTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPointerType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPointerTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPointerTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPowerOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPowerOpStorageClass* storageArray = new SgPowerOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPowerOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPowerOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPowerOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPragma ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPragmaStorageClass* storageArray = new SgPragmaStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPragma::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPragmaStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPragmaStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPragmaDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPragmaDeclarationStorageClass* storageArray = new SgPragmaDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPragmaDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPragmaDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPragmaDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPrintStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPrintStatementStorageClass* storageArray = new SgPrintStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPrintStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPrintStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPrintStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgProcedureHeaderStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProcedureHeaderStatementStorageClass* storageArray = new SgProcedureHeaderStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgProcedureHeaderStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgProcedureHeaderStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgProcedureHeaderStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgProgramHeaderStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProgramHeaderStatementStorageClass* storageArray = new SgProgramHeaderStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgProgramHeaderStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgProgramHeaderStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgProgramHeaderStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgProject ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProjectStorageClass* storageArray = new SgProjectStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgProject::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgProjectStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgProjectStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPseudoDestructorRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPseudoDestructorRefExpStorageClass* storageArray = new SgPseudoDestructorRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPseudoDestructorRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPseudoDestructorRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPseudoDestructorRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPythonGlobalStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPythonGlobalStmtStorageClass* storageArray = new SgPythonGlobalStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPythonGlobalStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPythonGlobalStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPythonGlobalStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPythonPrintStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPythonPrintStmtStorageClass* storageArray = new SgPythonPrintStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPythonPrintStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPythonPrintStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPythonPrintStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgQualifiedName ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgQualifiedNameStorageClass* storageArray = new SgQualifiedNameStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgQualifiedName::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgQualifiedNameStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgQualifiedNameType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgQualifiedNameTypeStorageClass* storageArray = new SgQualifiedNameTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgQualifiedNameType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgQualifiedNameTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgQualifiedNameTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRangeExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRangeExpStorageClass* storageArray = new SgRangeExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRangeExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRangeExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRangeExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRangeBasedForStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRangeBasedForStatementStorageClass* storageArray = new SgRangeBasedForStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRangeBasedForStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRangeBasedForStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRangeBasedForStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgReadStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReadStatementStorageClass* storageArray = new SgReadStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgReadStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgReadStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgReadStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRealPartOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRealPartOpStorageClass* storageArray = new SgRealPartOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRealPartOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRealPartOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRealPartOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRefExpStorageClass* storageArray = new SgRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgReferenceType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReferenceTypeStorageClass* storageArray = new SgReferenceTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgReferenceType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgReferenceTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgReferenceTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRemOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRemOpStorageClass* storageArray = new SgRemOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRemOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRemOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRemOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRenamePair ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRenamePairStorageClass* storageArray = new SgRenamePairStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRenamePair::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRenamePairStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRenamePairStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRenameSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRenameSymbolStorageClass* storageArray = new SgRenameSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRenameSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRenameSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRenameSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgReplicationOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReplicationOpStorageClass* storageArray = new SgReplicationOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgReplicationOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgReplicationOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgReplicationOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgReturnStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReturnStmtStorageClass* storageArray = new SgReturnStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgReturnStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgReturnStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgReturnStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRewindStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRewindStatementStorageClass* storageArray = new SgRewindStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRewindStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRewindStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRewindStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRshiftAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRshiftAssignOpStorageClass* storageArray = new SgRshiftAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRshiftAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRshiftAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRshiftAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRshiftOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRshiftOpStorageClass* storageArray = new SgRshiftOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRshiftOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRshiftOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRshiftOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRvalueReferenceType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRvalueReferenceTypeStorageClass* storageArray = new SgRvalueReferenceTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRvalueReferenceType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRvalueReferenceTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRvalueReferenceTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaUnsignedRshiftAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnsignedRshiftAssignOpStorageClass* storageArray = new SgJavaUnsignedRshiftAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaUnsignedRshiftAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaUnsignedRshiftAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaUnsignedRshiftAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaUnsignedRshiftOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnsignedRshiftOpStorageClass* storageArray = new SgJavaUnsignedRshiftOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaUnsignedRshiftOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaUnsignedRshiftOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaUnsignedRshiftOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgScopeOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopeOpStorageClass* storageArray = new SgScopeOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgScopeOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgScopeOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgScopeOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgScopeStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopeStatementStorageClass* storageArray = new SgScopeStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgScopeStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgScopeStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgScopeStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSequenceStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSequenceStatementStorageClass* storageArray = new SgSequenceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSequenceStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSequenceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSequenceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSetComprehension ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSetComprehensionStorageClass* storageArray = new SgSetComprehensionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSetComprehension::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSetComprehensionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSetComprehensionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgShortVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgShortValStorageClass* storageArray = new SgShortValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgShortVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgShortValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgShortValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSizeOfOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSizeOfOpStorageClass* storageArray = new SgSizeOfOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSizeOfOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSizeOfOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSizeOfOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAlignOfOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAlignOfOpStorageClass* storageArray = new SgAlignOfOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAlignOfOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAlignOfOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAlignOfOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaInstanceOfOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaInstanceOfOpStorageClass* storageArray = new SgJavaInstanceOfOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaInstanceOfOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaInstanceOfOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaInstanceOfOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSourceFile ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSourceFileStorageClass* storageArray = new SgSourceFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSourceFile::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSourceFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSourceFileStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSpaceshipOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpaceshipOpStorageClass* storageArray = new SgSpaceshipOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSpaceshipOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSpaceshipOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSpaceshipOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSpawnStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpawnStmtStorageClass* storageArray = new SgSpawnStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSpawnStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSpawnStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSpawnStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSyncAllStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSyncAllStatementStorageClass* storageArray = new SgSyncAllStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSyncAllStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSyncAllStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSyncAllStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSyncImagesStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSyncImagesStatementStorageClass* storageArray = new SgSyncImagesStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSyncImagesStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSyncImagesStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSyncImagesStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSyncMemoryStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSyncMemoryStatementStorageClass* storageArray = new SgSyncMemoryStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSyncMemoryStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSyncMemoryStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSyncMemoryStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSyncTeamStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSyncTeamStatementStorageClass* storageArray = new SgSyncTeamStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSyncTeamStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSyncTeamStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSyncTeamStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLockStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLockStatementStorageClass* storageArray = new SgLockStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLockStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLockStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLockStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnlockStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnlockStatementStorageClass* storageArray = new SgUnlockStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnlockStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnlockStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnlockStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaThrowStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaThrowStatementStorageClass* storageArray = new SgJavaThrowStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaThrowStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaThrowStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaThrowStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaForEachStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaForEachStatementStorageClass* storageArray = new SgJavaForEachStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaForEachStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaForEachStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaForEachStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaSynchronizedStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaSynchronizedStatementStorageClass* storageArray = new SgJavaSynchronizedStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaSynchronizedStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaSynchronizedStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaSynchronizedStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaParameterizedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaParameterizedTypeStorageClass* storageArray = new SgJavaParameterizedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaParameterizedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaParameterizedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaParameterizedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaWildcardType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaWildcardTypeStorageClass* storageArray = new SgJavaWildcardTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaWildcardType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaWildcardTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaWildcardTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgProcessControlStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProcessControlStatementStorageClass* storageArray = new SgProcessControlStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgProcessControlStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgProcessControlStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgProcessControlStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSpecialFunctionModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpecialFunctionModifierStorageClass* storageArray = new SgSpecialFunctionModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSpecialFunctionModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSpecialFunctionModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementStorageClass* storageArray = new SgStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStaticAssertionDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStaticAssertionDeclarationStorageClass* storageArray = new SgStaticAssertionDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStaticAssertionDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStaticAssertionDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStaticAssertionDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStmtDeclarationStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStmtDeclarationStatementStorageClass* storageArray = new SgStmtDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStmtDeclarationStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStmtDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStmtDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStatementExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementExpressionStorageClass* storageArray = new SgStatementExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStatementExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStatementExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStatementExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStatementFunctionStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementFunctionStatementStorageClass* storageArray = new SgStatementFunctionStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStatementFunctionStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStatementFunctionStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStatementFunctionStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStorageModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStorageModifierStorageClass* storageArray = new SgStorageModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStorageModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStorageModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStringConversion ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringConversionStorageClass* storageArray = new SgStringConversionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStringConversion::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStringConversionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStringConversionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStringKeyedBidirectionalGraph ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringKeyedBidirectionalGraphStorageClass* storageArray = new SgStringKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStringKeyedBidirectionalGraph::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStringKeyedBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStringKeyedBidirectionalGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStringVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringValStorageClass* storageArray = new SgStringValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStringVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStringValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStringValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStructureModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStructureModifierStorageClass* storageArray = new SgStructureModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStructureModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStructureModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSubscriptExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSubscriptExpressionStorageClass* storageArray = new SgSubscriptExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSubscriptExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSubscriptExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSubscriptExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSubtractOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSubtractOpStorageClass* storageArray = new SgSubtractOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSubtractOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSubtractOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSubtractOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSupport ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSupportStorageClass* storageArray = new SgSupportStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSupport::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSupportStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSwitchStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSwitchStatementStorageClass* storageArray = new SgSwitchStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSwitchStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSwitchStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSwitchStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSymbolTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSymbolTableStorageClass* storageArray = new SgSymbolTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSymbolTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSymbolTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSymbolTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateArgument ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateArgumentStorageClass* storageArray = new SgTemplateArgumentStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateArgument::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateArgumentStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateArgumentList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateArgumentListStorageClass* storageArray = new SgTemplateArgumentListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateArgumentList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateArgumentListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateArgumentListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateDeclarationStorageClass* storageArray = new SgTemplateDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateClassDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassDeclarationStorageClass* storageArray = new SgTemplateClassDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateClassDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateClassDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateClassDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateClassSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassSymbolStorageClass* storageArray = new SgTemplateClassSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateClassSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateClassSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateClassSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateFunctionDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionDeclarationStorageClass* storageArray = new SgTemplateFunctionDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateFunctionDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateFunctionDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateFunctionRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionRefExpStorageClass* storageArray = new SgTemplateFunctionRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateFunctionRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateFunctionRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateFunctionRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateFunctionSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionSymbolStorageClass* storageArray = new SgTemplateFunctionSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateFunctionSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateFunctionSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateFunctionSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateMemberFunctionDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateMemberFunctionDeclarationStorageClass* storageArray = new SgTemplateMemberFunctionDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateMemberFunctionDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateMemberFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateMemberFunctionDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateMemberFunctionRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateMemberFunctionRefExpStorageClass* storageArray = new SgTemplateMemberFunctionRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateMemberFunctionRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateMemberFunctionRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateMemberFunctionRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateMemberFunctionSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateMemberFunctionSymbolStorageClass* storageArray = new SgTemplateMemberFunctionSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateMemberFunctionSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateMemberFunctionSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateMemberFunctionSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateTypedefDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateTypedefDeclarationStorageClass* storageArray = new SgTemplateTypedefDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateTypedefDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateTypedefDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateTypedefDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateTypedefSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateTypedefSymbolStorageClass* storageArray = new SgTemplateTypedefSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateTypedefSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateTypedefSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateTypedefSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateVariableDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateVariableDeclarationStorageClass* storageArray = new SgTemplateVariableDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateVariableDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateVariableDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateVariableDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateVariableSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateVariableSymbolStorageClass* storageArray = new SgTemplateVariableSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateVariableSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateVariableSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateVariableSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateClassDefinition ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassDefinitionStorageClass* storageArray = new SgTemplateClassDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateClassDefinition::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateClassDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateClassDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateFunctionDefinition ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionDefinitionStorageClass* storageArray = new SgTemplateFunctionDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateFunctionDefinition::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateFunctionDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateFunctionDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDeclStorageClass* storageArray = new SgTemplateInstantiationDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationDefn ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDefnStorageClass* storageArray = new SgTemplateInstantiationDefnStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationDefn::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationDefnStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationDefnStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDirectiveStatementStorageClass* storageArray = new SgTemplateInstantiationDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationFunctionDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationFunctionDeclStorageClass* storageArray = new SgTemplateInstantiationFunctionDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationFunctionDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationFunctionDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationFunctionDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationMemberFunctionDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationMemberFunctionDeclStorageClass* storageArray = new SgTemplateInstantiationMemberFunctionDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationMemberFunctionDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationMemberFunctionDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationMemberFunctionDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationTypedefDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationTypedefDeclarationStorageClass* storageArray = new SgTemplateInstantiationTypedefDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationTypedefDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationTypedefDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationTypedefDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateParameter ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterStorageClass* storageArray = new SgTemplateParameterStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateParameter::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateParameterStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateParameterVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterValStorageClass* storageArray = new SgTemplateParameterValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateParameterVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateParameterValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateParameterValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateParameterList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterListStorageClass* storageArray = new SgTemplateParameterListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateParameterList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateParameterListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateParameterListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateSymbolStorageClass* storageArray = new SgTemplateSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateTypeStorageClass* storageArray = new SgTemplateTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgThisExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgThisExpStorageClass* storageArray = new SgThisExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgThisExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgThisExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgThisExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeTraitBuiltinOperator ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeTraitBuiltinOperatorStorageClass* storageArray = new SgTypeTraitBuiltinOperatorStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeTraitBuiltinOperator::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeTraitBuiltinOperatorStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeTraitBuiltinOperatorStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSuperExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSuperExpStorageClass* storageArray = new SgSuperExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSuperExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSuperExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSuperExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgThrowOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgThrowOpStorageClass* storageArray = new SgThrowOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgThrowOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgThrowOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgThrowOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgToken ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTokenStorageClass* storageArray = new SgTokenStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgToken::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTokenStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTokenStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTryStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTryStmtStorageClass* storageArray = new SgTryStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTryStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTryStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTryStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTupleExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTupleExpStorageClass* storageArray = new SgTupleExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTupleExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTupleExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTupleExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeStorageClass* storageArray = new SgTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeBool ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeBoolStorageClass* storageArray = new SgTypeBoolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeBool::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeBoolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeBoolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeChar ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCharStorageClass* storageArray = new SgTypeCharStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeChar::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeCharStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeCharStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeChar16 ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeChar16StorageClass* storageArray = new SgTypeChar16StorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeChar16::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeChar16StorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeChar16StorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeChar32 ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeChar32StorageClass* storageArray = new SgTypeChar32StorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeChar32::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeChar32StorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeChar32StorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeComplex ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeComplexStorageClass* storageArray = new SgTypeComplexStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeComplex::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeComplexStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeComplexStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeDefault ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeDefaultStorageClass* storageArray = new SgTypeDefaultStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeDefault::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeDefaultStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeDefaultStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeExpressionStorageClass* storageArray = new SgTypeExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeLabel ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLabelStorageClass* storageArray = new SgTypeLabelStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeLabel::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeLabelStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeLabelStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeDouble ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeDoubleStorageClass* storageArray = new SgTypeDoubleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeDouble::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeDoubleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeDoubleStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeEllipse ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeEllipseStorageClass* storageArray = new SgTypeEllipseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeEllipse::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeEllipseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeEllipseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeFixed ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFixedStorageClass* storageArray = new SgTypeFixedStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeFixed::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeFixedStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeFixedStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeFloat ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFloatStorageClass* storageArray = new SgTypeFloatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeFloat::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeFloatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeFloatStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeFloat128 ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFloat128StorageClass* storageArray = new SgTypeFloat128StorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeFloat128::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeFloat128StorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeFloat128StorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeFloat80 ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFloat80StorageClass* storageArray = new SgTypeFloat80StorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeFloat80::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeFloat80StorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeFloat80StorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeGlobalVoid ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeGlobalVoidStorageClass* storageArray = new SgTypeGlobalVoidStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeGlobalVoid::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeGlobalVoidStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeGlobalVoidStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeIdOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeIdOpStorageClass* storageArray = new SgTypeIdOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeIdOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeIdOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeIdOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeImaginary ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeImaginaryStorageClass* storageArray = new SgTypeImaginaryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeImaginary::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeImaginaryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeImaginaryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeInt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeIntStorageClass* storageArray = new SgTypeIntStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeInt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeIntStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeIntStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeLong ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongStorageClass* storageArray = new SgTypeLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeLong::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeLongDouble ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongDoubleStorageClass* storageArray = new SgTypeLongDoubleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeLongDouble::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeLongDoubleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeLongDoubleStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeLongLong ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongLongStorageClass* storageArray = new SgTypeLongLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeLongLong::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeLongLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeLongLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeModifierStorageClass* storageArray = new SgTypeModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeMatrix ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeMatrixStorageClass* storageArray = new SgTypeMatrixStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeMatrix::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeMatrixStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeMatrixStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeTuple ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeTupleStorageClass* storageArray = new SgTypeTupleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeTuple::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeTupleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeTupleStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeNullptr ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeNullptrStorageClass* storageArray = new SgTypeNullptrStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeNullptr::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeNullptrStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeNullptrStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeOfType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeOfTypeStorageClass* storageArray = new SgTypeOfTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeOfType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeOfTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeOfTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeShort ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeShortStorageClass* storageArray = new SgTypeShortStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeShort::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeShortStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeShortStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSigned128bitInteger ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSigned128bitIntegerStorageClass* storageArray = new SgTypeSigned128bitIntegerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSigned128bitInteger::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSigned128bitIntegerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSigned128bitIntegerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedChar ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedCharStorageClass* storageArray = new SgTypeSignedCharStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedChar::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedCharStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedCharStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedInt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedIntStorageClass* storageArray = new SgTypeSignedIntStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedInt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedIntStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedIntStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedLong ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedLongStorageClass* storageArray = new SgTypeSignedLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedLong::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedLongLong ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedLongLongStorageClass* storageArray = new SgTypeSignedLongLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedLongLong::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedLongLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedLongLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedShort ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedShortStorageClass* storageArray = new SgTypeSignedShortStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedShort::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedShortStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedShortStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeString ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeStringStorageClass* storageArray = new SgTypeStringStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeString::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeStringStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeStringStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnknown ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnknownStorageClass* storageArray = new SgTypeUnknownStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnknown::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnknownStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnknownStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsigned128bitInteger ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsigned128bitIntegerStorageClass* storageArray = new SgTypeUnsigned128bitIntegerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsigned128bitInteger::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsigned128bitIntegerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsigned128bitIntegerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedChar ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedCharStorageClass* storageArray = new SgTypeUnsignedCharStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedChar::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedCharStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedCharStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedInt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedIntStorageClass* storageArray = new SgTypeUnsignedIntStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedInt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedIntStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedIntStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedLong ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedLongStorageClass* storageArray = new SgTypeUnsignedLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedLong::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedLongLong ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedLongLongStorageClass* storageArray = new SgTypeUnsignedLongLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedLongLong::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedLongLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedLongLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedShort ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedShortStorageClass* storageArray = new SgTypeUnsignedShortStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedShort::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedShortStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedShortStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeVoid ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeVoidStorageClass* storageArray = new SgTypeVoidStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeVoid::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeVoidStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeVoidStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeWchar ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeWcharStorageClass* storageArray = new SgTypeWcharStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeWchar::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeWcharStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeWcharStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypedefDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefDeclarationStorageClass* storageArray = new SgTypedefDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypedefDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypedefDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypedefDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypedefSeq ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefSeqStorageClass* storageArray = new SgTypedefSeqStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypedefSeq::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypedefSeqStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypedefSeqStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypedefSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefSymbolStorageClass* storageArray = new SgTypedefSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypedefSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypedefSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypedefSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypedefType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefTypeStorageClass* storageArray = new SgTypedefTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypedefType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypedefTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypedefTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUPC_AccessModifier ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUPC_AccessModifierStorageClass* storageArray = new SgUPC_AccessModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUPC_AccessModifier::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUPC_AccessModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnaryAddOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnaryAddOpStorageClass* storageArray = new SgUnaryAddOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnaryAddOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnaryAddOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnaryAddOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnaryOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnaryOpStorageClass* storageArray = new SgUnaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnaryOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUndefDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUndefDirectiveStatementStorageClass* storageArray = new SgUndefDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUndefDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUndefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUndefDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUndirectedGraphEdge ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUndirectedGraphEdgeStorageClass* storageArray = new SgUndirectedGraphEdgeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUndirectedGraphEdge::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUndirectedGraphEdgeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUndirectedGraphEdgeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnknownArrayOrFunctionReference ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnknownArrayOrFunctionReferenceStorageClass* storageArray = new SgUnknownArrayOrFunctionReferenceStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnknownArrayOrFunctionReference::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnknownArrayOrFunctionReferenceStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnknownArrayOrFunctionReferenceStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnknownFile ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnknownFileStorageClass* storageArray = new SgUnknownFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnknownFile::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnknownFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnknownFileStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnparse_Info ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnparse_InfoStorageClass* storageArray = new SgUnparse_InfoStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnparse_Info::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnparse_InfoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnparse_InfoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedCharVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedCharValStorageClass* storageArray = new SgUnsignedCharValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedCharVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedCharValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedCharValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedIntVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedIntValStorageClass* storageArray = new SgUnsignedIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedIntVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedLongLongIntVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedLongLongIntValStorageClass* storageArray = new SgUnsignedLongLongIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedLongLongIntVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedLongLongIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedLongLongIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedLongVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedLongValStorageClass* storageArray = new SgUnsignedLongValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedLongVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedLongValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedLongValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedShortVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedShortValStorageClass* storageArray = new SgUnsignedShortValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedShortVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedShortValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedShortValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcBarrierStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcBarrierStatementStorageClass* storageArray = new SgUpcBarrierStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcBarrierStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcBarrierStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcBarrierStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcBlocksizeofExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcBlocksizeofExpressionStorageClass* storageArray = new SgUpcBlocksizeofExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcBlocksizeofExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcBlocksizeofExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcBlocksizeofExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcElemsizeofExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcElemsizeofExpressionStorageClass* storageArray = new SgUpcElemsizeofExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcElemsizeofExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcElemsizeofExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcElemsizeofExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcFenceStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcFenceStatementStorageClass* storageArray = new SgUpcFenceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcFenceStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcFenceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcFenceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcForAllStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcForAllStatementStorageClass* storageArray = new SgUpcForAllStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcForAllStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcForAllStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcForAllStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcLocalsizeofExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcLocalsizeofExpressionStorageClass* storageArray = new SgUpcLocalsizeofExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcLocalsizeofExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcLocalsizeofExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcLocalsizeofExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcMythread ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcMythreadStorageClass* storageArray = new SgUpcMythreadStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcMythread::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcMythreadStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcMythreadStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcNotifyStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcNotifyStatementStorageClass* storageArray = new SgUpcNotifyStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcNotifyStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcNotifyStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcNotifyStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcThreads ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcThreadsStorageClass* storageArray = new SgUpcThreadsStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcThreads::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcThreadsStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcThreadsStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcWaitStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcWaitStatementStorageClass* storageArray = new SgUpcWaitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcWaitStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcWaitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcWaitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUseStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUseStatementStorageClass* storageArray = new SgUseStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUseStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUseStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUseStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUserDefinedBinaryOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUserDefinedBinaryOpStorageClass* storageArray = new SgUserDefinedBinaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUserDefinedBinaryOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUserDefinedBinaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUserDefinedBinaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUserDefinedUnaryOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUserDefinedUnaryOpStorageClass* storageArray = new SgUserDefinedUnaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUserDefinedUnaryOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUserDefinedUnaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUserDefinedUnaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUsingDeclarationStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUsingDeclarationStatementStorageClass* storageArray = new SgUsingDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUsingDeclarationStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUsingDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUsingDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUsingDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUsingDirectiveStatementStorageClass* storageArray = new SgUsingDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUsingDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUsingDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUsingDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgValueExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgValueExpStorageClass* storageArray = new SgValueExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgValueExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgValueExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgValueExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgCopyOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgCopyOpStorageClass* storageArray = new SgVarArgCopyOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgCopyOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgCopyOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgCopyOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgEndOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgEndOpStorageClass* storageArray = new SgVarArgEndOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgEndOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgEndOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgEndOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgOpStorageClass* storageArray = new SgVarArgOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgStartOneOperandOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgStartOneOperandOpStorageClass* storageArray = new SgVarArgStartOneOperandOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgStartOneOperandOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgStartOneOperandOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgStartOneOperandOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgStartOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgStartOpStorageClass* storageArray = new SgVarArgStartOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgStartOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgStartOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgStartOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarRefExpStorageClass* storageArray = new SgVarRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariableDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableDeclarationStorageClass* storageArray = new SgVariableDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariableDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariableDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariableDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariableDefinition ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableDefinitionStorageClass* storageArray = new SgVariableDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariableDefinition::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariableDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariableDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariableSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableSymbolStorageClass* storageArray = new SgVariableSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariableSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariableSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariableSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariantExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariantExpressionStorageClass* storageArray = new SgVariantExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariantExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariantExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariantExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariantStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariantStatementStorageClass* storageArray = new SgVariantStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariantStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariantStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariantStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVoidVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVoidValStorageClass* storageArray = new SgVoidValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVoidVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVoidValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVoidValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWaitStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWaitStatementStorageClass* storageArray = new SgWaitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWaitStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWaitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWaitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWarningDirectiveStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWarningDirectiveStatementStorageClass* storageArray = new SgWarningDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWarningDirectiveStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWarningDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWarningDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWithStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWithStatementStorageClass* storageArray = new SgWithStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWithStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWithStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWithStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWcharVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWcharValStorageClass* storageArray = new SgWcharValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWcharVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWcharValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWcharValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWhereStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhereStatementStorageClass* storageArray = new SgWhereStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWhereStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWhereStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWhereStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWhileStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhileStmtStorageClass* storageArray = new SgWhileStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWhileStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWhileStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWhileStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWriteStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWriteStatementStorageClass* storageArray = new SgWriteStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWriteStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWriteStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWriteStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgXorAssignOp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgXorAssignOpStorageClass* storageArray = new SgXorAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgXorAssignOp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgXorAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgXorAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgYieldExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgYieldExpressionStorageClass* storageArray = new SgYieldExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgYieldExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgYieldExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgYieldExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_Sg_File_Info ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          Sg_File_InfoStorageClass* storageArray = new Sg_File_InfoStorageClass[sizeOfActualPool] ;
           storageClassIndex = Sg_File_Info::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( Sg_File_InfoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           Sg_File_InfoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeCAFTeam ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCAFTeamStorageClass* storageArray = new SgTypeCAFTeamStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeCAFTeam::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeCAFTeamStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeCAFTeamStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCAFWithTeamStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCAFWithTeamStatementStorageClass* storageArray = new SgCAFWithTeamStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCAFWithTeamStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCAFWithTeamStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCAFWithTeamStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCAFCoExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCAFCoExpressionStorageClass* storageArray = new SgCAFCoExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCAFCoExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCAFCoExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCAFCoExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCallExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCallExpressionStorageClass* storageArray = new SgCallExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCallExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCallExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCallExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeCrayPointer ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCrayPointerStorageClass* storageArray = new SgTypeCrayPointerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeCrayPointer::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeCrayPointerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeCrayPointerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaImportStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaImportStatementStorageClass* storageArray = new SgJavaImportStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaImportStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaImportStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaImportStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaPackageDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaPackageDeclarationStorageClass* storageArray = new SgJavaPackageDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaPackageDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaPackageDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaPackageDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaPackageStatement ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaPackageStatementStorageClass* storageArray = new SgJavaPackageStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaPackageStatement::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaPackageStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaPackageStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaImportStatementList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaImportStatementListStorageClass* storageArray = new SgJavaImportStatementListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaImportStatementList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaImportStatementListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaImportStatementListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaClassDeclarationList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaClassDeclarationListStorageClass* storageArray = new SgJavaClassDeclarationListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaClassDeclarationList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaClassDeclarationListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaClassDeclarationListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaMemberValuePair ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaMemberValuePairStorageClass* storageArray = new SgJavaMemberValuePairStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaMemberValuePair::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaMemberValuePairStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaMemberValuePairStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaAnnotation ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaAnnotationStorageClass* storageArray = new SgJavaAnnotationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaAnnotation::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaAnnotationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaAnnotationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaMarkerAnnotation ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaMarkerAnnotationStorageClass* storageArray = new SgJavaMarkerAnnotationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaMarkerAnnotation::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaMarkerAnnotationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaMarkerAnnotationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaSingleMemberAnnotation ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaSingleMemberAnnotationStorageClass* storageArray = new SgJavaSingleMemberAnnotationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaSingleMemberAnnotation::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaSingleMemberAnnotationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaSingleMemberAnnotationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaNormalAnnotation ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaNormalAnnotationStorageClass* storageArray = new SgJavaNormalAnnotationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaNormalAnnotation::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaNormalAnnotationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaNormalAnnotationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaTypeExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaTypeExpressionStorageClass* storageArray = new SgJavaTypeExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaTypeExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaTypeExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaTypeExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaQualifiedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaQualifiedTypeStorageClass* storageArray = new SgJavaQualifiedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaQualifiedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaQualifiedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaQualifiedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassExpStorageClass* storageArray = new SgClassExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaUnionType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnionTypeStorageClass* storageArray = new SgJavaUnionTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaUnionType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaUnionTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaUnionTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaParameterType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaParameterTypeStorageClass* storageArray = new SgJavaParameterTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaParameterType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaParameterTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaParameterTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsyncStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsyncStmtStorageClass* storageArray = new SgAsyncStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsyncStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsyncStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsyncStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFinishStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFinishStmtStorageClass* storageArray = new SgFinishStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFinishStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFinishStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFinishStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAtStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAtStmtStorageClass* storageArray = new SgAtStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAtStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAtStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAtStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAtomicStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAtomicStmtStorageClass* storageArray = new SgAtomicStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAtomicStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAtomicStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAtomicStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWhenStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhenStmtStorageClass* storageArray = new SgWhenStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWhenStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWhenStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWhenStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAtExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAtExpStorageClass* storageArray = new SgAtExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAtExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAtExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAtExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFinishExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFinishExpStorageClass* storageArray = new SgFinishExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFinishExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFinishExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFinishExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgHereExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgHereExpStorageClass* storageArray = new SgHereExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgHereExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgHereExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgHereExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDotDotExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotDotExpStorageClass* storageArray = new SgDotDotExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDotDotExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDotDotExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDotDotExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNullInstruction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNullInstructionStorageClass* storageArray = new SgAsmNullInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNullInstruction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNullInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNullInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaComponentClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaComponentClauseStorageClass* storageArray = new SgAdaComponentClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaComponentClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaComponentClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaComponentClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaIndexConstraint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaIndexConstraintStorageClass* storageArray = new SgAdaIndexConstraintStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaIndexConstraint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaIndexConstraintStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaIndexConstraintStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaModularType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaModularTypeStorageClass* storageArray = new SgAdaModularTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaModularType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaModularTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaModularTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaRepresentationClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRepresentationClauseStorageClass* storageArray = new SgAdaRepresentationClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaRepresentationClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaRepresentationClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaRepresentationClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaFunctionRenamingDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFunctionRenamingDeclStorageClass* storageArray = new SgAdaFunctionRenamingDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaFunctionRenamingDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaFunctionRenamingDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaFunctionRenamingDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaSelectStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaSelectStmtStorageClass* storageArray = new SgAdaSelectStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaSelectStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaSelectStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaSelectStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaSelectAlternativeStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaSelectAlternativeStmtStorageClass* storageArray = new SgAdaSelectAlternativeStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaSelectAlternativeStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaSelectAlternativeStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaSelectAlternativeStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaTerminateStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaTerminateStmtStorageClass* storageArray = new SgAdaTerminateStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaTerminateStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaTerminateStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaTerminateStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmAarch32Coprocessor ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmAarch32CoprocessorStorageClass* storageArray = new SgAsmAarch32CoprocessorStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmAarch32Coprocessor::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmAarch32CoprocessorStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmAarch32CoprocessorStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaAttributeClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAttributeClauseStorageClass* storageArray = new SgAdaAttributeClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaAttributeClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaAttributeClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaAttributeClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryConcat ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryConcatStorageClass* storageArray = new SgAsmBinaryConcatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryConcat::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryConcatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryConcatStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmByteOrder ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmByteOrderStorageClass* storageArray = new SgAsmByteOrderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmByteOrder::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmByteOrderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmByteOrderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaDerivedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDerivedTypeStorageClass* storageArray = new SgAdaDerivedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaDerivedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaDerivedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaDerivedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaAttributeExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAttributeExpStorageClass* storageArray = new SgAdaAttributeExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaAttributeExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaAttributeExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaAttributeExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaEnumRepresentationClause ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaEnumRepresentationClauseStorageClass* storageArray = new SgAdaEnumRepresentationClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaEnumRepresentationClause::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaEnumRepresentationClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaEnumRepresentationClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryPreupdate ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryPreupdateStorageClass* storageArray = new SgAsmBinaryPreupdateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryPreupdate::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryPreupdateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryPreupdateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryPostupdate ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryPostupdateStorageClass* storageArray = new SgAsmBinaryPostupdateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryPostupdate::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryPostupdateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryPostupdateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaOthersExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaOthersExpStorageClass* storageArray = new SgAdaOthersExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaOthersExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaOthersExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaOthersExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaRenamingSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRenamingSymbolStorageClass* storageArray = new SgAdaRenamingSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaRenamingSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaRenamingSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaRenamingSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaRenamingRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaRenamingRefExpStorageClass* storageArray = new SgAdaRenamingRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaRenamingRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaRenamingRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaRenamingRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaGenericDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericDeclStorageClass* storageArray = new SgAdaGenericDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaGenericDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaGenericDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaGenericDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaGenericDefn ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericDefnStorageClass* storageArray = new SgAdaGenericDefnStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaGenericDefn::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaGenericDefnStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaGenericDefnStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaFormalType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFormalTypeStorageClass* storageArray = new SgAdaFormalTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaFormalType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaFormalTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaFormalTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaGenericSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericSymbolStorageClass* storageArray = new SgAdaGenericSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaGenericSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaGenericSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaGenericSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaFormalTypeDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFormalTypeDeclStorageClass* storageArray = new SgAdaFormalTypeDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaFormalTypeDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaFormalTypeDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaFormalTypeDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaUnitRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaUnitRefExpStorageClass* storageArray = new SgAdaUnitRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaUnitRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaUnitRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaUnitRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaDiscriminatedTypeDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDiscriminatedTypeDeclStorageClass* storageArray = new SgAdaDiscriminatedTypeDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaDiscriminatedTypeDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaDiscriminatedTypeDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaDiscriminatedTypeDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaDiscriminatedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDiscriminatedTypeStorageClass* storageArray = new SgAdaDiscriminatedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaDiscriminatedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaDiscriminatedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaDiscriminatedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaDiscriminantConstraint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDiscriminantConstraintStorageClass* storageArray = new SgAdaDiscriminantConstraintStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaDiscriminantConstraint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaDiscriminantConstraintStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaDiscriminantConstraintStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaGenericInstanceDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericInstanceDeclStorageClass* storageArray = new SgAdaGenericInstanceDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaGenericInstanceDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaGenericInstanceDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaGenericInstanceDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaUnscopedBlock ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaUnscopedBlockStorageClass* storageArray = new SgAdaUnscopedBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaUnscopedBlock::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaUnscopedBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaUnscopedBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaInheritedFunctionSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaInheritedFunctionSymbolStorageClass* storageArray = new SgAdaInheritedFunctionSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaInheritedFunctionSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaInheritedFunctionSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaInheritedFunctionSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaProtectedBody ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedBodyStorageClass* storageArray = new SgAdaProtectedBodyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaProtectedBody::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaProtectedBodyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaProtectedBodyStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaProtectedBodyDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedBodyDeclStorageClass* storageArray = new SgAdaProtectedBodyDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaProtectedBodyDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaProtectedBodyDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaProtectedBodyDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaProtectedSpec ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedSpecStorageClass* storageArray = new SgAdaProtectedSpecStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaProtectedSpec::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaProtectedSpecStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaProtectedSpecStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaProtectedSpecDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedSpecDeclStorageClass* storageArray = new SgAdaProtectedSpecDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaProtectedSpecDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaProtectedSpecDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaProtectedSpecDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaProtectedSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedSymbolStorageClass* storageArray = new SgAdaProtectedSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaProtectedSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaProtectedSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaProtectedSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaProtectedRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedRefExpStorageClass* storageArray = new SgAdaProtectedRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaProtectedRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaProtectedRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaProtectedRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaProtectedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedTypeStorageClass* storageArray = new SgAdaProtectedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaProtectedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaProtectedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaProtectedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaProtectedTypeDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaProtectedTypeDeclStorageClass* storageArray = new SgAdaProtectedTypeDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaProtectedTypeDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaProtectedTypeDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaProtectedTypeDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaDigitsConstraint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDigitsConstraintStorageClass* storageArray = new SgAdaDigitsConstraintStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaDigitsConstraint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaDigitsConstraintStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaDigitsConstraintStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaAncestorInitializer ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaAncestorInitializerStorageClass* storageArray = new SgAdaAncestorInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaAncestorInitializer::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaAncestorInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaAncestorInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaDeltaConstraint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaDeltaConstraintStorageClass* storageArray = new SgAdaDeltaConstraintStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaDeltaConstraint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaDeltaConstraintStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaDeltaConstraintStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaSubroutineType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaSubroutineTypeStorageClass* storageArray = new SgAdaSubroutineTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaSubroutineType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaSubroutineTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaSubroutineTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaGenericInstanceSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaGenericInstanceSymbolStorageClass* storageArray = new SgAdaGenericInstanceSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaGenericInstanceSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaGenericInstanceSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaGenericInstanceSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaFormalPackageDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFormalPackageDeclStorageClass* storageArray = new SgAdaFormalPackageDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaFormalPackageDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaFormalPackageDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaFormalPackageDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaFormalPackageSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaFormalPackageSymbolStorageClass* storageArray = new SgAdaFormalPackageSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaFormalPackageSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaFormalPackageSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaFormalPackageSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmAttributeTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmAttributeTableStorageClass* storageArray = new SgAsmJvmAttributeTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmAttributeTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmAttributeTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmAttributeTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmMethodTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmMethodTableStorageClass* storageArray = new SgAsmJvmMethodTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmMethodTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmMethodTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmMethodTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmField ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmFieldStorageClass* storageArray = new SgAsmJvmFieldStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmField::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmFieldStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmFieldTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmFieldTableStorageClass* storageArray = new SgAsmJvmFieldTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmFieldTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmFieldTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmFieldTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmExceptionHandler ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmExceptionHandlerStorageClass* storageArray = new SgAsmJvmExceptionHandlerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmExceptionHandler::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmExceptionHandlerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmExceptionTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmExceptionTableStorageClass* storageArray = new SgAsmJvmExceptionTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmExceptionTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmExceptionTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmExceptionTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmClass ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmClassStorageClass* storageArray = new SgAsmJvmClassStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmClass::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmClassStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmLineNumberEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLineNumberEntryStorageClass* storageArray = new SgAsmJvmLineNumberEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmLineNumberEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmLineNumberEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmLineNumberTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLineNumberTableStorageClass* storageArray = new SgAsmJvmLineNumberTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmLineNumberTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmLineNumberTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmLineNumberTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmInnerClassesEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmInnerClassesEntryStorageClass* storageArray = new SgAsmJvmInnerClassesEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmInnerClassesEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmInnerClassesEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmInnerClasses ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmInnerClassesStorageClass* storageArray = new SgAsmJvmInnerClassesStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmInnerClasses::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmInnerClassesStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmInnerClassesStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilInstruction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilInstructionStorageClass* storageArray = new SgAsmCilInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilInstruction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStackExpression ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStackExpressionStorageClass* storageArray = new SgAsmStackExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStackExpression::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStackExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStackExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmEnclosingMethod ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmEnclosingMethodStorageClass* storageArray = new SgAsmJvmEnclosingMethodStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmEnclosingMethod::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmEnclosingMethodStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaNullConstraint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaNullConstraintStorageClass* storageArray = new SgAdaNullConstraintStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaNullConstraint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaNullConstraintStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaNullConstraintStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmModuleMainClass ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmModuleMainClassStorageClass* storageArray = new SgAsmJvmModuleMainClassStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmModuleMainClass::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmModuleMainClassStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmInstructionList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInstructionListStorageClass* storageArray = new SgAsmInstructionListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmInstructionList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmInstructionListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmInstructionListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilNode ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilNodeStorageClass* storageArray = new SgAsmCilNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilNode::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssembly ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyStorageClass* storageArray = new SgAsmCilAssemblyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssembly::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyOS ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyOSStorageClass* storageArray = new SgAsmCilAssemblyOSStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyOS::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyOSStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyProcessor ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyProcessorStorageClass* storageArray = new SgAsmCilAssemblyProcessorStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyProcessor::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyProcessorStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyRef ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefStorageClass* storageArray = new SgAsmCilAssemblyRefStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyRef::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyRefStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyRefOS ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefOSStorageClass* storageArray = new SgAsmCilAssemblyRefOSStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyRefOS::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyRefOSStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyRefProcessor ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefProcessorStorageClass* storageArray = new SgAsmCilAssemblyRefProcessorStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyRefProcessor::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyRefProcessorStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilClassLayout ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilClassLayoutStorageClass* storageArray = new SgAsmCilClassLayoutStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilClassLayout::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilClassLayoutStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilConstant ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilConstantStorageClass* storageArray = new SgAsmCilConstantStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilConstant::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilConstantStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilCustomAttribute ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilCustomAttributeStorageClass* storageArray = new SgAsmCilCustomAttributeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilCustomAttribute::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilCustomAttributeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilDeclSecurity ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilDeclSecurityStorageClass* storageArray = new SgAsmCilDeclSecurityStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilDeclSecurity::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilDeclSecurityStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilEvent ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilEventStorageClass* storageArray = new SgAsmCilEventStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilEvent::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilEventStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilEventMap ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilEventMapStorageClass* storageArray = new SgAsmCilEventMapStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilEventMap::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilEventMapStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilExportedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilExportedTypeStorageClass* storageArray = new SgAsmCilExportedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilExportedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilExportedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilField ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldStorageClass* storageArray = new SgAsmCilFieldStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilField::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFieldStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilFieldLayout ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldLayoutStorageClass* storageArray = new SgAsmCilFieldLayoutStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilFieldLayout::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFieldLayoutStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilFieldMarshal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldMarshalStorageClass* storageArray = new SgAsmCilFieldMarshalStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilFieldMarshal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFieldMarshalStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilFieldRVA ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldRVAStorageClass* storageArray = new SgAsmCilFieldRVAStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilFieldRVA::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFieldRVAStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilFile ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFileStorageClass* storageArray = new SgAsmCilFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilFile::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilGenericParam ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilGenericParamStorageClass* storageArray = new SgAsmCilGenericParamStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilGenericParam::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilGenericParamStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilGenericParamConstraint ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilGenericParamConstraintStorageClass* storageArray = new SgAsmCilGenericParamConstraintStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilGenericParamConstraint::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilGenericParamConstraintStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilImplMap ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilImplMapStorageClass* storageArray = new SgAsmCilImplMapStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilImplMap::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilImplMapStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilInterfaceImpl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilInterfaceImplStorageClass* storageArray = new SgAsmCilInterfaceImplStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilInterfaceImpl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilInterfaceImplStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilManifestResource ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilManifestResourceStorageClass* storageArray = new SgAsmCilManifestResourceStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilManifestResource::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilManifestResourceStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMemberRef ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMemberRefStorageClass* storageArray = new SgAsmCilMemberRefStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMemberRef::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMemberRefStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMethodDef ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodDefStorageClass* storageArray = new SgAsmCilMethodDefStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMethodDef::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMethodDefStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilMethodDefStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMethodImpl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodImplStorageClass* storageArray = new SgAsmCilMethodImplStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMethodImpl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMethodImplStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMethodSemantics ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodSemanticsStorageClass* storageArray = new SgAsmCilMethodSemanticsStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMethodSemantics::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMethodSemanticsStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMethodSpec ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodSpecStorageClass* storageArray = new SgAsmCilMethodSpecStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMethodSpec::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMethodSpecStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilModule ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilModuleStorageClass* storageArray = new SgAsmCilModuleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilModule::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilModuleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilModuleRef ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilModuleRefStorageClass* storageArray = new SgAsmCilModuleRefStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilModuleRef::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilModuleRefStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilNestedClass ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilNestedClassStorageClass* storageArray = new SgAsmCilNestedClassStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilNestedClass::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilNestedClassStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilParam ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilParamStorageClass* storageArray = new SgAsmCilParamStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilParam::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilParamStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilProperty ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilPropertyStorageClass* storageArray = new SgAsmCilPropertyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilProperty::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilPropertyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilPropertyMap ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilPropertyMapStorageClass* storageArray = new SgAsmCilPropertyMapStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilPropertyMap::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilPropertyMapStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilStandAloneSig ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilStandAloneSigStorageClass* storageArray = new SgAsmCilStandAloneSigStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilStandAloneSig::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilStandAloneSigStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilTypeDef ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeDefStorageClass* storageArray = new SgAsmCilTypeDefStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilTypeDef::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilTypeDefStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilTypeRef ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeRefStorageClass* storageArray = new SgAsmCilTypeRefStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilTypeRef::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilTypeRefStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilTypeSpec ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeSpecStorageClass* storageArray = new SgAsmCilTypeSpecStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilTypeSpec::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilTypeSpecStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaParameterList ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaParameterListStorageClass* storageArray = new SgAdaParameterListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaParameterList::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaParameterListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaParameterListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMetadata ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMetadataStorageClass* storageArray = new SgAsmCilMetadataStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMetadata::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMetadataStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMetadataRoot ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMetadataRootStorageClass* storageArray = new SgAsmCilMetadataRootStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMetadataRoot::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMetadataRootStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilMetadataRootStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilDataStream ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilDataStreamStorageClass* storageArray = new SgAsmCilDataStreamStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilDataStream::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilDataStreamStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilDataStreamStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMetadataHeap ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMetadataHeapStorageClass* storageArray = new SgAsmCilMetadataHeapStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMetadataHeap::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMetadataHeapStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilMetadataHeapStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilUint8Heap ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilUint8HeapStorageClass* storageArray = new SgAsmCilUint8HeapStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilUint8Heap::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilUint8HeapStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilUint8HeapStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilUint32Heap ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilUint32HeapStorageClass* storageArray = new SgAsmCilUint32HeapStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilUint32Heap::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilUint32HeapStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilUint32HeapStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCliHeader ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCliHeaderStorageClass* storageArray = new SgAsmCliHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCliHeader::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCliHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCliHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaVariantDecl ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaVariantDeclStorageClass* storageArray = new SgAdaVariantDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaVariantDecl::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaVariantDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaVariantDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAdaVariantWhenStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAdaVariantWhenStmtStorageClass* storageArray = new SgAdaVariantWhenStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAdaVariantWhenStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAdaVariantWhenStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAdaVariantWhenStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyTableStorageClass* storageArray = new SgAsmCilAssemblyTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilAssemblyTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyOSTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyOSTableStorageClass* storageArray = new SgAsmCilAssemblyOSTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyOSTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyOSTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilAssemblyOSTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyProcessorTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyProcessorTableStorageClass* storageArray = new SgAsmCilAssemblyProcessorTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyProcessorTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyProcessorTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilAssemblyProcessorTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyRefTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefTableStorageClass* storageArray = new SgAsmCilAssemblyRefTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyRefTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyRefTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilAssemblyRefTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyRefOSTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefOSTableStorageClass* storageArray = new SgAsmCilAssemblyRefOSTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyRefOSTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyRefOSTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilAssemblyRefOSTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilAssemblyRefProcessorTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilAssemblyRefProcessorTableStorageClass* storageArray = new SgAsmCilAssemblyRefProcessorTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilAssemblyRefProcessorTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilAssemblyRefProcessorTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilAssemblyRefProcessorTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilClassLayoutTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilClassLayoutTableStorageClass* storageArray = new SgAsmCilClassLayoutTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilClassLayoutTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilClassLayoutTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilClassLayoutTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilConstantTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilConstantTableStorageClass* storageArray = new SgAsmCilConstantTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilConstantTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilConstantTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilConstantTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilCustomAttributeTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilCustomAttributeTableStorageClass* storageArray = new SgAsmCilCustomAttributeTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilCustomAttributeTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilCustomAttributeTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilCustomAttributeTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilDeclSecurityTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilDeclSecurityTableStorageClass* storageArray = new SgAsmCilDeclSecurityTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilDeclSecurityTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilDeclSecurityTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilDeclSecurityTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilEventTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilEventTableStorageClass* storageArray = new SgAsmCilEventTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilEventTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilEventTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilEventTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilEventMapTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilEventMapTableStorageClass* storageArray = new SgAsmCilEventMapTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilEventMapTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilEventMapTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilEventMapTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilExportedTypeTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilExportedTypeTableStorageClass* storageArray = new SgAsmCilExportedTypeTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilExportedTypeTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilExportedTypeTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilExportedTypeTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilFieldTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldTableStorageClass* storageArray = new SgAsmCilFieldTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilFieldTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFieldTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilFieldTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilFieldLayoutTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldLayoutTableStorageClass* storageArray = new SgAsmCilFieldLayoutTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilFieldLayoutTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFieldLayoutTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilFieldLayoutTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilFieldMarshalTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldMarshalTableStorageClass* storageArray = new SgAsmCilFieldMarshalTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilFieldMarshalTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFieldMarshalTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilFieldMarshalTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilFieldRVATable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFieldRVATableStorageClass* storageArray = new SgAsmCilFieldRVATableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilFieldRVATable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFieldRVATableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilFieldRVATableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilFileTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilFileTableStorageClass* storageArray = new SgAsmCilFileTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilFileTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilFileTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilFileTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilGenericParamTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilGenericParamTableStorageClass* storageArray = new SgAsmCilGenericParamTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilGenericParamTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilGenericParamTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilGenericParamTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilGenericParamConstraintTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilGenericParamConstraintTableStorageClass* storageArray = new SgAsmCilGenericParamConstraintTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilGenericParamConstraintTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilGenericParamConstraintTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilGenericParamConstraintTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilImplMapTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilImplMapTableStorageClass* storageArray = new SgAsmCilImplMapTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilImplMapTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilImplMapTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilImplMapTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilInterfaceImplTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilInterfaceImplTableStorageClass* storageArray = new SgAsmCilInterfaceImplTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilInterfaceImplTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilInterfaceImplTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilInterfaceImplTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilManifestResourceTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilManifestResourceTableStorageClass* storageArray = new SgAsmCilManifestResourceTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilManifestResourceTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilManifestResourceTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilManifestResourceTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMemberRefTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMemberRefTableStorageClass* storageArray = new SgAsmCilMemberRefTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMemberRefTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMemberRefTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilMemberRefTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMethodDefTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodDefTableStorageClass* storageArray = new SgAsmCilMethodDefTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMethodDefTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMethodDefTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilMethodDefTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMethodImplTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodImplTableStorageClass* storageArray = new SgAsmCilMethodImplTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMethodImplTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMethodImplTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilMethodImplTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMethodSemanticsTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodSemanticsTableStorageClass* storageArray = new SgAsmCilMethodSemanticsTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMethodSemanticsTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMethodSemanticsTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilMethodSemanticsTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMethodSpecTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodSpecTableStorageClass* storageArray = new SgAsmCilMethodSpecTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMethodSpecTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMethodSpecTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilMethodSpecTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilModuleTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilModuleTableStorageClass* storageArray = new SgAsmCilModuleTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilModuleTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilModuleTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilModuleTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilModuleRefTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilModuleRefTableStorageClass* storageArray = new SgAsmCilModuleRefTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilModuleRefTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilModuleRefTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilModuleRefTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilNestedClassTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilNestedClassTableStorageClass* storageArray = new SgAsmCilNestedClassTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilNestedClassTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilNestedClassTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilNestedClassTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilParamTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilParamTableStorageClass* storageArray = new SgAsmCilParamTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilParamTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilParamTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilParamTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilPropertyTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilPropertyTableStorageClass* storageArray = new SgAsmCilPropertyTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilPropertyTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilPropertyTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilPropertyTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilPropertyMapTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilPropertyMapTableStorageClass* storageArray = new SgAsmCilPropertyMapTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilPropertyMapTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilPropertyMapTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilPropertyMapTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilStandAloneSigTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilStandAloneSigTableStorageClass* storageArray = new SgAsmCilStandAloneSigTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilStandAloneSigTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilStandAloneSigTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilStandAloneSigTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilTypeDefTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeDefTableStorageClass* storageArray = new SgAsmCilTypeDefTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilTypeDefTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilTypeDefTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilTypeDefTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilTypeRefTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeRefTableStorageClass* storageArray = new SgAsmCilTypeRefTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilTypeRefTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilTypeRefTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilTypeRefTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilTypeSpecTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilTypeSpecTableStorageClass* storageArray = new SgAsmCilTypeSpecTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilTypeSpecTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilTypeSpecTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilTypeSpecTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJvmComposite ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJvmCompositeStorageClass* storageArray = new SgJvmCompositeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJvmComposite::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJvmCompositeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJvmCompositeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFortranContinueStmt ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranContinueStmtStorageClass* storageArray = new SgFortranContinueStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFortranContinueStmt::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFortranContinueStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFortranContinueStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmStackMapTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmStackMapTableStorageClass* storageArray = new SgAsmJvmStackMapTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmStackMapTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmStackMapTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmStackMapTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmStackMapFrame ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmStackMapFrameStorageClass* storageArray = new SgAsmJvmStackMapFrameStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmStackMapFrame::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmStackMapFrameStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmStackMapFrameStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmStackMapVerificationType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmStackMapVerificationTypeStorageClass* storageArray = new SgAsmJvmStackMapVerificationTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmStackMapVerificationType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmStackMapVerificationTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmBootstrapMethod ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmBootstrapMethodStorageClass* storageArray = new SgAsmJvmBootstrapMethodStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmBootstrapMethod::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmBootstrapMethodStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmBootstrapMethodStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmBootstrapMethods ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmBootstrapMethodsStorageClass* storageArray = new SgAsmJvmBootstrapMethodsStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmBootstrapMethods::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmBootstrapMethodsStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmBootstrapMethodsStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmExceptions ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmExceptionsStorageClass* storageArray = new SgAsmJvmExceptionsStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmExceptions::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmExceptionsStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmExceptionsStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmNestMembers ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmNestMembersStorageClass* storageArray = new SgAsmJvmNestMembersStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmNestMembers::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmNestMembersStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmNestMembersStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmNestHost ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmNestHostStorageClass* storageArray = new SgAsmJvmNestHostStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmNestHost::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmNestHostStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJovialLabelDeclaration ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJovialLabelDeclarationStorageClass* storageArray = new SgJovialLabelDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJovialLabelDeclaration::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJovialLabelDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJovialLabelDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmLocalVariableEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLocalVariableEntryStorageClass* storageArray = new SgAsmJvmLocalVariableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmLocalVariableEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmLocalVariableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmLocalVariableTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLocalVariableTableStorageClass* storageArray = new SgAsmJvmLocalVariableTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmLocalVariableTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmLocalVariableTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmLocalVariableTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmLocalVariableTypeEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLocalVariableTypeEntryStorageClass* storageArray = new SgAsmJvmLocalVariableTypeEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmLocalVariableTypeEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmLocalVariableTypeEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmLocalVariableTypeTable ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmLocalVariableTypeTableStorageClass* storageArray = new SgAsmJvmLocalVariableTypeTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmLocalVariableTypeTable::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmLocalVariableTypeTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmLocalVariableTypeTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUserInstruction ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUserInstructionStorageClass* storageArray = new SgAsmUserInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUserInstruction::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUserInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUserInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmMethodParameters ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmMethodParametersStorageClass* storageArray = new SgAsmJvmMethodParametersStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmMethodParameters::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmMethodParametersStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmJvmMethodParametersStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmMethodParametersEntry ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmMethodParametersEntryStorageClass* storageArray = new SgAsmJvmMethodParametersEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmMethodParametersEntry::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmMethodParametersEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmVoidType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmVoidTypeStorageClass* storageArray = new SgAsmVoidTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmVoidType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmVoidTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPointerType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPointerTypeStorageClass* storageArray = new SgAsmPointerTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPointerType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPointerTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRangeType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRangeTypeStorageClass* storageArray = new SgRangeTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRangeType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRangeTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRangeTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilExceptionData ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilExceptionDataStorageClass* storageArray = new SgAsmCilExceptionDataStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilExceptionData::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilExceptionDataStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilMethodData ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilMethodDataStorageClass* storageArray = new SgAsmCilMethodDataStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilMethodData::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilMethodDataStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilMethodDataStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateVariableInstantiation ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateVariableInstantiationStorageClass* storageArray = new SgTemplateVariableInstantiationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateVariableInstantiation::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateVariableInstantiationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateVariableInstantiationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgReferenceExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReferenceExpStorageClass* storageArray = new SgReferenceExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgReferenceExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgReferenceExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgReferenceExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeRefExpStorageClass* storageArray = new SgTypeRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgScopedRefExp ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopedRefExpStorageClass* storageArray = new SgScopedRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgScopedRefExp::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgScopedRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgScopedRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgScopedType ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopedTypeStorageClass* storageArray = new SgScopedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgScopedType::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgScopedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgScopedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSymbol ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSymbolStorageClass* storageArray = new SgTypeSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSymbol::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmSynthetic ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmSyntheticStorageClass* storageArray = new SgAsmJvmSyntheticStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmSynthetic::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmSyntheticStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmJvmDeprecated ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmJvmDeprecatedStorageClass* storageArray = new SgAsmJvmDeprecatedStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmJvmDeprecated::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmJvmDeprecatedStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSignedCharVal ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSignedCharValStorageClass* storageArray = new SgSignedCharValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSignedCharVal::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSignedCharValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSignedCharValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCilErrorHeap ); 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCilErrorHeapStorageClass* storageArray = new SgAsmCilErrorHeapStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCilErrorHeap::initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCilErrorHeapStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCilErrorHeapStorageClass :: writeEasyStorageDataToFile(out) ;
        }  


/* #line 549 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
   
     }

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() closing file:");
     std::string endString = "ROSE_AST_BINARY_END";
     out.write ( endString.c_str(), endString.size() );
     }
     
  // clear everything, actually, this does not work, since I need a different way to 
  // initialize the actualRebuildAst
 //    delete actualRebuildAst;
 //    vectorOfASTs.clear();
     

     return ;
}


/* JH (01/03/2006) This method stores an AST in binary format to the file. 
*/
void 
AST_FILE_IO :: writeASTToFile ( std::string fileName )
  {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile():");
 
     std::ofstream out;
     out.open ( fileName.c_str(), std::ios::out | std::ios::binary );
     if ( !out )
        {
          std::cout << "Problems opening file " << fileName << " for writing AST!" << std::endl;
          exit(-1);
        }
     AST_FILE_IO::writeASTToStream(out);

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() closing file: time (sec) = ");
     out.close() ;
     }
     
     return ;
   }

std::string 
AST_FILE_IO :: writeASTToString()
  {
    std::ostringstream out;
    AST_FILE_IO::writeASTToStream(out);
    return out.str();
  }

/* JW (06/21/2006) Changed to use streams in base implementation */
SgProject*
AST_FILE_IO :: readASTFromStream ( std::istream& inFile )
  {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::readASTFromStream() time (sec) = ");
 
     assert ( freepointersOfCurrentAstAreSetToGlobalIndices == false );
     std::string startString = "ROSE_AST_BINARY_START";
     char* startChar = new char [startString.size()+1];
     startChar[startString.size()] = '\0';
     inFile.read ( startChar, startString.size() );
     assert (inFile);
     assert ( string(startChar) == startString );
     delete [] startChar;
     REGISTER_ATTRIBUTE_FOR_FILE_IO(AstAttribute) ;

  // 1. Read the accumulatedPoolSizesOfNewAst 
     if ( SgProject::get_verbose() > 0 )
          std::cout << "Here we start the reading of the AST specific data ... " << std::endl;

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Allocating AstDataStorageClass ... " << std::endl;
     AstDataStorageClass staticTemp;
     
     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- before AstDataStorageClass::readEasyStorageDataFromFile() .... " << std::endl;

#if FILE_IO_MEMORY_POOL_CHECK
  // AST_FileIO::MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_A;
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_A;
     memoryCheckingTraversal_A.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- before AstDataStorageClass::readEasyStorageDataFromFile() .... " << std::endl;

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() raw file read:");

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Reading the data from file ... " << std::endl;

     inFile.read ( (char*)(&staticTemp) , sizeof(AstDataStorageClass) );
     assert (inFile);

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Reading the static (EasyStorage) data from file ... " << std::endl;

     AstDataStorageClass::readEasyStorageDataFromFile(inFile);
     }
     
     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- after AstDataStorageClass::readEasyStorageDataFromFile() .... " << std::endl;

#if FILE_IO_MEMORY_POOL_CHECK
  // AST_FileIO::MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_B;
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_B;
     memoryCheckingTraversal_B.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- after AstDataStorageClass::readEasyStorageDataFromFile() .... " << std::endl;

  // 1.a Introducing a marker to check the right position in the file     

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() raw file (marker) read:");

     std::string markString = "#########";
     char* markChar = new char [markString.size()+1];

  // DQ (9/24/2007): Bug fix suggested by Jeremiah.
     markChar[markString.size()] = '\0';

     inFile.read ( markChar, markString.size() );
     assert (inFile);
     assert ( string(markChar) == markString ); 
     delete [] markChar;
     }
     
     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- after marker read .... " << std::endl;

#if FILE_IO_MEMORY_POOL_CHECK
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_C;
     memoryCheckingTraversal_C.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- after marker read .... " << std::endl;

  // 2. Initialize the StorageClass and read

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() rebuild AST (part 1):");

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Initializing the actualRebuildAST with staticTemp ... " << std::endl;

  // This calls the constructor AstSpecificDataManagingClass(const AstSpecificDataManagingClassStorageClass& source ).
  // The code used to generate this function is in: ROSETTA/src/buildStorageClasses.C
  // Note that AstData is typedefed to AstSpecificDataManagingClass 
     actualRebuildAst = new AstData(staticTemp);
  // extendMemoryPoolsForRebuildingAST();

  // The call to the constructor calls "extendMemoryPoolsForRebuildingAST()" which uses valid pointers
  // to reference the extended memory blocks where the new AST extends beyond the current memory block.
  // This means that freepointer values at the end of a sequence of memroy blocks will have values
  // that are not equal to "AST_FileIO::IS_VALID_POINTER()", thus causing warnings to be spewed
  // from the "MemoryCheckingTraversalForAstFileIO" tests (which I have added more of lately).
  // It seems that calling "new AstData(staticTemp)" is not meant to be done where part of the AST was 
  // read from a file??? Also the frepointer value of the next to last block in the memory block list
  // appears to be lost after the call to "extendMemoryPoolsForRebuildingAST()".

  // The problem is that when freepointers are converted to "AST_FileIO::IS_VALID_POINTER()", the last
  // block in the chain is lost. since it points to an entry that is not allocated and thus not used.
  // The freepointers, and/or the extension of the memory pools overwrites the last block in the chain.
  // But I don't yet see exactly why!!!

  // One thing to test is if the new operators are working properly (or used) when the "AST_FileIO::IS_VALID_POINTER()"
  // values are in place in the AST.  Seems like it would be an error. to mix an AST read from disk with
  // and AST that has been extended via "extendMemoryPoolsForRebuildingAST()".

  // I think the problem is in the conversion of freepointer values back to correct values after having
  // been set as "AST_FileIO::IS_VALID_POINTER()" (particularly when the "AST_FileIO::IS_VALID_POINTER()"
  // value has been over written.

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- after actualRebuildAst = new AstData() .... " << std::endl;

#if FILE_IO_MEMORY_POOL_CHECK
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_D;
     memoryCheckingTraversal_D.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- after actualRebuildAst = new AstData() .... " << std::endl;

  // 3.
  // DQ (6/7/2010): Not clear why this is only called for where there is a single AST.
  // printf ("AST_FILE_IO::vectorOfASTs.size() = %" PRIuPTR " \n",AST_FILE_IO::vectorOfASTs.size());
     if (AST_FILE_IO::vectorOfASTs.size() == 1)
        { 
          if ( SgProject::get_verbose() > 0 )
               std::cout << "setting the static data of an AST, but only for the first AST in a pool ... " << std::flush;

          actualRebuildAst->setStaticDataMembersOfIRNodes();

          if ( SgProject::get_verbose() > 0 )
               std::cout << "done" << std::endl;
        }

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Calling AstDataStorageClass::deleteStaticDataOfEasyStorageClasses() .... " << std::endl;

#if FILE_IO_MEMORY_POOL_CHECK
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_D2;
     memoryCheckingTraversal_D2.traverseMemoryPool();
#endif

     AstDataStorageClass::deleteStaticDataOfEasyStorageClasses();
     }

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- after AstDataStorageClass::deleteStaticDataOfEasyStorageClasses() .... " << std::endl;

#if FILE_IO_MEMORY_POOL_CHECK
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_E;
     memoryCheckingTraversal_E.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- after AstDataStorageClass::deleteStaticDataOfEasyStorageClasses() .... " << std::endl;

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() rebuild AST (part 2):");

     unsigned long sizeOfActualPool  = 0;
  // DQ (9/3/2015): Fixed unsigned-ness of type.
  // unsigned long storageClassIndex = 0 ;


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAccessModifier ); 
     SgAccessModifierStorageClass* storageArraySgAccessModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAccessModifier = new SgAccessModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAccessModifier) , sizeof ( SgAccessModifierStorageClass ) * sizeOfActualPool) ;
          SgAccessModifierStorageClass* storageArray = storageArraySgAccessModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAccessModifier ( *storageArray ) ; 
#else
               SgAccessModifier* tmp = new SgAccessModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAccessModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgActualArgumentExpression ); 
     SgActualArgumentExpressionStorageClass* storageArraySgActualArgumentExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgActualArgumentExpression = new SgActualArgumentExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgActualArgumentExpression) , sizeof ( SgActualArgumentExpressionStorageClass ) * sizeOfActualPool) ;
        SgActualArgumentExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgActualArgumentExpressionStorageClass* storageArray = storageArraySgActualArgumentExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgActualArgumentExpression ( *storageArray ) ; 
#else
               SgActualArgumentExpression* tmp = new SgActualArgumentExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgActualArgumentExpression;  
      SgActualArgumentExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAbsOp ); 
     SgAbsOpStorageClass* storageArraySgAbsOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAbsOp = new SgAbsOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAbsOp) , sizeof ( SgAbsOpStorageClass ) * sizeOfActualPool) ;
        SgAbsOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAbsOpStorageClass* storageArray = storageArraySgAbsOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAbsOp ( *storageArray ) ; 
#else
               SgAbsOp* tmp = new SgAbsOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAbsOp;  
      SgAbsOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaAccessType ); 
     SgAdaAccessTypeStorageClass* storageArraySgAdaAccessType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaAccessType = new SgAdaAccessTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaAccessType) , sizeof ( SgAdaAccessTypeStorageClass ) * sizeOfActualPool) ;
        SgAdaAccessTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaAccessTypeStorageClass* storageArray = storageArraySgAdaAccessType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaAccessType ( *storageArray ) ; 
#else
               SgAdaAccessType* tmp = new SgAdaAccessType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaAccessType;  
      SgAdaAccessTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaAcceptStmt ); 
     SgAdaAcceptStmtStorageClass* storageArraySgAdaAcceptStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaAcceptStmt = new SgAdaAcceptStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaAcceptStmt) , sizeof ( SgAdaAcceptStmtStorageClass ) * sizeOfActualPool) ;
        SgAdaAcceptStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaAcceptStmtStorageClass* storageArray = storageArraySgAdaAcceptStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaAcceptStmt ( *storageArray ) ; 
#else
               SgAdaAcceptStmt* tmp = new SgAdaAcceptStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaAcceptStmt;  
      SgAdaAcceptStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaDelayStmt ); 
     SgAdaDelayStmtStorageClass* storageArraySgAdaDelayStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaDelayStmt = new SgAdaDelayStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaDelayStmt) , sizeof ( SgAdaDelayStmtStorageClass ) * sizeOfActualPool) ;
        SgAdaDelayStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaDelayStmtStorageClass* storageArray = storageArraySgAdaDelayStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaDelayStmt ( *storageArray ) ; 
#else
               SgAdaDelayStmt* tmp = new SgAdaDelayStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaDelayStmt;  
      SgAdaDelayStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaEntryDecl ); 
     SgAdaEntryDeclStorageClass* storageArraySgAdaEntryDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaEntryDecl = new SgAdaEntryDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaEntryDecl) , sizeof ( SgAdaEntryDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaEntryDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaEntryDeclStorageClass* storageArray = storageArraySgAdaEntryDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaEntryDecl ( *storageArray ) ; 
#else
               SgAdaEntryDecl* tmp = new SgAdaEntryDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaEntryDecl;  
      SgAdaEntryDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaExitStmt ); 
     SgAdaExitStmtStorageClass* storageArraySgAdaExitStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaExitStmt = new SgAdaExitStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaExitStmt) , sizeof ( SgAdaExitStmtStorageClass ) * sizeOfActualPool) ;
        SgAdaExitStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaExitStmtStorageClass* storageArray = storageArraySgAdaExitStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaExitStmt ( *storageArray ) ; 
#else
               SgAdaExitStmt* tmp = new SgAdaExitStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaExitStmt;  
      SgAdaExitStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaDiscreteType ); 
     SgAdaDiscreteTypeStorageClass* storageArraySgAdaDiscreteType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaDiscreteType = new SgAdaDiscreteTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaDiscreteType) , sizeof ( SgAdaDiscreteTypeStorageClass ) * sizeOfActualPool) ;
        SgAdaDiscreteTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaDiscreteTypeStorageClass* storageArray = storageArraySgAdaDiscreteType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaDiscreteType ( *storageArray ) ; 
#else
               SgAdaDiscreteType* tmp = new SgAdaDiscreteType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaDiscreteType;  
      SgAdaDiscreteTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaFloatVal ); 
     SgAdaFloatValStorageClass* storageArraySgAdaFloatVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaFloatVal = new SgAdaFloatValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaFloatVal) , sizeof ( SgAdaFloatValStorageClass ) * sizeOfActualPool) ;
        SgAdaFloatValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaFloatValStorageClass* storageArray = storageArraySgAdaFloatVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaFloatVal ( *storageArray ) ; 
#else
               SgAdaFloatVal* tmp = new SgAdaFloatVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaFloatVal;  
      SgAdaFloatValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaLoopStmt ); 
     SgAdaLoopStmtStorageClass* storageArraySgAdaLoopStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaLoopStmt = new SgAdaLoopStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaLoopStmt) , sizeof ( SgAdaLoopStmtStorageClass ) * sizeOfActualPool) ;
        SgAdaLoopStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaLoopStmtStorageClass* storageArray = storageArraySgAdaLoopStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaLoopStmt ( *storageArray ) ; 
#else
               SgAdaLoopStmt* tmp = new SgAdaLoopStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaLoopStmt;  
      SgAdaLoopStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaPackageBody ); 
     SgAdaPackageBodyStorageClass* storageArraySgAdaPackageBody = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaPackageBody = new SgAdaPackageBodyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaPackageBody) , sizeof ( SgAdaPackageBodyStorageClass ) * sizeOfActualPool) ;
        SgAdaPackageBodyStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaPackageBodyStorageClass* storageArray = storageArraySgAdaPackageBody;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaPackageBody ( *storageArray ) ; 
#else
               SgAdaPackageBody* tmp = new SgAdaPackageBody ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaPackageBody;  
      SgAdaPackageBodyStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaPackageBodyDecl ); 
     SgAdaPackageBodyDeclStorageClass* storageArraySgAdaPackageBodyDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaPackageBodyDecl = new SgAdaPackageBodyDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaPackageBodyDecl) , sizeof ( SgAdaPackageBodyDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaPackageBodyDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaPackageBodyDeclStorageClass* storageArray = storageArraySgAdaPackageBodyDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaPackageBodyDecl ( *storageArray ) ; 
#else
               SgAdaPackageBodyDecl* tmp = new SgAdaPackageBodyDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaPackageBodyDecl;  
      SgAdaPackageBodyDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaPackageSpec ); 
     SgAdaPackageSpecStorageClass* storageArraySgAdaPackageSpec = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaPackageSpec = new SgAdaPackageSpecStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaPackageSpec) , sizeof ( SgAdaPackageSpecStorageClass ) * sizeOfActualPool) ;
        SgAdaPackageSpecStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaPackageSpecStorageClass* storageArray = storageArraySgAdaPackageSpec;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaPackageSpec ( *storageArray ) ; 
#else
               SgAdaPackageSpec* tmp = new SgAdaPackageSpec ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaPackageSpec;  
      SgAdaPackageSpecStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaPackageSpecDecl ); 
     SgAdaPackageSpecDeclStorageClass* storageArraySgAdaPackageSpecDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaPackageSpecDecl = new SgAdaPackageSpecDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaPackageSpecDecl) , sizeof ( SgAdaPackageSpecDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaPackageSpecDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaPackageSpecDeclStorageClass* storageArray = storageArraySgAdaPackageSpecDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaPackageSpecDecl ( *storageArray ) ; 
#else
               SgAdaPackageSpecDecl* tmp = new SgAdaPackageSpecDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaPackageSpecDecl;  
      SgAdaPackageSpecDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaPackageSymbol ); 
     SgAdaPackageSymbolStorageClass* storageArraySgAdaPackageSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaPackageSymbol = new SgAdaPackageSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaPackageSymbol) , sizeof ( SgAdaPackageSymbolStorageClass ) * sizeOfActualPool) ;
        SgAdaPackageSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaPackageSymbolStorageClass* storageArray = storageArraySgAdaPackageSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaPackageSymbol ( *storageArray ) ; 
#else
               SgAdaPackageSymbol* tmp = new SgAdaPackageSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaPackageSymbol;  
      SgAdaPackageSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaRangeConstraint ); 
     SgAdaRangeConstraintStorageClass* storageArraySgAdaRangeConstraint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaRangeConstraint = new SgAdaRangeConstraintStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaRangeConstraint) , sizeof ( SgAdaRangeConstraintStorageClass ) * sizeOfActualPool) ;
        SgAdaRangeConstraintStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaRangeConstraintStorageClass* storageArray = storageArraySgAdaRangeConstraint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaRangeConstraint ( *storageArray ) ; 
#else
               SgAdaRangeConstraint* tmp = new SgAdaRangeConstraint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaRangeConstraint;  
      SgAdaRangeConstraintStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaRenamingDecl ); 
     SgAdaRenamingDeclStorageClass* storageArraySgAdaRenamingDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaRenamingDecl = new SgAdaRenamingDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaRenamingDecl) , sizeof ( SgAdaRenamingDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaRenamingDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaRenamingDeclStorageClass* storageArray = storageArraySgAdaRenamingDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaRenamingDecl ( *storageArray ) ; 
#else
               SgAdaRenamingDecl* tmp = new SgAdaRenamingDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaRenamingDecl;  
      SgAdaRenamingDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaSubtype ); 
     SgAdaSubtypeStorageClass* storageArraySgAdaSubtype = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaSubtype = new SgAdaSubtypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaSubtype) , sizeof ( SgAdaSubtypeStorageClass ) * sizeOfActualPool) ;
        SgAdaSubtypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaSubtypeStorageClass* storageArray = storageArraySgAdaSubtype;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaSubtype ( *storageArray ) ; 
#else
               SgAdaSubtype* tmp = new SgAdaSubtype ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaSubtype;  
      SgAdaSubtypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTaskBody ); 
     SgAdaTaskBodyStorageClass* storageArraySgAdaTaskBody = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTaskBody = new SgAdaTaskBodyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTaskBody) , sizeof ( SgAdaTaskBodyStorageClass ) * sizeOfActualPool) ;
        SgAdaTaskBodyStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTaskBodyStorageClass* storageArray = storageArraySgAdaTaskBody;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTaskBody ( *storageArray ) ; 
#else
               SgAdaTaskBody* tmp = new SgAdaTaskBody ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTaskBody;  
      SgAdaTaskBodyStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTaskBodyDecl ); 
     SgAdaTaskBodyDeclStorageClass* storageArraySgAdaTaskBodyDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTaskBodyDecl = new SgAdaTaskBodyDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTaskBodyDecl) , sizeof ( SgAdaTaskBodyDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaTaskBodyDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTaskBodyDeclStorageClass* storageArray = storageArraySgAdaTaskBodyDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTaskBodyDecl ( *storageArray ) ; 
#else
               SgAdaTaskBodyDecl* tmp = new SgAdaTaskBodyDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTaskBodyDecl;  
      SgAdaTaskBodyDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTaskSpec ); 
     SgAdaTaskSpecStorageClass* storageArraySgAdaTaskSpec = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTaskSpec = new SgAdaTaskSpecStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTaskSpec) , sizeof ( SgAdaTaskSpecStorageClass ) * sizeOfActualPool) ;
        SgAdaTaskSpecStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTaskSpecStorageClass* storageArray = storageArraySgAdaTaskSpec;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTaskSpec ( *storageArray ) ; 
#else
               SgAdaTaskSpec* tmp = new SgAdaTaskSpec ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTaskSpec;  
      SgAdaTaskSpecStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTaskSpecDecl ); 
     SgAdaTaskSpecDeclStorageClass* storageArraySgAdaTaskSpecDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTaskSpecDecl = new SgAdaTaskSpecDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTaskSpecDecl) , sizeof ( SgAdaTaskSpecDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaTaskSpecDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTaskSpecDeclStorageClass* storageArray = storageArraySgAdaTaskSpecDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTaskSpecDecl ( *storageArray ) ; 
#else
               SgAdaTaskSpecDecl* tmp = new SgAdaTaskSpecDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTaskSpecDecl;  
      SgAdaTaskSpecDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTaskSymbol ); 
     SgAdaTaskSymbolStorageClass* storageArraySgAdaTaskSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTaskSymbol = new SgAdaTaskSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTaskSymbol) , sizeof ( SgAdaTaskSymbolStorageClass ) * sizeOfActualPool) ;
        SgAdaTaskSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTaskSymbolStorageClass* storageArray = storageArraySgAdaTaskSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTaskSymbol ( *storageArray ) ; 
#else
               SgAdaTaskSymbol* tmp = new SgAdaTaskSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTaskSymbol;  
      SgAdaTaskSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTaskRefExp ); 
     SgAdaTaskRefExpStorageClass* storageArraySgAdaTaskRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTaskRefExp = new SgAdaTaskRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTaskRefExp) , sizeof ( SgAdaTaskRefExpStorageClass ) * sizeOfActualPool) ;
        SgAdaTaskRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTaskRefExpStorageClass* storageArray = storageArraySgAdaTaskRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTaskRefExp ( *storageArray ) ; 
#else
               SgAdaTaskRefExp* tmp = new SgAdaTaskRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTaskRefExp;  
      SgAdaTaskRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTaskType ); 
     SgAdaTaskTypeStorageClass* storageArraySgAdaTaskType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTaskType = new SgAdaTaskTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTaskType) , sizeof ( SgAdaTaskTypeStorageClass ) * sizeOfActualPool) ;
        SgAdaTaskTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTaskTypeStorageClass* storageArray = storageArraySgAdaTaskType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTaskType ( *storageArray ) ; 
#else
               SgAdaTaskType* tmp = new SgAdaTaskType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTaskType;  
      SgAdaTaskTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTaskTypeDecl ); 
     SgAdaTaskTypeDeclStorageClass* storageArraySgAdaTaskTypeDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTaskTypeDecl = new SgAdaTaskTypeDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTaskTypeDecl) , sizeof ( SgAdaTaskTypeDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaTaskTypeDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTaskTypeDeclStorageClass* storageArray = storageArraySgAdaTaskTypeDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTaskTypeDecl ( *storageArray ) ; 
#else
               SgAdaTaskTypeDecl* tmp = new SgAdaTaskTypeDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTaskTypeDecl;  
      SgAdaTaskTypeDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTypeConstraint ); 
     SgAdaTypeConstraintStorageClass* storageArraySgAdaTypeConstraint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTypeConstraint = new SgAdaTypeConstraintStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTypeConstraint) , sizeof ( SgAdaTypeConstraintStorageClass ) * sizeOfActualPool) ;
        SgAdaTypeConstraintStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTypeConstraintStorageClass* storageArray = storageArraySgAdaTypeConstraint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTypeConstraint ( *storageArray ) ; 
#else
               SgAdaTypeConstraint* tmp = new SgAdaTypeConstraint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTypeConstraint;  
      SgAdaTypeConstraintStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAddOp ); 
     SgAddOpStorageClass* storageArraySgAddOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAddOp = new SgAddOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAddOp) , sizeof ( SgAddOpStorageClass ) * sizeOfActualPool) ;
        SgAddOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAddOpStorageClass* storageArray = storageArraySgAddOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAddOp ( *storageArray ) ; 
#else
               SgAddOp* tmp = new SgAddOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAddOp;  
      SgAddOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAddressOfOp ); 
     SgAddressOfOpStorageClass* storageArraySgAddressOfOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAddressOfOp = new SgAddressOfOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAddressOfOp) , sizeof ( SgAddressOfOpStorageClass ) * sizeOfActualPool) ;
        SgAddressOfOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAddressOfOpStorageClass* storageArray = storageArraySgAddressOfOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAddressOfOp ( *storageArray ) ; 
#else
               SgAddressOfOp* tmp = new SgAddressOfOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAddressOfOp;  
      SgAddressOfOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAggregateInitializer ); 
     SgAggregateInitializerStorageClass* storageArraySgAggregateInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAggregateInitializer = new SgAggregateInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAggregateInitializer) , sizeof ( SgAggregateInitializerStorageClass ) * sizeOfActualPool) ;
        SgAggregateInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAggregateInitializerStorageClass* storageArray = storageArraySgAggregateInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAggregateInitializer ( *storageArray ) ; 
#else
               SgAggregateInitializer* tmp = new SgAggregateInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAggregateInitializer;  
      SgAggregateInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAliasSymbol ); 
     SgAliasSymbolStorageClass* storageArraySgAliasSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAliasSymbol = new SgAliasSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAliasSymbol) , sizeof ( SgAliasSymbolStorageClass ) * sizeOfActualPool) ;
        SgAliasSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAliasSymbolStorageClass* storageArray = storageArraySgAliasSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAliasSymbol ( *storageArray ) ; 
#else
               SgAliasSymbol* tmp = new SgAliasSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAliasSymbol;  
      SgAliasSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAllocateStatement ); 
     SgAllocateStatementStorageClass* storageArraySgAllocateStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAllocateStatement = new SgAllocateStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAllocateStatement) , sizeof ( SgAllocateStatementStorageClass ) * sizeOfActualPool) ;
        SgAllocateStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAllocateStatementStorageClass* storageArray = storageArraySgAllocateStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAllocateStatement ( *storageArray ) ; 
#else
               SgAllocateStatement* tmp = new SgAllocateStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAllocateStatement;  
      SgAllocateStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAndAssignOp ); 
     SgAndAssignOpStorageClass* storageArraySgAndAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAndAssignOp = new SgAndAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAndAssignOp) , sizeof ( SgAndAssignOpStorageClass ) * sizeOfActualPool) ;
        SgAndAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAndAssignOpStorageClass* storageArray = storageArraySgAndAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAndAssignOp ( *storageArray ) ; 
#else
               SgAndAssignOp* tmp = new SgAndAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAndAssignOp;  
      SgAndAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAndOp ); 
     SgAndOpStorageClass* storageArraySgAndOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAndOp = new SgAndOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAndOp) , sizeof ( SgAndOpStorageClass ) * sizeOfActualPool) ;
        SgAndOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAndOpStorageClass* storageArray = storageArraySgAndOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAndOp ( *storageArray ) ; 
#else
               SgAndOp* tmp = new SgAndOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAndOp;  
      SgAndOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgArithmeticIfStatement ); 
     SgArithmeticIfStatementStorageClass* storageArraySgArithmeticIfStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgArithmeticIfStatement = new SgArithmeticIfStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgArithmeticIfStatement) , sizeof ( SgArithmeticIfStatementStorageClass ) * sizeOfActualPool) ;
        SgArithmeticIfStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgArithmeticIfStatementStorageClass* storageArray = storageArraySgArithmeticIfStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgArithmeticIfStatement ( *storageArray ) ; 
#else
               SgArithmeticIfStatement* tmp = new SgArithmeticIfStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgArithmeticIfStatement;  
      SgArithmeticIfStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgArrayType ); 
     SgArrayTypeStorageClass* storageArraySgArrayType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgArrayType = new SgArrayTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgArrayType) , sizeof ( SgArrayTypeStorageClass ) * sizeOfActualPool) ;
        SgArrayTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgArrayTypeStorageClass* storageArray = storageArraySgArrayType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgArrayType ( *storageArray ) ; 
#else
               SgArrayType* tmp = new SgArrayType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgArrayType;  
      SgArrayTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgArrowExp ); 
     SgArrowExpStorageClass* storageArraySgArrowExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgArrowExp = new SgArrowExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgArrowExp) , sizeof ( SgArrowExpStorageClass ) * sizeOfActualPool) ;
        SgArrowExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgArrowExpStorageClass* storageArray = storageArraySgArrowExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgArrowExp ( *storageArray ) ; 
#else
               SgArrowExp* tmp = new SgArrowExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgArrowExp;  
      SgArrowExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgArrowStarOp ); 
     SgArrowStarOpStorageClass* storageArraySgArrowStarOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgArrowStarOp = new SgArrowStarOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgArrowStarOp) , sizeof ( SgArrowStarOpStorageClass ) * sizeOfActualPool) ;
        SgArrowStarOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgArrowStarOpStorageClass* storageArray = storageArraySgArrowStarOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgArrowStarOp ( *storageArray ) ; 
#else
               SgArrowStarOp* tmp = new SgArrowStarOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgArrowStarOp;  
      SgArrowStarOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBasicString ); 
     SgAsmBasicStringStorageClass* storageArraySgAsmBasicString = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBasicString = new SgAsmBasicStringStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBasicString) , sizeof ( SgAsmBasicStringStorageClass ) * sizeOfActualPool) ;
        SgAsmBasicStringStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBasicStringStorageClass* storageArray = storageArraySgAsmBasicString;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBasicString ( *storageArray ) ; 
#else
               SgAsmBasicString* tmp = new SgAsmBasicString ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBasicString;  
      SgAsmBasicStringStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryAdd ); 
     SgAsmBinaryAddStorageClass* storageArraySgAsmBinaryAdd = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryAdd = new SgAsmBinaryAddStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryAdd) , sizeof ( SgAsmBinaryAddStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryAddStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryAddStorageClass* storageArray = storageArraySgAsmBinaryAdd;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryAdd ( *storageArray ) ; 
#else
               SgAsmBinaryAdd* tmp = new SgAsmBinaryAdd ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryAdd;  
      SgAsmBinaryAddStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryAsr ); 
     SgAsmBinaryAsrStorageClass* storageArraySgAsmBinaryAsr = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryAsr = new SgAsmBinaryAsrStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryAsr) , sizeof ( SgAsmBinaryAsrStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryAsrStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryAsrStorageClass* storageArray = storageArraySgAsmBinaryAsr;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryAsr ( *storageArray ) ; 
#else
               SgAsmBinaryAsr* tmp = new SgAsmBinaryAsr ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryAsr;  
      SgAsmBinaryAsrStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryDivide ); 
     SgAsmBinaryDivideStorageClass* storageArraySgAsmBinaryDivide = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryDivide = new SgAsmBinaryDivideStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryDivide) , sizeof ( SgAsmBinaryDivideStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryDivideStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryDivideStorageClass* storageArray = storageArraySgAsmBinaryDivide;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryDivide ( *storageArray ) ; 
#else
               SgAsmBinaryDivide* tmp = new SgAsmBinaryDivide ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryDivide;  
      SgAsmBinaryDivideStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryExpression ); 
     SgAsmBinaryExpressionStorageClass* storageArraySgAsmBinaryExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryExpression = new SgAsmBinaryExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryExpression) , sizeof ( SgAsmBinaryExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryExpressionStorageClass* storageArray = storageArraySgAsmBinaryExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryExpression ( *storageArray ) ; 
#else
               SgAsmBinaryExpression* tmp = new SgAsmBinaryExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryExpression;  
      SgAsmBinaryExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryLsl ); 
     SgAsmBinaryLslStorageClass* storageArraySgAsmBinaryLsl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryLsl = new SgAsmBinaryLslStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryLsl) , sizeof ( SgAsmBinaryLslStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryLslStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryLslStorageClass* storageArray = storageArraySgAsmBinaryLsl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryLsl ( *storageArray ) ; 
#else
               SgAsmBinaryLsl* tmp = new SgAsmBinaryLsl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryLsl;  
      SgAsmBinaryLslStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryLsr ); 
     SgAsmBinaryLsrStorageClass* storageArraySgAsmBinaryLsr = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryLsr = new SgAsmBinaryLsrStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryLsr) , sizeof ( SgAsmBinaryLsrStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryLsrStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryLsrStorageClass* storageArray = storageArraySgAsmBinaryLsr;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryLsr ( *storageArray ) ; 
#else
               SgAsmBinaryLsr* tmp = new SgAsmBinaryLsr ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryLsr;  
      SgAsmBinaryLsrStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryMod ); 
     SgAsmBinaryModStorageClass* storageArraySgAsmBinaryMod = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryMod = new SgAsmBinaryModStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryMod) , sizeof ( SgAsmBinaryModStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryModStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryModStorageClass* storageArray = storageArraySgAsmBinaryMod;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryMod ( *storageArray ) ; 
#else
               SgAsmBinaryMod* tmp = new SgAsmBinaryMod ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryMod;  
      SgAsmBinaryModStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryMsl ); 
     SgAsmBinaryMslStorageClass* storageArraySgAsmBinaryMsl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryMsl = new SgAsmBinaryMslStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryMsl) , sizeof ( SgAsmBinaryMslStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryMslStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryMslStorageClass* storageArray = storageArraySgAsmBinaryMsl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryMsl ( *storageArray ) ; 
#else
               SgAsmBinaryMsl* tmp = new SgAsmBinaryMsl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryMsl;  
      SgAsmBinaryMslStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryMultiply ); 
     SgAsmBinaryMultiplyStorageClass* storageArraySgAsmBinaryMultiply = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryMultiply = new SgAsmBinaryMultiplyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryMultiply) , sizeof ( SgAsmBinaryMultiplyStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryMultiplyStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryMultiplyStorageClass* storageArray = storageArraySgAsmBinaryMultiply;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryMultiply ( *storageArray ) ; 
#else
               SgAsmBinaryMultiply* tmp = new SgAsmBinaryMultiply ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryMultiply;  
      SgAsmBinaryMultiplyStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryRor ); 
     SgAsmBinaryRorStorageClass* storageArraySgAsmBinaryRor = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryRor = new SgAsmBinaryRorStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryRor) , sizeof ( SgAsmBinaryRorStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryRorStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryRorStorageClass* storageArray = storageArraySgAsmBinaryRor;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryRor ( *storageArray ) ; 
#else
               SgAsmBinaryRor* tmp = new SgAsmBinaryRor ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryRor;  
      SgAsmBinaryRorStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinarySubtract ); 
     SgAsmBinarySubtractStorageClass* storageArraySgAsmBinarySubtract = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinarySubtract = new SgAsmBinarySubtractStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinarySubtract) , sizeof ( SgAsmBinarySubtractStorageClass ) * sizeOfActualPool) ;
        SgAsmBinarySubtractStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinarySubtractStorageClass* storageArray = storageArraySgAsmBinarySubtract;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinarySubtract ( *storageArray ) ; 
#else
               SgAsmBinarySubtract* tmp = new SgAsmBinarySubtract ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinarySubtract;  
      SgAsmBinarySubtractStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBlock ); 
     SgAsmBlockStorageClass* storageArraySgAsmBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBlock = new SgAsmBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBlock) , sizeof ( SgAsmBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBlockStorageClass* storageArray = storageArraySgAsmBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBlock ( *storageArray ) ; 
#else
               SgAsmBlock* tmp = new SgAsmBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBlock;  
      SgAsmBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCoffStrtab ); 
     SgAsmCoffStrtabStorageClass* storageArraySgAsmCoffStrtab = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCoffStrtab = new SgAsmCoffStrtabStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCoffStrtab) , sizeof ( SgAsmCoffStrtabStorageClass ) * sizeOfActualPool) ;
        SgAsmCoffStrtabStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCoffStrtabStorageClass* storageArray = storageArraySgAsmCoffStrtab;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCoffStrtab ( *storageArray ) ; 
#else
               SgAsmCoffStrtab* tmp = new SgAsmCoffStrtab ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCoffStrtab;  
      SgAsmCoffStrtabStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCoffSymbol ); 
     SgAsmCoffSymbolStorageClass* storageArraySgAsmCoffSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCoffSymbol = new SgAsmCoffSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCoffSymbol) , sizeof ( SgAsmCoffSymbolStorageClass ) * sizeOfActualPool) ;
        SgAsmCoffSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCoffSymbolStorageClass* storageArray = storageArraySgAsmCoffSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCoffSymbol ( *storageArray ) ; 
#else
               SgAsmCoffSymbol* tmp = new SgAsmCoffSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCoffSymbol;  
      SgAsmCoffSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCoffSymbolList ); 
     SgAsmCoffSymbolListStorageClass* storageArraySgAsmCoffSymbolList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCoffSymbolList = new SgAsmCoffSymbolListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCoffSymbolList) , sizeof ( SgAsmCoffSymbolListStorageClass ) * sizeOfActualPool) ;
        SgAsmCoffSymbolListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCoffSymbolListStorageClass* storageArray = storageArraySgAsmCoffSymbolList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCoffSymbolList ( *storageArray ) ; 
#else
               SgAsmCoffSymbolList* tmp = new SgAsmCoffSymbolList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCoffSymbolList;  
      SgAsmCoffSymbolListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCoffSymbolTable ); 
     SgAsmCoffSymbolTableStorageClass* storageArraySgAsmCoffSymbolTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCoffSymbolTable = new SgAsmCoffSymbolTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCoffSymbolTable) , sizeof ( SgAsmCoffSymbolTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCoffSymbolTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCoffSymbolTableStorageClass* storageArray = storageArraySgAsmCoffSymbolTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCoffSymbolTable ( *storageArray ) ; 
#else
               SgAsmCoffSymbolTable* tmp = new SgAsmCoffSymbolTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCoffSymbolTable;  
      SgAsmCoffSymbolTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCommonSubExpression ); 
     SgAsmCommonSubExpressionStorageClass* storageArraySgAsmCommonSubExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCommonSubExpression = new SgAsmCommonSubExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCommonSubExpression) , sizeof ( SgAsmCommonSubExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmCommonSubExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCommonSubExpressionStorageClass* storageArray = storageArraySgAsmCommonSubExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCommonSubExpression ( *storageArray ) ; 
#else
               SgAsmCommonSubExpression* tmp = new SgAsmCommonSubExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCommonSubExpression;  
      SgAsmCommonSubExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmControlFlagsExpression ); 
     SgAsmControlFlagsExpressionStorageClass* storageArraySgAsmControlFlagsExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmControlFlagsExpression = new SgAsmControlFlagsExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmControlFlagsExpression) , sizeof ( SgAsmControlFlagsExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmControlFlagsExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmControlFlagsExpressionStorageClass* storageArray = storageArraySgAsmControlFlagsExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmControlFlagsExpression ( *storageArray ) ; 
#else
               SgAsmControlFlagsExpression* tmp = new SgAsmControlFlagsExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmControlFlagsExpression;  
      SgAsmControlFlagsExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmConstantExpression ); 
     SgAsmConstantExpressionStorageClass* storageArraySgAsmConstantExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmConstantExpression = new SgAsmConstantExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmConstantExpression) , sizeof ( SgAsmConstantExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmConstantExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmConstantExpressionStorageClass* storageArray = storageArraySgAsmConstantExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmConstantExpression ( *storageArray ) ; 
#else
               SgAsmConstantExpression* tmp = new SgAsmConstantExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmConstantExpression;  
      SgAsmConstantExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDOSExtendedHeader ); 
     SgAsmDOSExtendedHeaderStorageClass* storageArraySgAsmDOSExtendedHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDOSExtendedHeader = new SgAsmDOSExtendedHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDOSExtendedHeader) , sizeof ( SgAsmDOSExtendedHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmDOSExtendedHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDOSExtendedHeaderStorageClass* storageArray = storageArraySgAsmDOSExtendedHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDOSExtendedHeader ( *storageArray ) ; 
#else
               SgAsmDOSExtendedHeader* tmp = new SgAsmDOSExtendedHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDOSExtendedHeader;  
      SgAsmDOSExtendedHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDOSFileHeader ); 
     SgAsmDOSFileHeaderStorageClass* storageArraySgAsmDOSFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDOSFileHeader = new SgAsmDOSFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDOSFileHeader) , sizeof ( SgAsmDOSFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmDOSFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDOSFileHeaderStorageClass* storageArray = storageArraySgAsmDOSFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDOSFileHeader ( *storageArray ) ; 
#else
               SgAsmDOSFileHeader* tmp = new SgAsmDOSFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDOSFileHeader;  
      SgAsmDOSFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmSynthesizedDataStructureDeclaration ); 
     SgAsmSynthesizedDataStructureDeclarationStorageClass* storageArraySgAsmSynthesizedDataStructureDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmSynthesizedDataStructureDeclaration = new SgAsmSynthesizedDataStructureDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmSynthesizedDataStructureDeclaration) , sizeof ( SgAsmSynthesizedDataStructureDeclarationStorageClass ) * sizeOfActualPool) ;
        SgAsmSynthesizedDataStructureDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmSynthesizedDataStructureDeclarationStorageClass* storageArray = storageArraySgAsmSynthesizedDataStructureDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmSynthesizedDataStructureDeclaration ( *storageArray ) ; 
#else
               SgAsmSynthesizedDataStructureDeclaration* tmp = new SgAsmSynthesizedDataStructureDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmSynthesizedDataStructureDeclaration;  
      SgAsmSynthesizedDataStructureDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmSynthesizedDeclaration ); 
     SgAsmSynthesizedDeclarationStorageClass* storageArraySgAsmSynthesizedDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmSynthesizedDeclaration = new SgAsmSynthesizedDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmSynthesizedDeclaration) , sizeof ( SgAsmSynthesizedDeclarationStorageClass ) * sizeOfActualPool) ;
        SgAsmSynthesizedDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmSynthesizedDeclarationStorageClass* storageArray = storageArraySgAsmSynthesizedDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmSynthesizedDeclaration ( *storageArray ) ; 
#else
               SgAsmSynthesizedDeclaration* tmp = new SgAsmSynthesizedDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmSynthesizedDeclaration;  
      SgAsmSynthesizedDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDirectRegisterExpression ); 
     SgAsmDirectRegisterExpressionStorageClass* storageArraySgAsmDirectRegisterExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDirectRegisterExpression = new SgAsmDirectRegisterExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDirectRegisterExpression) , sizeof ( SgAsmDirectRegisterExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmDirectRegisterExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDirectRegisterExpressionStorageClass* storageArray = storageArraySgAsmDirectRegisterExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDirectRegisterExpression ( *storageArray ) ; 
#else
               SgAsmDirectRegisterExpression* tmp = new SgAsmDirectRegisterExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDirectRegisterExpression;  
      SgAsmDirectRegisterExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfAccessDeclaration ); 
     SgAsmDwarfAccessDeclarationStorageClass* storageArraySgAsmDwarfAccessDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfAccessDeclaration = new SgAsmDwarfAccessDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfAccessDeclaration) , sizeof ( SgAsmDwarfAccessDeclarationStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfAccessDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfAccessDeclarationStorageClass* storageArray = storageArraySgAsmDwarfAccessDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfAccessDeclaration ( *storageArray ) ; 
#else
               SgAsmDwarfAccessDeclaration* tmp = new SgAsmDwarfAccessDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfAccessDeclaration;  
      SgAsmDwarfAccessDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfArrayType ); 
     SgAsmDwarfArrayTypeStorageClass* storageArraySgAsmDwarfArrayType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfArrayType = new SgAsmDwarfArrayTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfArrayType) , sizeof ( SgAsmDwarfArrayTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfArrayTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfArrayTypeStorageClass* storageArray = storageArraySgAsmDwarfArrayType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfArrayType ( *storageArray ) ; 
#else
               SgAsmDwarfArrayType* tmp = new SgAsmDwarfArrayType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfArrayType;  
      SgAsmDwarfArrayTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfBaseType ); 
     SgAsmDwarfBaseTypeStorageClass* storageArraySgAsmDwarfBaseType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfBaseType = new SgAsmDwarfBaseTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfBaseType) , sizeof ( SgAsmDwarfBaseTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfBaseTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfBaseTypeStorageClass* storageArray = storageArraySgAsmDwarfBaseType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfBaseType ( *storageArray ) ; 
#else
               SgAsmDwarfBaseType* tmp = new SgAsmDwarfBaseType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfBaseType;  
      SgAsmDwarfBaseTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCatchBlock ); 
     SgAsmDwarfCatchBlockStorageClass* storageArraySgAsmDwarfCatchBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCatchBlock = new SgAsmDwarfCatchBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCatchBlock) , sizeof ( SgAsmDwarfCatchBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCatchBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCatchBlockStorageClass* storageArray = storageArraySgAsmDwarfCatchBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfCatchBlock ( *storageArray ) ; 
#else
               SgAsmDwarfCatchBlock* tmp = new SgAsmDwarfCatchBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCatchBlock;  
      SgAsmDwarfCatchBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfClassTemplate ); 
     SgAsmDwarfClassTemplateStorageClass* storageArraySgAsmDwarfClassTemplate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfClassTemplate = new SgAsmDwarfClassTemplateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfClassTemplate) , sizeof ( SgAsmDwarfClassTemplateStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfClassTemplateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfClassTemplateStorageClass* storageArray = storageArraySgAsmDwarfClassTemplate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfClassTemplate ( *storageArray ) ; 
#else
               SgAsmDwarfClassTemplate* tmp = new SgAsmDwarfClassTemplate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfClassTemplate;  
      SgAsmDwarfClassTemplateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfClassType ); 
     SgAsmDwarfClassTypeStorageClass* storageArraySgAsmDwarfClassType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfClassType = new SgAsmDwarfClassTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfClassType) , sizeof ( SgAsmDwarfClassTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfClassTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfClassTypeStorageClass* storageArray = storageArraySgAsmDwarfClassType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfClassType ( *storageArray ) ; 
#else
               SgAsmDwarfClassType* tmp = new SgAsmDwarfClassType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfClassType;  
      SgAsmDwarfClassTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCommonBlock ); 
     SgAsmDwarfCommonBlockStorageClass* storageArraySgAsmDwarfCommonBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCommonBlock = new SgAsmDwarfCommonBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCommonBlock) , sizeof ( SgAsmDwarfCommonBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCommonBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCommonBlockStorageClass* storageArray = storageArraySgAsmDwarfCommonBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfCommonBlock ( *storageArray ) ; 
#else
               SgAsmDwarfCommonBlock* tmp = new SgAsmDwarfCommonBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCommonBlock;  
      SgAsmDwarfCommonBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCommonInclusion ); 
     SgAsmDwarfCommonInclusionStorageClass* storageArraySgAsmDwarfCommonInclusion = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCommonInclusion = new SgAsmDwarfCommonInclusionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCommonInclusion) , sizeof ( SgAsmDwarfCommonInclusionStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCommonInclusionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCommonInclusionStorageClass* storageArray = storageArraySgAsmDwarfCommonInclusion;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfCommonInclusion ( *storageArray ) ; 
#else
               SgAsmDwarfCommonInclusion* tmp = new SgAsmDwarfCommonInclusion ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCommonInclusion;  
      SgAsmDwarfCommonInclusionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCompilationUnit ); 
     SgAsmDwarfCompilationUnitStorageClass* storageArraySgAsmDwarfCompilationUnit = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCompilationUnit = new SgAsmDwarfCompilationUnitStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCompilationUnit) , sizeof ( SgAsmDwarfCompilationUnitStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCompilationUnitStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCompilationUnitStorageClass* storageArray = storageArraySgAsmDwarfCompilationUnit;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfCompilationUnit ( *storageArray ) ; 
#else
               SgAsmDwarfCompilationUnit* tmp = new SgAsmDwarfCompilationUnit ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCompilationUnit;  
      SgAsmDwarfCompilationUnitStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCompilationUnitList ); 
     SgAsmDwarfCompilationUnitListStorageClass* storageArraySgAsmDwarfCompilationUnitList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCompilationUnitList = new SgAsmDwarfCompilationUnitListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCompilationUnitList) , sizeof ( SgAsmDwarfCompilationUnitListStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCompilationUnitListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCompilationUnitListStorageClass* storageArray = storageArraySgAsmDwarfCompilationUnitList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfCompilationUnitList ( *storageArray ) ; 
#else
               SgAsmDwarfCompilationUnitList* tmp = new SgAsmDwarfCompilationUnitList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCompilationUnitList;  
      SgAsmDwarfCompilationUnitListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCondition ); 
     SgAsmDwarfConditionStorageClass* storageArraySgAsmDwarfCondition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCondition = new SgAsmDwarfConditionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCondition) , sizeof ( SgAsmDwarfConditionStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConditionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConditionStorageClass* storageArray = storageArraySgAsmDwarfCondition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfCondition ( *storageArray ) ; 
#else
               SgAsmDwarfCondition* tmp = new SgAsmDwarfCondition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCondition;  
      SgAsmDwarfConditionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfConstType ); 
     SgAsmDwarfConstTypeStorageClass* storageArraySgAsmDwarfConstType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfConstType = new SgAsmDwarfConstTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfConstType) , sizeof ( SgAsmDwarfConstTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConstTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConstTypeStorageClass* storageArray = storageArraySgAsmDwarfConstType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfConstType ( *storageArray ) ; 
#else
               SgAsmDwarfConstType* tmp = new SgAsmDwarfConstType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfConstType;  
      SgAsmDwarfConstTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfConstant ); 
     SgAsmDwarfConstantStorageClass* storageArraySgAsmDwarfConstant = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfConstant = new SgAsmDwarfConstantStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfConstant) , sizeof ( SgAsmDwarfConstantStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConstantStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConstantStorageClass* storageArray = storageArraySgAsmDwarfConstant;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfConstant ( *storageArray ) ; 
#else
               SgAsmDwarfConstant* tmp = new SgAsmDwarfConstant ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfConstant;  
      SgAsmDwarfConstantStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfConstruct ); 
     SgAsmDwarfConstructStorageClass* storageArraySgAsmDwarfConstruct = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfConstruct = new SgAsmDwarfConstructStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfConstruct) , sizeof ( SgAsmDwarfConstructStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConstructStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConstructStorageClass* storageArray = storageArraySgAsmDwarfConstruct;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfConstruct ( *storageArray ) ; 
#else
               SgAsmDwarfConstruct* tmp = new SgAsmDwarfConstruct ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfConstruct;  
      SgAsmDwarfConstructStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfConstructList ); 
     SgAsmDwarfConstructListStorageClass* storageArraySgAsmDwarfConstructList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfConstructList = new SgAsmDwarfConstructListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfConstructList) , sizeof ( SgAsmDwarfConstructListStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConstructListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConstructListStorageClass* storageArray = storageArraySgAsmDwarfConstructList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfConstructList ( *storageArray ) ; 
#else
               SgAsmDwarfConstructList* tmp = new SgAsmDwarfConstructList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfConstructList;  
      SgAsmDwarfConstructListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfDwarfProcedure ); 
     SgAsmDwarfDwarfProcedureStorageClass* storageArraySgAsmDwarfDwarfProcedure = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfDwarfProcedure = new SgAsmDwarfDwarfProcedureStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfDwarfProcedure) , sizeof ( SgAsmDwarfDwarfProcedureStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfDwarfProcedureStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfDwarfProcedureStorageClass* storageArray = storageArraySgAsmDwarfDwarfProcedure;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfDwarfProcedure ( *storageArray ) ; 
#else
               SgAsmDwarfDwarfProcedure* tmp = new SgAsmDwarfDwarfProcedure ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfDwarfProcedure;  
      SgAsmDwarfDwarfProcedureStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfEntryPoint ); 
     SgAsmDwarfEntryPointStorageClass* storageArraySgAsmDwarfEntryPoint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfEntryPoint = new SgAsmDwarfEntryPointStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfEntryPoint) , sizeof ( SgAsmDwarfEntryPointStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfEntryPointStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfEntryPointStorageClass* storageArray = storageArraySgAsmDwarfEntryPoint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfEntryPoint ( *storageArray ) ; 
#else
               SgAsmDwarfEntryPoint* tmp = new SgAsmDwarfEntryPoint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfEntryPoint;  
      SgAsmDwarfEntryPointStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfEnumerationType ); 
     SgAsmDwarfEnumerationTypeStorageClass* storageArraySgAsmDwarfEnumerationType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfEnumerationType = new SgAsmDwarfEnumerationTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfEnumerationType) , sizeof ( SgAsmDwarfEnumerationTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfEnumerationTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfEnumerationTypeStorageClass* storageArray = storageArraySgAsmDwarfEnumerationType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfEnumerationType ( *storageArray ) ; 
#else
               SgAsmDwarfEnumerationType* tmp = new SgAsmDwarfEnumerationType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfEnumerationType;  
      SgAsmDwarfEnumerationTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfEnumerator ); 
     SgAsmDwarfEnumeratorStorageClass* storageArraySgAsmDwarfEnumerator = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfEnumerator = new SgAsmDwarfEnumeratorStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfEnumerator) , sizeof ( SgAsmDwarfEnumeratorStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfEnumeratorStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfEnumeratorStorageClass* storageArray = storageArraySgAsmDwarfEnumerator;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfEnumerator ( *storageArray ) ; 
#else
               SgAsmDwarfEnumerator* tmp = new SgAsmDwarfEnumerator ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfEnumerator;  
      SgAsmDwarfEnumeratorStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFileType ); 
     SgAsmDwarfFileTypeStorageClass* storageArraySgAsmDwarfFileType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFileType = new SgAsmDwarfFileTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFileType) , sizeof ( SgAsmDwarfFileTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFileTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFileTypeStorageClass* storageArray = storageArraySgAsmDwarfFileType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfFileType ( *storageArray ) ; 
#else
               SgAsmDwarfFileType* tmp = new SgAsmDwarfFileType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFileType;  
      SgAsmDwarfFileTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFormalParameter ); 
     SgAsmDwarfFormalParameterStorageClass* storageArraySgAsmDwarfFormalParameter = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFormalParameter = new SgAsmDwarfFormalParameterStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFormalParameter) , sizeof ( SgAsmDwarfFormalParameterStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFormalParameterStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFormalParameterStorageClass* storageArray = storageArraySgAsmDwarfFormalParameter;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfFormalParameter ( *storageArray ) ; 
#else
               SgAsmDwarfFormalParameter* tmp = new SgAsmDwarfFormalParameter ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFormalParameter;  
      SgAsmDwarfFormalParameterStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFormatLabel ); 
     SgAsmDwarfFormatLabelStorageClass* storageArraySgAsmDwarfFormatLabel = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFormatLabel = new SgAsmDwarfFormatLabelStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFormatLabel) , sizeof ( SgAsmDwarfFormatLabelStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFormatLabelStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFormatLabelStorageClass* storageArray = storageArraySgAsmDwarfFormatLabel;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfFormatLabel ( *storageArray ) ; 
#else
               SgAsmDwarfFormatLabel* tmp = new SgAsmDwarfFormatLabel ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFormatLabel;  
      SgAsmDwarfFormatLabelStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFriend ); 
     SgAsmDwarfFriendStorageClass* storageArraySgAsmDwarfFriend = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFriend = new SgAsmDwarfFriendStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFriend) , sizeof ( SgAsmDwarfFriendStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFriendStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFriendStorageClass* storageArray = storageArraySgAsmDwarfFriend;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfFriend ( *storageArray ) ; 
#else
               SgAsmDwarfFriend* tmp = new SgAsmDwarfFriend ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFriend;  
      SgAsmDwarfFriendStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFunctionTemplate ); 
     SgAsmDwarfFunctionTemplateStorageClass* storageArraySgAsmDwarfFunctionTemplate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFunctionTemplate = new SgAsmDwarfFunctionTemplateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFunctionTemplate) , sizeof ( SgAsmDwarfFunctionTemplateStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFunctionTemplateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFunctionTemplateStorageClass* storageArray = storageArraySgAsmDwarfFunctionTemplate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfFunctionTemplate ( *storageArray ) ; 
#else
               SgAsmDwarfFunctionTemplate* tmp = new SgAsmDwarfFunctionTemplate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFunctionTemplate;  
      SgAsmDwarfFunctionTemplateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfImportedDeclaration ); 
     SgAsmDwarfImportedDeclarationStorageClass* storageArraySgAsmDwarfImportedDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfImportedDeclaration = new SgAsmDwarfImportedDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfImportedDeclaration) , sizeof ( SgAsmDwarfImportedDeclarationStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfImportedDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfImportedDeclarationStorageClass* storageArray = storageArraySgAsmDwarfImportedDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfImportedDeclaration ( *storageArray ) ; 
#else
               SgAsmDwarfImportedDeclaration* tmp = new SgAsmDwarfImportedDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfImportedDeclaration;  
      SgAsmDwarfImportedDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfImportedModule ); 
     SgAsmDwarfImportedModuleStorageClass* storageArraySgAsmDwarfImportedModule = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfImportedModule = new SgAsmDwarfImportedModuleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfImportedModule) , sizeof ( SgAsmDwarfImportedModuleStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfImportedModuleStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfImportedModuleStorageClass* storageArray = storageArraySgAsmDwarfImportedModule;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfImportedModule ( *storageArray ) ; 
#else
               SgAsmDwarfImportedModule* tmp = new SgAsmDwarfImportedModule ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfImportedModule;  
      SgAsmDwarfImportedModuleStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfImportedUnit ); 
     SgAsmDwarfImportedUnitStorageClass* storageArraySgAsmDwarfImportedUnit = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfImportedUnit = new SgAsmDwarfImportedUnitStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfImportedUnit) , sizeof ( SgAsmDwarfImportedUnitStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfImportedUnitStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfImportedUnitStorageClass* storageArray = storageArraySgAsmDwarfImportedUnit;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfImportedUnit ( *storageArray ) ; 
#else
               SgAsmDwarfImportedUnit* tmp = new SgAsmDwarfImportedUnit ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfImportedUnit;  
      SgAsmDwarfImportedUnitStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfInformation ); 
     SgAsmDwarfInformationStorageClass* storageArraySgAsmDwarfInformation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfInformation = new SgAsmDwarfInformationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfInformation) , sizeof ( SgAsmDwarfInformationStorageClass ) * sizeOfActualPool) ;
          SgAsmDwarfInformationStorageClass* storageArray = storageArraySgAsmDwarfInformation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfInformation ( *storageArray ) ; 
#else
               SgAsmDwarfInformation* tmp = new SgAsmDwarfInformation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfInformation;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfInheritance ); 
     SgAsmDwarfInheritanceStorageClass* storageArraySgAsmDwarfInheritance = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfInheritance = new SgAsmDwarfInheritanceStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfInheritance) , sizeof ( SgAsmDwarfInheritanceStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfInheritanceStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfInheritanceStorageClass* storageArray = storageArraySgAsmDwarfInheritance;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfInheritance ( *storageArray ) ; 
#else
               SgAsmDwarfInheritance* tmp = new SgAsmDwarfInheritance ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfInheritance;  
      SgAsmDwarfInheritanceStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfInlinedSubroutine ); 
     SgAsmDwarfInlinedSubroutineStorageClass* storageArraySgAsmDwarfInlinedSubroutine = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfInlinedSubroutine = new SgAsmDwarfInlinedSubroutineStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfInlinedSubroutine) , sizeof ( SgAsmDwarfInlinedSubroutineStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfInlinedSubroutineStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfInlinedSubroutineStorageClass* storageArray = storageArraySgAsmDwarfInlinedSubroutine;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfInlinedSubroutine ( *storageArray ) ; 
#else
               SgAsmDwarfInlinedSubroutine* tmp = new SgAsmDwarfInlinedSubroutine ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfInlinedSubroutine;  
      SgAsmDwarfInlinedSubroutineStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfInterfaceType ); 
     SgAsmDwarfInterfaceTypeStorageClass* storageArraySgAsmDwarfInterfaceType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfInterfaceType = new SgAsmDwarfInterfaceTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfInterfaceType) , sizeof ( SgAsmDwarfInterfaceTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfInterfaceTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfInterfaceTypeStorageClass* storageArray = storageArraySgAsmDwarfInterfaceType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfInterfaceType ( *storageArray ) ; 
#else
               SgAsmDwarfInterfaceType* tmp = new SgAsmDwarfInterfaceType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfInterfaceType;  
      SgAsmDwarfInterfaceTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfLabel ); 
     SgAsmDwarfLabelStorageClass* storageArraySgAsmDwarfLabel = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfLabel = new SgAsmDwarfLabelStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfLabel) , sizeof ( SgAsmDwarfLabelStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfLabelStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfLabelStorageClass* storageArray = storageArraySgAsmDwarfLabel;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfLabel ( *storageArray ) ; 
#else
               SgAsmDwarfLabel* tmp = new SgAsmDwarfLabel ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfLabel;  
      SgAsmDwarfLabelStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfLexicalBlock ); 
     SgAsmDwarfLexicalBlockStorageClass* storageArraySgAsmDwarfLexicalBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfLexicalBlock = new SgAsmDwarfLexicalBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfLexicalBlock) , sizeof ( SgAsmDwarfLexicalBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfLexicalBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfLexicalBlockStorageClass* storageArray = storageArraySgAsmDwarfLexicalBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfLexicalBlock ( *storageArray ) ; 
#else
               SgAsmDwarfLexicalBlock* tmp = new SgAsmDwarfLexicalBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfLexicalBlock;  
      SgAsmDwarfLexicalBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfLine ); 
     SgAsmDwarfLineStorageClass* storageArraySgAsmDwarfLine = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfLine = new SgAsmDwarfLineStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfLine) , sizeof ( SgAsmDwarfLineStorageClass ) * sizeOfActualPool) ;
          SgAsmDwarfLineStorageClass* storageArray = storageArraySgAsmDwarfLine;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfLine ( *storageArray ) ; 
#else
               SgAsmDwarfLine* tmp = new SgAsmDwarfLine ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfLine;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfLineList ); 
     SgAsmDwarfLineListStorageClass* storageArraySgAsmDwarfLineList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfLineList = new SgAsmDwarfLineListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfLineList) , sizeof ( SgAsmDwarfLineListStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfLineListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfLineListStorageClass* storageArray = storageArraySgAsmDwarfLineList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfLineList ( *storageArray ) ; 
#else
               SgAsmDwarfLineList* tmp = new SgAsmDwarfLineList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfLineList;  
      SgAsmDwarfLineListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfMacro ); 
     SgAsmDwarfMacroStorageClass* storageArraySgAsmDwarfMacro = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfMacro = new SgAsmDwarfMacroStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfMacro) , sizeof ( SgAsmDwarfMacroStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfMacroStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfMacroStorageClass* storageArray = storageArraySgAsmDwarfMacro;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfMacro ( *storageArray ) ; 
#else
               SgAsmDwarfMacro* tmp = new SgAsmDwarfMacro ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfMacro;  
      SgAsmDwarfMacroStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfMacroList ); 
     SgAsmDwarfMacroListStorageClass* storageArraySgAsmDwarfMacroList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfMacroList = new SgAsmDwarfMacroListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfMacroList) , sizeof ( SgAsmDwarfMacroListStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfMacroListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfMacroListStorageClass* storageArray = storageArraySgAsmDwarfMacroList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfMacroList ( *storageArray ) ; 
#else
               SgAsmDwarfMacroList* tmp = new SgAsmDwarfMacroList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfMacroList;  
      SgAsmDwarfMacroListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfMember ); 
     SgAsmDwarfMemberStorageClass* storageArraySgAsmDwarfMember = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfMember = new SgAsmDwarfMemberStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfMember) , sizeof ( SgAsmDwarfMemberStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfMemberStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfMemberStorageClass* storageArray = storageArraySgAsmDwarfMember;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfMember ( *storageArray ) ; 
#else
               SgAsmDwarfMember* tmp = new SgAsmDwarfMember ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfMember;  
      SgAsmDwarfMemberStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfModule ); 
     SgAsmDwarfModuleStorageClass* storageArraySgAsmDwarfModule = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfModule = new SgAsmDwarfModuleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfModule) , sizeof ( SgAsmDwarfModuleStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfModuleStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfModuleStorageClass* storageArray = storageArraySgAsmDwarfModule;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfModule ( *storageArray ) ; 
#else
               SgAsmDwarfModule* tmp = new SgAsmDwarfModule ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfModule;  
      SgAsmDwarfModuleStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfMutableType ); 
     SgAsmDwarfMutableTypeStorageClass* storageArraySgAsmDwarfMutableType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfMutableType = new SgAsmDwarfMutableTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfMutableType) , sizeof ( SgAsmDwarfMutableTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfMutableTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfMutableTypeStorageClass* storageArray = storageArraySgAsmDwarfMutableType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfMutableType ( *storageArray ) ; 
#else
               SgAsmDwarfMutableType* tmp = new SgAsmDwarfMutableType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfMutableType;  
      SgAsmDwarfMutableTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfNamelist ); 
     SgAsmDwarfNamelistStorageClass* storageArraySgAsmDwarfNamelist = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfNamelist = new SgAsmDwarfNamelistStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfNamelist) , sizeof ( SgAsmDwarfNamelistStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfNamelistStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfNamelistStorageClass* storageArray = storageArraySgAsmDwarfNamelist;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfNamelist ( *storageArray ) ; 
#else
               SgAsmDwarfNamelist* tmp = new SgAsmDwarfNamelist ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfNamelist;  
      SgAsmDwarfNamelistStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfNamelistItem ); 
     SgAsmDwarfNamelistItemStorageClass* storageArraySgAsmDwarfNamelistItem = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfNamelistItem = new SgAsmDwarfNamelistItemStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfNamelistItem) , sizeof ( SgAsmDwarfNamelistItemStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfNamelistItemStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfNamelistItemStorageClass* storageArray = storageArraySgAsmDwarfNamelistItem;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfNamelistItem ( *storageArray ) ; 
#else
               SgAsmDwarfNamelistItem* tmp = new SgAsmDwarfNamelistItem ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfNamelistItem;  
      SgAsmDwarfNamelistItemStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfNamespace ); 
     SgAsmDwarfNamespaceStorageClass* storageArraySgAsmDwarfNamespace = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfNamespace = new SgAsmDwarfNamespaceStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfNamespace) , sizeof ( SgAsmDwarfNamespaceStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfNamespaceStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfNamespaceStorageClass* storageArray = storageArraySgAsmDwarfNamespace;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfNamespace ( *storageArray ) ; 
#else
               SgAsmDwarfNamespace* tmp = new SgAsmDwarfNamespace ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfNamespace;  
      SgAsmDwarfNamespaceStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfPackedType ); 
     SgAsmDwarfPackedTypeStorageClass* storageArraySgAsmDwarfPackedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfPackedType = new SgAsmDwarfPackedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfPackedType) , sizeof ( SgAsmDwarfPackedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfPackedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfPackedTypeStorageClass* storageArray = storageArraySgAsmDwarfPackedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfPackedType ( *storageArray ) ; 
#else
               SgAsmDwarfPackedType* tmp = new SgAsmDwarfPackedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfPackedType;  
      SgAsmDwarfPackedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfPartialUnit ); 
     SgAsmDwarfPartialUnitStorageClass* storageArraySgAsmDwarfPartialUnit = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfPartialUnit = new SgAsmDwarfPartialUnitStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfPartialUnit) , sizeof ( SgAsmDwarfPartialUnitStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfPartialUnitStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfPartialUnitStorageClass* storageArray = storageArraySgAsmDwarfPartialUnit;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfPartialUnit ( *storageArray ) ; 
#else
               SgAsmDwarfPartialUnit* tmp = new SgAsmDwarfPartialUnit ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfPartialUnit;  
      SgAsmDwarfPartialUnitStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfPointerType ); 
     SgAsmDwarfPointerTypeStorageClass* storageArraySgAsmDwarfPointerType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfPointerType = new SgAsmDwarfPointerTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfPointerType) , sizeof ( SgAsmDwarfPointerTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfPointerTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfPointerTypeStorageClass* storageArray = storageArraySgAsmDwarfPointerType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfPointerType ( *storageArray ) ; 
#else
               SgAsmDwarfPointerType* tmp = new SgAsmDwarfPointerType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfPointerType;  
      SgAsmDwarfPointerTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfPtrToMemberType ); 
     SgAsmDwarfPtrToMemberTypeStorageClass* storageArraySgAsmDwarfPtrToMemberType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfPtrToMemberType = new SgAsmDwarfPtrToMemberTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfPtrToMemberType) , sizeof ( SgAsmDwarfPtrToMemberTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfPtrToMemberTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfPtrToMemberTypeStorageClass* storageArray = storageArraySgAsmDwarfPtrToMemberType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfPtrToMemberType ( *storageArray ) ; 
#else
               SgAsmDwarfPtrToMemberType* tmp = new SgAsmDwarfPtrToMemberType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfPtrToMemberType;  
      SgAsmDwarfPtrToMemberTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfReferenceType ); 
     SgAsmDwarfReferenceTypeStorageClass* storageArraySgAsmDwarfReferenceType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfReferenceType = new SgAsmDwarfReferenceTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfReferenceType) , sizeof ( SgAsmDwarfReferenceTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfReferenceTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfReferenceTypeStorageClass* storageArray = storageArraySgAsmDwarfReferenceType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfReferenceType ( *storageArray ) ; 
#else
               SgAsmDwarfReferenceType* tmp = new SgAsmDwarfReferenceType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfReferenceType;  
      SgAsmDwarfReferenceTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfRestrictType ); 
     SgAsmDwarfRestrictTypeStorageClass* storageArraySgAsmDwarfRestrictType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfRestrictType = new SgAsmDwarfRestrictTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfRestrictType) , sizeof ( SgAsmDwarfRestrictTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfRestrictTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfRestrictTypeStorageClass* storageArray = storageArraySgAsmDwarfRestrictType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfRestrictType ( *storageArray ) ; 
#else
               SgAsmDwarfRestrictType* tmp = new SgAsmDwarfRestrictType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfRestrictType;  
      SgAsmDwarfRestrictTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSetType ); 
     SgAsmDwarfSetTypeStorageClass* storageArraySgAsmDwarfSetType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSetType = new SgAsmDwarfSetTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSetType) , sizeof ( SgAsmDwarfSetTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSetTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSetTypeStorageClass* storageArray = storageArraySgAsmDwarfSetType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfSetType ( *storageArray ) ; 
#else
               SgAsmDwarfSetType* tmp = new SgAsmDwarfSetType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSetType;  
      SgAsmDwarfSetTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSharedType ); 
     SgAsmDwarfSharedTypeStorageClass* storageArraySgAsmDwarfSharedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSharedType = new SgAsmDwarfSharedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSharedType) , sizeof ( SgAsmDwarfSharedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSharedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSharedTypeStorageClass* storageArray = storageArraySgAsmDwarfSharedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfSharedType ( *storageArray ) ; 
#else
               SgAsmDwarfSharedType* tmp = new SgAsmDwarfSharedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSharedType;  
      SgAsmDwarfSharedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfStringType ); 
     SgAsmDwarfStringTypeStorageClass* storageArraySgAsmDwarfStringType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfStringType = new SgAsmDwarfStringTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfStringType) , sizeof ( SgAsmDwarfStringTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfStringTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfStringTypeStorageClass* storageArray = storageArraySgAsmDwarfStringType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfStringType ( *storageArray ) ; 
#else
               SgAsmDwarfStringType* tmp = new SgAsmDwarfStringType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfStringType;  
      SgAsmDwarfStringTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfStructureType ); 
     SgAsmDwarfStructureTypeStorageClass* storageArraySgAsmDwarfStructureType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfStructureType = new SgAsmDwarfStructureTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfStructureType) , sizeof ( SgAsmDwarfStructureTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfStructureTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfStructureTypeStorageClass* storageArray = storageArraySgAsmDwarfStructureType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfStructureType ( *storageArray ) ; 
#else
               SgAsmDwarfStructureType* tmp = new SgAsmDwarfStructureType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfStructureType;  
      SgAsmDwarfStructureTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSubprogram ); 
     SgAsmDwarfSubprogramStorageClass* storageArraySgAsmDwarfSubprogram = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSubprogram = new SgAsmDwarfSubprogramStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSubprogram) , sizeof ( SgAsmDwarfSubprogramStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSubprogramStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSubprogramStorageClass* storageArray = storageArraySgAsmDwarfSubprogram;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfSubprogram ( *storageArray ) ; 
#else
               SgAsmDwarfSubprogram* tmp = new SgAsmDwarfSubprogram ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSubprogram;  
      SgAsmDwarfSubprogramStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSubrangeType ); 
     SgAsmDwarfSubrangeTypeStorageClass* storageArraySgAsmDwarfSubrangeType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSubrangeType = new SgAsmDwarfSubrangeTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSubrangeType) , sizeof ( SgAsmDwarfSubrangeTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSubrangeTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSubrangeTypeStorageClass* storageArray = storageArraySgAsmDwarfSubrangeType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfSubrangeType ( *storageArray ) ; 
#else
               SgAsmDwarfSubrangeType* tmp = new SgAsmDwarfSubrangeType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSubrangeType;  
      SgAsmDwarfSubrangeTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSubroutineType ); 
     SgAsmDwarfSubroutineTypeStorageClass* storageArraySgAsmDwarfSubroutineType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSubroutineType = new SgAsmDwarfSubroutineTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSubroutineType) , sizeof ( SgAsmDwarfSubroutineTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSubroutineTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSubroutineTypeStorageClass* storageArray = storageArraySgAsmDwarfSubroutineType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfSubroutineType ( *storageArray ) ; 
#else
               SgAsmDwarfSubroutineType* tmp = new SgAsmDwarfSubroutineType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSubroutineType;  
      SgAsmDwarfSubroutineTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfTemplateTypeParameter ); 
     SgAsmDwarfTemplateTypeParameterStorageClass* storageArraySgAsmDwarfTemplateTypeParameter = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfTemplateTypeParameter = new SgAsmDwarfTemplateTypeParameterStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfTemplateTypeParameter) , sizeof ( SgAsmDwarfTemplateTypeParameterStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfTemplateTypeParameterStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfTemplateTypeParameterStorageClass* storageArray = storageArraySgAsmDwarfTemplateTypeParameter;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfTemplateTypeParameter ( *storageArray ) ; 
#else
               SgAsmDwarfTemplateTypeParameter* tmp = new SgAsmDwarfTemplateTypeParameter ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfTemplateTypeParameter;  
      SgAsmDwarfTemplateTypeParameterStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfTemplateValueParameter ); 
     SgAsmDwarfTemplateValueParameterStorageClass* storageArraySgAsmDwarfTemplateValueParameter = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfTemplateValueParameter = new SgAsmDwarfTemplateValueParameterStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfTemplateValueParameter) , sizeof ( SgAsmDwarfTemplateValueParameterStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfTemplateValueParameterStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfTemplateValueParameterStorageClass* storageArray = storageArraySgAsmDwarfTemplateValueParameter;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfTemplateValueParameter ( *storageArray ) ; 
#else
               SgAsmDwarfTemplateValueParameter* tmp = new SgAsmDwarfTemplateValueParameter ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfTemplateValueParameter;  
      SgAsmDwarfTemplateValueParameterStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfThrownType ); 
     SgAsmDwarfThrownTypeStorageClass* storageArraySgAsmDwarfThrownType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfThrownType = new SgAsmDwarfThrownTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfThrownType) , sizeof ( SgAsmDwarfThrownTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfThrownTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfThrownTypeStorageClass* storageArray = storageArraySgAsmDwarfThrownType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfThrownType ( *storageArray ) ; 
#else
               SgAsmDwarfThrownType* tmp = new SgAsmDwarfThrownType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfThrownType;  
      SgAsmDwarfThrownTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfTryBlock ); 
     SgAsmDwarfTryBlockStorageClass* storageArraySgAsmDwarfTryBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfTryBlock = new SgAsmDwarfTryBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfTryBlock) , sizeof ( SgAsmDwarfTryBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfTryBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfTryBlockStorageClass* storageArray = storageArraySgAsmDwarfTryBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfTryBlock ( *storageArray ) ; 
#else
               SgAsmDwarfTryBlock* tmp = new SgAsmDwarfTryBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfTryBlock;  
      SgAsmDwarfTryBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfTypedef ); 
     SgAsmDwarfTypedefStorageClass* storageArraySgAsmDwarfTypedef = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfTypedef = new SgAsmDwarfTypedefStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfTypedef) , sizeof ( SgAsmDwarfTypedefStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfTypedefStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfTypedefStorageClass* storageArray = storageArraySgAsmDwarfTypedef;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfTypedef ( *storageArray ) ; 
#else
               SgAsmDwarfTypedef* tmp = new SgAsmDwarfTypedef ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfTypedef;  
      SgAsmDwarfTypedefStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUnionType ); 
     SgAsmDwarfUnionTypeStorageClass* storageArraySgAsmDwarfUnionType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUnionType = new SgAsmDwarfUnionTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUnionType) , sizeof ( SgAsmDwarfUnionTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUnionTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUnionTypeStorageClass* storageArray = storageArraySgAsmDwarfUnionType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfUnionType ( *storageArray ) ; 
#else
               SgAsmDwarfUnionType* tmp = new SgAsmDwarfUnionType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUnionType;  
      SgAsmDwarfUnionTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUnknownConstruct ); 
     SgAsmDwarfUnknownConstructStorageClass* storageArraySgAsmDwarfUnknownConstruct = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUnknownConstruct = new SgAsmDwarfUnknownConstructStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUnknownConstruct) , sizeof ( SgAsmDwarfUnknownConstructStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUnknownConstructStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUnknownConstructStorageClass* storageArray = storageArraySgAsmDwarfUnknownConstruct;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfUnknownConstruct ( *storageArray ) ; 
#else
               SgAsmDwarfUnknownConstruct* tmp = new SgAsmDwarfUnknownConstruct ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUnknownConstruct;  
      SgAsmDwarfUnknownConstructStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUnspecifiedParameters ); 
     SgAsmDwarfUnspecifiedParametersStorageClass* storageArraySgAsmDwarfUnspecifiedParameters = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUnspecifiedParameters = new SgAsmDwarfUnspecifiedParametersStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUnspecifiedParameters) , sizeof ( SgAsmDwarfUnspecifiedParametersStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUnspecifiedParametersStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUnspecifiedParametersStorageClass* storageArray = storageArraySgAsmDwarfUnspecifiedParameters;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfUnspecifiedParameters ( *storageArray ) ; 
#else
               SgAsmDwarfUnspecifiedParameters* tmp = new SgAsmDwarfUnspecifiedParameters ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUnspecifiedParameters;  
      SgAsmDwarfUnspecifiedParametersStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUnspecifiedType ); 
     SgAsmDwarfUnspecifiedTypeStorageClass* storageArraySgAsmDwarfUnspecifiedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUnspecifiedType = new SgAsmDwarfUnspecifiedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUnspecifiedType) , sizeof ( SgAsmDwarfUnspecifiedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUnspecifiedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUnspecifiedTypeStorageClass* storageArray = storageArraySgAsmDwarfUnspecifiedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfUnspecifiedType ( *storageArray ) ; 
#else
               SgAsmDwarfUnspecifiedType* tmp = new SgAsmDwarfUnspecifiedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUnspecifiedType;  
      SgAsmDwarfUnspecifiedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUpcRelaxedType ); 
     SgAsmDwarfUpcRelaxedTypeStorageClass* storageArraySgAsmDwarfUpcRelaxedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUpcRelaxedType = new SgAsmDwarfUpcRelaxedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUpcRelaxedType) , sizeof ( SgAsmDwarfUpcRelaxedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUpcRelaxedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUpcRelaxedTypeStorageClass* storageArray = storageArraySgAsmDwarfUpcRelaxedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfUpcRelaxedType ( *storageArray ) ; 
#else
               SgAsmDwarfUpcRelaxedType* tmp = new SgAsmDwarfUpcRelaxedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUpcRelaxedType;  
      SgAsmDwarfUpcRelaxedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUpcSharedType ); 
     SgAsmDwarfUpcSharedTypeStorageClass* storageArraySgAsmDwarfUpcSharedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUpcSharedType = new SgAsmDwarfUpcSharedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUpcSharedType) , sizeof ( SgAsmDwarfUpcSharedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUpcSharedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUpcSharedTypeStorageClass* storageArray = storageArraySgAsmDwarfUpcSharedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfUpcSharedType ( *storageArray ) ; 
#else
               SgAsmDwarfUpcSharedType* tmp = new SgAsmDwarfUpcSharedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUpcSharedType;  
      SgAsmDwarfUpcSharedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUpcStrictType ); 
     SgAsmDwarfUpcStrictTypeStorageClass* storageArraySgAsmDwarfUpcStrictType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUpcStrictType = new SgAsmDwarfUpcStrictTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUpcStrictType) , sizeof ( SgAsmDwarfUpcStrictTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUpcStrictTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUpcStrictTypeStorageClass* storageArray = storageArraySgAsmDwarfUpcStrictType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfUpcStrictType ( *storageArray ) ; 
#else
               SgAsmDwarfUpcStrictType* tmp = new SgAsmDwarfUpcStrictType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUpcStrictType;  
      SgAsmDwarfUpcStrictTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfVariable ); 
     SgAsmDwarfVariableStorageClass* storageArraySgAsmDwarfVariable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfVariable = new SgAsmDwarfVariableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfVariable) , sizeof ( SgAsmDwarfVariableStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfVariableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfVariableStorageClass* storageArray = storageArraySgAsmDwarfVariable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfVariable ( *storageArray ) ; 
#else
               SgAsmDwarfVariable* tmp = new SgAsmDwarfVariable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfVariable;  
      SgAsmDwarfVariableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfVariant ); 
     SgAsmDwarfVariantStorageClass* storageArraySgAsmDwarfVariant = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfVariant = new SgAsmDwarfVariantStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfVariant) , sizeof ( SgAsmDwarfVariantStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfVariantStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfVariantStorageClass* storageArray = storageArraySgAsmDwarfVariant;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfVariant ( *storageArray ) ; 
#else
               SgAsmDwarfVariant* tmp = new SgAsmDwarfVariant ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfVariant;  
      SgAsmDwarfVariantStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfVariantPart ); 
     SgAsmDwarfVariantPartStorageClass* storageArraySgAsmDwarfVariantPart = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfVariantPart = new SgAsmDwarfVariantPartStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfVariantPart) , sizeof ( SgAsmDwarfVariantPartStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfVariantPartStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfVariantPartStorageClass* storageArray = storageArraySgAsmDwarfVariantPart;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfVariantPart ( *storageArray ) ; 
#else
               SgAsmDwarfVariantPart* tmp = new SgAsmDwarfVariantPart ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfVariantPart;  
      SgAsmDwarfVariantPartStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfVolatileType ); 
     SgAsmDwarfVolatileTypeStorageClass* storageArraySgAsmDwarfVolatileType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfVolatileType = new SgAsmDwarfVolatileTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfVolatileType) , sizeof ( SgAsmDwarfVolatileTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfVolatileTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfVolatileTypeStorageClass* storageArray = storageArraySgAsmDwarfVolatileType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfVolatileType ( *storageArray ) ; 
#else
               SgAsmDwarfVolatileType* tmp = new SgAsmDwarfVolatileType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfVolatileType;  
      SgAsmDwarfVolatileTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfWithStmt ); 
     SgAsmDwarfWithStmtStorageClass* storageArraySgAsmDwarfWithStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfWithStmt = new SgAsmDwarfWithStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfWithStmt) , sizeof ( SgAsmDwarfWithStmtStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfWithStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfWithStmtStorageClass* storageArray = storageArraySgAsmDwarfWithStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmDwarfWithStmt ( *storageArray ) ; 
#else
               SgAsmDwarfWithStmt* tmp = new SgAsmDwarfWithStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfWithStmt;  
      SgAsmDwarfWithStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfDynamicEntry ); 
     SgAsmElfDynamicEntryStorageClass* storageArraySgAsmElfDynamicEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfDynamicEntry = new SgAsmElfDynamicEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfDynamicEntry) , sizeof ( SgAsmElfDynamicEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfDynamicEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfDynamicEntryStorageClass* storageArray = storageArraySgAsmElfDynamicEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfDynamicEntry ( *storageArray ) ; 
#else
               SgAsmElfDynamicEntry* tmp = new SgAsmElfDynamicEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfDynamicEntry;  
      SgAsmElfDynamicEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfDynamicEntryList ); 
     SgAsmElfDynamicEntryListStorageClass* storageArraySgAsmElfDynamicEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfDynamicEntryList = new SgAsmElfDynamicEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfDynamicEntryList) , sizeof ( SgAsmElfDynamicEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfDynamicEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfDynamicEntryListStorageClass* storageArray = storageArraySgAsmElfDynamicEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfDynamicEntryList ( *storageArray ) ; 
#else
               SgAsmElfDynamicEntryList* tmp = new SgAsmElfDynamicEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfDynamicEntryList;  
      SgAsmElfDynamicEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfDynamicSection ); 
     SgAsmElfDynamicSectionStorageClass* storageArraySgAsmElfDynamicSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfDynamicSection = new SgAsmElfDynamicSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfDynamicSection) , sizeof ( SgAsmElfDynamicSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfDynamicSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfDynamicSectionStorageClass* storageArray = storageArraySgAsmElfDynamicSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfDynamicSection ( *storageArray ) ; 
#else
               SgAsmElfDynamicSection* tmp = new SgAsmElfDynamicSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfDynamicSection;  
      SgAsmElfDynamicSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameEntryCI ); 
     SgAsmElfEHFrameEntryCIStorageClass* storageArraySgAsmElfEHFrameEntryCI = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameEntryCI = new SgAsmElfEHFrameEntryCIStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameEntryCI) , sizeof ( SgAsmElfEHFrameEntryCIStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameEntryCIStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameEntryCIStorageClass* storageArray = storageArraySgAsmElfEHFrameEntryCI;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfEHFrameEntryCI ( *storageArray ) ; 
#else
               SgAsmElfEHFrameEntryCI* tmp = new SgAsmElfEHFrameEntryCI ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameEntryCI;  
      SgAsmElfEHFrameEntryCIStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameEntryCIList ); 
     SgAsmElfEHFrameEntryCIListStorageClass* storageArraySgAsmElfEHFrameEntryCIList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameEntryCIList = new SgAsmElfEHFrameEntryCIListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameEntryCIList) , sizeof ( SgAsmElfEHFrameEntryCIListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameEntryCIListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameEntryCIListStorageClass* storageArray = storageArraySgAsmElfEHFrameEntryCIList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfEHFrameEntryCIList ( *storageArray ) ; 
#else
               SgAsmElfEHFrameEntryCIList* tmp = new SgAsmElfEHFrameEntryCIList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameEntryCIList;  
      SgAsmElfEHFrameEntryCIListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameEntryFD ); 
     SgAsmElfEHFrameEntryFDStorageClass* storageArraySgAsmElfEHFrameEntryFD = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameEntryFD = new SgAsmElfEHFrameEntryFDStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameEntryFD) , sizeof ( SgAsmElfEHFrameEntryFDStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameEntryFDStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameEntryFDStorageClass* storageArray = storageArraySgAsmElfEHFrameEntryFD;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfEHFrameEntryFD ( *storageArray ) ; 
#else
               SgAsmElfEHFrameEntryFD* tmp = new SgAsmElfEHFrameEntryFD ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameEntryFD;  
      SgAsmElfEHFrameEntryFDStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameEntryFDList ); 
     SgAsmElfEHFrameEntryFDListStorageClass* storageArraySgAsmElfEHFrameEntryFDList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameEntryFDList = new SgAsmElfEHFrameEntryFDListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameEntryFDList) , sizeof ( SgAsmElfEHFrameEntryFDListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameEntryFDListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameEntryFDListStorageClass* storageArray = storageArraySgAsmElfEHFrameEntryFDList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfEHFrameEntryFDList ( *storageArray ) ; 
#else
               SgAsmElfEHFrameEntryFDList* tmp = new SgAsmElfEHFrameEntryFDList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameEntryFDList;  
      SgAsmElfEHFrameEntryFDListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameSection ); 
     SgAsmElfEHFrameSectionStorageClass* storageArraySgAsmElfEHFrameSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameSection = new SgAsmElfEHFrameSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameSection) , sizeof ( SgAsmElfEHFrameSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameSectionStorageClass* storageArray = storageArraySgAsmElfEHFrameSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfEHFrameSection ( *storageArray ) ; 
#else
               SgAsmElfEHFrameSection* tmp = new SgAsmElfEHFrameSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameSection;  
      SgAsmElfEHFrameSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfFileHeader ); 
     SgAsmElfFileHeaderStorageClass* storageArraySgAsmElfFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfFileHeader = new SgAsmElfFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfFileHeader) , sizeof ( SgAsmElfFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmElfFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfFileHeaderStorageClass* storageArray = storageArraySgAsmElfFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfFileHeader ( *storageArray ) ; 
#else
               SgAsmElfFileHeader* tmp = new SgAsmElfFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfFileHeader;  
      SgAsmElfFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfNoteEntry ); 
     SgAsmElfNoteEntryStorageClass* storageArraySgAsmElfNoteEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfNoteEntry = new SgAsmElfNoteEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfNoteEntry) , sizeof ( SgAsmElfNoteEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfNoteEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfNoteEntryStorageClass* storageArray = storageArraySgAsmElfNoteEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfNoteEntry ( *storageArray ) ; 
#else
               SgAsmElfNoteEntry* tmp = new SgAsmElfNoteEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfNoteEntry;  
      SgAsmElfNoteEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfNoteEntryList ); 
     SgAsmElfNoteEntryListStorageClass* storageArraySgAsmElfNoteEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfNoteEntryList = new SgAsmElfNoteEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfNoteEntryList) , sizeof ( SgAsmElfNoteEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfNoteEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfNoteEntryListStorageClass* storageArray = storageArraySgAsmElfNoteEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfNoteEntryList ( *storageArray ) ; 
#else
               SgAsmElfNoteEntryList* tmp = new SgAsmElfNoteEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfNoteEntryList;  
      SgAsmElfNoteEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfNoteSection ); 
     SgAsmElfNoteSectionStorageClass* storageArraySgAsmElfNoteSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfNoteSection = new SgAsmElfNoteSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfNoteSection) , sizeof ( SgAsmElfNoteSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfNoteSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfNoteSectionStorageClass* storageArray = storageArraySgAsmElfNoteSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfNoteSection ( *storageArray ) ; 
#else
               SgAsmElfNoteSection* tmp = new SgAsmElfNoteSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfNoteSection;  
      SgAsmElfNoteSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfRelocEntry ); 
     SgAsmElfRelocEntryStorageClass* storageArraySgAsmElfRelocEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfRelocEntry = new SgAsmElfRelocEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfRelocEntry) , sizeof ( SgAsmElfRelocEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfRelocEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfRelocEntryStorageClass* storageArray = storageArraySgAsmElfRelocEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfRelocEntry ( *storageArray ) ; 
#else
               SgAsmElfRelocEntry* tmp = new SgAsmElfRelocEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfRelocEntry;  
      SgAsmElfRelocEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfRelocEntryList ); 
     SgAsmElfRelocEntryListStorageClass* storageArraySgAsmElfRelocEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfRelocEntryList = new SgAsmElfRelocEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfRelocEntryList) , sizeof ( SgAsmElfRelocEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfRelocEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfRelocEntryListStorageClass* storageArray = storageArraySgAsmElfRelocEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfRelocEntryList ( *storageArray ) ; 
#else
               SgAsmElfRelocEntryList* tmp = new SgAsmElfRelocEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfRelocEntryList;  
      SgAsmElfRelocEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfRelocSection ); 
     SgAsmElfRelocSectionStorageClass* storageArraySgAsmElfRelocSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfRelocSection = new SgAsmElfRelocSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfRelocSection) , sizeof ( SgAsmElfRelocSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfRelocSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfRelocSectionStorageClass* storageArray = storageArraySgAsmElfRelocSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfRelocSection ( *storageArray ) ; 
#else
               SgAsmElfRelocSection* tmp = new SgAsmElfRelocSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfRelocSection;  
      SgAsmElfRelocSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSection ); 
     SgAsmElfSectionStorageClass* storageArraySgAsmElfSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSection = new SgAsmElfSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSection) , sizeof ( SgAsmElfSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSectionStorageClass* storageArray = storageArraySgAsmElfSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSection ( *storageArray ) ; 
#else
               SgAsmElfSection* tmp = new SgAsmElfSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSection;  
      SgAsmElfSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSectionTable ); 
     SgAsmElfSectionTableStorageClass* storageArraySgAsmElfSectionTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSectionTable = new SgAsmElfSectionTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSectionTable) , sizeof ( SgAsmElfSectionTableStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSectionTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSectionTableStorageClass* storageArray = storageArraySgAsmElfSectionTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSectionTable ( *storageArray ) ; 
#else
               SgAsmElfSectionTable* tmp = new SgAsmElfSectionTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSectionTable;  
      SgAsmElfSectionTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSectionTableEntry ); 
     SgAsmElfSectionTableEntryStorageClass* storageArraySgAsmElfSectionTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSectionTableEntry = new SgAsmElfSectionTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSectionTableEntry) , sizeof ( SgAsmElfSectionTableEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSectionTableEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSectionTableEntryStorageClass* storageArray = storageArraySgAsmElfSectionTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSectionTableEntry ( *storageArray ) ; 
#else
               SgAsmElfSectionTableEntry* tmp = new SgAsmElfSectionTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSectionTableEntry;  
      SgAsmElfSectionTableEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSegmentTable ); 
     SgAsmElfSegmentTableStorageClass* storageArraySgAsmElfSegmentTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSegmentTable = new SgAsmElfSegmentTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSegmentTable) , sizeof ( SgAsmElfSegmentTableStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSegmentTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSegmentTableStorageClass* storageArray = storageArraySgAsmElfSegmentTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSegmentTable ( *storageArray ) ; 
#else
               SgAsmElfSegmentTable* tmp = new SgAsmElfSegmentTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSegmentTable;  
      SgAsmElfSegmentTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSegmentTableEntry ); 
     SgAsmElfSegmentTableEntryStorageClass* storageArraySgAsmElfSegmentTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSegmentTableEntry = new SgAsmElfSegmentTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSegmentTableEntry) , sizeof ( SgAsmElfSegmentTableEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSegmentTableEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSegmentTableEntryStorageClass* storageArray = storageArraySgAsmElfSegmentTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSegmentTableEntry ( *storageArray ) ; 
#else
               SgAsmElfSegmentTableEntry* tmp = new SgAsmElfSegmentTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSegmentTableEntry;  
      SgAsmElfSegmentTableEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSegmentTableEntryList ); 
     SgAsmElfSegmentTableEntryListStorageClass* storageArraySgAsmElfSegmentTableEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSegmentTableEntryList = new SgAsmElfSegmentTableEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSegmentTableEntryList) , sizeof ( SgAsmElfSegmentTableEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSegmentTableEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSegmentTableEntryListStorageClass* storageArray = storageArraySgAsmElfSegmentTableEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSegmentTableEntryList ( *storageArray ) ; 
#else
               SgAsmElfSegmentTableEntryList* tmp = new SgAsmElfSegmentTableEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSegmentTableEntryList;  
      SgAsmElfSegmentTableEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfStringSection ); 
     SgAsmElfStringSectionStorageClass* storageArraySgAsmElfStringSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfStringSection = new SgAsmElfStringSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfStringSection) , sizeof ( SgAsmElfStringSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfStringSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfStringSectionStorageClass* storageArray = storageArraySgAsmElfStringSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfStringSection ( *storageArray ) ; 
#else
               SgAsmElfStringSection* tmp = new SgAsmElfStringSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfStringSection;  
      SgAsmElfStringSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfStrtab ); 
     SgAsmElfStrtabStorageClass* storageArraySgAsmElfStrtab = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfStrtab = new SgAsmElfStrtabStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfStrtab) , sizeof ( SgAsmElfStrtabStorageClass ) * sizeOfActualPool) ;
        SgAsmElfStrtabStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfStrtabStorageClass* storageArray = storageArraySgAsmElfStrtab;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfStrtab ( *storageArray ) ; 
#else
               SgAsmElfStrtab* tmp = new SgAsmElfStrtab ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfStrtab;  
      SgAsmElfStrtabStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymbol ); 
     SgAsmElfSymbolStorageClass* storageArraySgAsmElfSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymbol = new SgAsmElfSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymbol) , sizeof ( SgAsmElfSymbolStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymbolStorageClass* storageArray = storageArraySgAsmElfSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymbol ( *storageArray ) ; 
#else
               SgAsmElfSymbol* tmp = new SgAsmElfSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymbol;  
      SgAsmElfSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymbolList ); 
     SgAsmElfSymbolListStorageClass* storageArraySgAsmElfSymbolList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymbolList = new SgAsmElfSymbolListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymbolList) , sizeof ( SgAsmElfSymbolListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymbolListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymbolListStorageClass* storageArray = storageArraySgAsmElfSymbolList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymbolList ( *storageArray ) ; 
#else
               SgAsmElfSymbolList* tmp = new SgAsmElfSymbolList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymbolList;  
      SgAsmElfSymbolListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymbolSection ); 
     SgAsmElfSymbolSectionStorageClass* storageArraySgAsmElfSymbolSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymbolSection = new SgAsmElfSymbolSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymbolSection) , sizeof ( SgAsmElfSymbolSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymbolSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymbolSectionStorageClass* storageArray = storageArraySgAsmElfSymbolSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymbolSection ( *storageArray ) ; 
#else
               SgAsmElfSymbolSection* tmp = new SgAsmElfSymbolSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymbolSection;  
      SgAsmElfSymbolSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedAux ); 
     SgAsmElfSymverDefinedAuxStorageClass* storageArraySgAsmElfSymverDefinedAux = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedAux = new SgAsmElfSymverDefinedAuxStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedAux) , sizeof ( SgAsmElfSymverDefinedAuxStorageClass ) * sizeOfActualPool) ;
          SgAsmElfSymverDefinedAuxStorageClass* storageArray = storageArraySgAsmElfSymverDefinedAux;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverDefinedAux ( *storageArray ) ; 
#else
               SgAsmElfSymverDefinedAux* tmp = new SgAsmElfSymverDefinedAux ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedAux;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedAuxList ); 
     SgAsmElfSymverDefinedAuxListStorageClass* storageArraySgAsmElfSymverDefinedAuxList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedAuxList = new SgAsmElfSymverDefinedAuxListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedAuxList) , sizeof ( SgAsmElfSymverDefinedAuxListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverDefinedAuxListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverDefinedAuxListStorageClass* storageArray = storageArraySgAsmElfSymverDefinedAuxList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverDefinedAuxList ( *storageArray ) ; 
#else
               SgAsmElfSymverDefinedAuxList* tmp = new SgAsmElfSymverDefinedAuxList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedAuxList;  
      SgAsmElfSymverDefinedAuxListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedEntry ); 
     SgAsmElfSymverDefinedEntryStorageClass* storageArraySgAsmElfSymverDefinedEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedEntry = new SgAsmElfSymverDefinedEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedEntry) , sizeof ( SgAsmElfSymverDefinedEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmElfSymverDefinedEntryStorageClass* storageArray = storageArraySgAsmElfSymverDefinedEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverDefinedEntry ( *storageArray ) ; 
#else
               SgAsmElfSymverDefinedEntry* tmp = new SgAsmElfSymverDefinedEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedEntryList ); 
     SgAsmElfSymverDefinedEntryListStorageClass* storageArraySgAsmElfSymverDefinedEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedEntryList = new SgAsmElfSymverDefinedEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedEntryList) , sizeof ( SgAsmElfSymverDefinedEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverDefinedEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverDefinedEntryListStorageClass* storageArray = storageArraySgAsmElfSymverDefinedEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverDefinedEntryList ( *storageArray ) ; 
#else
               SgAsmElfSymverDefinedEntryList* tmp = new SgAsmElfSymverDefinedEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedEntryList;  
      SgAsmElfSymverDefinedEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedSection ); 
     SgAsmElfSymverDefinedSectionStorageClass* storageArraySgAsmElfSymverDefinedSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedSection = new SgAsmElfSymverDefinedSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedSection) , sizeof ( SgAsmElfSymverDefinedSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverDefinedSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverDefinedSectionStorageClass* storageArray = storageArraySgAsmElfSymverDefinedSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverDefinedSection ( *storageArray ) ; 
#else
               SgAsmElfSymverDefinedSection* tmp = new SgAsmElfSymverDefinedSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedSection;  
      SgAsmElfSymverDefinedSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverEntry ); 
     SgAsmElfSymverEntryStorageClass* storageArraySgAsmElfSymverEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverEntry = new SgAsmElfSymverEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverEntry) , sizeof ( SgAsmElfSymverEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmElfSymverEntryStorageClass* storageArray = storageArraySgAsmElfSymverEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverEntry ( *storageArray ) ; 
#else
               SgAsmElfSymverEntry* tmp = new SgAsmElfSymverEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverEntryList ); 
     SgAsmElfSymverEntryListStorageClass* storageArraySgAsmElfSymverEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverEntryList = new SgAsmElfSymverEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverEntryList) , sizeof ( SgAsmElfSymverEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverEntryListStorageClass* storageArray = storageArraySgAsmElfSymverEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverEntryList ( *storageArray ) ; 
#else
               SgAsmElfSymverEntryList* tmp = new SgAsmElfSymverEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverEntryList;  
      SgAsmElfSymverEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededAux ); 
     SgAsmElfSymverNeededAuxStorageClass* storageArraySgAsmElfSymverNeededAux = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededAux = new SgAsmElfSymverNeededAuxStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededAux) , sizeof ( SgAsmElfSymverNeededAuxStorageClass ) * sizeOfActualPool) ;
          SgAsmElfSymverNeededAuxStorageClass* storageArray = storageArraySgAsmElfSymverNeededAux;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverNeededAux ( *storageArray ) ; 
#else
               SgAsmElfSymverNeededAux* tmp = new SgAsmElfSymverNeededAux ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededAux;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededAuxList ); 
     SgAsmElfSymverNeededAuxListStorageClass* storageArraySgAsmElfSymverNeededAuxList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededAuxList = new SgAsmElfSymverNeededAuxListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededAuxList) , sizeof ( SgAsmElfSymverNeededAuxListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverNeededAuxListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverNeededAuxListStorageClass* storageArray = storageArraySgAsmElfSymverNeededAuxList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverNeededAuxList ( *storageArray ) ; 
#else
               SgAsmElfSymverNeededAuxList* tmp = new SgAsmElfSymverNeededAuxList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededAuxList;  
      SgAsmElfSymverNeededAuxListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededEntry ); 
     SgAsmElfSymverNeededEntryStorageClass* storageArraySgAsmElfSymverNeededEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededEntry = new SgAsmElfSymverNeededEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededEntry) , sizeof ( SgAsmElfSymverNeededEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmElfSymverNeededEntryStorageClass* storageArray = storageArraySgAsmElfSymverNeededEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverNeededEntry ( *storageArray ) ; 
#else
               SgAsmElfSymverNeededEntry* tmp = new SgAsmElfSymverNeededEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededEntryList ); 
     SgAsmElfSymverNeededEntryListStorageClass* storageArraySgAsmElfSymverNeededEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededEntryList = new SgAsmElfSymverNeededEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededEntryList) , sizeof ( SgAsmElfSymverNeededEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverNeededEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverNeededEntryListStorageClass* storageArray = storageArraySgAsmElfSymverNeededEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverNeededEntryList ( *storageArray ) ; 
#else
               SgAsmElfSymverNeededEntryList* tmp = new SgAsmElfSymverNeededEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededEntryList;  
      SgAsmElfSymverNeededEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededSection ); 
     SgAsmElfSymverNeededSectionStorageClass* storageArraySgAsmElfSymverNeededSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededSection = new SgAsmElfSymverNeededSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededSection) , sizeof ( SgAsmElfSymverNeededSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverNeededSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverNeededSectionStorageClass* storageArray = storageArraySgAsmElfSymverNeededSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverNeededSection ( *storageArray ) ; 
#else
               SgAsmElfSymverNeededSection* tmp = new SgAsmElfSymverNeededSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededSection;  
      SgAsmElfSymverNeededSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverSection ); 
     SgAsmElfSymverSectionStorageClass* storageArraySgAsmElfSymverSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverSection = new SgAsmElfSymverSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverSection) , sizeof ( SgAsmElfSymverSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverSectionStorageClass* storageArray = storageArraySgAsmElfSymverSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmElfSymverSection ( *storageArray ) ; 
#else
               SgAsmElfSymverSection* tmp = new SgAsmElfSymverSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverSection;  
      SgAsmElfSymverSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmExecutableFileFormat ); 
     SgAsmExecutableFileFormatStorageClass* storageArraySgAsmExecutableFileFormat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmExecutableFileFormat = new SgAsmExecutableFileFormatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmExecutableFileFormat) , sizeof ( SgAsmExecutableFileFormatStorageClass ) * sizeOfActualPool) ;
          SgAsmExecutableFileFormatStorageClass* storageArray = storageArraySgAsmExecutableFileFormat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmExecutableFileFormat ( *storageArray ) ; 
#else
               SgAsmExecutableFileFormat* tmp = new SgAsmExecutableFileFormat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmExecutableFileFormat;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmExprListExp ); 
     SgAsmExprListExpStorageClass* storageArraySgAsmExprListExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmExprListExp = new SgAsmExprListExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmExprListExp) , sizeof ( SgAsmExprListExpStorageClass ) * sizeOfActualPool) ;
        SgAsmExprListExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmExprListExpStorageClass* storageArray = storageArraySgAsmExprListExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmExprListExp ( *storageArray ) ; 
#else
               SgAsmExprListExp* tmp = new SgAsmExprListExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmExprListExp;  
      SgAsmExprListExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmExpression ); 
     SgAsmExpressionStorageClass* storageArraySgAsmExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmExpression = new SgAsmExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmExpression) , sizeof ( SgAsmExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmExpressionStorageClass* storageArray = storageArraySgAsmExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmExpression ( *storageArray ) ; 
#else
               SgAsmExpression* tmp = new SgAsmExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmExpression;  
      SgAsmExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmSynthesizedFieldDeclaration ); 
     SgAsmSynthesizedFieldDeclarationStorageClass* storageArraySgAsmSynthesizedFieldDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmSynthesizedFieldDeclaration = new SgAsmSynthesizedFieldDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmSynthesizedFieldDeclaration) , sizeof ( SgAsmSynthesizedFieldDeclarationStorageClass ) * sizeOfActualPool) ;
        SgAsmSynthesizedFieldDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmSynthesizedFieldDeclarationStorageClass* storageArray = storageArraySgAsmSynthesizedFieldDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmSynthesizedFieldDeclaration ( *storageArray ) ; 
#else
               SgAsmSynthesizedFieldDeclaration* tmp = new SgAsmSynthesizedFieldDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmSynthesizedFieldDeclaration;  
      SgAsmSynthesizedFieldDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmFloatType ); 
     SgAsmFloatTypeStorageClass* storageArraySgAsmFloatType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmFloatType = new SgAsmFloatTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmFloatType) , sizeof ( SgAsmFloatTypeStorageClass ) * sizeOfActualPool) ;
          SgAsmFloatTypeStorageClass* storageArray = storageArraySgAsmFloatType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmFloatType ( *storageArray ) ; 
#else
               SgAsmFloatType* tmp = new SgAsmFloatType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmFloatType;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmFloatValueExpression ); 
     SgAsmFloatValueExpressionStorageClass* storageArraySgAsmFloatValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmFloatValueExpression = new SgAsmFloatValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmFloatValueExpression) , sizeof ( SgAsmFloatValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmFloatValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmFloatValueExpressionStorageClass* storageArray = storageArraySgAsmFloatValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmFloatValueExpression ( *storageArray ) ; 
#else
               SgAsmFloatValueExpression* tmp = new SgAsmFloatValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmFloatValueExpression;  
      SgAsmFloatValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmFunction ); 
     SgAsmFunctionStorageClass* storageArraySgAsmFunction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmFunction = new SgAsmFunctionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmFunction) , sizeof ( SgAsmFunctionStorageClass ) * sizeOfActualPool) ;
        SgAsmFunctionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmFunctionStorageClass* storageArray = storageArraySgAsmFunction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmFunction ( *storageArray ) ; 
#else
               SgAsmFunction* tmp = new SgAsmFunction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmFunction;  
      SgAsmFunctionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericDLL ); 
     SgAsmGenericDLLStorageClass* storageArraySgAsmGenericDLL = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericDLL = new SgAsmGenericDLLStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericDLL) , sizeof ( SgAsmGenericDLLStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericDLLStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericDLLStorageClass* storageArray = storageArraySgAsmGenericDLL;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericDLL ( *storageArray ) ; 
#else
               SgAsmGenericDLL* tmp = new SgAsmGenericDLL ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericDLL;  
      SgAsmGenericDLLStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericDLLList ); 
     SgAsmGenericDLLListStorageClass* storageArraySgAsmGenericDLLList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericDLLList = new SgAsmGenericDLLListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericDLLList) , sizeof ( SgAsmGenericDLLListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericDLLListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericDLLListStorageClass* storageArray = storageArraySgAsmGenericDLLList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericDLLList ( *storageArray ) ; 
#else
               SgAsmGenericDLLList* tmp = new SgAsmGenericDLLList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericDLLList;  
      SgAsmGenericDLLListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericFile ); 
     SgAsmGenericFileStorageClass* storageArraySgAsmGenericFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericFile = new SgAsmGenericFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericFile) , sizeof ( SgAsmGenericFileStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericFileStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericFileStorageClass* storageArray = storageArraySgAsmGenericFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericFile ( *storageArray ) ; 
#else
               SgAsmGenericFile* tmp = new SgAsmGenericFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericFile;  
      SgAsmGenericFileStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericFileList ); 
     SgAsmGenericFileListStorageClass* storageArraySgAsmGenericFileList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericFileList = new SgAsmGenericFileListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericFileList) , sizeof ( SgAsmGenericFileListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericFileListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericFileListStorageClass* storageArray = storageArraySgAsmGenericFileList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericFileList ( *storageArray ) ; 
#else
               SgAsmGenericFileList* tmp = new SgAsmGenericFileList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericFileList;  
      SgAsmGenericFileListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericFormat ); 
     SgAsmGenericFormatStorageClass* storageArraySgAsmGenericFormat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericFormat = new SgAsmGenericFormatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericFormat) , sizeof ( SgAsmGenericFormatStorageClass ) * sizeOfActualPool) ;
          SgAsmGenericFormatStorageClass* storageArray = storageArraySgAsmGenericFormat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericFormat ( *storageArray ) ; 
#else
               SgAsmGenericFormat* tmp = new SgAsmGenericFormat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericFormat;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericHeader ); 
     SgAsmGenericHeaderStorageClass* storageArraySgAsmGenericHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericHeader = new SgAsmGenericHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericHeader) , sizeof ( SgAsmGenericHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericHeaderStorageClass* storageArray = storageArraySgAsmGenericHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericHeader ( *storageArray ) ; 
#else
               SgAsmGenericHeader* tmp = new SgAsmGenericHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericHeader;  
      SgAsmGenericHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericHeaderList ); 
     SgAsmGenericHeaderListStorageClass* storageArraySgAsmGenericHeaderList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericHeaderList = new SgAsmGenericHeaderListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericHeaderList) , sizeof ( SgAsmGenericHeaderListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericHeaderListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericHeaderListStorageClass* storageArray = storageArraySgAsmGenericHeaderList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericHeaderList ( *storageArray ) ; 
#else
               SgAsmGenericHeaderList* tmp = new SgAsmGenericHeaderList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericHeaderList;  
      SgAsmGenericHeaderListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericSection ); 
     SgAsmGenericSectionStorageClass* storageArraySgAsmGenericSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericSection = new SgAsmGenericSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericSection) , sizeof ( SgAsmGenericSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericSectionStorageClass* storageArray = storageArraySgAsmGenericSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericSection ( *storageArray ) ; 
#else
               SgAsmGenericSection* tmp = new SgAsmGenericSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericSection;  
      SgAsmGenericSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericSectionList ); 
     SgAsmGenericSectionListStorageClass* storageArraySgAsmGenericSectionList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericSectionList = new SgAsmGenericSectionListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericSectionList) , sizeof ( SgAsmGenericSectionListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericSectionListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericSectionListStorageClass* storageArray = storageArraySgAsmGenericSectionList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericSectionList ( *storageArray ) ; 
#else
               SgAsmGenericSectionList* tmp = new SgAsmGenericSectionList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericSectionList;  
      SgAsmGenericSectionListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericString ); 
     SgAsmGenericStringStorageClass* storageArraySgAsmGenericString = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericString = new SgAsmGenericStringStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericString) , sizeof ( SgAsmGenericStringStorageClass ) * sizeOfActualPool) ;
          SgAsmGenericStringStorageClass* storageArray = storageArraySgAsmGenericString;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericString ( *storageArray ) ; 
#else
               SgAsmGenericString* tmp = new SgAsmGenericString ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericString;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericStrtab ); 
     SgAsmGenericStrtabStorageClass* storageArraySgAsmGenericStrtab = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericStrtab = new SgAsmGenericStrtabStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericStrtab) , sizeof ( SgAsmGenericStrtabStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericStrtabStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericStrtabStorageClass* storageArray = storageArraySgAsmGenericStrtab;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericStrtab ( *storageArray ) ; 
#else
               SgAsmGenericStrtab* tmp = new SgAsmGenericStrtab ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericStrtab;  
      SgAsmGenericStrtabStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericSymbol ); 
     SgAsmGenericSymbolStorageClass* storageArraySgAsmGenericSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericSymbol = new SgAsmGenericSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericSymbol) , sizeof ( SgAsmGenericSymbolStorageClass ) * sizeOfActualPool) ;
          SgAsmGenericSymbolStorageClass* storageArray = storageArraySgAsmGenericSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericSymbol ( *storageArray ) ; 
#else
               SgAsmGenericSymbol* tmp = new SgAsmGenericSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericSymbol;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericSymbolList ); 
     SgAsmGenericSymbolListStorageClass* storageArraySgAsmGenericSymbolList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericSymbolList = new SgAsmGenericSymbolListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericSymbolList) , sizeof ( SgAsmGenericSymbolListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericSymbolListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericSymbolListStorageClass* storageArray = storageArraySgAsmGenericSymbolList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmGenericSymbolList ( *storageArray ) ; 
#else
               SgAsmGenericSymbolList* tmp = new SgAsmGenericSymbolList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericSymbolList;  
      SgAsmGenericSymbolListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmIndirectRegisterExpression ); 
     SgAsmIndirectRegisterExpressionStorageClass* storageArraySgAsmIndirectRegisterExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmIndirectRegisterExpression = new SgAsmIndirectRegisterExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmIndirectRegisterExpression) , sizeof ( SgAsmIndirectRegisterExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmIndirectRegisterExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmIndirectRegisterExpressionStorageClass* storageArray = storageArraySgAsmIndirectRegisterExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmIndirectRegisterExpression ( *storageArray ) ; 
#else
               SgAsmIndirectRegisterExpression* tmp = new SgAsmIndirectRegisterExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmIndirectRegisterExpression;  
      SgAsmIndirectRegisterExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmInstruction ); 
     SgAsmInstructionStorageClass* storageArraySgAsmInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmInstruction = new SgAsmInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmInstruction) , sizeof ( SgAsmInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmInstructionStorageClass* storageArray = storageArraySgAsmInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmInstruction ( *storageArray ) ; 
#else
               SgAsmInstruction* tmp = new SgAsmInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmInstruction;  
      SgAsmInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmIntegerValueExpression ); 
     SgAsmIntegerValueExpressionStorageClass* storageArraySgAsmIntegerValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmIntegerValueExpression = new SgAsmIntegerValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmIntegerValueExpression) , sizeof ( SgAsmIntegerValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmIntegerValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmIntegerValueExpressionStorageClass* storageArray = storageArraySgAsmIntegerValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmIntegerValueExpression ( *storageArray ) ; 
#else
               SgAsmIntegerValueExpression* tmp = new SgAsmIntegerValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmIntegerValueExpression;  
      SgAsmIntegerValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmIntegerType ); 
     SgAsmIntegerTypeStorageClass* storageArraySgAsmIntegerType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmIntegerType = new SgAsmIntegerTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmIntegerType) , sizeof ( SgAsmIntegerTypeStorageClass ) * sizeOfActualPool) ;
          SgAsmIntegerTypeStorageClass* storageArray = storageArraySgAsmIntegerType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmIntegerType ( *storageArray ) ; 
#else
               SgAsmIntegerType* tmp = new SgAsmIntegerType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmIntegerType;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmInterpretation ); 
     SgAsmInterpretationStorageClass* storageArraySgAsmInterpretation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmInterpretation = new SgAsmInterpretationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmInterpretation) , sizeof ( SgAsmInterpretationStorageClass ) * sizeOfActualPool) ;
          SgAsmInterpretationStorageClass* storageArray = storageArraySgAsmInterpretation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmInterpretation ( *storageArray ) ; 
#else
               SgAsmInterpretation* tmp = new SgAsmInterpretation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmInterpretation;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmInterpretationList ); 
     SgAsmInterpretationListStorageClass* storageArraySgAsmInterpretationList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmInterpretationList = new SgAsmInterpretationListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmInterpretationList) , sizeof ( SgAsmInterpretationListStorageClass ) * sizeOfActualPool) ;
        SgAsmInterpretationListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmInterpretationListStorageClass* storageArray = storageArraySgAsmInterpretationList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmInterpretationList ( *storageArray ) ; 
#else
               SgAsmInterpretationList* tmp = new SgAsmInterpretationList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmInterpretationList;  
      SgAsmInterpretationListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmAttribute ); 
     SgAsmJvmAttributeStorageClass* storageArraySgAsmJvmAttribute = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmAttribute = new SgAsmJvmAttributeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmAttribute) , sizeof ( SgAsmJvmAttributeStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmAttributeStorageClass* storageArray = storageArraySgAsmJvmAttribute;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmAttribute ( *storageArray ) ; 
#else
               SgAsmJvmAttribute* tmp = new SgAsmJvmAttribute ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmAttribute;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmCodeAttribute ); 
     SgAsmJvmCodeAttributeStorageClass* storageArraySgAsmJvmCodeAttribute = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmCodeAttribute = new SgAsmJvmCodeAttributeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmCodeAttribute) , sizeof ( SgAsmJvmCodeAttributeStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmCodeAttributeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmCodeAttributeStorageClass* storageArray = storageArraySgAsmJvmCodeAttribute;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmCodeAttribute ( *storageArray ) ; 
#else
               SgAsmJvmCodeAttribute* tmp = new SgAsmJvmCodeAttribute ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmCodeAttribute;  
      SgAsmJvmCodeAttributeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmMethod ); 
     SgAsmJvmMethodStorageClass* storageArraySgAsmJvmMethod = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmMethod = new SgAsmJvmMethodStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmMethod) , sizeof ( SgAsmJvmMethodStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmMethodStorageClass* storageArray = storageArraySgAsmJvmMethod;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmMethod ( *storageArray ) ; 
#else
               SgAsmJvmMethod* tmp = new SgAsmJvmMethod ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmMethod;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmConstantPool ); 
     SgAsmJvmConstantPoolStorageClass* storageArraySgAsmJvmConstantPool = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmConstantPool = new SgAsmJvmConstantPoolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmConstantPool) , sizeof ( SgAsmJvmConstantPoolStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmConstantPoolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmConstantPoolStorageClass* storageArray = storageArraySgAsmJvmConstantPool;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmConstantPool ( *storageArray ) ; 
#else
               SgAsmJvmConstantPool* tmp = new SgAsmJvmConstantPool ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmConstantPool;  
      SgAsmJvmConstantPoolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmConstantPoolEntry ); 
     SgAsmJvmConstantPoolEntryStorageClass* storageArraySgAsmJvmConstantPoolEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmConstantPoolEntry = new SgAsmJvmConstantPoolEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmConstantPoolEntry) , sizeof ( SgAsmJvmConstantPoolEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmConstantPoolEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmConstantPoolEntryStorageClass* storageArray = storageArraySgAsmJvmConstantPoolEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmConstantPoolEntry ( *storageArray ) ; 
#else
               SgAsmJvmConstantPoolEntry* tmp = new SgAsmJvmConstantPoolEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmConstantPoolEntry;  
      SgAsmJvmConstantPoolEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmConstantValue ); 
     SgAsmJvmConstantValueStorageClass* storageArraySgAsmJvmConstantValue = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmConstantValue = new SgAsmJvmConstantValueStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmConstantValue) , sizeof ( SgAsmJvmConstantValueStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmConstantValueStorageClass* storageArray = storageArraySgAsmJvmConstantValue;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmConstantValue ( *storageArray ) ; 
#else
               SgAsmJvmConstantValue* tmp = new SgAsmJvmConstantValue ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmConstantValue;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmInstruction ); 
     SgAsmJvmInstructionStorageClass* storageArraySgAsmJvmInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmInstruction = new SgAsmJvmInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmInstruction) , sizeof ( SgAsmJvmInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmInstructionStorageClass* storageArray = storageArraySgAsmJvmInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmInstruction ( *storageArray ) ; 
#else
               SgAsmJvmInstruction* tmp = new SgAsmJvmInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmInstruction;  
      SgAsmJvmInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmFileHeader ); 
     SgAsmJvmFileHeaderStorageClass* storageArraySgAsmJvmFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmFileHeader = new SgAsmJvmFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmFileHeader) , sizeof ( SgAsmJvmFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmFileHeaderStorageClass* storageArray = storageArraySgAsmJvmFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmFileHeader ( *storageArray ) ; 
#else
               SgAsmJvmFileHeader* tmp = new SgAsmJvmFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmFileHeader;  
      SgAsmJvmFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmNode ); 
     SgAsmJvmNodeStorageClass* storageArraySgAsmJvmNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmNode = new SgAsmJvmNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmNode) , sizeof ( SgAsmJvmNodeStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmNodeStorageClass* storageArray = storageArraySgAsmJvmNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmNode ( *storageArray ) ; 
#else
               SgAsmJvmNode* tmp = new SgAsmJvmNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmNode;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmSignature ); 
     SgAsmJvmSignatureStorageClass* storageArraySgAsmJvmSignature = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmSignature = new SgAsmJvmSignatureStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmSignature) , sizeof ( SgAsmJvmSignatureStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmSignatureStorageClass* storageArray = storageArraySgAsmJvmSignature;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmSignature ( *storageArray ) ; 
#else
               SgAsmJvmSignature* tmp = new SgAsmJvmSignature ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmSignature;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmSourceFile ); 
     SgAsmJvmSourceFileStorageClass* storageArraySgAsmJvmSourceFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmSourceFile = new SgAsmJvmSourceFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmSourceFile) , sizeof ( SgAsmJvmSourceFileStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmSourceFileStorageClass* storageArray = storageArraySgAsmJvmSourceFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmSourceFile ( *storageArray ) ; 
#else
               SgAsmJvmSourceFile* tmp = new SgAsmJvmSourceFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmSourceFile;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEEntryPoint ); 
     SgAsmLEEntryPointStorageClass* storageArraySgAsmLEEntryPoint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEEntryPoint = new SgAsmLEEntryPointStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEEntryPoint) , sizeof ( SgAsmLEEntryPointStorageClass ) * sizeOfActualPool) ;
        SgAsmLEEntryPointStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLEEntryPointStorageClass* storageArray = storageArraySgAsmLEEntryPoint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLEEntryPoint ( *storageArray ) ; 
#else
               SgAsmLEEntryPoint* tmp = new SgAsmLEEntryPoint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEEntryPoint;  
      SgAsmLEEntryPointStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEEntryTable ); 
     SgAsmLEEntryTableStorageClass* storageArraySgAsmLEEntryTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEEntryTable = new SgAsmLEEntryTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEEntryTable) , sizeof ( SgAsmLEEntryTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLEEntryTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLEEntryTableStorageClass* storageArray = storageArraySgAsmLEEntryTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLEEntryTable ( *storageArray ) ; 
#else
               SgAsmLEEntryTable* tmp = new SgAsmLEEntryTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEEntryTable;  
      SgAsmLEEntryTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEFileHeader ); 
     SgAsmLEFileHeaderStorageClass* storageArraySgAsmLEFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEFileHeader = new SgAsmLEFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEFileHeader) , sizeof ( SgAsmLEFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmLEFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLEFileHeaderStorageClass* storageArray = storageArraySgAsmLEFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLEFileHeader ( *storageArray ) ; 
#else
               SgAsmLEFileHeader* tmp = new SgAsmLEFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEFileHeader;  
      SgAsmLEFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLENameTable ); 
     SgAsmLENameTableStorageClass* storageArraySgAsmLENameTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLENameTable = new SgAsmLENameTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLENameTable) , sizeof ( SgAsmLENameTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLENameTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLENameTableStorageClass* storageArray = storageArraySgAsmLENameTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLENameTable ( *storageArray ) ; 
#else
               SgAsmLENameTable* tmp = new SgAsmLENameTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLENameTable;  
      SgAsmLENameTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEPageTable ); 
     SgAsmLEPageTableStorageClass* storageArraySgAsmLEPageTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEPageTable = new SgAsmLEPageTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEPageTable) , sizeof ( SgAsmLEPageTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLEPageTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLEPageTableStorageClass* storageArray = storageArraySgAsmLEPageTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLEPageTable ( *storageArray ) ; 
#else
               SgAsmLEPageTable* tmp = new SgAsmLEPageTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEPageTable;  
      SgAsmLEPageTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEPageTableEntry ); 
     SgAsmLEPageTableEntryStorageClass* storageArraySgAsmLEPageTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEPageTableEntry = new SgAsmLEPageTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEPageTableEntry) , sizeof ( SgAsmLEPageTableEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmLEPageTableEntryStorageClass* storageArray = storageArraySgAsmLEPageTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLEPageTableEntry ( *storageArray ) ; 
#else
               SgAsmLEPageTableEntry* tmp = new SgAsmLEPageTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEPageTableEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLERelocTable ); 
     SgAsmLERelocTableStorageClass* storageArraySgAsmLERelocTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLERelocTable = new SgAsmLERelocTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLERelocTable) , sizeof ( SgAsmLERelocTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLERelocTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLERelocTableStorageClass* storageArray = storageArraySgAsmLERelocTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLERelocTable ( *storageArray ) ; 
#else
               SgAsmLERelocTable* tmp = new SgAsmLERelocTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLERelocTable;  
      SgAsmLERelocTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLESection ); 
     SgAsmLESectionStorageClass* storageArraySgAsmLESection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLESection = new SgAsmLESectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLESection) , sizeof ( SgAsmLESectionStorageClass ) * sizeOfActualPool) ;
        SgAsmLESectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLESectionStorageClass* storageArray = storageArraySgAsmLESection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLESection ( *storageArray ) ; 
#else
               SgAsmLESection* tmp = new SgAsmLESection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLESection;  
      SgAsmLESectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLESectionTable ); 
     SgAsmLESectionTableStorageClass* storageArraySgAsmLESectionTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLESectionTable = new SgAsmLESectionTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLESectionTable) , sizeof ( SgAsmLESectionTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLESectionTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLESectionTableStorageClass* storageArray = storageArraySgAsmLESectionTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLESectionTable ( *storageArray ) ; 
#else
               SgAsmLESectionTable* tmp = new SgAsmLESectionTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLESectionTable;  
      SgAsmLESectionTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLESectionTableEntry ); 
     SgAsmLESectionTableEntryStorageClass* storageArraySgAsmLESectionTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLESectionTableEntry = new SgAsmLESectionTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLESectionTableEntry) , sizeof ( SgAsmLESectionTableEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmLESectionTableEntryStorageClass* storageArray = storageArraySgAsmLESectionTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmLESectionTableEntry ( *storageArray ) ; 
#else
               SgAsmLESectionTableEntry* tmp = new SgAsmLESectionTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLESectionTableEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmM68kInstruction ); 
     SgAsmM68kInstructionStorageClass* storageArraySgAsmM68kInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmM68kInstruction = new SgAsmM68kInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmM68kInstruction) , sizeof ( SgAsmM68kInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmM68kInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmM68kInstructionStorageClass* storageArray = storageArraySgAsmM68kInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmM68kInstruction ( *storageArray ) ; 
#else
               SgAsmM68kInstruction* tmp = new SgAsmM68kInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmM68kInstruction;  
      SgAsmM68kInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmMemoryReferenceExpression ); 
     SgAsmMemoryReferenceExpressionStorageClass* storageArraySgAsmMemoryReferenceExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmMemoryReferenceExpression = new SgAsmMemoryReferenceExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmMemoryReferenceExpression) , sizeof ( SgAsmMemoryReferenceExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmMemoryReferenceExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmMemoryReferenceExpressionStorageClass* storageArray = storageArraySgAsmMemoryReferenceExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmMemoryReferenceExpression ( *storageArray ) ; 
#else
               SgAsmMemoryReferenceExpression* tmp = new SgAsmMemoryReferenceExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmMemoryReferenceExpression;  
      SgAsmMemoryReferenceExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmMipsInstruction ); 
     SgAsmMipsInstructionStorageClass* storageArraySgAsmMipsInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmMipsInstruction = new SgAsmMipsInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmMipsInstruction) , sizeof ( SgAsmMipsInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmMipsInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmMipsInstructionStorageClass* storageArray = storageArraySgAsmMipsInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmMipsInstruction ( *storageArray ) ; 
#else
               SgAsmMipsInstruction* tmp = new SgAsmMipsInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmMipsInstruction;  
      SgAsmMipsInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEEntryPoint ); 
     SgAsmNEEntryPointStorageClass* storageArraySgAsmNEEntryPoint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEEntryPoint = new SgAsmNEEntryPointStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEEntryPoint) , sizeof ( SgAsmNEEntryPointStorageClass ) * sizeOfActualPool) ;
          SgAsmNEEntryPointStorageClass* storageArray = storageArraySgAsmNEEntryPoint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNEEntryPoint ( *storageArray ) ; 
#else
               SgAsmNEEntryPoint* tmp = new SgAsmNEEntryPoint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEEntryPoint;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEEntryTable ); 
     SgAsmNEEntryTableStorageClass* storageArraySgAsmNEEntryTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEEntryTable = new SgAsmNEEntryTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEEntryTable) , sizeof ( SgAsmNEEntryTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNEEntryTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNEEntryTableStorageClass* storageArray = storageArraySgAsmNEEntryTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNEEntryTable ( *storageArray ) ; 
#else
               SgAsmNEEntryTable* tmp = new SgAsmNEEntryTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEEntryTable;  
      SgAsmNEEntryTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEFileHeader ); 
     SgAsmNEFileHeaderStorageClass* storageArraySgAsmNEFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEFileHeader = new SgAsmNEFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEFileHeader) , sizeof ( SgAsmNEFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmNEFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNEFileHeaderStorageClass* storageArray = storageArraySgAsmNEFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNEFileHeader ( *storageArray ) ; 
#else
               SgAsmNEFileHeader* tmp = new SgAsmNEFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEFileHeader;  
      SgAsmNEFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEModuleTable ); 
     SgAsmNEModuleTableStorageClass* storageArraySgAsmNEModuleTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEModuleTable = new SgAsmNEModuleTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEModuleTable) , sizeof ( SgAsmNEModuleTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNEModuleTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNEModuleTableStorageClass* storageArray = storageArraySgAsmNEModuleTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNEModuleTable ( *storageArray ) ; 
#else
               SgAsmNEModuleTable* tmp = new SgAsmNEModuleTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEModuleTable;  
      SgAsmNEModuleTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNENameTable ); 
     SgAsmNENameTableStorageClass* storageArraySgAsmNENameTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNENameTable = new SgAsmNENameTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNENameTable) , sizeof ( SgAsmNENameTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNENameTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNENameTableStorageClass* storageArray = storageArraySgAsmNENameTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNENameTable ( *storageArray ) ; 
#else
               SgAsmNENameTable* tmp = new SgAsmNENameTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNENameTable;  
      SgAsmNENameTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNERelocEntry ); 
     SgAsmNERelocEntryStorageClass* storageArraySgAsmNERelocEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNERelocEntry = new SgAsmNERelocEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNERelocEntry) , sizeof ( SgAsmNERelocEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmNERelocEntryStorageClass* storageArray = storageArraySgAsmNERelocEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNERelocEntry ( *storageArray ) ; 
#else
               SgAsmNERelocEntry* tmp = new SgAsmNERelocEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNERelocEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNERelocTable ); 
     SgAsmNERelocTableStorageClass* storageArraySgAsmNERelocTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNERelocTable = new SgAsmNERelocTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNERelocTable) , sizeof ( SgAsmNERelocTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNERelocTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNERelocTableStorageClass* storageArray = storageArraySgAsmNERelocTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNERelocTable ( *storageArray ) ; 
#else
               SgAsmNERelocTable* tmp = new SgAsmNERelocTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNERelocTable;  
      SgAsmNERelocTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNESection ); 
     SgAsmNESectionStorageClass* storageArraySgAsmNESection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNESection = new SgAsmNESectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNESection) , sizeof ( SgAsmNESectionStorageClass ) * sizeOfActualPool) ;
        SgAsmNESectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNESectionStorageClass* storageArray = storageArraySgAsmNESection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNESection ( *storageArray ) ; 
#else
               SgAsmNESection* tmp = new SgAsmNESection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNESection;  
      SgAsmNESectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNESectionTable ); 
     SgAsmNESectionTableStorageClass* storageArraySgAsmNESectionTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNESectionTable = new SgAsmNESectionTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNESectionTable) , sizeof ( SgAsmNESectionTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNESectionTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNESectionTableStorageClass* storageArray = storageArraySgAsmNESectionTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNESectionTable ( *storageArray ) ; 
#else
               SgAsmNESectionTable* tmp = new SgAsmNESectionTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNESectionTable;  
      SgAsmNESectionTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNESectionTableEntry ); 
     SgAsmNESectionTableEntryStorageClass* storageArraySgAsmNESectionTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNESectionTableEntry = new SgAsmNESectionTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNESectionTableEntry) , sizeof ( SgAsmNESectionTableEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmNESectionTableEntryStorageClass* storageArray = storageArraySgAsmNESectionTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNESectionTableEntry ( *storageArray ) ; 
#else
               SgAsmNESectionTableEntry* tmp = new SgAsmNESectionTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNESectionTableEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEStringTable ); 
     SgAsmNEStringTableStorageClass* storageArraySgAsmNEStringTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEStringTable = new SgAsmNEStringTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEStringTable) , sizeof ( SgAsmNEStringTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNEStringTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNEStringTableStorageClass* storageArray = storageArraySgAsmNEStringTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNEStringTable ( *storageArray ) ; 
#else
               SgAsmNEStringTable* tmp = new SgAsmNEStringTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEStringTable;  
      SgAsmNEStringTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNode ); 
     SgAsmNodeStorageClass* storageArraySgAsmNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNode = new SgAsmNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNode) , sizeof ( SgAsmNodeStorageClass ) * sizeOfActualPool) ;
          SgAsmNodeStorageClass* storageArray = storageArraySgAsmNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNode ( *storageArray ) ; 
#else
               SgAsmNode* tmp = new SgAsmNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNode;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmOp ); 
     SgAsmOpStorageClass* storageArraySgAsmOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmOp = new SgAsmOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmOp) , sizeof ( SgAsmOpStorageClass ) * sizeOfActualPool) ;
        SgAsmOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmOpStorageClass* storageArray = storageArraySgAsmOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmOp ( *storageArray ) ; 
#else
               SgAsmOp* tmp = new SgAsmOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmOp;  
      SgAsmOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmOperandList ); 
     SgAsmOperandListStorageClass* storageArraySgAsmOperandList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmOperandList = new SgAsmOperandListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmOperandList) , sizeof ( SgAsmOperandListStorageClass ) * sizeOfActualPool) ;
        SgAsmOperandListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmOperandListStorageClass* storageArray = storageArraySgAsmOperandList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmOperandList ( *storageArray ) ; 
#else
               SgAsmOperandList* tmp = new SgAsmOperandList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmOperandList;  
      SgAsmOperandListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEExportDirectory ); 
     SgAsmPEExportDirectoryStorageClass* storageArraySgAsmPEExportDirectory = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEExportDirectory = new SgAsmPEExportDirectoryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEExportDirectory) , sizeof ( SgAsmPEExportDirectoryStorageClass ) * sizeOfActualPool) ;
          SgAsmPEExportDirectoryStorageClass* storageArray = storageArraySgAsmPEExportDirectory;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEExportDirectory ( *storageArray ) ; 
#else
               SgAsmPEExportDirectory* tmp = new SgAsmPEExportDirectory ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEExportDirectory;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEExportEntry ); 
     SgAsmPEExportEntryStorageClass* storageArraySgAsmPEExportEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEExportEntry = new SgAsmPEExportEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEExportEntry) , sizeof ( SgAsmPEExportEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmPEExportEntryStorageClass* storageArray = storageArraySgAsmPEExportEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEExportEntry ( *storageArray ) ; 
#else
               SgAsmPEExportEntry* tmp = new SgAsmPEExportEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEExportEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEExportEntryList ); 
     SgAsmPEExportEntryListStorageClass* storageArraySgAsmPEExportEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEExportEntryList = new SgAsmPEExportEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEExportEntryList) , sizeof ( SgAsmPEExportEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmPEExportEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEExportEntryListStorageClass* storageArray = storageArraySgAsmPEExportEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEExportEntryList ( *storageArray ) ; 
#else
               SgAsmPEExportEntryList* tmp = new SgAsmPEExportEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEExportEntryList;  
      SgAsmPEExportEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEExportSection ); 
     SgAsmPEExportSectionStorageClass* storageArraySgAsmPEExportSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEExportSection = new SgAsmPEExportSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEExportSection) , sizeof ( SgAsmPEExportSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmPEExportSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEExportSectionStorageClass* storageArray = storageArraySgAsmPEExportSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEExportSection ( *storageArray ) ; 
#else
               SgAsmPEExportSection* tmp = new SgAsmPEExportSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEExportSection;  
      SgAsmPEExportSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEFileHeader ); 
     SgAsmPEFileHeaderStorageClass* storageArraySgAsmPEFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEFileHeader = new SgAsmPEFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEFileHeader) , sizeof ( SgAsmPEFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmPEFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEFileHeaderStorageClass* storageArray = storageArraySgAsmPEFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEFileHeader ( *storageArray ) ; 
#else
               SgAsmPEFileHeader* tmp = new SgAsmPEFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEFileHeader;  
      SgAsmPEFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportDirectory ); 
     SgAsmPEImportDirectoryStorageClass* storageArraySgAsmPEImportDirectory = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportDirectory = new SgAsmPEImportDirectoryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportDirectory) , sizeof ( SgAsmPEImportDirectoryStorageClass ) * sizeOfActualPool) ;
          SgAsmPEImportDirectoryStorageClass* storageArray = storageArraySgAsmPEImportDirectory;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEImportDirectory ( *storageArray ) ; 
#else
               SgAsmPEImportDirectory* tmp = new SgAsmPEImportDirectory ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportDirectory;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportDirectoryList ); 
     SgAsmPEImportDirectoryListStorageClass* storageArraySgAsmPEImportDirectoryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportDirectoryList = new SgAsmPEImportDirectoryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportDirectoryList) , sizeof ( SgAsmPEImportDirectoryListStorageClass ) * sizeOfActualPool) ;
        SgAsmPEImportDirectoryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEImportDirectoryListStorageClass* storageArray = storageArraySgAsmPEImportDirectoryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEImportDirectoryList ( *storageArray ) ; 
#else
               SgAsmPEImportDirectoryList* tmp = new SgAsmPEImportDirectoryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportDirectoryList;  
      SgAsmPEImportDirectoryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportItem ); 
     SgAsmPEImportItemStorageClass* storageArraySgAsmPEImportItem = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportItem = new SgAsmPEImportItemStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportItem) , sizeof ( SgAsmPEImportItemStorageClass ) * sizeOfActualPool) ;
          SgAsmPEImportItemStorageClass* storageArray = storageArraySgAsmPEImportItem;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEImportItem ( *storageArray ) ; 
#else
               SgAsmPEImportItem* tmp = new SgAsmPEImportItem ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportItem;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportItemList ); 
     SgAsmPEImportItemListStorageClass* storageArraySgAsmPEImportItemList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportItemList = new SgAsmPEImportItemListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportItemList) , sizeof ( SgAsmPEImportItemListStorageClass ) * sizeOfActualPool) ;
        SgAsmPEImportItemListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEImportItemListStorageClass* storageArray = storageArraySgAsmPEImportItemList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEImportItemList ( *storageArray ) ; 
#else
               SgAsmPEImportItemList* tmp = new SgAsmPEImportItemList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportItemList;  
      SgAsmPEImportItemListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportSection ); 
     SgAsmPEImportSectionStorageClass* storageArraySgAsmPEImportSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportSection = new SgAsmPEImportSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportSection) , sizeof ( SgAsmPEImportSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmPEImportSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEImportSectionStorageClass* storageArray = storageArraySgAsmPEImportSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEImportSection ( *storageArray ) ; 
#else
               SgAsmPEImportSection* tmp = new SgAsmPEImportSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportSection;  
      SgAsmPEImportSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPERVASizePair ); 
     SgAsmPERVASizePairStorageClass* storageArraySgAsmPERVASizePair = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPERVASizePair = new SgAsmPERVASizePairStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPERVASizePair) , sizeof ( SgAsmPERVASizePairStorageClass ) * sizeOfActualPool) ;
          SgAsmPERVASizePairStorageClass* storageArray = storageArraySgAsmPERVASizePair;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPERVASizePair ( *storageArray ) ; 
#else
               SgAsmPERVASizePair* tmp = new SgAsmPERVASizePair ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPERVASizePair;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPERVASizePairList ); 
     SgAsmPERVASizePairListStorageClass* storageArraySgAsmPERVASizePairList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPERVASizePairList = new SgAsmPERVASizePairListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPERVASizePairList) , sizeof ( SgAsmPERVASizePairListStorageClass ) * sizeOfActualPool) ;
        SgAsmPERVASizePairListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPERVASizePairListStorageClass* storageArray = storageArraySgAsmPERVASizePairList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPERVASizePairList ( *storageArray ) ; 
#else
               SgAsmPERVASizePairList* tmp = new SgAsmPERVASizePairList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPERVASizePairList;  
      SgAsmPERVASizePairListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPESection ); 
     SgAsmPESectionStorageClass* storageArraySgAsmPESection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPESection = new SgAsmPESectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPESection) , sizeof ( SgAsmPESectionStorageClass ) * sizeOfActualPool) ;
        SgAsmPESectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPESectionStorageClass* storageArray = storageArraySgAsmPESection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPESection ( *storageArray ) ; 
#else
               SgAsmPESection* tmp = new SgAsmPESection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPESection;  
      SgAsmPESectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPESectionTable ); 
     SgAsmPESectionTableStorageClass* storageArraySgAsmPESectionTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPESectionTable = new SgAsmPESectionTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPESectionTable) , sizeof ( SgAsmPESectionTableStorageClass ) * sizeOfActualPool) ;
        SgAsmPESectionTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPESectionTableStorageClass* storageArray = storageArraySgAsmPESectionTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPESectionTable ( *storageArray ) ; 
#else
               SgAsmPESectionTable* tmp = new SgAsmPESectionTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPESectionTable;  
      SgAsmPESectionTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPESectionTableEntry ); 
     SgAsmPESectionTableEntryStorageClass* storageArraySgAsmPESectionTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPESectionTableEntry = new SgAsmPESectionTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPESectionTableEntry) , sizeof ( SgAsmPESectionTableEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmPESectionTableEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPESectionTableEntryStorageClass* storageArray = storageArraySgAsmPESectionTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPESectionTableEntry ( *storageArray ) ; 
#else
               SgAsmPESectionTableEntry* tmp = new SgAsmPESectionTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPESectionTableEntry;  
      SgAsmPESectionTableEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEStringSection ); 
     SgAsmPEStringSectionStorageClass* storageArraySgAsmPEStringSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEStringSection = new SgAsmPEStringSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEStringSection) , sizeof ( SgAsmPEStringSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmPEStringSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEStringSectionStorageClass* storageArray = storageArraySgAsmPEStringSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPEStringSection ( *storageArray ) ; 
#else
               SgAsmPEStringSection* tmp = new SgAsmPEStringSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEStringSection;  
      SgAsmPEStringSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPowerpcInstruction ); 
     SgAsmPowerpcInstructionStorageClass* storageArraySgAsmPowerpcInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPowerpcInstruction = new SgAsmPowerpcInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPowerpcInstruction) , sizeof ( SgAsmPowerpcInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmPowerpcInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPowerpcInstructionStorageClass* storageArray = storageArraySgAsmPowerpcInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPowerpcInstruction ( *storageArray ) ; 
#else
               SgAsmPowerpcInstruction* tmp = new SgAsmPowerpcInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPowerpcInstruction;  
      SgAsmPowerpcInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmRegisterNames ); 
     SgAsmRegisterNamesStorageClass* storageArraySgAsmRegisterNames = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmRegisterNames = new SgAsmRegisterNamesStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmRegisterNames) , sizeof ( SgAsmRegisterNamesStorageClass ) * sizeOfActualPool) ;
        SgAsmRegisterNamesStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmRegisterNamesStorageClass* storageArray = storageArraySgAsmRegisterNames;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmRegisterNames ( *storageArray ) ; 
#else
               SgAsmRegisterNames* tmp = new SgAsmRegisterNames ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmRegisterNames;  
      SgAsmRegisterNamesStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmRegisterReferenceExpression ); 
     SgAsmRegisterReferenceExpressionStorageClass* storageArraySgAsmRegisterReferenceExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmRegisterReferenceExpression = new SgAsmRegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmRegisterReferenceExpression) , sizeof ( SgAsmRegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmRegisterReferenceExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmRegisterReferenceExpressionStorageClass* storageArray = storageArraySgAsmRegisterReferenceExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmRegisterReferenceExpression ( *storageArray ) ; 
#else
               SgAsmRegisterReferenceExpression* tmp = new SgAsmRegisterReferenceExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmRegisterReferenceExpression;  
      SgAsmRegisterReferenceExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmRiscOperation ); 
     SgAsmRiscOperationStorageClass* storageArraySgAsmRiscOperation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmRiscOperation = new SgAsmRiscOperationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmRiscOperation) , sizeof ( SgAsmRiscOperationStorageClass ) * sizeOfActualPool) ;
        SgAsmRiscOperationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmRiscOperationStorageClass* storageArray = storageArraySgAsmRiscOperation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmRiscOperation ( *storageArray ) ; 
#else
               SgAsmRiscOperation* tmp = new SgAsmRiscOperation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmRiscOperation;  
      SgAsmRiscOperationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmScalarType ); 
     SgAsmScalarTypeStorageClass* storageArraySgAsmScalarType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmScalarType = new SgAsmScalarTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmScalarType) , sizeof ( SgAsmScalarTypeStorageClass ) * sizeOfActualPool) ;
          SgAsmScalarTypeStorageClass* storageArray = storageArraySgAsmScalarType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmScalarType ( *storageArray ) ; 
#else
               SgAsmScalarType* tmp = new SgAsmScalarType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmScalarType;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStatement ); 
     SgAsmStatementStorageClass* storageArraySgAsmStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStatement = new SgAsmStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStatement) , sizeof ( SgAsmStatementStorageClass ) * sizeOfActualPool) ;
        SgAsmStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStatementStorageClass* storageArray = storageArraySgAsmStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmStatement ( *storageArray ) ; 
#else
               SgAsmStatement* tmp = new SgAsmStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStatement;  
      SgAsmStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStaticData ); 
     SgAsmStaticDataStorageClass* storageArraySgAsmStaticData = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStaticData = new SgAsmStaticDataStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStaticData) , sizeof ( SgAsmStaticDataStorageClass ) * sizeOfActualPool) ;
        SgAsmStaticDataStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStaticDataStorageClass* storageArray = storageArraySgAsmStaticData;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmStaticData ( *storageArray ) ; 
#else
               SgAsmStaticData* tmp = new SgAsmStaticData ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStaticData;  
      SgAsmStaticDataStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStmt ); 
     SgAsmStmtStorageClass* storageArraySgAsmStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStmt = new SgAsmStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStmt) , sizeof ( SgAsmStmtStorageClass ) * sizeOfActualPool) ;
        SgAsmStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStmtStorageClass* storageArray = storageArraySgAsmStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmStmt ( *storageArray ) ; 
#else
               SgAsmStmt* tmp = new SgAsmStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStmt;  
      SgAsmStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStoredString ); 
     SgAsmStoredStringStorageClass* storageArraySgAsmStoredString = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStoredString = new SgAsmStoredStringStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStoredString) , sizeof ( SgAsmStoredStringStorageClass ) * sizeOfActualPool) ;
          SgAsmStoredStringStorageClass* storageArray = storageArraySgAsmStoredString;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmStoredString ( *storageArray ) ; 
#else
               SgAsmStoredString* tmp = new SgAsmStoredString ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStoredString;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStringStorage ); 
     SgAsmStringStorageStorageClass* storageArraySgAsmStringStorage = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStringStorage = new SgAsmStringStorageStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStringStorage) , sizeof ( SgAsmStringStorageStorageClass ) * sizeOfActualPool) ;
        SgAsmStringStorageStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStringStorageStorageClass* storageArray = storageArraySgAsmStringStorage;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmStringStorage ( *storageArray ) ; 
#else
               SgAsmStringStorage* tmp = new SgAsmStringStorage ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStringStorage;  
      SgAsmStringStorageStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmType ); 
     SgAsmTypeStorageClass* storageArraySgAsmType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmType = new SgAsmTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmType) , sizeof ( SgAsmTypeStorageClass ) * sizeOfActualPool) ;
          SgAsmTypeStorageClass* storageArray = storageArraySgAsmType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmType ( *storageArray ) ; 
#else
               SgAsmType* tmp = new SgAsmType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmType;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryExpression ); 
     SgAsmUnaryExpressionStorageClass* storageArraySgAsmUnaryExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryExpression = new SgAsmUnaryExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryExpression) , sizeof ( SgAsmUnaryExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryExpressionStorageClass* storageArray = storageArraySgAsmUnaryExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmUnaryExpression ( *storageArray ) ; 
#else
               SgAsmUnaryExpression* tmp = new SgAsmUnaryExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryExpression;  
      SgAsmUnaryExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryMinus ); 
     SgAsmUnaryMinusStorageClass* storageArraySgAsmUnaryMinus = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryMinus = new SgAsmUnaryMinusStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryMinus) , sizeof ( SgAsmUnaryMinusStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryMinusStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryMinusStorageClass* storageArray = storageArraySgAsmUnaryMinus;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmUnaryMinus ( *storageArray ) ; 
#else
               SgAsmUnaryMinus* tmp = new SgAsmUnaryMinus ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryMinus;  
      SgAsmUnaryMinusStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryPlus ); 
     SgAsmUnaryPlusStorageClass* storageArraySgAsmUnaryPlus = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryPlus = new SgAsmUnaryPlusStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryPlus) , sizeof ( SgAsmUnaryPlusStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryPlusStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryPlusStorageClass* storageArray = storageArraySgAsmUnaryPlus;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmUnaryPlus ( *storageArray ) ; 
#else
               SgAsmUnaryPlus* tmp = new SgAsmUnaryPlus ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryPlus;  
      SgAsmUnaryPlusStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryRrx ); 
     SgAsmUnaryRrxStorageClass* storageArraySgAsmUnaryRrx = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryRrx = new SgAsmUnaryRrxStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryRrx) , sizeof ( SgAsmUnaryRrxStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryRrxStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryRrxStorageClass* storageArray = storageArraySgAsmUnaryRrx;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmUnaryRrx ( *storageArray ) ; 
#else
               SgAsmUnaryRrx* tmp = new SgAsmUnaryRrx ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryRrx;  
      SgAsmUnaryRrxStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnarySignedExtend ); 
     SgAsmUnarySignedExtendStorageClass* storageArraySgAsmUnarySignedExtend = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnarySignedExtend = new SgAsmUnarySignedExtendStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnarySignedExtend) , sizeof ( SgAsmUnarySignedExtendStorageClass ) * sizeOfActualPool) ;
        SgAsmUnarySignedExtendStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnarySignedExtendStorageClass* storageArray = storageArraySgAsmUnarySignedExtend;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmUnarySignedExtend ( *storageArray ) ; 
#else
               SgAsmUnarySignedExtend* tmp = new SgAsmUnarySignedExtend ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnarySignedExtend;  
      SgAsmUnarySignedExtendStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryUnsignedExtend ); 
     SgAsmUnaryUnsignedExtendStorageClass* storageArraySgAsmUnaryUnsignedExtend = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryUnsignedExtend = new SgAsmUnaryUnsignedExtendStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryUnsignedExtend) , sizeof ( SgAsmUnaryUnsignedExtendStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryUnsignedExtendStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryUnsignedExtendStorageClass* storageArray = storageArraySgAsmUnaryUnsignedExtend;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmUnaryUnsignedExtend ( *storageArray ) ; 
#else
               SgAsmUnaryUnsignedExtend* tmp = new SgAsmUnaryUnsignedExtend ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryUnsignedExtend;  
      SgAsmUnaryUnsignedExtendStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryTruncate ); 
     SgAsmUnaryTruncateStorageClass* storageArraySgAsmUnaryTruncate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryTruncate = new SgAsmUnaryTruncateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryTruncate) , sizeof ( SgAsmUnaryTruncateStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryTruncateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryTruncateStorageClass* storageArray = storageArraySgAsmUnaryTruncate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmUnaryTruncate ( *storageArray ) ; 
#else
               SgAsmUnaryTruncate* tmp = new SgAsmUnaryTruncate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryTruncate;  
      SgAsmUnaryTruncateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmValueExpression ); 
     SgAsmValueExpressionStorageClass* storageArraySgAsmValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmValueExpression = new SgAsmValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmValueExpression) , sizeof ( SgAsmValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmValueExpressionStorageClass* storageArray = storageArraySgAsmValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmValueExpression ( *storageArray ) ; 
#else
               SgAsmValueExpression* tmp = new SgAsmValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmValueExpression;  
      SgAsmValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmVectorType ); 
     SgAsmVectorTypeStorageClass* storageArraySgAsmVectorType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmVectorType = new SgAsmVectorTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmVectorType) , sizeof ( SgAsmVectorTypeStorageClass ) * sizeOfActualPool) ;
          SgAsmVectorTypeStorageClass* storageArray = storageArraySgAsmVectorType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmVectorType ( *storageArray ) ; 
#else
               SgAsmVectorType* tmp = new SgAsmVectorType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmVectorType;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmX86Instruction ); 
     SgAsmX86InstructionStorageClass* storageArraySgAsmX86Instruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmX86Instruction = new SgAsmX86InstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmX86Instruction) , sizeof ( SgAsmX86InstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmX86InstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmX86InstructionStorageClass* storageArray = storageArraySgAsmX86Instruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmX86Instruction ( *storageArray ) ; 
#else
               SgAsmX86Instruction* tmp = new SgAsmX86Instruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmX86Instruction;  
      SgAsmX86InstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryAddressSymbol ); 
     SgAsmBinaryAddressSymbolStorageClass* storageArraySgAsmBinaryAddressSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryAddressSymbol = new SgAsmBinaryAddressSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryAddressSymbol) , sizeof ( SgAsmBinaryAddressSymbolStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryAddressSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryAddressSymbolStorageClass* storageArray = storageArraySgAsmBinaryAddressSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryAddressSymbol ( *storageArray ) ; 
#else
               SgAsmBinaryAddressSymbol* tmp = new SgAsmBinaryAddressSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryAddressSymbol;  
      SgAsmBinaryAddressSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryDataSymbol ); 
     SgAsmBinaryDataSymbolStorageClass* storageArraySgAsmBinaryDataSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryDataSymbol = new SgAsmBinaryDataSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryDataSymbol) , sizeof ( SgAsmBinaryDataSymbolStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryDataSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryDataSymbolStorageClass* storageArray = storageArraySgAsmBinaryDataSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryDataSymbol ( *storageArray ) ; 
#else
               SgAsmBinaryDataSymbol* tmp = new SgAsmBinaryDataSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryDataSymbol;  
      SgAsmBinaryDataSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssertStmt ); 
     SgAssertStmtStorageClass* storageArraySgAssertStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssertStmt = new SgAssertStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssertStmt) , sizeof ( SgAssertStmtStorageClass ) * sizeOfActualPool) ;
        SgAssertStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssertStmtStorageClass* storageArray = storageArraySgAssertStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAssertStmt ( *storageArray ) ; 
#else
               SgAssertStmt* tmp = new SgAssertStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssertStmt;  
      SgAssertStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssignInitializer ); 
     SgAssignInitializerStorageClass* storageArraySgAssignInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssignInitializer = new SgAssignInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssignInitializer) , sizeof ( SgAssignInitializerStorageClass ) * sizeOfActualPool) ;
        SgAssignInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssignInitializerStorageClass* storageArray = storageArraySgAssignInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAssignInitializer ( *storageArray ) ; 
#else
               SgAssignInitializer* tmp = new SgAssignInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssignInitializer;  
      SgAssignInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssignOp ); 
     SgAssignOpStorageClass* storageArraySgAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssignOp = new SgAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssignOp) , sizeof ( SgAssignOpStorageClass ) * sizeOfActualPool) ;
        SgAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssignOpStorageClass* storageArray = storageArraySgAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAssignOp ( *storageArray ) ; 
#else
               SgAssignOp* tmp = new SgAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssignOp;  
      SgAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssignStatement ); 
     SgAssignStatementStorageClass* storageArraySgAssignStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssignStatement = new SgAssignStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssignStatement) , sizeof ( SgAssignStatementStorageClass ) * sizeOfActualPool) ;
        SgAssignStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssignStatementStorageClass* storageArray = storageArraySgAssignStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAssignStatement ( *storageArray ) ; 
#else
               SgAssignStatement* tmp = new SgAssignStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssignStatement;  
      SgAssignStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssignedGotoStatement ); 
     SgAssignedGotoStatementStorageClass* storageArraySgAssignedGotoStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssignedGotoStatement = new SgAssignedGotoStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssignedGotoStatement) , sizeof ( SgAssignedGotoStatementStorageClass ) * sizeOfActualPool) ;
        SgAssignedGotoStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssignedGotoStatementStorageClass* storageArray = storageArraySgAssignedGotoStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAssignedGotoStatement ( *storageArray ) ; 
#else
               SgAssignedGotoStatement* tmp = new SgAssignedGotoStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssignedGotoStatement;  
      SgAssignedGotoStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssociateStatement ); 
     SgAssociateStatementStorageClass* storageArraySgAssociateStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssociateStatement = new SgAssociateStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssociateStatement) , sizeof ( SgAssociateStatementStorageClass ) * sizeOfActualPool) ;
        SgAssociateStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssociateStatementStorageClass* storageArray = storageArraySgAssociateStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAssociateStatement ( *storageArray ) ; 
#else
               SgAssociateStatement* tmp = new SgAssociateStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssociateStatement;  
      SgAssociateStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsteriskShapeExp ); 
     SgAsteriskShapeExpStorageClass* storageArraySgAsteriskShapeExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsteriskShapeExp = new SgAsteriskShapeExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsteriskShapeExp) , sizeof ( SgAsteriskShapeExpStorageClass ) * sizeOfActualPool) ;
        SgAsteriskShapeExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsteriskShapeExpStorageClass* storageArray = storageArraySgAsteriskShapeExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsteriskShapeExp ( *storageArray ) ; 
#else
               SgAsteriskShapeExp* tmp = new SgAsteriskShapeExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsteriskShapeExp;  
      SgAsteriskShapeExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAtOp ); 
     SgAtOpStorageClass* storageArraySgAtOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAtOp = new SgAtOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAtOp) , sizeof ( SgAtOpStorageClass ) * sizeOfActualPool) ;
        SgAtOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAtOpStorageClass* storageArray = storageArraySgAtOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAtOp ( *storageArray ) ; 
#else
               SgAtOp* tmp = new SgAtOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAtOp;  
      SgAtOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAttribute ); 
     SgAttributeStorageClass* storageArraySgAttribute = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAttribute = new SgAttributeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAttribute) , sizeof ( SgAttributeStorageClass ) * sizeOfActualPool) ;
        SgAttributeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAttributeStorageClass* storageArray = storageArraySgAttribute;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAttribute ( *storageArray ) ; 
#else
               SgAttribute* tmp = new SgAttribute ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAttribute;  
      SgAttributeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAttributeSpecificationStatement ); 
     SgAttributeSpecificationStatementStorageClass* storageArraySgAttributeSpecificationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAttributeSpecificationStatement = new SgAttributeSpecificationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAttributeSpecificationStatement) , sizeof ( SgAttributeSpecificationStatementStorageClass ) * sizeOfActualPool) ;
        SgAttributeSpecificationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAttributeSpecificationStatementStorageClass* storageArray = storageArraySgAttributeSpecificationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAttributeSpecificationStatement ( *storageArray ) ; 
#else
               SgAttributeSpecificationStatement* tmp = new SgAttributeSpecificationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAttributeSpecificationStatement;  
      SgAttributeSpecificationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAutoType ); 
     SgAutoTypeStorageClass* storageArraySgAutoType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAutoType = new SgAutoTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAutoType) , sizeof ( SgAutoTypeStorageClass ) * sizeOfActualPool) ;
        SgAutoTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAutoTypeStorageClass* storageArray = storageArraySgAutoType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAutoType ( *storageArray ) ; 
#else
               SgAutoType* tmp = new SgAutoType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAutoType;  
      SgAutoTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAwaitExpression ); 
     SgAwaitExpressionStorageClass* storageArraySgAwaitExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAwaitExpression = new SgAwaitExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAwaitExpression) , sizeof ( SgAwaitExpressionStorageClass ) * sizeOfActualPool) ;
        SgAwaitExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAwaitExpressionStorageClass* storageArray = storageArraySgAwaitExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAwaitExpression ( *storageArray ) ; 
#else
               SgAwaitExpression* tmp = new SgAwaitExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAwaitExpression;  
      SgAwaitExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBackspaceStatement ); 
     SgBackspaceStatementStorageClass* storageArraySgBackspaceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBackspaceStatement = new SgBackspaceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBackspaceStatement) , sizeof ( SgBackspaceStatementStorageClass ) * sizeOfActualPool) ;
        SgBackspaceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBackspaceStatementStorageClass* storageArray = storageArraySgBackspaceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBackspaceStatement ( *storageArray ) ; 
#else
               SgBackspaceStatement* tmp = new SgBackspaceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBackspaceStatement;  
      SgBackspaceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBaseClass ); 
     SgBaseClassStorageClass* storageArraySgBaseClass = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBaseClass = new SgBaseClassStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBaseClass) , sizeof ( SgBaseClassStorageClass ) * sizeOfActualPool) ;
          SgBaseClassStorageClass* storageArray = storageArraySgBaseClass;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBaseClass ( *storageArray ) ; 
#else
               SgBaseClass* tmp = new SgBaseClass ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBaseClass;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExpBaseClass ); 
     SgExpBaseClassStorageClass* storageArraySgExpBaseClass = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExpBaseClass = new SgExpBaseClassStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExpBaseClass) , sizeof ( SgExpBaseClassStorageClass ) * sizeOfActualPool) ;
          SgExpBaseClassStorageClass* storageArray = storageArraySgExpBaseClass;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgExpBaseClass ( *storageArray ) ; 
#else
               SgExpBaseClass* tmp = new SgExpBaseClass ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExpBaseClass;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBaseClassModifier ); 
     SgBaseClassModifierStorageClass* storageArraySgBaseClassModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBaseClassModifier = new SgBaseClassModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBaseClassModifier) , sizeof ( SgBaseClassModifierStorageClass ) * sizeOfActualPool) ;
        SgBaseClassModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBaseClassModifierStorageClass* storageArray = storageArraySgBaseClassModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBaseClassModifier ( *storageArray ) ; 
#else
               SgBaseClassModifier* tmp = new SgBaseClassModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBaseClassModifier;  
      SgBaseClassModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBasicBlock ); 
     SgBasicBlockStorageClass* storageArraySgBasicBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBasicBlock = new SgBasicBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBasicBlock) , sizeof ( SgBasicBlockStorageClass ) * sizeOfActualPool) ;
        SgBasicBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBasicBlockStorageClass* storageArray = storageArraySgBasicBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBasicBlock ( *storageArray ) ; 
#else
               SgBasicBlock* tmp = new SgBasicBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBasicBlock;  
      SgBasicBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBidirectionalGraph ); 
     SgBidirectionalGraphStorageClass* storageArraySgBidirectionalGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBidirectionalGraph = new SgBidirectionalGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBidirectionalGraph) , sizeof ( SgBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
        SgBidirectionalGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBidirectionalGraphStorageClass* storageArray = storageArraySgBidirectionalGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBidirectionalGraph ( *storageArray ) ; 
#else
               SgBidirectionalGraph* tmp = new SgBidirectionalGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBidirectionalGraph;  
      SgBidirectionalGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBinaryComposite ); 
     SgBinaryCompositeStorageClass* storageArraySgBinaryComposite = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBinaryComposite = new SgBinaryCompositeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBinaryComposite) , sizeof ( SgBinaryCompositeStorageClass ) * sizeOfActualPool) ;
        SgBinaryCompositeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBinaryCompositeStorageClass* storageArray = storageArraySgBinaryComposite;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBinaryComposite ( *storageArray ) ; 
#else
               SgBinaryComposite* tmp = new SgBinaryComposite ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBinaryComposite;  
      SgBinaryCompositeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBinaryOp ); 
     SgBinaryOpStorageClass* storageArraySgBinaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBinaryOp = new SgBinaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBinaryOp) , sizeof ( SgBinaryOpStorageClass ) * sizeOfActualPool) ;
        SgBinaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBinaryOpStorageClass* storageArray = storageArraySgBinaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBinaryOp ( *storageArray ) ; 
#else
               SgBinaryOp* tmp = new SgBinaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBinaryOp;  
      SgBinaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitAndOp ); 
     SgBitAndOpStorageClass* storageArraySgBitAndOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitAndOp = new SgBitAndOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitAndOp) , sizeof ( SgBitAndOpStorageClass ) * sizeOfActualPool) ;
        SgBitAndOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitAndOpStorageClass* storageArray = storageArraySgBitAndOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBitAndOp ( *storageArray ) ; 
#else
               SgBitAndOp* tmp = new SgBitAndOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitAndOp;  
      SgBitAndOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitAttribute ); 
     SgBitAttributeStorageClass* storageArraySgBitAttribute = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitAttribute = new SgBitAttributeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitAttribute) , sizeof ( SgBitAttributeStorageClass ) * sizeOfActualPool) ;
        SgBitAttributeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitAttributeStorageClass* storageArray = storageArraySgBitAttribute;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBitAttribute ( *storageArray ) ; 
#else
               SgBitAttribute* tmp = new SgBitAttribute ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitAttribute;  
      SgBitAttributeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitComplementOp ); 
     SgBitComplementOpStorageClass* storageArraySgBitComplementOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitComplementOp = new SgBitComplementOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitComplementOp) , sizeof ( SgBitComplementOpStorageClass ) * sizeOfActualPool) ;
        SgBitComplementOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitComplementOpStorageClass* storageArray = storageArraySgBitComplementOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBitComplementOp ( *storageArray ) ; 
#else
               SgBitComplementOp* tmp = new SgBitComplementOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitComplementOp;  
      SgBitComplementOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitEqvOp ); 
     SgBitEqvOpStorageClass* storageArraySgBitEqvOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitEqvOp = new SgBitEqvOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitEqvOp) , sizeof ( SgBitEqvOpStorageClass ) * sizeOfActualPool) ;
        SgBitEqvOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitEqvOpStorageClass* storageArray = storageArraySgBitEqvOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBitEqvOp ( *storageArray ) ; 
#else
               SgBitEqvOp* tmp = new SgBitEqvOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitEqvOp;  
      SgBitEqvOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitOrOp ); 
     SgBitOrOpStorageClass* storageArraySgBitOrOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitOrOp = new SgBitOrOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitOrOp) , sizeof ( SgBitOrOpStorageClass ) * sizeOfActualPool) ;
        SgBitOrOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitOrOpStorageClass* storageArray = storageArraySgBitOrOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBitOrOp ( *storageArray ) ; 
#else
               SgBitOrOp* tmp = new SgBitOrOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitOrOp;  
      SgBitOrOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitXorOp ); 
     SgBitXorOpStorageClass* storageArraySgBitXorOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitXorOp = new SgBitXorOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitXorOp) , sizeof ( SgBitXorOpStorageClass ) * sizeOfActualPool) ;
        SgBitXorOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitXorOpStorageClass* storageArray = storageArraySgBitXorOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBitXorOp ( *storageArray ) ; 
#else
               SgBitXorOp* tmp = new SgBitXorOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitXorOp;  
      SgBitXorOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBlockDataStatement ); 
     SgBlockDataStatementStorageClass* storageArraySgBlockDataStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBlockDataStatement = new SgBlockDataStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBlockDataStatement) , sizeof ( SgBlockDataStatementStorageClass ) * sizeOfActualPool) ;
        SgBlockDataStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBlockDataStatementStorageClass* storageArray = storageArraySgBlockDataStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBlockDataStatement ( *storageArray ) ; 
#else
               SgBlockDataStatement* tmp = new SgBlockDataStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBlockDataStatement;  
      SgBlockDataStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBoolValExp ); 
     SgBoolValExpStorageClass* storageArraySgBoolValExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBoolValExp = new SgBoolValExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBoolValExp) , sizeof ( SgBoolValExpStorageClass ) * sizeOfActualPool) ;
        SgBoolValExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBoolValExpStorageClass* storageArray = storageArraySgBoolValExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBoolValExp ( *storageArray ) ; 
#else
               SgBoolValExp* tmp = new SgBoolValExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBoolValExp;  
      SgBoolValExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBreakStmt ); 
     SgBreakStmtStorageClass* storageArraySgBreakStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBreakStmt = new SgBreakStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBreakStmt) , sizeof ( SgBreakStmtStorageClass ) * sizeOfActualPool) ;
        SgBreakStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBreakStmtStorageClass* storageArray = storageArraySgBreakStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBreakStmt ( *storageArray ) ; 
#else
               SgBreakStmt* tmp = new SgBreakStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBreakStmt;  
      SgBreakStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBracedInitializer ); 
     SgBracedInitializerStorageClass* storageArraySgBracedInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBracedInitializer = new SgBracedInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBracedInitializer) , sizeof ( SgBracedInitializerStorageClass ) * sizeOfActualPool) ;
        SgBracedInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBracedInitializerStorageClass* storageArray = storageArraySgBracedInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgBracedInitializer ( *storageArray ) ; 
#else
               SgBracedInitializer* tmp = new SgBracedInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBracedInitializer;  
      SgBracedInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgC_PreprocessorDirectiveStatement ); 
     SgC_PreprocessorDirectiveStatementStorageClass* storageArraySgC_PreprocessorDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgC_PreprocessorDirectiveStatement = new SgC_PreprocessorDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgC_PreprocessorDirectiveStatement) , sizeof ( SgC_PreprocessorDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgC_PreprocessorDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgC_PreprocessorDirectiveStatementStorageClass* storageArray = storageArraySgC_PreprocessorDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgC_PreprocessorDirectiveStatement ( *storageArray ) ; 
#else
               SgC_PreprocessorDirectiveStatement* tmp = new SgC_PreprocessorDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgC_PreprocessorDirectiveStatement;  
      SgC_PreprocessorDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCaseOptionStmt ); 
     SgCaseOptionStmtStorageClass* storageArraySgCaseOptionStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCaseOptionStmt = new SgCaseOptionStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCaseOptionStmt) , sizeof ( SgCaseOptionStmtStorageClass ) * sizeOfActualPool) ;
        SgCaseOptionStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCaseOptionStmtStorageClass* storageArray = storageArraySgCaseOptionStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCaseOptionStmt ( *storageArray ) ; 
#else
               SgCaseOptionStmt* tmp = new SgCaseOptionStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCaseOptionStmt;  
      SgCaseOptionStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCastExp ); 
     SgCastExpStorageClass* storageArraySgCastExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCastExp = new SgCastExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCastExp) , sizeof ( SgCastExpStorageClass ) * sizeOfActualPool) ;
        SgCastExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCastExpStorageClass* storageArray = storageArraySgCastExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCastExp ( *storageArray ) ; 
#else
               SgCastExp* tmp = new SgCastExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCastExp;  
      SgCastExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCatchOptionStmt ); 
     SgCatchOptionStmtStorageClass* storageArraySgCatchOptionStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCatchOptionStmt = new SgCatchOptionStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCatchOptionStmt) , sizeof ( SgCatchOptionStmtStorageClass ) * sizeOfActualPool) ;
        SgCatchOptionStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCatchOptionStmtStorageClass* storageArray = storageArraySgCatchOptionStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCatchOptionStmt ( *storageArray ) ; 
#else
               SgCatchOptionStmt* tmp = new SgCatchOptionStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCatchOptionStmt;  
      SgCatchOptionStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCatchStatementSeq ); 
     SgCatchStatementSeqStorageClass* storageArraySgCatchStatementSeq = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCatchStatementSeq = new SgCatchStatementSeqStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCatchStatementSeq) , sizeof ( SgCatchStatementSeqStorageClass ) * sizeOfActualPool) ;
        SgCatchStatementSeqStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCatchStatementSeqStorageClass* storageArray = storageArraySgCatchStatementSeq;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCatchStatementSeq ( *storageArray ) ; 
#else
               SgCatchStatementSeq* tmp = new SgCatchStatementSeq ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCatchStatementSeq;  
      SgCatchStatementSeqStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCharVal ); 
     SgCharValStorageClass* storageArraySgCharVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCharVal = new SgCharValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCharVal) , sizeof ( SgCharValStorageClass ) * sizeOfActualPool) ;
        SgCharValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCharValStorageClass* storageArray = storageArraySgCharVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCharVal ( *storageArray ) ; 
#else
               SgCharVal* tmp = new SgCharVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCharVal;  
      SgCharValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgChar16Val ); 
     SgChar16ValStorageClass* storageArraySgChar16Val = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgChar16Val = new SgChar16ValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgChar16Val) , sizeof ( SgChar16ValStorageClass ) * sizeOfActualPool) ;
        SgChar16ValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgChar16ValStorageClass* storageArray = storageArraySgChar16Val;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgChar16Val ( *storageArray ) ; 
#else
               SgChar16Val* tmp = new SgChar16Val ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgChar16Val;  
      SgChar16ValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgChar32Val ); 
     SgChar32ValStorageClass* storageArraySgChar32Val = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgChar32Val = new SgChar32ValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgChar32Val) , sizeof ( SgChar32ValStorageClass ) * sizeOfActualPool) ;
        SgChar32ValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgChar32ValStorageClass* storageArray = storageArraySgChar32Val;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgChar32Val ( *storageArray ) ; 
#else
               SgChar32Val* tmp = new SgChar32Val ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgChar32Val;  
      SgChar32ValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgChooseExpression ); 
     SgChooseExpressionStorageClass* storageArraySgChooseExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgChooseExpression = new SgChooseExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgChooseExpression) , sizeof ( SgChooseExpressionStorageClass ) * sizeOfActualPool) ;
        SgChooseExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgChooseExpressionStorageClass* storageArray = storageArraySgChooseExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgChooseExpression ( *storageArray ) ; 
#else
               SgChooseExpression* tmp = new SgChooseExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgChooseExpression;  
      SgChooseExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassDecl_attr ); 
     SgClassDecl_attrStorageClass* storageArraySgClassDecl_attr = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassDecl_attr = new SgClassDecl_attrStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassDecl_attr) , sizeof ( SgClassDecl_attrStorageClass ) * sizeOfActualPool) ;
        SgClassDecl_attrStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassDecl_attrStorageClass* storageArray = storageArraySgClassDecl_attr;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClassDecl_attr ( *storageArray ) ; 
#else
               SgClassDecl_attr* tmp = new SgClassDecl_attr ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassDecl_attr;  
      SgClassDecl_attrStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassDeclaration ); 
     SgClassDeclarationStorageClass* storageArraySgClassDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassDeclaration = new SgClassDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassDeclaration) , sizeof ( SgClassDeclarationStorageClass ) * sizeOfActualPool) ;
        SgClassDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassDeclarationStorageClass* storageArray = storageArraySgClassDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClassDeclaration ( *storageArray ) ; 
#else
               SgClassDeclaration* tmp = new SgClassDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassDeclaration;  
      SgClassDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassDefinition ); 
     SgClassDefinitionStorageClass* storageArraySgClassDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassDefinition = new SgClassDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassDefinition) , sizeof ( SgClassDefinitionStorageClass ) * sizeOfActualPool) ;
        SgClassDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassDefinitionStorageClass* storageArray = storageArraySgClassDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClassDefinition ( *storageArray ) ; 
#else
               SgClassDefinition* tmp = new SgClassDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassDefinition;  
      SgClassDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassNameRefExp ); 
     SgClassNameRefExpStorageClass* storageArraySgClassNameRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassNameRefExp = new SgClassNameRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassNameRefExp) , sizeof ( SgClassNameRefExpStorageClass ) * sizeOfActualPool) ;
        SgClassNameRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassNameRefExpStorageClass* storageArray = storageArraySgClassNameRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClassNameRefExp ( *storageArray ) ; 
#else
               SgClassNameRefExp* tmp = new SgClassNameRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassNameRefExp;  
      SgClassNameRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassSymbol ); 
     SgClassSymbolStorageClass* storageArraySgClassSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassSymbol = new SgClassSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassSymbol) , sizeof ( SgClassSymbolStorageClass ) * sizeOfActualPool) ;
        SgClassSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassSymbolStorageClass* storageArray = storageArraySgClassSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClassSymbol ( *storageArray ) ; 
#else
               SgClassSymbol* tmp = new SgClassSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassSymbol;  
      SgClassSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassType ); 
     SgClassTypeStorageClass* storageArraySgClassType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassType = new SgClassTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassType) , sizeof ( SgClassTypeStorageClass ) * sizeOfActualPool) ;
        SgClassTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassTypeStorageClass* storageArray = storageArraySgClassType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClassType ( *storageArray ) ; 
#else
               SgClassType* tmp = new SgClassType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassType;  
      SgClassTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClinkageDeclarationStatement ); 
     SgClinkageDeclarationStatementStorageClass* storageArraySgClinkageDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClinkageDeclarationStatement = new SgClinkageDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClinkageDeclarationStatement) , sizeof ( SgClinkageDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgClinkageDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClinkageDeclarationStatementStorageClass* storageArray = storageArraySgClinkageDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClinkageDeclarationStatement ( *storageArray ) ; 
#else
               SgClinkageDeclarationStatement* tmp = new SgClinkageDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClinkageDeclarationStatement;  
      SgClinkageDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClinkageEndStatement ); 
     SgClinkageEndStatementStorageClass* storageArraySgClinkageEndStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClinkageEndStatement = new SgClinkageEndStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClinkageEndStatement) , sizeof ( SgClinkageEndStatementStorageClass ) * sizeOfActualPool) ;
        SgClinkageEndStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClinkageEndStatementStorageClass* storageArray = storageArraySgClinkageEndStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClinkageEndStatement ( *storageArray ) ; 
#else
               SgClinkageEndStatement* tmp = new SgClinkageEndStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClinkageEndStatement;  
      SgClinkageEndStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClinkageStartStatement ); 
     SgClinkageStartStatementStorageClass* storageArraySgClinkageStartStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClinkageStartStatement = new SgClinkageStartStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClinkageStartStatement) , sizeof ( SgClinkageStartStatementStorageClass ) * sizeOfActualPool) ;
        SgClinkageStartStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClinkageStartStatementStorageClass* storageArray = storageArraySgClinkageStartStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClinkageStartStatement ( *storageArray ) ; 
#else
               SgClinkageStartStatement* tmp = new SgClinkageStartStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClinkageStartStatement;  
      SgClinkageStartStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCloseStatement ); 
     SgCloseStatementStorageClass* storageArraySgCloseStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCloseStatement = new SgCloseStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCloseStatement) , sizeof ( SgCloseStatementStorageClass ) * sizeOfActualPool) ;
        SgCloseStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCloseStatementStorageClass* storageArray = storageArraySgCloseStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCloseStatement ( *storageArray ) ; 
#else
               SgCloseStatement* tmp = new SgCloseStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCloseStatement;  
      SgCloseStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgColonShapeExp ); 
     SgColonShapeExpStorageClass* storageArraySgColonShapeExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgColonShapeExp = new SgColonShapeExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgColonShapeExp) , sizeof ( SgColonShapeExpStorageClass ) * sizeOfActualPool) ;
        SgColonShapeExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgColonShapeExpStorageClass* storageArray = storageArraySgColonShapeExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgColonShapeExp ( *storageArray ) ; 
#else
               SgColonShapeExp* tmp = new SgColonShapeExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgColonShapeExp;  
      SgColonShapeExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCommaOpExp ); 
     SgCommaOpExpStorageClass* storageArraySgCommaOpExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCommaOpExp = new SgCommaOpExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCommaOpExp) , sizeof ( SgCommaOpExpStorageClass ) * sizeOfActualPool) ;
        SgCommaOpExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCommaOpExpStorageClass* storageArray = storageArraySgCommaOpExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCommaOpExp ( *storageArray ) ; 
#else
               SgCommaOpExp* tmp = new SgCommaOpExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCommaOpExp;  
      SgCommaOpExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCommonBlock ); 
     SgCommonBlockStorageClass* storageArraySgCommonBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCommonBlock = new SgCommonBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCommonBlock) , sizeof ( SgCommonBlockStorageClass ) * sizeOfActualPool) ;
        SgCommonBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCommonBlockStorageClass* storageArray = storageArraySgCommonBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCommonBlock ( *storageArray ) ; 
#else
               SgCommonBlock* tmp = new SgCommonBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCommonBlock;  
      SgCommonBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCommonBlockObject ); 
     SgCommonBlockObjectStorageClass* storageArraySgCommonBlockObject = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCommonBlockObject = new SgCommonBlockObjectStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCommonBlockObject) , sizeof ( SgCommonBlockObjectStorageClass ) * sizeOfActualPool) ;
        SgCommonBlockObjectStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCommonBlockObjectStorageClass* storageArray = storageArraySgCommonBlockObject;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCommonBlockObject ( *storageArray ) ; 
#else
               SgCommonBlockObject* tmp = new SgCommonBlockObject ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCommonBlockObject;  
      SgCommonBlockObjectStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCommonSymbol ); 
     SgCommonSymbolStorageClass* storageArraySgCommonSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCommonSymbol = new SgCommonSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCommonSymbol) , sizeof ( SgCommonSymbolStorageClass ) * sizeOfActualPool) ;
        SgCommonSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCommonSymbolStorageClass* storageArray = storageArraySgCommonSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCommonSymbol ( *storageArray ) ; 
#else
               SgCommonSymbol* tmp = new SgCommonSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCommonSymbol;  
      SgCommonSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgComplexVal ); 
     SgComplexValStorageClass* storageArraySgComplexVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgComplexVal = new SgComplexValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgComplexVal) , sizeof ( SgComplexValStorageClass ) * sizeOfActualPool) ;
        SgComplexValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgComplexValStorageClass* storageArray = storageArraySgComplexVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgComplexVal ( *storageArray ) ; 
#else
               SgComplexVal* tmp = new SgComplexVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgComplexVal;  
      SgComplexValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgComprehension ); 
     SgComprehensionStorageClass* storageArraySgComprehension = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgComprehension = new SgComprehensionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgComprehension) , sizeof ( SgComprehensionStorageClass ) * sizeOfActualPool) ;
        SgComprehensionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgComprehensionStorageClass* storageArray = storageArraySgComprehension;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgComprehension ( *storageArray ) ; 
#else
               SgComprehension* tmp = new SgComprehension ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgComprehension;  
      SgComprehensionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCompoundAssignOp ); 
     SgCompoundAssignOpStorageClass* storageArraySgCompoundAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCompoundAssignOp = new SgCompoundAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCompoundAssignOp) , sizeof ( SgCompoundAssignOpStorageClass ) * sizeOfActualPool) ;
        SgCompoundAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCompoundAssignOpStorageClass* storageArray = storageArraySgCompoundAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCompoundAssignOp ( *storageArray ) ; 
#else
               SgCompoundAssignOp* tmp = new SgCompoundAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCompoundAssignOp;  
      SgCompoundAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCompoundInitializer ); 
     SgCompoundInitializerStorageClass* storageArraySgCompoundInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCompoundInitializer = new SgCompoundInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCompoundInitializer) , sizeof ( SgCompoundInitializerStorageClass ) * sizeOfActualPool) ;
        SgCompoundInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCompoundInitializerStorageClass* storageArray = storageArraySgCompoundInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCompoundInitializer ( *storageArray ) ; 
#else
               SgCompoundInitializer* tmp = new SgCompoundInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCompoundInitializer;  
      SgCompoundInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCompoundLiteralExp ); 
     SgCompoundLiteralExpStorageClass* storageArraySgCompoundLiteralExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCompoundLiteralExp = new SgCompoundLiteralExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCompoundLiteralExp) , sizeof ( SgCompoundLiteralExpStorageClass ) * sizeOfActualPool) ;
        SgCompoundLiteralExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCompoundLiteralExpStorageClass* storageArray = storageArraySgCompoundLiteralExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCompoundLiteralExp ( *storageArray ) ; 
#else
               SgCompoundLiteralExp* tmp = new SgCompoundLiteralExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCompoundLiteralExp;  
      SgCompoundLiteralExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgComputedGotoStatement ); 
     SgComputedGotoStatementStorageClass* storageArraySgComputedGotoStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgComputedGotoStatement = new SgComputedGotoStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgComputedGotoStatement) , sizeof ( SgComputedGotoStatementStorageClass ) * sizeOfActualPool) ;
        SgComputedGotoStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgComputedGotoStatementStorageClass* storageArray = storageArraySgComputedGotoStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgComputedGotoStatement ( *storageArray ) ; 
#else
               SgComputedGotoStatement* tmp = new SgComputedGotoStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgComputedGotoStatement;  
      SgComputedGotoStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConcatenationOp ); 
     SgConcatenationOpStorageClass* storageArraySgConcatenationOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConcatenationOp = new SgConcatenationOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConcatenationOp) , sizeof ( SgConcatenationOpStorageClass ) * sizeOfActualPool) ;
        SgConcatenationOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgConcatenationOpStorageClass* storageArray = storageArraySgConcatenationOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgConcatenationOp ( *storageArray ) ; 
#else
               SgConcatenationOp* tmp = new SgConcatenationOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConcatenationOp;  
      SgConcatenationOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConditionalExp ); 
     SgConditionalExpStorageClass* storageArraySgConditionalExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConditionalExp = new SgConditionalExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConditionalExp) , sizeof ( SgConditionalExpStorageClass ) * sizeOfActualPool) ;
        SgConditionalExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgConditionalExpStorageClass* storageArray = storageArraySgConditionalExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgConditionalExp ( *storageArray ) ; 
#else
               SgConditionalExp* tmp = new SgConditionalExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConditionalExp;  
      SgConditionalExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConjugateOp ); 
     SgConjugateOpStorageClass* storageArraySgConjugateOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConjugateOp = new SgConjugateOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConjugateOp) , sizeof ( SgConjugateOpStorageClass ) * sizeOfActualPool) ;
        SgConjugateOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgConjugateOpStorageClass* storageArray = storageArraySgConjugateOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgConjugateOp ( *storageArray ) ; 
#else
               SgConjugateOp* tmp = new SgConjugateOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConjugateOp;  
      SgConjugateOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConstVolatileModifier ); 
     SgConstVolatileModifierStorageClass* storageArraySgConstVolatileModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConstVolatileModifier = new SgConstVolatileModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConstVolatileModifier) , sizeof ( SgConstVolatileModifierStorageClass ) * sizeOfActualPool) ;
          SgConstVolatileModifierStorageClass* storageArray = storageArraySgConstVolatileModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgConstVolatileModifier ( *storageArray ) ; 
#else
               SgConstVolatileModifier* tmp = new SgConstVolatileModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConstVolatileModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConstructorInitializer ); 
     SgConstructorInitializerStorageClass* storageArraySgConstructorInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConstructorInitializer = new SgConstructorInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConstructorInitializer) , sizeof ( SgConstructorInitializerStorageClass ) * sizeOfActualPool) ;
        SgConstructorInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgConstructorInitializerStorageClass* storageArray = storageArraySgConstructorInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgConstructorInitializer ( *storageArray ) ; 
#else
               SgConstructorInitializer* tmp = new SgConstructorInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConstructorInitializer;  
      SgConstructorInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgContainsStatement ); 
     SgContainsStatementStorageClass* storageArraySgContainsStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgContainsStatement = new SgContainsStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgContainsStatement) , sizeof ( SgContainsStatementStorageClass ) * sizeOfActualPool) ;
        SgContainsStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgContainsStatementStorageClass* storageArray = storageArraySgContainsStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgContainsStatement ( *storageArray ) ; 
#else
               SgContainsStatement* tmp = new SgContainsStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgContainsStatement;  
      SgContainsStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgContinueStmt ); 
     SgContinueStmtStorageClass* storageArraySgContinueStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgContinueStmt = new SgContinueStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgContinueStmt) , sizeof ( SgContinueStmtStorageClass ) * sizeOfActualPool) ;
        SgContinueStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgContinueStmtStorageClass* storageArray = storageArraySgContinueStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgContinueStmt ( *storageArray ) ; 
#else
               SgContinueStmt* tmp = new SgContinueStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgContinueStmt;  
      SgContinueStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCtorInitializerList ); 
     SgCtorInitializerListStorageClass* storageArraySgCtorInitializerList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCtorInitializerList = new SgCtorInitializerListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCtorInitializerList) , sizeof ( SgCtorInitializerListStorageClass ) * sizeOfActualPool) ;
        SgCtorInitializerListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCtorInitializerListStorageClass* storageArray = storageArraySgCtorInitializerList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCtorInitializerList ( *storageArray ) ; 
#else
               SgCtorInitializerList* tmp = new SgCtorInitializerList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCtorInitializerList;  
      SgCtorInitializerListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDataStatementGroup ); 
     SgDataStatementGroupStorageClass* storageArraySgDataStatementGroup = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDataStatementGroup = new SgDataStatementGroupStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDataStatementGroup) , sizeof ( SgDataStatementGroupStorageClass ) * sizeOfActualPool) ;
        SgDataStatementGroupStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDataStatementGroupStorageClass* storageArray = storageArraySgDataStatementGroup;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDataStatementGroup ( *storageArray ) ; 
#else
               SgDataStatementGroup* tmp = new SgDataStatementGroup ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDataStatementGroup;  
      SgDataStatementGroupStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDataStatementObject ); 
     SgDataStatementObjectStorageClass* storageArraySgDataStatementObject = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDataStatementObject = new SgDataStatementObjectStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDataStatementObject) , sizeof ( SgDataStatementObjectStorageClass ) * sizeOfActualPool) ;
          SgDataStatementObjectStorageClass* storageArray = storageArraySgDataStatementObject;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDataStatementObject ( *storageArray ) ; 
#else
               SgDataStatementObject* tmp = new SgDataStatementObject ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDataStatementObject;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDataStatementValue ); 
     SgDataStatementValueStorageClass* storageArraySgDataStatementValue = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDataStatementValue = new SgDataStatementValueStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDataStatementValue) , sizeof ( SgDataStatementValueStorageClass ) * sizeOfActualPool) ;
          SgDataStatementValueStorageClass* storageArray = storageArraySgDataStatementValue;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDataStatementValue ( *storageArray ) ; 
#else
               SgDataStatementValue* tmp = new SgDataStatementValue ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDataStatementValue;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeadIfDirectiveStatement ); 
     SgDeadIfDirectiveStatementStorageClass* storageArraySgDeadIfDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeadIfDirectiveStatement = new SgDeadIfDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeadIfDirectiveStatement) , sizeof ( SgDeadIfDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgDeadIfDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeadIfDirectiveStatementStorageClass* storageArray = storageArraySgDeadIfDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDeadIfDirectiveStatement ( *storageArray ) ; 
#else
               SgDeadIfDirectiveStatement* tmp = new SgDeadIfDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeadIfDirectiveStatement;  
      SgDeadIfDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeallocateStatement ); 
     SgDeallocateStatementStorageClass* storageArraySgDeallocateStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeallocateStatement = new SgDeallocateStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeallocateStatement) , sizeof ( SgDeallocateStatementStorageClass ) * sizeOfActualPool) ;
        SgDeallocateStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeallocateStatementStorageClass* storageArray = storageArraySgDeallocateStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDeallocateStatement ( *storageArray ) ; 
#else
               SgDeallocateStatement* tmp = new SgDeallocateStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeallocateStatement;  
      SgDeallocateStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeclarationModifier ); 
     SgDeclarationModifierStorageClass* storageArraySgDeclarationModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeclarationModifier = new SgDeclarationModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeclarationModifier) , sizeof ( SgDeclarationModifierStorageClass ) * sizeOfActualPool) ;
        SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeclarationModifierStorageClass* storageArray = storageArraySgDeclarationModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDeclarationModifier ( *storageArray ) ; 
#else
               SgDeclarationModifier* tmp = new SgDeclarationModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeclarationModifier;  
      SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeclarationScope ); 
     SgDeclarationScopeStorageClass* storageArraySgDeclarationScope = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeclarationScope = new SgDeclarationScopeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeclarationScope) , sizeof ( SgDeclarationScopeStorageClass ) * sizeOfActualPool) ;
        SgDeclarationScopeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeclarationScopeStorageClass* storageArray = storageArraySgDeclarationScope;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDeclarationScope ( *storageArray ) ; 
#else
               SgDeclarationScope* tmp = new SgDeclarationScope ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeclarationScope;  
      SgDeclarationScopeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeclarationStatement ); 
     SgDeclarationStatementStorageClass* storageArraySgDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeclarationStatement = new SgDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeclarationStatement) , sizeof ( SgDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeclarationStatementStorageClass* storageArray = storageArraySgDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDeclarationStatement ( *storageArray ) ; 
#else
               SgDeclarationStatement* tmp = new SgDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeclarationStatement;  
      SgDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeclType ); 
     SgDeclTypeStorageClass* storageArraySgDeclType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeclType = new SgDeclTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeclType) , sizeof ( SgDeclTypeStorageClass ) * sizeOfActualPool) ;
        SgDeclTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeclTypeStorageClass* storageArray = storageArraySgDeclType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDeclType ( *storageArray ) ; 
#else
               SgDeclType* tmp = new SgDeclType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeclType;  
      SgDeclTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDefaultOptionStmt ); 
     SgDefaultOptionStmtStorageClass* storageArraySgDefaultOptionStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDefaultOptionStmt = new SgDefaultOptionStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDefaultOptionStmt) , sizeof ( SgDefaultOptionStmtStorageClass ) * sizeOfActualPool) ;
        SgDefaultOptionStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDefaultOptionStmtStorageClass* storageArray = storageArraySgDefaultOptionStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDefaultOptionStmt ( *storageArray ) ; 
#else
               SgDefaultOptionStmt* tmp = new SgDefaultOptionStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDefaultOptionStmt;  
      SgDefaultOptionStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDefaultSymbol ); 
     SgDefaultSymbolStorageClass* storageArraySgDefaultSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDefaultSymbol = new SgDefaultSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDefaultSymbol) , sizeof ( SgDefaultSymbolStorageClass ) * sizeOfActualPool) ;
        SgDefaultSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDefaultSymbolStorageClass* storageArray = storageArraySgDefaultSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDefaultSymbol ( *storageArray ) ; 
#else
               SgDefaultSymbol* tmp = new SgDefaultSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDefaultSymbol;  
      SgDefaultSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDefineDirectiveStatement ); 
     SgDefineDirectiveStatementStorageClass* storageArraySgDefineDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDefineDirectiveStatement = new SgDefineDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDefineDirectiveStatement) , sizeof ( SgDefineDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgDefineDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDefineDirectiveStatementStorageClass* storageArray = storageArraySgDefineDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDefineDirectiveStatement ( *storageArray ) ; 
#else
               SgDefineDirectiveStatement* tmp = new SgDefineDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDefineDirectiveStatement;  
      SgDefineDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeleteExp ); 
     SgDeleteExpStorageClass* storageArraySgDeleteExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeleteExp = new SgDeleteExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeleteExp) , sizeof ( SgDeleteExpStorageClass ) * sizeOfActualPool) ;
        SgDeleteExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeleteExpStorageClass* storageArray = storageArraySgDeleteExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDeleteExp ( *storageArray ) ; 
#else
               SgDeleteExp* tmp = new SgDeleteExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeleteExp;  
      SgDeleteExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDerivedTypeStatement ); 
     SgDerivedTypeStatementStorageClass* storageArraySgDerivedTypeStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDerivedTypeStatement = new SgDerivedTypeStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDerivedTypeStatement) , sizeof ( SgDerivedTypeStatementStorageClass ) * sizeOfActualPool) ;
        SgDerivedTypeStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDerivedTypeStatementStorageClass* storageArray = storageArraySgDerivedTypeStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDerivedTypeStatement ( *storageArray ) ; 
#else
               SgDerivedTypeStatement* tmp = new SgDerivedTypeStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDerivedTypeStatement;  
      SgDerivedTypeStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDesignatedInitializer ); 
     SgDesignatedInitializerStorageClass* storageArraySgDesignatedInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDesignatedInitializer = new SgDesignatedInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDesignatedInitializer) , sizeof ( SgDesignatedInitializerStorageClass ) * sizeOfActualPool) ;
        SgDesignatedInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDesignatedInitializerStorageClass* storageArray = storageArraySgDesignatedInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDesignatedInitializer ( *storageArray ) ; 
#else
               SgDesignatedInitializer* tmp = new SgDesignatedInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDesignatedInitializer;  
      SgDesignatedInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDictionaryComprehension ); 
     SgDictionaryComprehensionStorageClass* storageArraySgDictionaryComprehension = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDictionaryComprehension = new SgDictionaryComprehensionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDictionaryComprehension) , sizeof ( SgDictionaryComprehensionStorageClass ) * sizeOfActualPool) ;
        SgDictionaryComprehensionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDictionaryComprehensionStorageClass* storageArray = storageArraySgDictionaryComprehension;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDictionaryComprehension ( *storageArray ) ; 
#else
               SgDictionaryComprehension* tmp = new SgDictionaryComprehension ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDictionaryComprehension;  
      SgDictionaryComprehensionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDictionaryExp ); 
     SgDictionaryExpStorageClass* storageArraySgDictionaryExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDictionaryExp = new SgDictionaryExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDictionaryExp) , sizeof ( SgDictionaryExpStorageClass ) * sizeOfActualPool) ;
        SgDictionaryExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDictionaryExpStorageClass* storageArray = storageArraySgDictionaryExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDictionaryExp ( *storageArray ) ; 
#else
               SgDictionaryExp* tmp = new SgDictionaryExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDictionaryExp;  
      SgDictionaryExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDimensionObject ); 
     SgDimensionObjectStorageClass* storageArraySgDimensionObject = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDimensionObject = new SgDimensionObjectStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDimensionObject) , sizeof ( SgDimensionObjectStorageClass ) * sizeOfActualPool) ;
          SgDimensionObjectStorageClass* storageArray = storageArraySgDimensionObject;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDimensionObject ( *storageArray ) ; 
#else
               SgDimensionObject* tmp = new SgDimensionObject ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDimensionObject;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDirectedGraphEdge ); 
     SgDirectedGraphEdgeStorageClass* storageArraySgDirectedGraphEdge = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDirectedGraphEdge = new SgDirectedGraphEdgeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDirectedGraphEdge) , sizeof ( SgDirectedGraphEdgeStorageClass ) * sizeOfActualPool) ;
        SgDirectedGraphEdgeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDirectedGraphEdgeStorageClass* storageArray = storageArraySgDirectedGraphEdge;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDirectedGraphEdge ( *storageArray ) ; 
#else
               SgDirectedGraphEdge* tmp = new SgDirectedGraphEdge ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDirectedGraphEdge;  
      SgDirectedGraphEdgeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDirectory ); 
     SgDirectoryStorageClass* storageArraySgDirectory = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDirectory = new SgDirectoryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDirectory) , sizeof ( SgDirectoryStorageClass ) * sizeOfActualPool) ;
        SgDirectoryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDirectoryStorageClass* storageArray = storageArraySgDirectory;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDirectory ( *storageArray ) ; 
#else
               SgDirectory* tmp = new SgDirectory ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDirectory;  
      SgDirectoryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDirectoryList ); 
     SgDirectoryListStorageClass* storageArraySgDirectoryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDirectoryList = new SgDirectoryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDirectoryList) , sizeof ( SgDirectoryListStorageClass ) * sizeOfActualPool) ;
        SgDirectoryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDirectoryListStorageClass* storageArray = storageArraySgDirectoryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDirectoryList ( *storageArray ) ; 
#else
               SgDirectoryList* tmp = new SgDirectoryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDirectoryList;  
      SgDirectoryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDivAssignOp ); 
     SgDivAssignOpStorageClass* storageArraySgDivAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDivAssignOp = new SgDivAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDivAssignOp) , sizeof ( SgDivAssignOpStorageClass ) * sizeOfActualPool) ;
        SgDivAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDivAssignOpStorageClass* storageArray = storageArraySgDivAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDivAssignOp ( *storageArray ) ; 
#else
               SgDivAssignOp* tmp = new SgDivAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDivAssignOp;  
      SgDivAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDivideOp ); 
     SgDivideOpStorageClass* storageArraySgDivideOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDivideOp = new SgDivideOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDivideOp) , sizeof ( SgDivideOpStorageClass ) * sizeOfActualPool) ;
        SgDivideOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDivideOpStorageClass* storageArray = storageArraySgDivideOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDivideOp ( *storageArray ) ; 
#else
               SgDivideOp* tmp = new SgDivideOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDivideOp;  
      SgDivideOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDoWhileStmt ); 
     SgDoWhileStmtStorageClass* storageArraySgDoWhileStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDoWhileStmt = new SgDoWhileStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDoWhileStmt) , sizeof ( SgDoWhileStmtStorageClass ) * sizeOfActualPool) ;
        SgDoWhileStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDoWhileStmtStorageClass* storageArray = storageArraySgDoWhileStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDoWhileStmt ( *storageArray ) ; 
#else
               SgDoWhileStmt* tmp = new SgDoWhileStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDoWhileStmt;  
      SgDoWhileStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDotExp ); 
     SgDotExpStorageClass* storageArraySgDotExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDotExp = new SgDotExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDotExp) , sizeof ( SgDotExpStorageClass ) * sizeOfActualPool) ;
        SgDotExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDotExpStorageClass* storageArray = storageArraySgDotExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDotExp ( *storageArray ) ; 
#else
               SgDotExp* tmp = new SgDotExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDotExp;  
      SgDotExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDotStarOp ); 
     SgDotStarOpStorageClass* storageArraySgDotStarOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDotStarOp = new SgDotStarOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDotStarOp) , sizeof ( SgDotStarOpStorageClass ) * sizeOfActualPool) ;
        SgDotStarOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDotStarOpStorageClass* storageArray = storageArraySgDotStarOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDotStarOp ( *storageArray ) ; 
#else
               SgDotStarOp* tmp = new SgDotStarOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDotStarOp;  
      SgDotStarOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDoubleVal ); 
     SgDoubleValStorageClass* storageArraySgDoubleVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDoubleVal = new SgDoubleValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDoubleVal) , sizeof ( SgDoubleValStorageClass ) * sizeOfActualPool) ;
        SgDoubleValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDoubleValStorageClass* storageArray = storageArraySgDoubleVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDoubleVal ( *storageArray ) ; 
#else
               SgDoubleVal* tmp = new SgDoubleVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDoubleVal;  
      SgDoubleValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElaboratedTypeModifier ); 
     SgElaboratedTypeModifierStorageClass* storageArraySgElaboratedTypeModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElaboratedTypeModifier = new SgElaboratedTypeModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElaboratedTypeModifier) , sizeof ( SgElaboratedTypeModifierStorageClass ) * sizeOfActualPool) ;
          SgElaboratedTypeModifierStorageClass* storageArray = storageArraySgElaboratedTypeModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElaboratedTypeModifier ( *storageArray ) ; 
#else
               SgElaboratedTypeModifier* tmp = new SgElaboratedTypeModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElaboratedTypeModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElementwiseOp ); 
     SgElementwiseOpStorageClass* storageArraySgElementwiseOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElementwiseOp = new SgElementwiseOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElementwiseOp) , sizeof ( SgElementwiseOpStorageClass ) * sizeOfActualPool) ;
        SgElementwiseOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElementwiseOpStorageClass* storageArray = storageArraySgElementwiseOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElementwiseOp ( *storageArray ) ; 
#else
               SgElementwiseOp* tmp = new SgElementwiseOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElementwiseOp;  
      SgElementwiseOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElementwiseAddOp ); 
     SgElementwiseAddOpStorageClass* storageArraySgElementwiseAddOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElementwiseAddOp = new SgElementwiseAddOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElementwiseAddOp) , sizeof ( SgElementwiseAddOpStorageClass ) * sizeOfActualPool) ;
        SgElementwiseAddOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElementwiseAddOpStorageClass* storageArray = storageArraySgElementwiseAddOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElementwiseAddOp ( *storageArray ) ; 
#else
               SgElementwiseAddOp* tmp = new SgElementwiseAddOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElementwiseAddOp;  
      SgElementwiseAddOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElementwiseDivideOp ); 
     SgElementwiseDivideOpStorageClass* storageArraySgElementwiseDivideOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElementwiseDivideOp = new SgElementwiseDivideOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElementwiseDivideOp) , sizeof ( SgElementwiseDivideOpStorageClass ) * sizeOfActualPool) ;
        SgElementwiseDivideOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElementwiseDivideOpStorageClass* storageArray = storageArraySgElementwiseDivideOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElementwiseDivideOp ( *storageArray ) ; 
#else
               SgElementwiseDivideOp* tmp = new SgElementwiseDivideOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElementwiseDivideOp;  
      SgElementwiseDivideOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElementwiseLeftDivideOp ); 
     SgElementwiseLeftDivideOpStorageClass* storageArraySgElementwiseLeftDivideOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElementwiseLeftDivideOp = new SgElementwiseLeftDivideOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElementwiseLeftDivideOp) , sizeof ( SgElementwiseLeftDivideOpStorageClass ) * sizeOfActualPool) ;
        SgElementwiseLeftDivideOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElementwiseLeftDivideOpStorageClass* storageArray = storageArraySgElementwiseLeftDivideOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElementwiseLeftDivideOp ( *storageArray ) ; 
#else
               SgElementwiseLeftDivideOp* tmp = new SgElementwiseLeftDivideOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElementwiseLeftDivideOp;  
      SgElementwiseLeftDivideOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElementwiseMultiplyOp ); 
     SgElementwiseMultiplyOpStorageClass* storageArraySgElementwiseMultiplyOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElementwiseMultiplyOp = new SgElementwiseMultiplyOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElementwiseMultiplyOp) , sizeof ( SgElementwiseMultiplyOpStorageClass ) * sizeOfActualPool) ;
        SgElementwiseMultiplyOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElementwiseMultiplyOpStorageClass* storageArray = storageArraySgElementwiseMultiplyOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElementwiseMultiplyOp ( *storageArray ) ; 
#else
               SgElementwiseMultiplyOp* tmp = new SgElementwiseMultiplyOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElementwiseMultiplyOp;  
      SgElementwiseMultiplyOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElementwisePowerOp ); 
     SgElementwisePowerOpStorageClass* storageArraySgElementwisePowerOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElementwisePowerOp = new SgElementwisePowerOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElementwisePowerOp) , sizeof ( SgElementwisePowerOpStorageClass ) * sizeOfActualPool) ;
        SgElementwisePowerOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElementwisePowerOpStorageClass* storageArray = storageArraySgElementwisePowerOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElementwisePowerOp ( *storageArray ) ; 
#else
               SgElementwisePowerOp* tmp = new SgElementwisePowerOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElementwisePowerOp;  
      SgElementwisePowerOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElementwiseSubtractOp ); 
     SgElementwiseSubtractOpStorageClass* storageArraySgElementwiseSubtractOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElementwiseSubtractOp = new SgElementwiseSubtractOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElementwiseSubtractOp) , sizeof ( SgElementwiseSubtractOpStorageClass ) * sizeOfActualPool) ;
        SgElementwiseSubtractOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElementwiseSubtractOpStorageClass* storageArray = storageArraySgElementwiseSubtractOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElementwiseSubtractOp ( *storageArray ) ; 
#else
               SgElementwiseSubtractOp* tmp = new SgElementwiseSubtractOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElementwiseSubtractOp;  
      SgElementwiseSubtractOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElseDirectiveStatement ); 
     SgElseDirectiveStatementStorageClass* storageArraySgElseDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElseDirectiveStatement = new SgElseDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElseDirectiveStatement) , sizeof ( SgElseDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgElseDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElseDirectiveStatementStorageClass* storageArray = storageArraySgElseDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElseDirectiveStatement ( *storageArray ) ; 
#else
               SgElseDirectiveStatement* tmp = new SgElseDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElseDirectiveStatement;  
      SgElseDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElseWhereStatement ); 
     SgElseWhereStatementStorageClass* storageArraySgElseWhereStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElseWhereStatement = new SgElseWhereStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElseWhereStatement) , sizeof ( SgElseWhereStatementStorageClass ) * sizeOfActualPool) ;
        SgElseWhereStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElseWhereStatementStorageClass* storageArray = storageArraySgElseWhereStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElseWhereStatement ( *storageArray ) ; 
#else
               SgElseWhereStatement* tmp = new SgElseWhereStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElseWhereStatement;  
      SgElseWhereStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElseifDirectiveStatement ); 
     SgElseifDirectiveStatementStorageClass* storageArraySgElseifDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElseifDirectiveStatement = new SgElseifDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElseifDirectiveStatement) , sizeof ( SgElseifDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgElseifDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElseifDirectiveStatementStorageClass* storageArray = storageArraySgElseifDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgElseifDirectiveStatement ( *storageArray ) ; 
#else
               SgElseifDirectiveStatement* tmp = new SgElseifDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElseifDirectiveStatement;  
      SgElseifDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEmptyDeclaration ); 
     SgEmptyDeclarationStorageClass* storageArraySgEmptyDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEmptyDeclaration = new SgEmptyDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEmptyDeclaration) , sizeof ( SgEmptyDeclarationStorageClass ) * sizeOfActualPool) ;
        SgEmptyDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEmptyDeclarationStorageClass* storageArray = storageArraySgEmptyDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEmptyDeclaration ( *storageArray ) ; 
#else
               SgEmptyDeclaration* tmp = new SgEmptyDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEmptyDeclaration;  
      SgEmptyDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEmptyDirectiveStatement ); 
     SgEmptyDirectiveStatementStorageClass* storageArraySgEmptyDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEmptyDirectiveStatement = new SgEmptyDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEmptyDirectiveStatement) , sizeof ( SgEmptyDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgEmptyDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEmptyDirectiveStatementStorageClass* storageArray = storageArraySgEmptyDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEmptyDirectiveStatement ( *storageArray ) ; 
#else
               SgEmptyDirectiveStatement* tmp = new SgEmptyDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEmptyDirectiveStatement;  
      SgEmptyDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEndfileStatement ); 
     SgEndfileStatementStorageClass* storageArraySgEndfileStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEndfileStatement = new SgEndfileStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEndfileStatement) , sizeof ( SgEndfileStatementStorageClass ) * sizeOfActualPool) ;
        SgEndfileStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEndfileStatementStorageClass* storageArray = storageArraySgEndfileStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEndfileStatement ( *storageArray ) ; 
#else
               SgEndfileStatement* tmp = new SgEndfileStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEndfileStatement;  
      SgEndfileStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEndifDirectiveStatement ); 
     SgEndifDirectiveStatementStorageClass* storageArraySgEndifDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEndifDirectiveStatement = new SgEndifDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEndifDirectiveStatement) , sizeof ( SgEndifDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgEndifDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEndifDirectiveStatementStorageClass* storageArray = storageArraySgEndifDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEndifDirectiveStatement ( *storageArray ) ; 
#else
               SgEndifDirectiveStatement* tmp = new SgEndifDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEndifDirectiveStatement;  
      SgEndifDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEntryStatement ); 
     SgEntryStatementStorageClass* storageArraySgEntryStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEntryStatement = new SgEntryStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEntryStatement) , sizeof ( SgEntryStatementStorageClass ) * sizeOfActualPool) ;
        SgEntryStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEntryStatementStorageClass* storageArray = storageArraySgEntryStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEntryStatement ( *storageArray ) ; 
#else
               SgEntryStatement* tmp = new SgEntryStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEntryStatement;  
      SgEntryStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumDeclaration ); 
     SgEnumDeclarationStorageClass* storageArraySgEnumDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumDeclaration = new SgEnumDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumDeclaration) , sizeof ( SgEnumDeclarationStorageClass ) * sizeOfActualPool) ;
        SgEnumDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumDeclarationStorageClass* storageArray = storageArraySgEnumDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEnumDeclaration ( *storageArray ) ; 
#else
               SgEnumDeclaration* tmp = new SgEnumDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumDeclaration;  
      SgEnumDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumFieldSymbol ); 
     SgEnumFieldSymbolStorageClass* storageArraySgEnumFieldSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumFieldSymbol = new SgEnumFieldSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumFieldSymbol) , sizeof ( SgEnumFieldSymbolStorageClass ) * sizeOfActualPool) ;
        SgEnumFieldSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumFieldSymbolStorageClass* storageArray = storageArraySgEnumFieldSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEnumFieldSymbol ( *storageArray ) ; 
#else
               SgEnumFieldSymbol* tmp = new SgEnumFieldSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumFieldSymbol;  
      SgEnumFieldSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumSymbol ); 
     SgEnumSymbolStorageClass* storageArraySgEnumSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumSymbol = new SgEnumSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumSymbol) , sizeof ( SgEnumSymbolStorageClass ) * sizeOfActualPool) ;
        SgEnumSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumSymbolStorageClass* storageArray = storageArraySgEnumSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEnumSymbol ( *storageArray ) ; 
#else
               SgEnumSymbol* tmp = new SgEnumSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumSymbol;  
      SgEnumSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumType ); 
     SgEnumTypeStorageClass* storageArraySgEnumType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumType = new SgEnumTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumType) , sizeof ( SgEnumTypeStorageClass ) * sizeOfActualPool) ;
        SgEnumTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumTypeStorageClass* storageArray = storageArraySgEnumType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEnumType ( *storageArray ) ; 
#else
               SgEnumType* tmp = new SgEnumType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumType;  
      SgEnumTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumVal ); 
     SgEnumValStorageClass* storageArraySgEnumVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumVal = new SgEnumValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumVal) , sizeof ( SgEnumValStorageClass ) * sizeOfActualPool) ;
        SgEnumValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumValStorageClass* storageArray = storageArraySgEnumVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEnumVal ( *storageArray ) ; 
#else
               SgEnumVal* tmp = new SgEnumVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumVal;  
      SgEnumValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEqualityOp ); 
     SgEqualityOpStorageClass* storageArraySgEqualityOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEqualityOp = new SgEqualityOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEqualityOp) , sizeof ( SgEqualityOpStorageClass ) * sizeOfActualPool) ;
        SgEqualityOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEqualityOpStorageClass* storageArray = storageArraySgEqualityOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEqualityOp ( *storageArray ) ; 
#else
               SgEqualityOp* tmp = new SgEqualityOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEqualityOp;  
      SgEqualityOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEquivalenceStatement ); 
     SgEquivalenceStatementStorageClass* storageArraySgEquivalenceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEquivalenceStatement = new SgEquivalenceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEquivalenceStatement) , sizeof ( SgEquivalenceStatementStorageClass ) * sizeOfActualPool) ;
        SgEquivalenceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEquivalenceStatementStorageClass* storageArray = storageArraySgEquivalenceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgEquivalenceStatement ( *storageArray ) ; 
#else
               SgEquivalenceStatement* tmp = new SgEquivalenceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEquivalenceStatement;  
      SgEquivalenceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgErrorDirectiveStatement ); 
     SgErrorDirectiveStatementStorageClass* storageArraySgErrorDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgErrorDirectiveStatement = new SgErrorDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgErrorDirectiveStatement) , sizeof ( SgErrorDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgErrorDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgErrorDirectiveStatementStorageClass* storageArray = storageArraySgErrorDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgErrorDirectiveStatement ( *storageArray ) ; 
#else
               SgErrorDirectiveStatement* tmp = new SgErrorDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgErrorDirectiveStatement;  
      SgErrorDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExecStatement ); 
     SgExecStatementStorageClass* storageArraySgExecStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExecStatement = new SgExecStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExecStatement) , sizeof ( SgExecStatementStorageClass ) * sizeOfActualPool) ;
        SgExecStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExecStatementStorageClass* storageArray = storageArraySgExecStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgExecStatement ( *storageArray ) ; 
#else
               SgExecStatement* tmp = new SgExecStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExecStatement;  
      SgExecStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExponentiationOp ); 
     SgExponentiationOpStorageClass* storageArraySgExponentiationOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExponentiationOp = new SgExponentiationOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExponentiationOp) , sizeof ( SgExponentiationOpStorageClass ) * sizeOfActualPool) ;
        SgExponentiationOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExponentiationOpStorageClass* storageArray = storageArraySgExponentiationOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgExponentiationOp ( *storageArray ) ; 
#else
               SgExponentiationOp* tmp = new SgExponentiationOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExponentiationOp;  
      SgExponentiationOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExponentiationAssignOp ); 
     SgExponentiationAssignOpStorageClass* storageArraySgExponentiationAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExponentiationAssignOp = new SgExponentiationAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExponentiationAssignOp) , sizeof ( SgExponentiationAssignOpStorageClass ) * sizeOfActualPool) ;
        SgExponentiationAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExponentiationAssignOpStorageClass* storageArray = storageArraySgExponentiationAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgExponentiationAssignOp ( *storageArray ) ; 
#else
               SgExponentiationAssignOp* tmp = new SgExponentiationAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExponentiationAssignOp;  
      SgExponentiationAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExprListExp ); 
     SgExprListExpStorageClass* storageArraySgExprListExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExprListExp = new SgExprListExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExprListExp) , sizeof ( SgExprListExpStorageClass ) * sizeOfActualPool) ;
        SgExprListExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExprListExpStorageClass* storageArray = storageArraySgExprListExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgExprListExp ( *storageArray ) ; 
#else
               SgExprListExp* tmp = new SgExprListExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExprListExp;  
      SgExprListExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExprStatement ); 
     SgExprStatementStorageClass* storageArraySgExprStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExprStatement = new SgExprStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExprStatement) , sizeof ( SgExprStatementStorageClass ) * sizeOfActualPool) ;
        SgExprStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExprStatementStorageClass* storageArray = storageArraySgExprStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgExprStatement ( *storageArray ) ; 
#else
               SgExprStatement* tmp = new SgExprStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExprStatement;  
      SgExprStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExpression ); 
     SgExpressionStorageClass* storageArraySgExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExpression = new SgExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExpression) , sizeof ( SgExpressionStorageClass ) * sizeOfActualPool) ;
        SgExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExpressionStorageClass* storageArray = storageArraySgExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgExpression ( *storageArray ) ; 
#else
               SgExpression* tmp = new SgExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExpression;  
      SgExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExpressionRoot ); 
     SgExpressionRootStorageClass* storageArraySgExpressionRoot = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExpressionRoot = new SgExpressionRootStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExpressionRoot) , sizeof ( SgExpressionRootStorageClass ) * sizeOfActualPool) ;
        SgExpressionRootStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExpressionRootStorageClass* storageArray = storageArraySgExpressionRoot;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgExpressionRoot ( *storageArray ) ; 
#else
               SgExpressionRoot* tmp = new SgExpressionRoot ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExpressionRoot;  
      SgExpressionRootStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFile ); 
     SgFileStorageClass* storageArraySgFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFile = new SgFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFile) , sizeof ( SgFileStorageClass ) * sizeOfActualPool) ;
        SgFileStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFileStorageClass* storageArray = storageArraySgFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFile ( *storageArray ) ; 
#else
               SgFile* tmp = new SgFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFile;  
      SgFileStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFileList ); 
     SgFileListStorageClass* storageArraySgFileList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFileList = new SgFileListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFileList) , sizeof ( SgFileListStorageClass ) * sizeOfActualPool) ;
        SgFileListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFileListStorageClass* storageArray = storageArraySgFileList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFileList ( *storageArray ) ; 
#else
               SgFileList* tmp = new SgFileList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFileList;  
      SgFileListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFloatVal ); 
     SgFloatValStorageClass* storageArraySgFloatVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFloatVal = new SgFloatValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFloatVal) , sizeof ( SgFloatValStorageClass ) * sizeOfActualPool) ;
        SgFloatValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFloatValStorageClass* storageArray = storageArraySgFloatVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFloatVal ( *storageArray ) ; 
#else
               SgFloatVal* tmp = new SgFloatVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFloatVal;  
      SgFloatValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFloat128Val ); 
     SgFloat128ValStorageClass* storageArraySgFloat128Val = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFloat128Val = new SgFloat128ValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFloat128Val) , sizeof ( SgFloat128ValStorageClass ) * sizeOfActualPool) ;
        SgFloat128ValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFloat128ValStorageClass* storageArray = storageArraySgFloat128Val;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFloat128Val ( *storageArray ) ; 
#else
               SgFloat128Val* tmp = new SgFloat128Val ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFloat128Val;  
      SgFloat128ValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFloat80Val ); 
     SgFloat80ValStorageClass* storageArraySgFloat80Val = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFloat80Val = new SgFloat80ValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFloat80Val) , sizeof ( SgFloat80ValStorageClass ) * sizeOfActualPool) ;
        SgFloat80ValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFloat80ValStorageClass* storageArray = storageArraySgFloat80Val;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFloat80Val ( *storageArray ) ; 
#else
               SgFloat80Val* tmp = new SgFloat80Val ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFloat80Val;  
      SgFloat80ValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFoldExpression ); 
     SgFoldExpressionStorageClass* storageArraySgFoldExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFoldExpression = new SgFoldExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFoldExpression) , sizeof ( SgFoldExpressionStorageClass ) * sizeOfActualPool) ;
        SgFoldExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFoldExpressionStorageClass* storageArray = storageArraySgFoldExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFoldExpression ( *storageArray ) ; 
#else
               SgFoldExpression* tmp = new SgFoldExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFoldExpression;  
      SgFoldExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFlushStatement ); 
     SgFlushStatementStorageClass* storageArraySgFlushStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFlushStatement = new SgFlushStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFlushStatement) , sizeof ( SgFlushStatementStorageClass ) * sizeOfActualPool) ;
        SgFlushStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFlushStatementStorageClass* storageArray = storageArraySgFlushStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFlushStatement ( *storageArray ) ; 
#else
               SgFlushStatement* tmp = new SgFlushStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFlushStatement;  
      SgFlushStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgForAllStatement ); 
     SgForAllStatementStorageClass* storageArraySgForAllStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgForAllStatement = new SgForAllStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgForAllStatement) , sizeof ( SgForAllStatementStorageClass ) * sizeOfActualPool) ;
        SgForAllStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgForAllStatementStorageClass* storageArray = storageArraySgForAllStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgForAllStatement ( *storageArray ) ; 
#else
               SgForAllStatement* tmp = new SgForAllStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgForAllStatement;  
      SgForAllStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgForInitStatement ); 
     SgForInitStatementStorageClass* storageArraySgForInitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgForInitStatement = new SgForInitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgForInitStatement) , sizeof ( SgForInitStatementStorageClass ) * sizeOfActualPool) ;
        SgForInitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgForInitStatementStorageClass* storageArray = storageArraySgForInitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgForInitStatement ( *storageArray ) ; 
#else
               SgForInitStatement* tmp = new SgForInitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgForInitStatement;  
      SgForInitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgForStatement ); 
     SgForStatementStorageClass* storageArraySgForStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgForStatement = new SgForStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgForStatement) , sizeof ( SgForStatementStorageClass ) * sizeOfActualPool) ;
        SgForStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgForStatementStorageClass* storageArray = storageArraySgForStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgForStatement ( *storageArray ) ; 
#else
               SgForStatement* tmp = new SgForStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgForStatement;  
      SgForStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFormatItem ); 
     SgFormatItemStorageClass* storageArraySgFormatItem = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFormatItem = new SgFormatItemStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFormatItem) , sizeof ( SgFormatItemStorageClass ) * sizeOfActualPool) ;
          SgFormatItemStorageClass* storageArray = storageArraySgFormatItem;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFormatItem ( *storageArray ) ; 
#else
               SgFormatItem* tmp = new SgFormatItem ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFormatItem;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFormatItemList ); 
     SgFormatItemListStorageClass* storageArraySgFormatItemList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFormatItemList = new SgFormatItemListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFormatItemList) , sizeof ( SgFormatItemListStorageClass ) * sizeOfActualPool) ;
        SgFormatItemListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFormatItemListStorageClass* storageArray = storageArraySgFormatItemList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFormatItemList ( *storageArray ) ; 
#else
               SgFormatItemList* tmp = new SgFormatItemList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFormatItemList;  
      SgFormatItemListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFormatStatement ); 
     SgFormatStatementStorageClass* storageArraySgFormatStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFormatStatement = new SgFormatStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFormatStatement) , sizeof ( SgFormatStatementStorageClass ) * sizeOfActualPool) ;
        SgFormatStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFormatStatementStorageClass* storageArray = storageArraySgFormatStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFormatStatement ( *storageArray ) ; 
#else
               SgFormatStatement* tmp = new SgFormatStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFormatStatement;  
      SgFormatStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFortranDo ); 
     SgFortranDoStorageClass* storageArraySgFortranDo = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFortranDo = new SgFortranDoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFortranDo) , sizeof ( SgFortranDoStorageClass ) * sizeOfActualPool) ;
        SgFortranDoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFortranDoStorageClass* storageArray = storageArraySgFortranDo;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFortranDo ( *storageArray ) ; 
#else
               SgFortranDo* tmp = new SgFortranDo ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFortranDo;  
      SgFortranDoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFortranIncludeLine ); 
     SgFortranIncludeLineStorageClass* storageArraySgFortranIncludeLine = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFortranIncludeLine = new SgFortranIncludeLineStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFortranIncludeLine) , sizeof ( SgFortranIncludeLineStorageClass ) * sizeOfActualPool) ;
        SgFortranIncludeLineStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFortranIncludeLineStorageClass* storageArray = storageArraySgFortranIncludeLine;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFortranIncludeLine ( *storageArray ) ; 
#else
               SgFortranIncludeLine* tmp = new SgFortranIncludeLine ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFortranIncludeLine;  
      SgFortranIncludeLineStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFortranNonblockedDo ); 
     SgFortranNonblockedDoStorageClass* storageArraySgFortranNonblockedDo = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFortranNonblockedDo = new SgFortranNonblockedDoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFortranNonblockedDo) , sizeof ( SgFortranNonblockedDoStorageClass ) * sizeOfActualPool) ;
        SgFortranNonblockedDoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFortranNonblockedDoStorageClass* storageArray = storageArraySgFortranNonblockedDo;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFortranNonblockedDo ( *storageArray ) ; 
#else
               SgFortranNonblockedDo* tmp = new SgFortranNonblockedDo ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFortranNonblockedDo;  
      SgFortranNonblockedDoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFuncDecl_attr ); 
     SgFuncDecl_attrStorageClass* storageArraySgFuncDecl_attr = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFuncDecl_attr = new SgFuncDecl_attrStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFuncDecl_attr) , sizeof ( SgFuncDecl_attrStorageClass ) * sizeOfActualPool) ;
        SgFuncDecl_attrStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFuncDecl_attrStorageClass* storageArray = storageArraySgFuncDecl_attr;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFuncDecl_attr ( *storageArray ) ; 
#else
               SgFuncDecl_attr* tmp = new SgFuncDecl_attr ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFuncDecl_attr;  
      SgFuncDecl_attrStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionCallExp ); 
     SgFunctionCallExpStorageClass* storageArraySgFunctionCallExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionCallExp = new SgFunctionCallExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionCallExp) , sizeof ( SgFunctionCallExpStorageClass ) * sizeOfActualPool) ;
        SgFunctionCallExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionCallExpStorageClass* storageArray = storageArraySgFunctionCallExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionCallExp ( *storageArray ) ; 
#else
               SgFunctionCallExp* tmp = new SgFunctionCallExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionCallExp;  
      SgFunctionCallExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionDeclaration ); 
     SgFunctionDeclarationStorageClass* storageArraySgFunctionDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionDeclaration = new SgFunctionDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionDeclaration) , sizeof ( SgFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
        SgFunctionDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionDeclarationStorageClass* storageArray = storageArraySgFunctionDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionDeclaration ( *storageArray ) ; 
#else
               SgFunctionDeclaration* tmp = new SgFunctionDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionDeclaration;  
      SgFunctionDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionDefinition ); 
     SgFunctionDefinitionStorageClass* storageArraySgFunctionDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionDefinition = new SgFunctionDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionDefinition) , sizeof ( SgFunctionDefinitionStorageClass ) * sizeOfActualPool) ;
        SgFunctionDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionDefinitionStorageClass* storageArray = storageArraySgFunctionDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionDefinition ( *storageArray ) ; 
#else
               SgFunctionDefinition* tmp = new SgFunctionDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionDefinition;  
      SgFunctionDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionParameterScope ); 
     SgFunctionParameterScopeStorageClass* storageArraySgFunctionParameterScope = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionParameterScope = new SgFunctionParameterScopeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionParameterScope) , sizeof ( SgFunctionParameterScopeStorageClass ) * sizeOfActualPool) ;
        SgFunctionParameterScopeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionParameterScopeStorageClass* storageArray = storageArraySgFunctionParameterScope;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionParameterScope ( *storageArray ) ; 
#else
               SgFunctionParameterScope* tmp = new SgFunctionParameterScope ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionParameterScope;  
      SgFunctionParameterScopeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionModifier ); 
     SgFunctionModifierStorageClass* storageArraySgFunctionModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionModifier = new SgFunctionModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionModifier) , sizeof ( SgFunctionModifierStorageClass ) * sizeOfActualPool) ;
        SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionModifierStorageClass* storageArray = storageArraySgFunctionModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionModifier ( *storageArray ) ; 
#else
               SgFunctionModifier* tmp = new SgFunctionModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionModifier;  
      SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionParameterList ); 
     SgFunctionParameterListStorageClass* storageArraySgFunctionParameterList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionParameterList = new SgFunctionParameterListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionParameterList) , sizeof ( SgFunctionParameterListStorageClass ) * sizeOfActualPool) ;
        SgFunctionParameterListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionParameterListStorageClass* storageArray = storageArraySgFunctionParameterList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionParameterList ( *storageArray ) ; 
#else
               SgFunctionParameterList* tmp = new SgFunctionParameterList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionParameterList;  
      SgFunctionParameterListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionParameterRefExp ); 
     SgFunctionParameterRefExpStorageClass* storageArraySgFunctionParameterRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionParameterRefExp = new SgFunctionParameterRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionParameterRefExp) , sizeof ( SgFunctionParameterRefExpStorageClass ) * sizeOfActualPool) ;
        SgFunctionParameterRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionParameterRefExpStorageClass* storageArray = storageArraySgFunctionParameterRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionParameterRefExp ( *storageArray ) ; 
#else
               SgFunctionParameterRefExp* tmp = new SgFunctionParameterRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionParameterRefExp;  
      SgFunctionParameterRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionParameterTypeList ); 
     SgFunctionParameterTypeListStorageClass* storageArraySgFunctionParameterTypeList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionParameterTypeList = new SgFunctionParameterTypeListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionParameterTypeList) , sizeof ( SgFunctionParameterTypeListStorageClass ) * sizeOfActualPool) ;
        SgFunctionParameterTypeListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionParameterTypeListStorageClass* storageArray = storageArraySgFunctionParameterTypeList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionParameterTypeList ( *storageArray ) ; 
#else
               SgFunctionParameterTypeList* tmp = new SgFunctionParameterTypeList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionParameterTypeList;  
      SgFunctionParameterTypeListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionRefExp ); 
     SgFunctionRefExpStorageClass* storageArraySgFunctionRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionRefExp = new SgFunctionRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionRefExp) , sizeof ( SgFunctionRefExpStorageClass ) * sizeOfActualPool) ;
        SgFunctionRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionRefExpStorageClass* storageArray = storageArraySgFunctionRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionRefExp ( *storageArray ) ; 
#else
               SgFunctionRefExp* tmp = new SgFunctionRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionRefExp;  
      SgFunctionRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionSymbol ); 
     SgFunctionSymbolStorageClass* storageArraySgFunctionSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionSymbol = new SgFunctionSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionSymbol) , sizeof ( SgFunctionSymbolStorageClass ) * sizeOfActualPool) ;
        SgFunctionSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionSymbolStorageClass* storageArray = storageArraySgFunctionSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionSymbol ( *storageArray ) ; 
#else
               SgFunctionSymbol* tmp = new SgFunctionSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionSymbol;  
      SgFunctionSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionType ); 
     SgFunctionTypeStorageClass* storageArraySgFunctionType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionType = new SgFunctionTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionType) , sizeof ( SgFunctionTypeStorageClass ) * sizeOfActualPool) ;
        SgFunctionTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionTypeStorageClass* storageArray = storageArraySgFunctionType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionType ( *storageArray ) ; 
#else
               SgFunctionType* tmp = new SgFunctionType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionType;  
      SgFunctionTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionTypeSymbol ); 
     SgFunctionTypeSymbolStorageClass* storageArraySgFunctionTypeSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionTypeSymbol = new SgFunctionTypeSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionTypeSymbol) , sizeof ( SgFunctionTypeSymbolStorageClass ) * sizeOfActualPool) ;
        SgFunctionTypeSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionTypeSymbolStorageClass* storageArray = storageArraySgFunctionTypeSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionTypeSymbol ( *storageArray ) ; 
#else
               SgFunctionTypeSymbol* tmp = new SgFunctionTypeSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionTypeSymbol;  
      SgFunctionTypeSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionTypeTable ); 
     SgFunctionTypeTableStorageClass* storageArraySgFunctionTypeTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionTypeTable = new SgFunctionTypeTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionTypeTable) , sizeof ( SgFunctionTypeTableStorageClass ) * sizeOfActualPool) ;
        SgFunctionTypeTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionTypeTableStorageClass* storageArray = storageArraySgFunctionTypeTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFunctionTypeTable ( *storageArray ) ; 
#else
               SgFunctionTypeTable* tmp = new SgFunctionTypeTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionTypeTable;  
      SgFunctionTypeTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeTable ); 
     SgTypeTableStorageClass* storageArraySgTypeTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeTable = new SgTypeTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeTable) , sizeof ( SgTypeTableStorageClass ) * sizeOfActualPool) ;
          SgTypeTableStorageClass* storageArray = storageArraySgTypeTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeTable ( *storageArray ) ; 
#else
               SgTypeTable* tmp = new SgTypeTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeTable;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGlobal ); 
     SgGlobalStorageClass* storageArraySgGlobal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGlobal = new SgGlobalStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGlobal) , sizeof ( SgGlobalStorageClass ) * sizeOfActualPool) ;
        SgGlobalStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGlobalStorageClass* storageArray = storageArraySgGlobal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgGlobal ( *storageArray ) ; 
#else
               SgGlobal* tmp = new SgGlobal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGlobal;  
      SgGlobalStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGotoStatement ); 
     SgGotoStatementStorageClass* storageArraySgGotoStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGotoStatement = new SgGotoStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGotoStatement) , sizeof ( SgGotoStatementStorageClass ) * sizeOfActualPool) ;
        SgGotoStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGotoStatementStorageClass* storageArray = storageArraySgGotoStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgGotoStatement ( *storageArray ) ; 
#else
               SgGotoStatement* tmp = new SgGotoStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGotoStatement;  
      SgGotoStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraph ); 
     SgGraphStorageClass* storageArraySgGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraph = new SgGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraph) , sizeof ( SgGraphStorageClass ) * sizeOfActualPool) ;
        SgGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGraphStorageClass* storageArray = storageArraySgGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgGraph ( *storageArray ) ; 
#else
               SgGraph* tmp = new SgGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraph;  
      SgGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraphEdge ); 
     SgGraphEdgeStorageClass* storageArraySgGraphEdge = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraphEdge = new SgGraphEdgeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraphEdge) , sizeof ( SgGraphEdgeStorageClass ) * sizeOfActualPool) ;
        SgGraphEdgeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGraphEdgeStorageClass* storageArray = storageArraySgGraphEdge;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgGraphEdge ( *storageArray ) ; 
#else
               SgGraphEdge* tmp = new SgGraphEdge ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraphEdge;  
      SgGraphEdgeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraphEdgeList ); 
     SgGraphEdgeListStorageClass* storageArraySgGraphEdgeList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraphEdgeList = new SgGraphEdgeListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraphEdgeList) , sizeof ( SgGraphEdgeListStorageClass ) * sizeOfActualPool) ;
          SgGraphEdgeListStorageClass* storageArray = storageArraySgGraphEdgeList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgGraphEdgeList ( *storageArray ) ; 
#else
               SgGraphEdgeList* tmp = new SgGraphEdgeList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraphEdgeList;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraphNode ); 
     SgGraphNodeStorageClass* storageArraySgGraphNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraphNode = new SgGraphNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraphNode) , sizeof ( SgGraphNodeStorageClass ) * sizeOfActualPool) ;
        SgGraphNodeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGraphNodeStorageClass* storageArray = storageArraySgGraphNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgGraphNode ( *storageArray ) ; 
#else
               SgGraphNode* tmp = new SgGraphNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraphNode;  
      SgGraphNodeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraphNodeList ); 
     SgGraphNodeListStorageClass* storageArraySgGraphNodeList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraphNodeList = new SgGraphNodeListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraphNodeList) , sizeof ( SgGraphNodeListStorageClass ) * sizeOfActualPool) ;
          SgGraphNodeListStorageClass* storageArray = storageArraySgGraphNodeList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgGraphNodeList ( *storageArray ) ; 
#else
               SgGraphNodeList* tmp = new SgGraphNodeList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraphNodeList;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGreaterOrEqualOp ); 
     SgGreaterOrEqualOpStorageClass* storageArraySgGreaterOrEqualOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGreaterOrEqualOp = new SgGreaterOrEqualOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGreaterOrEqualOp) , sizeof ( SgGreaterOrEqualOpStorageClass ) * sizeOfActualPool) ;
        SgGreaterOrEqualOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGreaterOrEqualOpStorageClass* storageArray = storageArraySgGreaterOrEqualOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgGreaterOrEqualOp ( *storageArray ) ; 
#else
               SgGreaterOrEqualOp* tmp = new SgGreaterOrEqualOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGreaterOrEqualOp;  
      SgGreaterOrEqualOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGreaterThanOp ); 
     SgGreaterThanOpStorageClass* storageArraySgGreaterThanOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGreaterThanOp = new SgGreaterThanOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGreaterThanOp) , sizeof ( SgGreaterThanOpStorageClass ) * sizeOfActualPool) ;
        SgGreaterThanOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGreaterThanOpStorageClass* storageArray = storageArraySgGreaterThanOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgGreaterThanOp ( *storageArray ) ; 
#else
               SgGreaterThanOp* tmp = new SgGreaterThanOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGreaterThanOp;  
      SgGreaterThanOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIOItemExpression ); 
     SgIOItemExpressionStorageClass* storageArraySgIOItemExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIOItemExpression = new SgIOItemExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIOItemExpression) , sizeof ( SgIOItemExpressionStorageClass ) * sizeOfActualPool) ;
        SgIOItemExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIOItemExpressionStorageClass* storageArray = storageArraySgIOItemExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIOItemExpression ( *storageArray ) ; 
#else
               SgIOItemExpression* tmp = new SgIOItemExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIOItemExpression;  
      SgIOItemExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIOStatement ); 
     SgIOStatementStorageClass* storageArraySgIOStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIOStatement = new SgIOStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIOStatement) , sizeof ( SgIOStatementStorageClass ) * sizeOfActualPool) ;
        SgIOStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIOStatementStorageClass* storageArray = storageArraySgIOStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIOStatement ( *storageArray ) ; 
#else
               SgIOStatement* tmp = new SgIOStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIOStatement;  
      SgIOStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIdentDirectiveStatement ); 
     SgIdentDirectiveStatementStorageClass* storageArraySgIdentDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIdentDirectiveStatement = new SgIdentDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIdentDirectiveStatement) , sizeof ( SgIdentDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIdentDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIdentDirectiveStatementStorageClass* storageArray = storageArraySgIdentDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIdentDirectiveStatement ( *storageArray ) ; 
#else
               SgIdentDirectiveStatement* tmp = new SgIdentDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIdentDirectiveStatement;  
      SgIdentDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIfDirectiveStatement ); 
     SgIfDirectiveStatementStorageClass* storageArraySgIfDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIfDirectiveStatement = new SgIfDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIfDirectiveStatement) , sizeof ( SgIfDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIfDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIfDirectiveStatementStorageClass* storageArray = storageArraySgIfDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIfDirectiveStatement ( *storageArray ) ; 
#else
               SgIfDirectiveStatement* tmp = new SgIfDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIfDirectiveStatement;  
      SgIfDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIfStmt ); 
     SgIfStmtStorageClass* storageArraySgIfStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIfStmt = new SgIfStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIfStmt) , sizeof ( SgIfStmtStorageClass ) * sizeOfActualPool) ;
        SgIfStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIfStmtStorageClass* storageArray = storageArraySgIfStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIfStmt ( *storageArray ) ; 
#else
               SgIfStmt* tmp = new SgIfStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIfStmt;  
      SgIfStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIfdefDirectiveStatement ); 
     SgIfdefDirectiveStatementStorageClass* storageArraySgIfdefDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIfdefDirectiveStatement = new SgIfdefDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIfdefDirectiveStatement) , sizeof ( SgIfdefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIfdefDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIfdefDirectiveStatementStorageClass* storageArray = storageArraySgIfdefDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIfdefDirectiveStatement ( *storageArray ) ; 
#else
               SgIfdefDirectiveStatement* tmp = new SgIfdefDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIfdefDirectiveStatement;  
      SgIfdefDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIfndefDirectiveStatement ); 
     SgIfndefDirectiveStatementStorageClass* storageArraySgIfndefDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIfndefDirectiveStatement = new SgIfndefDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIfndefDirectiveStatement) , sizeof ( SgIfndefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIfndefDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIfndefDirectiveStatementStorageClass* storageArray = storageArraySgIfndefDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIfndefDirectiveStatement ( *storageArray ) ; 
#else
               SgIfndefDirectiveStatement* tmp = new SgIfndefDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIfndefDirectiveStatement;  
      SgIfndefDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgImageControlStatement ); 
     SgImageControlStatementStorageClass* storageArraySgImageControlStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgImageControlStatement = new SgImageControlStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgImageControlStatement) , sizeof ( SgImageControlStatementStorageClass ) * sizeOfActualPool) ;
        SgImageControlStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgImageControlStatementStorageClass* storageArray = storageArraySgImageControlStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgImageControlStatement ( *storageArray ) ; 
#else
               SgImageControlStatement* tmp = new SgImageControlStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgImageControlStatement;  
      SgImageControlStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgImagPartOp ); 
     SgImagPartOpStorageClass* storageArraySgImagPartOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgImagPartOp = new SgImagPartOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgImagPartOp) , sizeof ( SgImagPartOpStorageClass ) * sizeOfActualPool) ;
        SgImagPartOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgImagPartOpStorageClass* storageArray = storageArraySgImagPartOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgImagPartOp ( *storageArray ) ; 
#else
               SgImagPartOp* tmp = new SgImagPartOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgImagPartOp;  
      SgImagPartOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgImplicitStatement ); 
     SgImplicitStatementStorageClass* storageArraySgImplicitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgImplicitStatement = new SgImplicitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgImplicitStatement) , sizeof ( SgImplicitStatementStorageClass ) * sizeOfActualPool) ;
        SgImplicitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgImplicitStatementStorageClass* storageArray = storageArraySgImplicitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgImplicitStatement ( *storageArray ) ; 
#else
               SgImplicitStatement* tmp = new SgImplicitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgImplicitStatement;  
      SgImplicitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgImpliedDo ); 
     SgImpliedDoStorageClass* storageArraySgImpliedDo = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgImpliedDo = new SgImpliedDoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgImpliedDo) , sizeof ( SgImpliedDoStorageClass ) * sizeOfActualPool) ;
        SgImpliedDoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgImpliedDoStorageClass* storageArray = storageArraySgImpliedDo;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgImpliedDo ( *storageArray ) ; 
#else
               SgImpliedDo* tmp = new SgImpliedDo ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgImpliedDo;  
      SgImpliedDoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgImportStatement ); 
     SgImportStatementStorageClass* storageArraySgImportStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgImportStatement = new SgImportStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgImportStatement) , sizeof ( SgImportStatementStorageClass ) * sizeOfActualPool) ;
        SgImportStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgImportStatementStorageClass* storageArray = storageArraySgImportStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgImportStatement ( *storageArray ) ; 
#else
               SgImportStatement* tmp = new SgImportStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgImportStatement;  
      SgImportStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIncidenceDirectedGraph ); 
     SgIncidenceDirectedGraphStorageClass* storageArraySgIncidenceDirectedGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIncidenceDirectedGraph = new SgIncidenceDirectedGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIncidenceDirectedGraph) , sizeof ( SgIncidenceDirectedGraphStorageClass ) * sizeOfActualPool) ;
        SgIncidenceDirectedGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIncidenceDirectedGraphStorageClass* storageArray = storageArraySgIncidenceDirectedGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIncidenceDirectedGraph ( *storageArray ) ; 
#else
               SgIncidenceDirectedGraph* tmp = new SgIncidenceDirectedGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIncidenceDirectedGraph;  
      SgIncidenceDirectedGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIncidenceUndirectedGraph ); 
     SgIncidenceUndirectedGraphStorageClass* storageArraySgIncidenceUndirectedGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIncidenceUndirectedGraph = new SgIncidenceUndirectedGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIncidenceUndirectedGraph) , sizeof ( SgIncidenceUndirectedGraphStorageClass ) * sizeOfActualPool) ;
        SgIncidenceUndirectedGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIncidenceUndirectedGraphStorageClass* storageArray = storageArraySgIncidenceUndirectedGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIncidenceUndirectedGraph ( *storageArray ) ; 
#else
               SgIncidenceUndirectedGraph* tmp = new SgIncidenceUndirectedGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIncidenceUndirectedGraph;  
      SgIncidenceUndirectedGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIncludeDirectiveStatement ); 
     SgIncludeDirectiveStatementStorageClass* storageArraySgIncludeDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIncludeDirectiveStatement = new SgIncludeDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIncludeDirectiveStatement) , sizeof ( SgIncludeDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIncludeDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIncludeDirectiveStatementStorageClass* storageArray = storageArraySgIncludeDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIncludeDirectiveStatement ( *storageArray ) ; 
#else
               SgIncludeDirectiveStatement* tmp = new SgIncludeDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIncludeDirectiveStatement;  
      SgIncludeDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIncludeFile ); 
     SgIncludeFileStorageClass* storageArraySgIncludeFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIncludeFile = new SgIncludeFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIncludeFile) , sizeof ( SgIncludeFileStorageClass ) * sizeOfActualPool) ;
        SgIncludeFileStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIncludeFileStorageClass* storageArray = storageArraySgIncludeFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIncludeFile ( *storageArray ) ; 
#else
               SgIncludeFile* tmp = new SgIncludeFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIncludeFile;  
      SgIncludeFileStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIncludeNextDirectiveStatement ); 
     SgIncludeNextDirectiveStatementStorageClass* storageArraySgIncludeNextDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIncludeNextDirectiveStatement = new SgIncludeNextDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIncludeNextDirectiveStatement) , sizeof ( SgIncludeNextDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIncludeNextDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIncludeNextDirectiveStatementStorageClass* storageArray = storageArraySgIncludeNextDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIncludeNextDirectiveStatement ( *storageArray ) ; 
#else
               SgIncludeNextDirectiveStatement* tmp = new SgIncludeNextDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIncludeNextDirectiveStatement;  
      SgIncludeNextDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInitializedName ); 
     SgInitializedNameStorageClass* storageArraySgInitializedName = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInitializedName = new SgInitializedNameStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInitializedName) , sizeof ( SgInitializedNameStorageClass ) * sizeOfActualPool) ;
        SgInitializedNameStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInitializedNameStorageClass* storageArray = storageArraySgInitializedName;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgInitializedName ( *storageArray ) ; 
#else
               SgInitializedName* tmp = new SgInitializedName ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInitializedName;  
      SgInitializedNameStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInitializer ); 
     SgInitializerStorageClass* storageArraySgInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInitializer = new SgInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInitializer) , sizeof ( SgInitializerStorageClass ) * sizeOfActualPool) ;
        SgInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInitializerStorageClass* storageArray = storageArraySgInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgInitializer ( *storageArray ) ; 
#else
               SgInitializer* tmp = new SgInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInitializer;  
      SgInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInquireStatement ); 
     SgInquireStatementStorageClass* storageArraySgInquireStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInquireStatement = new SgInquireStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInquireStatement) , sizeof ( SgInquireStatementStorageClass ) * sizeOfActualPool) ;
        SgInquireStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInquireStatementStorageClass* storageArray = storageArraySgInquireStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgInquireStatement ( *storageArray ) ; 
#else
               SgInquireStatement* tmp = new SgInquireStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInquireStatement;  
      SgInquireStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntKeyedBidirectionalGraph ); 
     SgIntKeyedBidirectionalGraphStorageClass* storageArraySgIntKeyedBidirectionalGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntKeyedBidirectionalGraph = new SgIntKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntKeyedBidirectionalGraph) , sizeof ( SgIntKeyedBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
        SgIntKeyedBidirectionalGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntKeyedBidirectionalGraphStorageClass* storageArray = storageArraySgIntKeyedBidirectionalGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIntKeyedBidirectionalGraph ( *storageArray ) ; 
#else
               SgIntKeyedBidirectionalGraph* tmp = new SgIntKeyedBidirectionalGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntKeyedBidirectionalGraph;  
      SgIntKeyedBidirectionalGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntVal ); 
     SgIntValStorageClass* storageArraySgIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntVal = new SgIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntVal) , sizeof ( SgIntValStorageClass ) * sizeOfActualPool) ;
        SgIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntValStorageClass* storageArray = storageArraySgIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIntVal ( *storageArray ) ; 
#else
               SgIntVal* tmp = new SgIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntVal;  
      SgIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntegerDivideOp ); 
     SgIntegerDivideOpStorageClass* storageArraySgIntegerDivideOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntegerDivideOp = new SgIntegerDivideOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntegerDivideOp) , sizeof ( SgIntegerDivideOpStorageClass ) * sizeOfActualPool) ;
        SgIntegerDivideOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntegerDivideOpStorageClass* storageArray = storageArraySgIntegerDivideOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIntegerDivideOp ( *storageArray ) ; 
#else
               SgIntegerDivideOp* tmp = new SgIntegerDivideOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntegerDivideOp;  
      SgIntegerDivideOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntegerDivideAssignOp ); 
     SgIntegerDivideAssignOpStorageClass* storageArraySgIntegerDivideAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntegerDivideAssignOp = new SgIntegerDivideAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntegerDivideAssignOp) , sizeof ( SgIntegerDivideAssignOpStorageClass ) * sizeOfActualPool) ;
        SgIntegerDivideAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntegerDivideAssignOpStorageClass* storageArray = storageArraySgIntegerDivideAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIntegerDivideAssignOp ( *storageArray ) ; 
#else
               SgIntegerDivideAssignOp* tmp = new SgIntegerDivideAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntegerDivideAssignOp;  
      SgIntegerDivideAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInterfaceBody ); 
     SgInterfaceBodyStorageClass* storageArraySgInterfaceBody = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInterfaceBody = new SgInterfaceBodyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInterfaceBody) , sizeof ( SgInterfaceBodyStorageClass ) * sizeOfActualPool) ;
        SgInterfaceBodyStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInterfaceBodyStorageClass* storageArray = storageArraySgInterfaceBody;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgInterfaceBody ( *storageArray ) ; 
#else
               SgInterfaceBody* tmp = new SgInterfaceBody ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInterfaceBody;  
      SgInterfaceBodyStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgHeaderFileBody ); 
     SgHeaderFileBodyStorageClass* storageArraySgHeaderFileBody = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgHeaderFileBody = new SgHeaderFileBodyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgHeaderFileBody) , sizeof ( SgHeaderFileBodyStorageClass ) * sizeOfActualPool) ;
        SgHeaderFileBodyStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgHeaderFileBodyStorageClass* storageArray = storageArraySgHeaderFileBody;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgHeaderFileBody ( *storageArray ) ; 
#else
               SgHeaderFileBody* tmp = new SgHeaderFileBody ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgHeaderFileBody;  
      SgHeaderFileBodyStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgHeaderFileReport ); 
     SgHeaderFileReportStorageClass* storageArraySgHeaderFileReport = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgHeaderFileReport = new SgHeaderFileReportStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgHeaderFileReport) , sizeof ( SgHeaderFileReportStorageClass ) * sizeOfActualPool) ;
        SgHeaderFileReportStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgHeaderFileReportStorageClass* storageArray = storageArraySgHeaderFileReport;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgHeaderFileReport ( *storageArray ) ; 
#else
               SgHeaderFileReport* tmp = new SgHeaderFileReport ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgHeaderFileReport;  
      SgHeaderFileReportStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInterfaceStatement ); 
     SgInterfaceStatementStorageClass* storageArraySgInterfaceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInterfaceStatement = new SgInterfaceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInterfaceStatement) , sizeof ( SgInterfaceStatementStorageClass ) * sizeOfActualPool) ;
        SgInterfaceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInterfaceStatementStorageClass* storageArray = storageArraySgInterfaceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgInterfaceStatement ( *storageArray ) ; 
#else
               SgInterfaceStatement* tmp = new SgInterfaceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInterfaceStatement;  
      SgInterfaceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInterfaceSymbol ); 
     SgInterfaceSymbolStorageClass* storageArraySgInterfaceSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInterfaceSymbol = new SgInterfaceSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInterfaceSymbol) , sizeof ( SgInterfaceSymbolStorageClass ) * sizeOfActualPool) ;
        SgInterfaceSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInterfaceSymbolStorageClass* storageArray = storageArraySgInterfaceSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgInterfaceSymbol ( *storageArray ) ; 
#else
               SgInterfaceSymbol* tmp = new SgInterfaceSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInterfaceSymbol;  
      SgInterfaceSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntrinsicSymbol ); 
     SgIntrinsicSymbolStorageClass* storageArraySgIntrinsicSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntrinsicSymbol = new SgIntrinsicSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntrinsicSymbol) , sizeof ( SgIntrinsicSymbolStorageClass ) * sizeOfActualPool) ;
        SgIntrinsicSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntrinsicSymbolStorageClass* storageArray = storageArraySgIntrinsicSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIntrinsicSymbol ( *storageArray ) ; 
#else
               SgIntrinsicSymbol* tmp = new SgIntrinsicSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntrinsicSymbol;  
      SgIntrinsicSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIsOp ); 
     SgIsOpStorageClass* storageArraySgIsOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIsOp = new SgIsOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIsOp) , sizeof ( SgIsOpStorageClass ) * sizeOfActualPool) ;
        SgIsOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIsOpStorageClass* storageArray = storageArraySgIsOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIsOp ( *storageArray ) ; 
#else
               SgIsOp* tmp = new SgIsOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIsOp;  
      SgIsOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIsNotOp ); 
     SgIsNotOpStorageClass* storageArraySgIsNotOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIsNotOp = new SgIsNotOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIsNotOp) , sizeof ( SgIsNotOpStorageClass ) * sizeOfActualPool) ;
        SgIsNotOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIsNotOpStorageClass* storageArray = storageArraySgIsNotOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIsNotOp ( *storageArray ) ; 
#else
               SgIsNotOp* tmp = new SgIsNotOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIsNotOp;  
      SgIsNotOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIorAssignOp ); 
     SgIorAssignOpStorageClass* storageArraySgIorAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIorAssignOp = new SgIorAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIorAssignOp) , sizeof ( SgIorAssignOpStorageClass ) * sizeOfActualPool) ;
        SgIorAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIorAssignOpStorageClass* storageArray = storageArraySgIorAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgIorAssignOp ( *storageArray ) ; 
#else
               SgIorAssignOp* tmp = new SgIorAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIorAssignOp;  
      SgIorAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialBitType ); 
     SgJovialBitTypeStorageClass* storageArraySgJovialBitType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialBitType = new SgJovialBitTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialBitType) , sizeof ( SgJovialBitTypeStorageClass ) * sizeOfActualPool) ;
        SgJovialBitTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialBitTypeStorageClass* storageArray = storageArraySgJovialBitType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialBitType ( *storageArray ) ; 
#else
               SgJovialBitType* tmp = new SgJovialBitType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialBitType;  
      SgJovialBitTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialBitVal ); 
     SgJovialBitValStorageClass* storageArraySgJovialBitVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialBitVal = new SgJovialBitValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialBitVal) , sizeof ( SgJovialBitValStorageClass ) * sizeOfActualPool) ;
        SgJovialBitValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialBitValStorageClass* storageArray = storageArraySgJovialBitVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialBitVal ( *storageArray ) ; 
#else
               SgJovialBitVal* tmp = new SgJovialBitVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialBitVal;  
      SgJovialBitValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialTableType ); 
     SgJovialTableTypeStorageClass* storageArraySgJovialTableType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialTableType = new SgJovialTableTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialTableType) , sizeof ( SgJovialTableTypeStorageClass ) * sizeOfActualPool) ;
        SgJovialTableTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialTableTypeStorageClass* storageArray = storageArraySgJovialTableType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialTableType ( *storageArray ) ; 
#else
               SgJovialTableType* tmp = new SgJovialTableType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialTableType;  
      SgJovialTableTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialCompoolStatement ); 
     SgJovialCompoolStatementStorageClass* storageArraySgJovialCompoolStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialCompoolStatement = new SgJovialCompoolStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialCompoolStatement) , sizeof ( SgJovialCompoolStatementStorageClass ) * sizeOfActualPool) ;
        SgJovialCompoolStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialCompoolStatementStorageClass* storageArray = storageArraySgJovialCompoolStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialCompoolStatement ( *storageArray ) ; 
#else
               SgJovialCompoolStatement* tmp = new SgJovialCompoolStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialCompoolStatement;  
      SgJovialCompoolStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialForThenStatement ); 
     SgJovialForThenStatementStorageClass* storageArraySgJovialForThenStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialForThenStatement = new SgJovialForThenStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialForThenStatement) , sizeof ( SgJovialForThenStatementStorageClass ) * sizeOfActualPool) ;
        SgJovialForThenStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialForThenStatementStorageClass* storageArray = storageArraySgJovialForThenStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialForThenStatement ( *storageArray ) ; 
#else
               SgJovialForThenStatement* tmp = new SgJovialForThenStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialForThenStatement;  
      SgJovialForThenStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialDefineDeclaration ); 
     SgJovialDefineDeclarationStorageClass* storageArraySgJovialDefineDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialDefineDeclaration = new SgJovialDefineDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialDefineDeclaration) , sizeof ( SgJovialDefineDeclarationStorageClass ) * sizeOfActualPool) ;
        SgJovialDefineDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialDefineDeclarationStorageClass* storageArray = storageArraySgJovialDefineDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialDefineDeclaration ( *storageArray ) ; 
#else
               SgJovialDefineDeclaration* tmp = new SgJovialDefineDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialDefineDeclaration;  
      SgJovialDefineDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialDirectiveStatement ); 
     SgJovialDirectiveStatementStorageClass* storageArraySgJovialDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialDirectiveStatement = new SgJovialDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialDirectiveStatement) , sizeof ( SgJovialDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgJovialDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialDirectiveStatementStorageClass* storageArray = storageArraySgJovialDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialDirectiveStatement ( *storageArray ) ; 
#else
               SgJovialDirectiveStatement* tmp = new SgJovialDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialDirectiveStatement;  
      SgJovialDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialOverlayDeclaration ); 
     SgJovialOverlayDeclarationStorageClass* storageArraySgJovialOverlayDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialOverlayDeclaration = new SgJovialOverlayDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialOverlayDeclaration) , sizeof ( SgJovialOverlayDeclarationStorageClass ) * sizeOfActualPool) ;
        SgJovialOverlayDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialOverlayDeclarationStorageClass* storageArray = storageArraySgJovialOverlayDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialOverlayDeclaration ( *storageArray ) ; 
#else
               SgJovialOverlayDeclaration* tmp = new SgJovialOverlayDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialOverlayDeclaration;  
      SgJovialOverlayDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialPresetPositionExp ); 
     SgJovialPresetPositionExpStorageClass* storageArraySgJovialPresetPositionExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialPresetPositionExp = new SgJovialPresetPositionExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialPresetPositionExp) , sizeof ( SgJovialPresetPositionExpStorageClass ) * sizeOfActualPool) ;
        SgJovialPresetPositionExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialPresetPositionExpStorageClass* storageArray = storageArraySgJovialPresetPositionExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialPresetPositionExp ( *storageArray ) ; 
#else
               SgJovialPresetPositionExp* tmp = new SgJovialPresetPositionExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialPresetPositionExp;  
      SgJovialPresetPositionExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialTablePresetExp ); 
     SgJovialTablePresetExpStorageClass* storageArraySgJovialTablePresetExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialTablePresetExp = new SgJovialTablePresetExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialTablePresetExp) , sizeof ( SgJovialTablePresetExpStorageClass ) * sizeOfActualPool) ;
        SgJovialTablePresetExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialTablePresetExpStorageClass* storageArray = storageArraySgJovialTablePresetExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialTablePresetExp ( *storageArray ) ; 
#else
               SgJovialTablePresetExp* tmp = new SgJovialTablePresetExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialTablePresetExp;  
      SgJovialTablePresetExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialTableStatement ); 
     SgJovialTableStatementStorageClass* storageArraySgJovialTableStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialTableStatement = new SgJovialTableStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialTableStatement) , sizeof ( SgJovialTableStatementStorageClass ) * sizeOfActualPool) ;
        SgJovialTableStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialTableStatementStorageClass* storageArray = storageArraySgJovialTableStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialTableStatement ( *storageArray ) ; 
#else
               SgJovialTableStatement* tmp = new SgJovialTableStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialTableStatement;  
      SgJovialTableStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgKeyDatumPair ); 
     SgKeyDatumPairStorageClass* storageArraySgKeyDatumPair = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgKeyDatumPair = new SgKeyDatumPairStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgKeyDatumPair) , sizeof ( SgKeyDatumPairStorageClass ) * sizeOfActualPool) ;
        SgKeyDatumPairStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgKeyDatumPairStorageClass* storageArray = storageArraySgKeyDatumPair;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgKeyDatumPair ( *storageArray ) ; 
#else
               SgKeyDatumPair* tmp = new SgKeyDatumPair ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgKeyDatumPair;  
      SgKeyDatumPairStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCudaKernelExecConfig ); 
     SgCudaKernelExecConfigStorageClass* storageArraySgCudaKernelExecConfig = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCudaKernelExecConfig = new SgCudaKernelExecConfigStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCudaKernelExecConfig) , sizeof ( SgCudaKernelExecConfigStorageClass ) * sizeOfActualPool) ;
        SgCudaKernelExecConfigStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCudaKernelExecConfigStorageClass* storageArray = storageArraySgCudaKernelExecConfig;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCudaKernelExecConfig ( *storageArray ) ; 
#else
               SgCudaKernelExecConfig* tmp = new SgCudaKernelExecConfig ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCudaKernelExecConfig;  
      SgCudaKernelExecConfigStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCudaKernelCallExp ); 
     SgCudaKernelCallExpStorageClass* storageArraySgCudaKernelCallExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCudaKernelCallExp = new SgCudaKernelCallExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCudaKernelCallExp) , sizeof ( SgCudaKernelCallExpStorageClass ) * sizeOfActualPool) ;
        SgCudaKernelCallExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCudaKernelCallExpStorageClass* storageArray = storageArraySgCudaKernelCallExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCudaKernelCallExp ( *storageArray ) ; 
#else
               SgCudaKernelCallExp* tmp = new SgCudaKernelCallExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCudaKernelCallExp;  
      SgCudaKernelCallExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLabelRefExp ); 
     SgLabelRefExpStorageClass* storageArraySgLabelRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLabelRefExp = new SgLabelRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLabelRefExp) , sizeof ( SgLabelRefExpStorageClass ) * sizeOfActualPool) ;
        SgLabelRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLabelRefExpStorageClass* storageArray = storageArraySgLabelRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLabelRefExp ( *storageArray ) ; 
#else
               SgLabelRefExp* tmp = new SgLabelRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLabelRefExp;  
      SgLabelRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLabelStatement ); 
     SgLabelStatementStorageClass* storageArraySgLabelStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLabelStatement = new SgLabelStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLabelStatement) , sizeof ( SgLabelStatementStorageClass ) * sizeOfActualPool) ;
        SgLabelStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLabelStatementStorageClass* storageArray = storageArraySgLabelStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLabelStatement ( *storageArray ) ; 
#else
               SgLabelStatement* tmp = new SgLabelStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLabelStatement;  
      SgLabelStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaLabelStatement ); 
     SgJavaLabelStatementStorageClass* storageArraySgJavaLabelStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaLabelStatement = new SgJavaLabelStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaLabelStatement) , sizeof ( SgJavaLabelStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaLabelStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaLabelStatementStorageClass* storageArray = storageArraySgJavaLabelStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaLabelStatement ( *storageArray ) ; 
#else
               SgJavaLabelStatement* tmp = new SgJavaLabelStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaLabelStatement;  
      SgJavaLabelStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLabelSymbol ); 
     SgLabelSymbolStorageClass* storageArraySgLabelSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLabelSymbol = new SgLabelSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLabelSymbol) , sizeof ( SgLabelSymbolStorageClass ) * sizeOfActualPool) ;
        SgLabelSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLabelSymbolStorageClass* storageArray = storageArraySgLabelSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLabelSymbol ( *storageArray ) ; 
#else
               SgLabelSymbol* tmp = new SgLabelSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLabelSymbol;  
      SgLabelSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaLabelSymbol ); 
     SgJavaLabelSymbolStorageClass* storageArraySgJavaLabelSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaLabelSymbol = new SgJavaLabelSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaLabelSymbol) , sizeof ( SgJavaLabelSymbolStorageClass ) * sizeOfActualPool) ;
        SgJavaLabelSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaLabelSymbolStorageClass* storageArray = storageArraySgJavaLabelSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaLabelSymbol ( *storageArray ) ; 
#else
               SgJavaLabelSymbol* tmp = new SgJavaLabelSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaLabelSymbol;  
      SgJavaLabelSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLambdaCapture ); 
     SgLambdaCaptureStorageClass* storageArraySgLambdaCapture = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLambdaCapture = new SgLambdaCaptureStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLambdaCapture) , sizeof ( SgLambdaCaptureStorageClass ) * sizeOfActualPool) ;
        SgLambdaCaptureStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLambdaCaptureStorageClass* storageArray = storageArraySgLambdaCapture;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLambdaCapture ( *storageArray ) ; 
#else
               SgLambdaCapture* tmp = new SgLambdaCapture ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLambdaCapture;  
      SgLambdaCaptureStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLambdaCaptureList ); 
     SgLambdaCaptureListStorageClass* storageArraySgLambdaCaptureList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLambdaCaptureList = new SgLambdaCaptureListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLambdaCaptureList) , sizeof ( SgLambdaCaptureListStorageClass ) * sizeOfActualPool) ;
        SgLambdaCaptureListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLambdaCaptureListStorageClass* storageArray = storageArraySgLambdaCaptureList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLambdaCaptureList ( *storageArray ) ; 
#else
               SgLambdaCaptureList* tmp = new SgLambdaCaptureList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLambdaCaptureList;  
      SgLambdaCaptureListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLambdaExp ); 
     SgLambdaExpStorageClass* storageArraySgLambdaExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLambdaExp = new SgLambdaExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLambdaExp) , sizeof ( SgLambdaExpStorageClass ) * sizeOfActualPool) ;
        SgLambdaExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLambdaExpStorageClass* storageArray = storageArraySgLambdaExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLambdaExp ( *storageArray ) ; 
#else
               SgLambdaExp* tmp = new SgLambdaExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLambdaExp;  
      SgLambdaExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLambdaRefExp ); 
     SgLambdaRefExpStorageClass* storageArraySgLambdaRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLambdaRefExp = new SgLambdaRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLambdaRefExp) , sizeof ( SgLambdaRefExpStorageClass ) * sizeOfActualPool) ;
        SgLambdaRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLambdaRefExpStorageClass* storageArray = storageArraySgLambdaRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLambdaRefExp ( *storageArray ) ; 
#else
               SgLambdaRefExp* tmp = new SgLambdaRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLambdaRefExp;  
      SgLambdaRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLeftDivideOp ); 
     SgLeftDivideOpStorageClass* storageArraySgLeftDivideOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLeftDivideOp = new SgLeftDivideOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLeftDivideOp) , sizeof ( SgLeftDivideOpStorageClass ) * sizeOfActualPool) ;
        SgLeftDivideOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLeftDivideOpStorageClass* storageArray = storageArraySgLeftDivideOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLeftDivideOp ( *storageArray ) ; 
#else
               SgLeftDivideOp* tmp = new SgLeftDivideOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLeftDivideOp;  
      SgLeftDivideOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLessOrEqualOp ); 
     SgLessOrEqualOpStorageClass* storageArraySgLessOrEqualOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLessOrEqualOp = new SgLessOrEqualOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLessOrEqualOp) , sizeof ( SgLessOrEqualOpStorageClass ) * sizeOfActualPool) ;
        SgLessOrEqualOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLessOrEqualOpStorageClass* storageArray = storageArraySgLessOrEqualOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLessOrEqualOp ( *storageArray ) ; 
#else
               SgLessOrEqualOp* tmp = new SgLessOrEqualOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLessOrEqualOp;  
      SgLessOrEqualOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLessThanOp ); 
     SgLessThanOpStorageClass* storageArraySgLessThanOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLessThanOp = new SgLessThanOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLessThanOp) , sizeof ( SgLessThanOpStorageClass ) * sizeOfActualPool) ;
        SgLessThanOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLessThanOpStorageClass* storageArray = storageArraySgLessThanOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLessThanOp ( *storageArray ) ; 
#else
               SgLessThanOp* tmp = new SgLessThanOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLessThanOp;  
      SgLessThanOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLineDirectiveStatement ); 
     SgLineDirectiveStatementStorageClass* storageArraySgLineDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLineDirectiveStatement = new SgLineDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLineDirectiveStatement) , sizeof ( SgLineDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgLineDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLineDirectiveStatementStorageClass* storageArray = storageArraySgLineDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLineDirectiveStatement ( *storageArray ) ; 
#else
               SgLineDirectiveStatement* tmp = new SgLineDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLineDirectiveStatement;  
      SgLineDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLinemarkerDirectiveStatement ); 
     SgLinemarkerDirectiveStatementStorageClass* storageArraySgLinemarkerDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLinemarkerDirectiveStatement = new SgLinemarkerDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLinemarkerDirectiveStatement) , sizeof ( SgLinemarkerDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgLinemarkerDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLinemarkerDirectiveStatementStorageClass* storageArray = storageArraySgLinemarkerDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLinemarkerDirectiveStatement ( *storageArray ) ; 
#else
               SgLinemarkerDirectiveStatement* tmp = new SgLinemarkerDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLinemarkerDirectiveStatement;  
      SgLinemarkerDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLinkageModifier ); 
     SgLinkageModifierStorageClass* storageArraySgLinkageModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLinkageModifier = new SgLinkageModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLinkageModifier) , sizeof ( SgLinkageModifierStorageClass ) * sizeOfActualPool) ;
          SgLinkageModifierStorageClass* storageArray = storageArraySgLinkageModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLinkageModifier ( *storageArray ) ; 
#else
               SgLinkageModifier* tmp = new SgLinkageModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLinkageModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgListComprehension ); 
     SgListComprehensionStorageClass* storageArraySgListComprehension = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgListComprehension = new SgListComprehensionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgListComprehension) , sizeof ( SgListComprehensionStorageClass ) * sizeOfActualPool) ;
        SgListComprehensionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgListComprehensionStorageClass* storageArray = storageArraySgListComprehension;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgListComprehension ( *storageArray ) ; 
#else
               SgListComprehension* tmp = new SgListComprehension ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgListComprehension;  
      SgListComprehensionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgListExp ); 
     SgListExpStorageClass* storageArraySgListExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgListExp = new SgListExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgListExp) , sizeof ( SgListExpStorageClass ) * sizeOfActualPool) ;
        SgListExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgListExpStorageClass* storageArray = storageArraySgListExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgListExp ( *storageArray ) ; 
#else
               SgListExp* tmp = new SgListExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgListExp;  
      SgListExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLocatedNode ); 
     SgLocatedNodeStorageClass* storageArraySgLocatedNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLocatedNode = new SgLocatedNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLocatedNode) , sizeof ( SgLocatedNodeStorageClass ) * sizeOfActualPool) ;
        SgLocatedNodeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLocatedNodeStorageClass* storageArray = storageArraySgLocatedNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLocatedNode ( *storageArray ) ; 
#else
               SgLocatedNode* tmp = new SgLocatedNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLocatedNode;  
      SgLocatedNodeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLocatedNodeSupport ); 
     SgLocatedNodeSupportStorageClass* storageArraySgLocatedNodeSupport = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLocatedNodeSupport = new SgLocatedNodeSupportStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLocatedNodeSupport) , sizeof ( SgLocatedNodeSupportStorageClass ) * sizeOfActualPool) ;
        SgLocatedNodeSupportStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLocatedNodeSupportStorageClass* storageArray = storageArraySgLocatedNodeSupport;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLocatedNodeSupport ( *storageArray ) ; 
#else
               SgLocatedNodeSupport* tmp = new SgLocatedNodeSupport ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLocatedNodeSupport;  
      SgLocatedNodeSupportStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLongDoubleVal ); 
     SgLongDoubleValStorageClass* storageArraySgLongDoubleVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLongDoubleVal = new SgLongDoubleValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLongDoubleVal) , sizeof ( SgLongDoubleValStorageClass ) * sizeOfActualPool) ;
        SgLongDoubleValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLongDoubleValStorageClass* storageArray = storageArraySgLongDoubleVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLongDoubleVal ( *storageArray ) ; 
#else
               SgLongDoubleVal* tmp = new SgLongDoubleVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLongDoubleVal;  
      SgLongDoubleValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLongIntVal ); 
     SgLongIntValStorageClass* storageArraySgLongIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLongIntVal = new SgLongIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLongIntVal) , sizeof ( SgLongIntValStorageClass ) * sizeOfActualPool) ;
        SgLongIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLongIntValStorageClass* storageArray = storageArraySgLongIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLongIntVal ( *storageArray ) ; 
#else
               SgLongIntVal* tmp = new SgLongIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLongIntVal;  
      SgLongIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLongLongIntVal ); 
     SgLongLongIntValStorageClass* storageArraySgLongLongIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLongLongIntVal = new SgLongLongIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLongLongIntVal) , sizeof ( SgLongLongIntValStorageClass ) * sizeOfActualPool) ;
        SgLongLongIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLongLongIntValStorageClass* storageArray = storageArraySgLongLongIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLongLongIntVal ( *storageArray ) ; 
#else
               SgLongLongIntVal* tmp = new SgLongLongIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLongLongIntVal;  
      SgLongLongIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLshiftAssignOp ); 
     SgLshiftAssignOpStorageClass* storageArraySgLshiftAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLshiftAssignOp = new SgLshiftAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLshiftAssignOp) , sizeof ( SgLshiftAssignOpStorageClass ) * sizeOfActualPool) ;
        SgLshiftAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLshiftAssignOpStorageClass* storageArray = storageArraySgLshiftAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLshiftAssignOp ( *storageArray ) ; 
#else
               SgLshiftAssignOp* tmp = new SgLshiftAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLshiftAssignOp;  
      SgLshiftAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLshiftOp ); 
     SgLshiftOpStorageClass* storageArraySgLshiftOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLshiftOp = new SgLshiftOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLshiftOp) , sizeof ( SgLshiftOpStorageClass ) * sizeOfActualPool) ;
        SgLshiftOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLshiftOpStorageClass* storageArray = storageArraySgLshiftOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLshiftOp ( *storageArray ) ; 
#else
               SgLshiftOp* tmp = new SgLshiftOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLshiftOp;  
      SgLshiftOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMagicColonExp ); 
     SgMagicColonExpStorageClass* storageArraySgMagicColonExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMagicColonExp = new SgMagicColonExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMagicColonExp) , sizeof ( SgMagicColonExpStorageClass ) * sizeOfActualPool) ;
        SgMagicColonExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMagicColonExpStorageClass* storageArray = storageArraySgMagicColonExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMagicColonExp ( *storageArray ) ; 
#else
               SgMagicColonExp* tmp = new SgMagicColonExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMagicColonExp;  
      SgMagicColonExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMatrixExp ); 
     SgMatrixExpStorageClass* storageArraySgMatrixExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMatrixExp = new SgMatrixExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMatrixExp) , sizeof ( SgMatrixExpStorageClass ) * sizeOfActualPool) ;
        SgMatrixExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMatrixExpStorageClass* storageArray = storageArraySgMatrixExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMatrixExp ( *storageArray ) ; 
#else
               SgMatrixExp* tmp = new SgMatrixExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMatrixExp;  
      SgMatrixExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMatrixTransposeOp ); 
     SgMatrixTransposeOpStorageClass* storageArraySgMatrixTransposeOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMatrixTransposeOp = new SgMatrixTransposeOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMatrixTransposeOp) , sizeof ( SgMatrixTransposeOpStorageClass ) * sizeOfActualPool) ;
        SgMatrixTransposeOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMatrixTransposeOpStorageClass* storageArray = storageArraySgMatrixTransposeOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMatrixTransposeOp ( *storageArray ) ; 
#else
               SgMatrixTransposeOp* tmp = new SgMatrixTransposeOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMatrixTransposeOp;  
      SgMatrixTransposeOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMatlabForStatement ); 
     SgMatlabForStatementStorageClass* storageArraySgMatlabForStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMatlabForStatement = new SgMatlabForStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMatlabForStatement) , sizeof ( SgMatlabForStatementStorageClass ) * sizeOfActualPool) ;
        SgMatlabForStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMatlabForStatementStorageClass* storageArray = storageArraySgMatlabForStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMatlabForStatement ( *storageArray ) ; 
#else
               SgMatlabForStatement* tmp = new SgMatlabForStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMatlabForStatement;  
      SgMatlabForStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMemberFunctionDeclaration ); 
     SgMemberFunctionDeclarationStorageClass* storageArraySgMemberFunctionDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMemberFunctionDeclaration = new SgMemberFunctionDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMemberFunctionDeclaration) , sizeof ( SgMemberFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
        SgMemberFunctionDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMemberFunctionDeclarationStorageClass* storageArray = storageArraySgMemberFunctionDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMemberFunctionDeclaration ( *storageArray ) ; 
#else
               SgMemberFunctionDeclaration* tmp = new SgMemberFunctionDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMemberFunctionDeclaration;  
      SgMemberFunctionDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMemberFunctionRefExp ); 
     SgMemberFunctionRefExpStorageClass* storageArraySgMemberFunctionRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMemberFunctionRefExp = new SgMemberFunctionRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMemberFunctionRefExp) , sizeof ( SgMemberFunctionRefExpStorageClass ) * sizeOfActualPool) ;
        SgMemberFunctionRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMemberFunctionRefExpStorageClass* storageArray = storageArraySgMemberFunctionRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMemberFunctionRefExp ( *storageArray ) ; 
#else
               SgMemberFunctionRefExp* tmp = new SgMemberFunctionRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMemberFunctionRefExp;  
      SgMemberFunctionRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMemberFunctionSymbol ); 
     SgMemberFunctionSymbolStorageClass* storageArraySgMemberFunctionSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMemberFunctionSymbol = new SgMemberFunctionSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMemberFunctionSymbol) , sizeof ( SgMemberFunctionSymbolStorageClass ) * sizeOfActualPool) ;
        SgMemberFunctionSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMemberFunctionSymbolStorageClass* storageArray = storageArraySgMemberFunctionSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMemberFunctionSymbol ( *storageArray ) ; 
#else
               SgMemberFunctionSymbol* tmp = new SgMemberFunctionSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMemberFunctionSymbol;  
      SgMemberFunctionSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMemberFunctionType ); 
     SgMemberFunctionTypeStorageClass* storageArraySgMemberFunctionType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMemberFunctionType = new SgMemberFunctionTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMemberFunctionType) , sizeof ( SgMemberFunctionTypeStorageClass ) * sizeOfActualPool) ;
        SgMemberFunctionTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMemberFunctionTypeStorageClass* storageArray = storageArraySgMemberFunctionType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMemberFunctionType ( *storageArray ) ; 
#else
               SgMemberFunctionType* tmp = new SgMemberFunctionType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMemberFunctionType;  
      SgMemberFunctionTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMembershipOp ); 
     SgMembershipOpStorageClass* storageArraySgMembershipOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMembershipOp = new SgMembershipOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMembershipOp) , sizeof ( SgMembershipOpStorageClass ) * sizeOfActualPool) ;
        SgMembershipOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMembershipOpStorageClass* storageArray = storageArraySgMembershipOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMembershipOp ( *storageArray ) ; 
#else
               SgMembershipOp* tmp = new SgMembershipOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMembershipOp;  
      SgMembershipOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMicrosoftAttributeDeclaration ); 
     SgMicrosoftAttributeDeclarationStorageClass* storageArraySgMicrosoftAttributeDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMicrosoftAttributeDeclaration = new SgMicrosoftAttributeDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMicrosoftAttributeDeclaration) , sizeof ( SgMicrosoftAttributeDeclarationStorageClass ) * sizeOfActualPool) ;
        SgMicrosoftAttributeDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMicrosoftAttributeDeclarationStorageClass* storageArray = storageArraySgMicrosoftAttributeDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMicrosoftAttributeDeclaration ( *storageArray ) ; 
#else
               SgMicrosoftAttributeDeclaration* tmp = new SgMicrosoftAttributeDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMicrosoftAttributeDeclaration;  
      SgMicrosoftAttributeDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMinusAssignOp ); 
     SgMinusAssignOpStorageClass* storageArraySgMinusAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMinusAssignOp = new SgMinusAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMinusAssignOp) , sizeof ( SgMinusAssignOpStorageClass ) * sizeOfActualPool) ;
        SgMinusAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMinusAssignOpStorageClass* storageArray = storageArraySgMinusAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMinusAssignOp ( *storageArray ) ; 
#else
               SgMinusAssignOp* tmp = new SgMinusAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMinusAssignOp;  
      SgMinusAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMinusMinusOp ); 
     SgMinusMinusOpStorageClass* storageArraySgMinusMinusOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMinusMinusOp = new SgMinusMinusOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMinusMinusOp) , sizeof ( SgMinusMinusOpStorageClass ) * sizeOfActualPool) ;
        SgMinusMinusOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMinusMinusOpStorageClass* storageArray = storageArraySgMinusMinusOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMinusMinusOp ( *storageArray ) ; 
#else
               SgMinusMinusOp* tmp = new SgMinusMinusOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMinusMinusOp;  
      SgMinusMinusOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMinusOp ); 
     SgMinusOpStorageClass* storageArraySgMinusOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMinusOp = new SgMinusOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMinusOp) , sizeof ( SgMinusOpStorageClass ) * sizeOfActualPool) ;
        SgMinusOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMinusOpStorageClass* storageArray = storageArraySgMinusOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMinusOp ( *storageArray ) ; 
#else
               SgMinusOp* tmp = new SgMinusOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMinusOp;  
      SgMinusOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModAssignOp ); 
     SgModAssignOpStorageClass* storageArraySgModAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModAssignOp = new SgModAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModAssignOp) , sizeof ( SgModAssignOpStorageClass ) * sizeOfActualPool) ;
        SgModAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModAssignOpStorageClass* storageArray = storageArraySgModAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgModAssignOp ( *storageArray ) ; 
#else
               SgModAssignOp* tmp = new SgModAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModAssignOp;  
      SgModAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModOp ); 
     SgModOpStorageClass* storageArraySgModOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModOp = new SgModOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModOp) , sizeof ( SgModOpStorageClass ) * sizeOfActualPool) ;
        SgModOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModOpStorageClass* storageArray = storageArraySgModOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgModOp ( *storageArray ) ; 
#else
               SgModOp* tmp = new SgModOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModOp;  
      SgModOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModifier ); 
     SgModifierStorageClass* storageArraySgModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModifier = new SgModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModifier) , sizeof ( SgModifierStorageClass ) * sizeOfActualPool) ;
          SgModifierStorageClass* storageArray = storageArraySgModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgModifier ( *storageArray ) ; 
#else
               SgModifier* tmp = new SgModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModifierNodes ); 
     SgModifierNodesStorageClass* storageArraySgModifierNodes = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModifierNodes = new SgModifierNodesStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModifierNodes) , sizeof ( SgModifierNodesStorageClass ) * sizeOfActualPool) ;
        SgModifierNodesStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModifierNodesStorageClass* storageArray = storageArraySgModifierNodes;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgModifierNodes ( *storageArray ) ; 
#else
               SgModifierNodes* tmp = new SgModifierNodes ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModifierNodes;  
      SgModifierNodesStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModifierType ); 
     SgModifierTypeStorageClass* storageArraySgModifierType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModifierType = new SgModifierTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModifierType) , sizeof ( SgModifierTypeStorageClass ) * sizeOfActualPool) ;
        SgModifierTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModifierTypeStorageClass* storageArray = storageArraySgModifierType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgModifierType ( *storageArray ) ; 
#else
               SgModifierType* tmp = new SgModifierType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModifierType;  
      SgModifierTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModuleStatement ); 
     SgModuleStatementStorageClass* storageArraySgModuleStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModuleStatement = new SgModuleStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModuleStatement) , sizeof ( SgModuleStatementStorageClass ) * sizeOfActualPool) ;
        SgModuleStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModuleStatementStorageClass* storageArray = storageArraySgModuleStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgModuleStatement ( *storageArray ) ; 
#else
               SgModuleStatement* tmp = new SgModuleStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModuleStatement;  
      SgModuleStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModuleSymbol ); 
     SgModuleSymbolStorageClass* storageArraySgModuleSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModuleSymbol = new SgModuleSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModuleSymbol) , sizeof ( SgModuleSymbolStorageClass ) * sizeOfActualPool) ;
        SgModuleSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModuleSymbolStorageClass* storageArray = storageArraySgModuleSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgModuleSymbol ( *storageArray ) ; 
#else
               SgModuleSymbol* tmp = new SgModuleSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModuleSymbol;  
      SgModuleSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMultAssignOp ); 
     SgMultAssignOpStorageClass* storageArraySgMultAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMultAssignOp = new SgMultAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMultAssignOp) , sizeof ( SgMultAssignOpStorageClass ) * sizeOfActualPool) ;
        SgMultAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMultAssignOpStorageClass* storageArray = storageArraySgMultAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMultAssignOp ( *storageArray ) ; 
#else
               SgMultAssignOp* tmp = new SgMultAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMultAssignOp;  
      SgMultAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMultiplyOp ); 
     SgMultiplyOpStorageClass* storageArraySgMultiplyOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMultiplyOp = new SgMultiplyOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMultiplyOp) , sizeof ( SgMultiplyOpStorageClass ) * sizeOfActualPool) ;
        SgMultiplyOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMultiplyOpStorageClass* storageArray = storageArraySgMultiplyOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgMultiplyOp ( *storageArray ) ; 
#else
               SgMultiplyOp* tmp = new SgMultiplyOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMultiplyOp;  
      SgMultiplyOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgName ); 
     SgNameStorageClass* storageArraySgName = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgName = new SgNameStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgName) , sizeof ( SgNameStorageClass ) * sizeOfActualPool) ;
        SgNameStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNameStorageClass* storageArray = storageArraySgName;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgName ( *storageArray ) ; 
#else
               SgName* tmp = new SgName ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgName;  
      SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNameGroup ); 
     SgNameGroupStorageClass* storageArraySgNameGroup = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNameGroup = new SgNameGroupStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNameGroup) , sizeof ( SgNameGroupStorageClass ) * sizeOfActualPool) ;
        SgNameGroupStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNameGroupStorageClass* storageArray = storageArraySgNameGroup;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNameGroup ( *storageArray ) ; 
#else
               SgNameGroup* tmp = new SgNameGroup ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNameGroup;  
      SgNameGroupStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamedType ); 
     SgNamedTypeStorageClass* storageArraySgNamedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamedType = new SgNamedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamedType) , sizeof ( SgNamedTypeStorageClass ) * sizeOfActualPool) ;
        SgNamedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamedTypeStorageClass* storageArray = storageArraySgNamedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNamedType ( *storageArray ) ; 
#else
               SgNamedType* tmp = new SgNamedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamedType;  
      SgNamedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamelistStatement ); 
     SgNamelistStatementStorageClass* storageArraySgNamelistStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamelistStatement = new SgNamelistStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamelistStatement) , sizeof ( SgNamelistStatementStorageClass ) * sizeOfActualPool) ;
        SgNamelistStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamelistStatementStorageClass* storageArray = storageArraySgNamelistStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNamelistStatement ( *storageArray ) ; 
#else
               SgNamelistStatement* tmp = new SgNamelistStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamelistStatement;  
      SgNamelistStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamespaceAliasDeclarationStatement ); 
     SgNamespaceAliasDeclarationStatementStorageClass* storageArraySgNamespaceAliasDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamespaceAliasDeclarationStatement = new SgNamespaceAliasDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamespaceAliasDeclarationStatement) , sizeof ( SgNamespaceAliasDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgNamespaceAliasDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamespaceAliasDeclarationStatementStorageClass* storageArray = storageArraySgNamespaceAliasDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNamespaceAliasDeclarationStatement ( *storageArray ) ; 
#else
               SgNamespaceAliasDeclarationStatement* tmp = new SgNamespaceAliasDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamespaceAliasDeclarationStatement;  
      SgNamespaceAliasDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamespaceDeclarationStatement ); 
     SgNamespaceDeclarationStatementStorageClass* storageArraySgNamespaceDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamespaceDeclarationStatement = new SgNamespaceDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamespaceDeclarationStatement) , sizeof ( SgNamespaceDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgNamespaceDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamespaceDeclarationStatementStorageClass* storageArray = storageArraySgNamespaceDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNamespaceDeclarationStatement ( *storageArray ) ; 
#else
               SgNamespaceDeclarationStatement* tmp = new SgNamespaceDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamespaceDeclarationStatement;  
      SgNamespaceDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamespaceDefinitionStatement ); 
     SgNamespaceDefinitionStatementStorageClass* storageArraySgNamespaceDefinitionStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamespaceDefinitionStatement = new SgNamespaceDefinitionStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamespaceDefinitionStatement) , sizeof ( SgNamespaceDefinitionStatementStorageClass ) * sizeOfActualPool) ;
        SgNamespaceDefinitionStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamespaceDefinitionStatementStorageClass* storageArray = storageArraySgNamespaceDefinitionStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNamespaceDefinitionStatement ( *storageArray ) ; 
#else
               SgNamespaceDefinitionStatement* tmp = new SgNamespaceDefinitionStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamespaceDefinitionStatement;  
      SgNamespaceDefinitionStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamespaceSymbol ); 
     SgNamespaceSymbolStorageClass* storageArraySgNamespaceSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamespaceSymbol = new SgNamespaceSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamespaceSymbol) , sizeof ( SgNamespaceSymbolStorageClass ) * sizeOfActualPool) ;
        SgNamespaceSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamespaceSymbolStorageClass* storageArray = storageArraySgNamespaceSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNamespaceSymbol ( *storageArray ) ; 
#else
               SgNamespaceSymbol* tmp = new SgNamespaceSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamespaceSymbol;  
      SgNamespaceSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNaryOp ); 
     SgNaryOpStorageClass* storageArraySgNaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNaryOp = new SgNaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNaryOp) , sizeof ( SgNaryOpStorageClass ) * sizeOfActualPool) ;
        SgNaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNaryOpStorageClass* storageArray = storageArraySgNaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNaryOp ( *storageArray ) ; 
#else
               SgNaryOp* tmp = new SgNaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNaryOp;  
      SgNaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNaryBooleanOp ); 
     SgNaryBooleanOpStorageClass* storageArraySgNaryBooleanOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNaryBooleanOp = new SgNaryBooleanOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNaryBooleanOp) , sizeof ( SgNaryBooleanOpStorageClass ) * sizeOfActualPool) ;
        SgNaryBooleanOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNaryBooleanOpStorageClass* storageArray = storageArraySgNaryBooleanOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNaryBooleanOp ( *storageArray ) ; 
#else
               SgNaryBooleanOp* tmp = new SgNaryBooleanOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNaryBooleanOp;  
      SgNaryBooleanOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNaryComparisonOp ); 
     SgNaryComparisonOpStorageClass* storageArraySgNaryComparisonOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNaryComparisonOp = new SgNaryComparisonOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNaryComparisonOp) , sizeof ( SgNaryComparisonOpStorageClass ) * sizeOfActualPool) ;
        SgNaryComparisonOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNaryComparisonOpStorageClass* storageArray = storageArraySgNaryComparisonOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNaryComparisonOp ( *storageArray ) ; 
#else
               SgNaryComparisonOp* tmp = new SgNaryComparisonOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNaryComparisonOp;  
      SgNaryComparisonOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNewExp ); 
     SgNewExpStorageClass* storageArraySgNewExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNewExp = new SgNewExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNewExp) , sizeof ( SgNewExpStorageClass ) * sizeOfActualPool) ;
        SgNewExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNewExpStorageClass* storageArray = storageArraySgNewExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNewExp ( *storageArray ) ; 
#else
               SgNewExp* tmp = new SgNewExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNewExp;  
      SgNewExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNode ); 
     SgNodeStorageClass* storageArraySgNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNode = new SgNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNode) , sizeof ( SgNodeStorageClass ) * sizeOfActualPool) ;
          SgNodeStorageClass* storageArray = storageArraySgNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNode ( *storageArray ) ; 
#else
               SgNode* tmp = new SgNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNode;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNoexceptOp ); 
     SgNoexceptOpStorageClass* storageArraySgNoexceptOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNoexceptOp = new SgNoexceptOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNoexceptOp) , sizeof ( SgNoexceptOpStorageClass ) * sizeOfActualPool) ;
        SgNoexceptOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNoexceptOpStorageClass* storageArray = storageArraySgNoexceptOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNoexceptOp ( *storageArray ) ; 
#else
               SgNoexceptOp* tmp = new SgNoexceptOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNoexceptOp;  
      SgNoexceptOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNotEqualOp ); 
     SgNotEqualOpStorageClass* storageArraySgNotEqualOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNotEqualOp = new SgNotEqualOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNotEqualOp) , sizeof ( SgNotEqualOpStorageClass ) * sizeOfActualPool) ;
        SgNotEqualOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNotEqualOpStorageClass* storageArray = storageArraySgNotEqualOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNotEqualOp ( *storageArray ) ; 
#else
               SgNotEqualOp* tmp = new SgNotEqualOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNotEqualOp;  
      SgNotEqualOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNotOp ); 
     SgNotOpStorageClass* storageArraySgNotOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNotOp = new SgNotOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNotOp) , sizeof ( SgNotOpStorageClass ) * sizeOfActualPool) ;
        SgNotOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNotOpStorageClass* storageArray = storageArraySgNotOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNotOp ( *storageArray ) ; 
#else
               SgNotOp* tmp = new SgNotOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNotOp;  
      SgNotOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNonMembershipOp ); 
     SgNonMembershipOpStorageClass* storageArraySgNonMembershipOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNonMembershipOp = new SgNonMembershipOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNonMembershipOp) , sizeof ( SgNonMembershipOpStorageClass ) * sizeOfActualPool) ;
        SgNonMembershipOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNonMembershipOpStorageClass* storageArray = storageArraySgNonMembershipOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNonMembershipOp ( *storageArray ) ; 
#else
               SgNonMembershipOp* tmp = new SgNonMembershipOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNonMembershipOp;  
      SgNonMembershipOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNonrealDecl ); 
     SgNonrealDeclStorageClass* storageArraySgNonrealDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNonrealDecl = new SgNonrealDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNonrealDecl) , sizeof ( SgNonrealDeclStorageClass ) * sizeOfActualPool) ;
        SgNonrealDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNonrealDeclStorageClass* storageArray = storageArraySgNonrealDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNonrealDecl ( *storageArray ) ; 
#else
               SgNonrealDecl* tmp = new SgNonrealDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNonrealDecl;  
      SgNonrealDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNonrealRefExp ); 
     SgNonrealRefExpStorageClass* storageArraySgNonrealRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNonrealRefExp = new SgNonrealRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNonrealRefExp) , sizeof ( SgNonrealRefExpStorageClass ) * sizeOfActualPool) ;
        SgNonrealRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNonrealRefExpStorageClass* storageArray = storageArraySgNonrealRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNonrealRefExp ( *storageArray ) ; 
#else
               SgNonrealRefExp* tmp = new SgNonrealRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNonrealRefExp;  
      SgNonrealRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNonrealSymbol ); 
     SgNonrealSymbolStorageClass* storageArraySgNonrealSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNonrealSymbol = new SgNonrealSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNonrealSymbol) , sizeof ( SgNonrealSymbolStorageClass ) * sizeOfActualPool) ;
        SgNonrealSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNonrealSymbolStorageClass* storageArray = storageArraySgNonrealSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNonrealSymbol ( *storageArray ) ; 
#else
               SgNonrealSymbol* tmp = new SgNonrealSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNonrealSymbol;  
      SgNonrealSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNonrealType ); 
     SgNonrealTypeStorageClass* storageArraySgNonrealType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNonrealType = new SgNonrealTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNonrealType) , sizeof ( SgNonrealTypeStorageClass ) * sizeOfActualPool) ;
        SgNonrealTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNonrealTypeStorageClass* storageArray = storageArraySgNonrealType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNonrealType ( *storageArray ) ; 
#else
               SgNonrealType* tmp = new SgNonrealType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNonrealType;  
      SgNonrealTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNonrealBaseClass ); 
     SgNonrealBaseClassStorageClass* storageArraySgNonrealBaseClass = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNonrealBaseClass = new SgNonrealBaseClassStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNonrealBaseClass) , sizeof ( SgNonrealBaseClassStorageClass ) * sizeOfActualPool) ;
          SgNonrealBaseClassStorageClass* storageArray = storageArraySgNonrealBaseClass;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNonrealBaseClass ( *storageArray ) ; 
#else
               SgNonrealBaseClass* tmp = new SgNonrealBaseClass ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNonrealBaseClass;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNullExpression ); 
     SgNullExpressionStorageClass* storageArraySgNullExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNullExpression = new SgNullExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNullExpression) , sizeof ( SgNullExpressionStorageClass ) * sizeOfActualPool) ;
        SgNullExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNullExpressionStorageClass* storageArray = storageArraySgNullExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNullExpression ( *storageArray ) ; 
#else
               SgNullExpression* tmp = new SgNullExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNullExpression;  
      SgNullExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNullptrValExp ); 
     SgNullptrValExpStorageClass* storageArraySgNullptrValExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNullptrValExp = new SgNullptrValExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNullptrValExp) , sizeof ( SgNullptrValExpStorageClass ) * sizeOfActualPool) ;
        SgNullptrValExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNullptrValExpStorageClass* storageArray = storageArraySgNullptrValExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNullptrValExp ( *storageArray ) ; 
#else
               SgNullptrValExp* tmp = new SgNullptrValExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNullptrValExp;  
      SgNullptrValExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNullStatement ); 
     SgNullStatementStorageClass* storageArraySgNullStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNullStatement = new SgNullStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNullStatement) , sizeof ( SgNullStatementStorageClass ) * sizeOfActualPool) ;
        SgNullStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNullStatementStorageClass* storageArray = storageArraySgNullStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNullStatement ( *storageArray ) ; 
#else
               SgNullStatement* tmp = new SgNullStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNullStatement;  
      SgNullStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNullifyStatement ); 
     SgNullifyStatementStorageClass* storageArraySgNullifyStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNullifyStatement = new SgNullifyStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNullifyStatement) , sizeof ( SgNullifyStatementStorageClass ) * sizeOfActualPool) ;
        SgNullifyStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNullifyStatementStorageClass* storageArray = storageArraySgNullifyStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgNullifyStatement ( *storageArray ) ; 
#else
               SgNullifyStatement* tmp = new SgNullifyStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNullifyStatement;  
      SgNullifyStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpAtomicStatement ); 
     SgOmpAtomicStatementStorageClass* storageArraySgOmpAtomicStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpAtomicStatement = new SgOmpAtomicStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpAtomicStatement) , sizeof ( SgOmpAtomicStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpAtomicStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpAtomicStatementStorageClass* storageArray = storageArraySgOmpAtomicStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpAtomicStatement ( *storageArray ) ; 
#else
               SgOmpAtomicStatement* tmp = new SgOmpAtomicStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpAtomicStatement;  
      SgOmpAtomicStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpBarrierStatement ); 
     SgOmpBarrierStatementStorageClass* storageArraySgOmpBarrierStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpBarrierStatement = new SgOmpBarrierStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpBarrierStatement) , sizeof ( SgOmpBarrierStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpBarrierStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpBarrierStatementStorageClass* storageArray = storageArraySgOmpBarrierStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpBarrierStatement ( *storageArray ) ; 
#else
               SgOmpBarrierStatement* tmp = new SgOmpBarrierStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpBarrierStatement;  
      SgOmpBarrierStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpCriticalStatement ); 
     SgOmpCriticalStatementStorageClass* storageArraySgOmpCriticalStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpCriticalStatement = new SgOmpCriticalStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpCriticalStatement) , sizeof ( SgOmpCriticalStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpCriticalStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpCriticalStatementStorageClass* storageArray = storageArraySgOmpCriticalStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpCriticalStatement ( *storageArray ) ; 
#else
               SgOmpCriticalStatement* tmp = new SgOmpCriticalStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpCriticalStatement;  
      SgOmpCriticalStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpClauseBodyStatement ); 
     SgOmpClauseBodyStatementStorageClass* storageArraySgOmpClauseBodyStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpClauseBodyStatement = new SgOmpClauseBodyStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpClauseBodyStatement) , sizeof ( SgOmpClauseBodyStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpClauseBodyStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpClauseBodyStatementStorageClass* storageArray = storageArraySgOmpClauseBodyStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpClauseBodyStatement ( *storageArray ) ; 
#else
               SgOmpClauseBodyStatement* tmp = new SgOmpClauseBodyStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpClauseBodyStatement;  
      SgOmpClauseBodyStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpBodyStatement ); 
     SgOmpBodyStatementStorageClass* storageArraySgOmpBodyStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpBodyStatement = new SgOmpBodyStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpBodyStatement) , sizeof ( SgOmpBodyStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpBodyStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpBodyStatementStorageClass* storageArray = storageArraySgOmpBodyStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpBodyStatement ( *storageArray ) ; 
#else
               SgOmpBodyStatement* tmp = new SgOmpBodyStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpBodyStatement;  
      SgOmpBodyStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpDoStatement ); 
     SgOmpDoStatementStorageClass* storageArraySgOmpDoStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpDoStatement = new SgOmpDoStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpDoStatement) , sizeof ( SgOmpDoStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpDoStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpDoStatementStorageClass* storageArray = storageArraySgOmpDoStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpDoStatement ( *storageArray ) ; 
#else
               SgOmpDoStatement* tmp = new SgOmpDoStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpDoStatement;  
      SgOmpDoStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpFlushStatement ); 
     SgOmpFlushStatementStorageClass* storageArraySgOmpFlushStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpFlushStatement = new SgOmpFlushStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpFlushStatement) , sizeof ( SgOmpFlushStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpFlushStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpFlushStatementStorageClass* storageArray = storageArraySgOmpFlushStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpFlushStatement ( *storageArray ) ; 
#else
               SgOmpFlushStatement* tmp = new SgOmpFlushStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpFlushStatement;  
      SgOmpFlushStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpDeclareSimdStatement ); 
     SgOmpDeclareSimdStatementStorageClass* storageArraySgOmpDeclareSimdStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpDeclareSimdStatement = new SgOmpDeclareSimdStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpDeclareSimdStatement) , sizeof ( SgOmpDeclareSimdStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpDeclareSimdStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpDeclareSimdStatementStorageClass* storageArray = storageArraySgOmpDeclareSimdStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpDeclareSimdStatement ( *storageArray ) ; 
#else
               SgOmpDeclareSimdStatement* tmp = new SgOmpDeclareSimdStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpDeclareSimdStatement;  
      SgOmpDeclareSimdStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpForStatement ); 
     SgOmpForStatementStorageClass* storageArraySgOmpForStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpForStatement = new SgOmpForStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpForStatement) , sizeof ( SgOmpForStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpForStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpForStatementStorageClass* storageArray = storageArraySgOmpForStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpForStatement ( *storageArray ) ; 
#else
               SgOmpForStatement* tmp = new SgOmpForStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpForStatement;  
      SgOmpForStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpForSimdStatement ); 
     SgOmpForSimdStatementStorageClass* storageArraySgOmpForSimdStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpForSimdStatement = new SgOmpForSimdStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpForSimdStatement) , sizeof ( SgOmpForSimdStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpForSimdStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpForSimdStatementStorageClass* storageArray = storageArraySgOmpForSimdStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpForSimdStatement ( *storageArray ) ; 
#else
               SgOmpForSimdStatement* tmp = new SgOmpForSimdStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpForSimdStatement;  
      SgOmpForSimdStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpMasterStatement ); 
     SgOmpMasterStatementStorageClass* storageArraySgOmpMasterStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpMasterStatement = new SgOmpMasterStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpMasterStatement) , sizeof ( SgOmpMasterStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpMasterStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpMasterStatementStorageClass* storageArray = storageArraySgOmpMasterStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpMasterStatement ( *storageArray ) ; 
#else
               SgOmpMasterStatement* tmp = new SgOmpMasterStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpMasterStatement;  
      SgOmpMasterStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpOrderedStatement ); 
     SgOmpOrderedStatementStorageClass* storageArraySgOmpOrderedStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpOrderedStatement = new SgOmpOrderedStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpOrderedStatement) , sizeof ( SgOmpOrderedStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpOrderedStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpOrderedStatementStorageClass* storageArray = storageArraySgOmpOrderedStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpOrderedStatement ( *storageArray ) ; 
#else
               SgOmpOrderedStatement* tmp = new SgOmpOrderedStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpOrderedStatement;  
      SgOmpOrderedStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpParallelStatement ); 
     SgOmpParallelStatementStorageClass* storageArraySgOmpParallelStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpParallelStatement = new SgOmpParallelStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpParallelStatement) , sizeof ( SgOmpParallelStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpParallelStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpParallelStatementStorageClass* storageArray = storageArraySgOmpParallelStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpParallelStatement ( *storageArray ) ; 
#else
               SgOmpParallelStatement* tmp = new SgOmpParallelStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpParallelStatement;  
      SgOmpParallelStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSectionStatement ); 
     SgOmpSectionStatementStorageClass* storageArraySgOmpSectionStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSectionStatement = new SgOmpSectionStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSectionStatement) , sizeof ( SgOmpSectionStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpSectionStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSectionStatementStorageClass* storageArray = storageArraySgOmpSectionStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpSectionStatement ( *storageArray ) ; 
#else
               SgOmpSectionStatement* tmp = new SgOmpSectionStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSectionStatement;  
      SgOmpSectionStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSectionsStatement ); 
     SgOmpSectionsStatementStorageClass* storageArraySgOmpSectionsStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSectionsStatement = new SgOmpSectionsStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSectionsStatement) , sizeof ( SgOmpSectionsStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpSectionsStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSectionsStatementStorageClass* storageArray = storageArraySgOmpSectionsStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpSectionsStatement ( *storageArray ) ; 
#else
               SgOmpSectionsStatement* tmp = new SgOmpSectionsStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSectionsStatement;  
      SgOmpSectionsStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSingleStatement ); 
     SgOmpSingleStatementStorageClass* storageArraySgOmpSingleStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSingleStatement = new SgOmpSingleStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSingleStatement) , sizeof ( SgOmpSingleStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpSingleStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSingleStatementStorageClass* storageArray = storageArraySgOmpSingleStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpSingleStatement ( *storageArray ) ; 
#else
               SgOmpSingleStatement* tmp = new SgOmpSingleStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSingleStatement;  
      SgOmpSingleStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpTaskStatement ); 
     SgOmpTaskStatementStorageClass* storageArraySgOmpTaskStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpTaskStatement = new SgOmpTaskStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpTaskStatement) , sizeof ( SgOmpTaskStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpTaskStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpTaskStatementStorageClass* storageArray = storageArraySgOmpTaskStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpTaskStatement ( *storageArray ) ; 
#else
               SgOmpTaskStatement* tmp = new SgOmpTaskStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpTaskStatement;  
      SgOmpTaskStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpTaskwaitStatement ); 
     SgOmpTaskwaitStatementStorageClass* storageArraySgOmpTaskwaitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpTaskwaitStatement = new SgOmpTaskwaitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpTaskwaitStatement) , sizeof ( SgOmpTaskwaitStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpTaskwaitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpTaskwaitStatementStorageClass* storageArray = storageArraySgOmpTaskwaitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpTaskwaitStatement ( *storageArray ) ; 
#else
               SgOmpTaskwaitStatement* tmp = new SgOmpTaskwaitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpTaskwaitStatement;  
      SgOmpTaskwaitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpThreadprivateStatement ); 
     SgOmpThreadprivateStatementStorageClass* storageArraySgOmpThreadprivateStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpThreadprivateStatement = new SgOmpThreadprivateStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpThreadprivateStatement) , sizeof ( SgOmpThreadprivateStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpThreadprivateStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpThreadprivateStatementStorageClass* storageArray = storageArraySgOmpThreadprivateStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpThreadprivateStatement ( *storageArray ) ; 
#else
               SgOmpThreadprivateStatement* tmp = new SgOmpThreadprivateStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpThreadprivateStatement;  
      SgOmpThreadprivateStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpWorkshareStatement ); 
     SgOmpWorkshareStatementStorageClass* storageArraySgOmpWorkshareStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpWorkshareStatement = new SgOmpWorkshareStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpWorkshareStatement) , sizeof ( SgOmpWorkshareStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpWorkshareStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpWorkshareStatementStorageClass* storageArray = storageArraySgOmpWorkshareStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpWorkshareStatement ( *storageArray ) ; 
#else
               SgOmpWorkshareStatement* tmp = new SgOmpWorkshareStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpWorkshareStatement;  
      SgOmpWorkshareStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpTargetStatement ); 
     SgOmpTargetStatementStorageClass* storageArraySgOmpTargetStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpTargetStatement = new SgOmpTargetStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpTargetStatement) , sizeof ( SgOmpTargetStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpTargetStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpTargetStatementStorageClass* storageArray = storageArraySgOmpTargetStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpTargetStatement ( *storageArray ) ; 
#else
               SgOmpTargetStatement* tmp = new SgOmpTargetStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpTargetStatement;  
      SgOmpTargetStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpTargetDataStatement ); 
     SgOmpTargetDataStatementStorageClass* storageArraySgOmpTargetDataStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpTargetDataStatement = new SgOmpTargetDataStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpTargetDataStatement) , sizeof ( SgOmpTargetDataStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpTargetDataStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpTargetDataStatementStorageClass* storageArray = storageArraySgOmpTargetDataStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpTargetDataStatement ( *storageArray ) ; 
#else
               SgOmpTargetDataStatement* tmp = new SgOmpTargetDataStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpTargetDataStatement;  
      SgOmpTargetDataStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSimdStatement ); 
     SgOmpSimdStatementStorageClass* storageArraySgOmpSimdStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSimdStatement = new SgOmpSimdStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSimdStatement) , sizeof ( SgOmpSimdStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpSimdStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSimdStatementStorageClass* storageArray = storageArraySgOmpSimdStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpSimdStatement ( *storageArray ) ; 
#else
               SgOmpSimdStatement* tmp = new SgOmpSimdStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSimdStatement;  
      SgOmpSimdStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpClause ); 
     SgOmpClauseStorageClass* storageArraySgOmpClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpClause = new SgOmpClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpClause) , sizeof ( SgOmpClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpClauseStorageClass* storageArray = storageArraySgOmpClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpClause ( *storageArray ) ; 
#else
               SgOmpClause* tmp = new SgOmpClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpClause;  
      SgOmpClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpBeginClause ); 
     SgOmpBeginClauseStorageClass* storageArraySgOmpBeginClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpBeginClause = new SgOmpBeginClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpBeginClause) , sizeof ( SgOmpBeginClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpBeginClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpBeginClauseStorageClass* storageArray = storageArraySgOmpBeginClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpBeginClause ( *storageArray ) ; 
#else
               SgOmpBeginClause* tmp = new SgOmpBeginClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpBeginClause;  
      SgOmpBeginClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpCollapseClause ); 
     SgOmpCollapseClauseStorageClass* storageArraySgOmpCollapseClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpCollapseClause = new SgOmpCollapseClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpCollapseClause) , sizeof ( SgOmpCollapseClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpCollapseClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpCollapseClauseStorageClass* storageArray = storageArraySgOmpCollapseClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpCollapseClause ( *storageArray ) ; 
#else
               SgOmpCollapseClause* tmp = new SgOmpCollapseClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpCollapseClause;  
      SgOmpCollapseClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpCopyinClause ); 
     SgOmpCopyinClauseStorageClass* storageArraySgOmpCopyinClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpCopyinClause = new SgOmpCopyinClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpCopyinClause) , sizeof ( SgOmpCopyinClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpCopyinClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpCopyinClauseStorageClass* storageArray = storageArraySgOmpCopyinClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpCopyinClause ( *storageArray ) ; 
#else
               SgOmpCopyinClause* tmp = new SgOmpCopyinClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpCopyinClause;  
      SgOmpCopyinClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpCopyprivateClause ); 
     SgOmpCopyprivateClauseStorageClass* storageArraySgOmpCopyprivateClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpCopyprivateClause = new SgOmpCopyprivateClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpCopyprivateClause) , sizeof ( SgOmpCopyprivateClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpCopyprivateClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpCopyprivateClauseStorageClass* storageArray = storageArraySgOmpCopyprivateClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpCopyprivateClause ( *storageArray ) ; 
#else
               SgOmpCopyprivateClause* tmp = new SgOmpCopyprivateClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpCopyprivateClause;  
      SgOmpCopyprivateClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpDefaultClause ); 
     SgOmpDefaultClauseStorageClass* storageArraySgOmpDefaultClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpDefaultClause = new SgOmpDefaultClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpDefaultClause) , sizeof ( SgOmpDefaultClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpDefaultClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpDefaultClauseStorageClass* storageArray = storageArraySgOmpDefaultClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpDefaultClause ( *storageArray ) ; 
#else
               SgOmpDefaultClause* tmp = new SgOmpDefaultClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpDefaultClause;  
      SgOmpDefaultClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpEndClause ); 
     SgOmpEndClauseStorageClass* storageArraySgOmpEndClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpEndClause = new SgOmpEndClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpEndClause) , sizeof ( SgOmpEndClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpEndClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpEndClauseStorageClass* storageArray = storageArraySgOmpEndClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpEndClause ( *storageArray ) ; 
#else
               SgOmpEndClause* tmp = new SgOmpEndClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpEndClause;  
      SgOmpEndClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpExpressionClause ); 
     SgOmpExpressionClauseStorageClass* storageArraySgOmpExpressionClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpExpressionClause = new SgOmpExpressionClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpExpressionClause) , sizeof ( SgOmpExpressionClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpExpressionClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpExpressionClauseStorageClass* storageArray = storageArraySgOmpExpressionClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpExpressionClause ( *storageArray ) ; 
#else
               SgOmpExpressionClause* tmp = new SgOmpExpressionClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpExpressionClause;  
      SgOmpExpressionClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpFirstprivateClause ); 
     SgOmpFirstprivateClauseStorageClass* storageArraySgOmpFirstprivateClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpFirstprivateClause = new SgOmpFirstprivateClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpFirstprivateClause) , sizeof ( SgOmpFirstprivateClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpFirstprivateClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpFirstprivateClauseStorageClass* storageArray = storageArraySgOmpFirstprivateClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpFirstprivateClause ( *storageArray ) ; 
#else
               SgOmpFirstprivateClause* tmp = new SgOmpFirstprivateClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpFirstprivateClause;  
      SgOmpFirstprivateClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpIfClause ); 
     SgOmpIfClauseStorageClass* storageArraySgOmpIfClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpIfClause = new SgOmpIfClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpIfClause) , sizeof ( SgOmpIfClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpIfClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpIfClauseStorageClass* storageArray = storageArraySgOmpIfClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpIfClause ( *storageArray ) ; 
#else
               SgOmpIfClause* tmp = new SgOmpIfClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpIfClause;  
      SgOmpIfClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpFinalClause ); 
     SgOmpFinalClauseStorageClass* storageArraySgOmpFinalClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpFinalClause = new SgOmpFinalClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpFinalClause) , sizeof ( SgOmpFinalClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpFinalClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpFinalClauseStorageClass* storageArray = storageArraySgOmpFinalClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpFinalClause ( *storageArray ) ; 
#else
               SgOmpFinalClause* tmp = new SgOmpFinalClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpFinalClause;  
      SgOmpFinalClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpPriorityClause ); 
     SgOmpPriorityClauseStorageClass* storageArraySgOmpPriorityClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpPriorityClause = new SgOmpPriorityClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpPriorityClause) , sizeof ( SgOmpPriorityClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpPriorityClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpPriorityClauseStorageClass* storageArray = storageArraySgOmpPriorityClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpPriorityClause ( *storageArray ) ; 
#else
               SgOmpPriorityClause* tmp = new SgOmpPriorityClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpPriorityClause;  
      SgOmpPriorityClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpDeviceClause ); 
     SgOmpDeviceClauseStorageClass* storageArraySgOmpDeviceClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpDeviceClause = new SgOmpDeviceClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpDeviceClause) , sizeof ( SgOmpDeviceClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpDeviceClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpDeviceClauseStorageClass* storageArray = storageArraySgOmpDeviceClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpDeviceClause ( *storageArray ) ; 
#else
               SgOmpDeviceClause* tmp = new SgOmpDeviceClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpDeviceClause;  
      SgOmpDeviceClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpLastprivateClause ); 
     SgOmpLastprivateClauseStorageClass* storageArraySgOmpLastprivateClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpLastprivateClause = new SgOmpLastprivateClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpLastprivateClause) , sizeof ( SgOmpLastprivateClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpLastprivateClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpLastprivateClauseStorageClass* storageArray = storageArraySgOmpLastprivateClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpLastprivateClause ( *storageArray ) ; 
#else
               SgOmpLastprivateClause* tmp = new SgOmpLastprivateClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpLastprivateClause;  
      SgOmpLastprivateClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpNowaitClause ); 
     SgOmpNowaitClauseStorageClass* storageArraySgOmpNowaitClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpNowaitClause = new SgOmpNowaitClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpNowaitClause) , sizeof ( SgOmpNowaitClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpNowaitClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpNowaitClauseStorageClass* storageArray = storageArraySgOmpNowaitClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpNowaitClause ( *storageArray ) ; 
#else
               SgOmpNowaitClause* tmp = new SgOmpNowaitClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpNowaitClause;  
      SgOmpNowaitClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpNumThreadsClause ); 
     SgOmpNumThreadsClauseStorageClass* storageArraySgOmpNumThreadsClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpNumThreadsClause = new SgOmpNumThreadsClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpNumThreadsClause) , sizeof ( SgOmpNumThreadsClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpNumThreadsClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpNumThreadsClauseStorageClass* storageArray = storageArraySgOmpNumThreadsClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpNumThreadsClause ( *storageArray ) ; 
#else
               SgOmpNumThreadsClause* tmp = new SgOmpNumThreadsClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpNumThreadsClause;  
      SgOmpNumThreadsClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpOrderedClause ); 
     SgOmpOrderedClauseStorageClass* storageArraySgOmpOrderedClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpOrderedClause = new SgOmpOrderedClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpOrderedClause) , sizeof ( SgOmpOrderedClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpOrderedClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpOrderedClauseStorageClass* storageArray = storageArraySgOmpOrderedClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpOrderedClause ( *storageArray ) ; 
#else
               SgOmpOrderedClause* tmp = new SgOmpOrderedClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpOrderedClause;  
      SgOmpOrderedClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpPrivateClause ); 
     SgOmpPrivateClauseStorageClass* storageArraySgOmpPrivateClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpPrivateClause = new SgOmpPrivateClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpPrivateClause) , sizeof ( SgOmpPrivateClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpPrivateClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpPrivateClauseStorageClass* storageArray = storageArraySgOmpPrivateClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpPrivateClause ( *storageArray ) ; 
#else
               SgOmpPrivateClause* tmp = new SgOmpPrivateClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpPrivateClause;  
      SgOmpPrivateClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpReductionClause ); 
     SgOmpReductionClauseStorageClass* storageArraySgOmpReductionClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpReductionClause = new SgOmpReductionClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpReductionClause) , sizeof ( SgOmpReductionClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpReductionClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpReductionClauseStorageClass* storageArray = storageArraySgOmpReductionClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpReductionClause ( *storageArray ) ; 
#else
               SgOmpReductionClause* tmp = new SgOmpReductionClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpReductionClause;  
      SgOmpReductionClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpScheduleClause ); 
     SgOmpScheduleClauseStorageClass* storageArraySgOmpScheduleClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpScheduleClause = new SgOmpScheduleClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpScheduleClause) , sizeof ( SgOmpScheduleClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpScheduleClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpScheduleClauseStorageClass* storageArray = storageArraySgOmpScheduleClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpScheduleClause ( *storageArray ) ; 
#else
               SgOmpScheduleClause* tmp = new SgOmpScheduleClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpScheduleClause;  
      SgOmpScheduleClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSharedClause ); 
     SgOmpSharedClauseStorageClass* storageArraySgOmpSharedClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSharedClause = new SgOmpSharedClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSharedClause) , sizeof ( SgOmpSharedClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpSharedClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSharedClauseStorageClass* storageArray = storageArraySgOmpSharedClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpSharedClause ( *storageArray ) ; 
#else
               SgOmpSharedClause* tmp = new SgOmpSharedClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSharedClause;  
      SgOmpSharedClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpUntiedClause ); 
     SgOmpUntiedClauseStorageClass* storageArraySgOmpUntiedClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpUntiedClause = new SgOmpUntiedClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpUntiedClause) , sizeof ( SgOmpUntiedClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpUntiedClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpUntiedClauseStorageClass* storageArray = storageArraySgOmpUntiedClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpUntiedClause ( *storageArray ) ; 
#else
               SgOmpUntiedClause* tmp = new SgOmpUntiedClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpUntiedClause;  
      SgOmpUntiedClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpMergeableClause ); 
     SgOmpMergeableClauseStorageClass* storageArraySgOmpMergeableClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpMergeableClause = new SgOmpMergeableClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpMergeableClause) , sizeof ( SgOmpMergeableClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpMergeableClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpMergeableClauseStorageClass* storageArray = storageArraySgOmpMergeableClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpMergeableClause ( *storageArray ) ; 
#else
               SgOmpMergeableClause* tmp = new SgOmpMergeableClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpMergeableClause;  
      SgOmpMergeableClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpVariablesClause ); 
     SgOmpVariablesClauseStorageClass* storageArraySgOmpVariablesClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpVariablesClause = new SgOmpVariablesClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpVariablesClause) , sizeof ( SgOmpVariablesClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpVariablesClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpVariablesClauseStorageClass* storageArray = storageArraySgOmpVariablesClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpVariablesClause ( *storageArray ) ; 
#else
               SgOmpVariablesClause* tmp = new SgOmpVariablesClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpVariablesClause;  
      SgOmpVariablesClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpMapClause ); 
     SgOmpMapClauseStorageClass* storageArraySgOmpMapClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpMapClause = new SgOmpMapClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpMapClause) , sizeof ( SgOmpMapClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpMapClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpMapClauseStorageClass* storageArray = storageArraySgOmpMapClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpMapClause ( *storageArray ) ; 
#else
               SgOmpMapClause* tmp = new SgOmpMapClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpMapClause;  
      SgOmpMapClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSafelenClause ); 
     SgOmpSafelenClauseStorageClass* storageArraySgOmpSafelenClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSafelenClause = new SgOmpSafelenClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSafelenClause) , sizeof ( SgOmpSafelenClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpSafelenClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSafelenClauseStorageClass* storageArray = storageArraySgOmpSafelenClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpSafelenClause ( *storageArray ) ; 
#else
               SgOmpSafelenClause* tmp = new SgOmpSafelenClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSafelenClause;  
      SgOmpSafelenClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSimdlenClause ); 
     SgOmpSimdlenClauseStorageClass* storageArraySgOmpSimdlenClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSimdlenClause = new SgOmpSimdlenClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSimdlenClause) , sizeof ( SgOmpSimdlenClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpSimdlenClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSimdlenClauseStorageClass* storageArray = storageArraySgOmpSimdlenClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpSimdlenClause ( *storageArray ) ; 
#else
               SgOmpSimdlenClause* tmp = new SgOmpSimdlenClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSimdlenClause;  
      SgOmpSimdlenClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpLinearClause ); 
     SgOmpLinearClauseStorageClass* storageArraySgOmpLinearClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpLinearClause = new SgOmpLinearClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpLinearClause) , sizeof ( SgOmpLinearClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpLinearClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpLinearClauseStorageClass* storageArray = storageArraySgOmpLinearClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpLinearClause ( *storageArray ) ; 
#else
               SgOmpLinearClause* tmp = new SgOmpLinearClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpLinearClause;  
      SgOmpLinearClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpUniformClause ); 
     SgOmpUniformClauseStorageClass* storageArraySgOmpUniformClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpUniformClause = new SgOmpUniformClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpUniformClause) , sizeof ( SgOmpUniformClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpUniformClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpUniformClauseStorageClass* storageArray = storageArraySgOmpUniformClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpUniformClause ( *storageArray ) ; 
#else
               SgOmpUniformClause* tmp = new SgOmpUniformClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpUniformClause;  
      SgOmpUniformClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpAlignedClause ); 
     SgOmpAlignedClauseStorageClass* storageArraySgOmpAlignedClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpAlignedClause = new SgOmpAlignedClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpAlignedClause) , sizeof ( SgOmpAlignedClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpAlignedClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpAlignedClauseStorageClass* storageArray = storageArraySgOmpAlignedClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpAlignedClause ( *storageArray ) ; 
#else
               SgOmpAlignedClause* tmp = new SgOmpAlignedClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpAlignedClause;  
      SgOmpAlignedClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpProcBindClause ); 
     SgOmpProcBindClauseStorageClass* storageArraySgOmpProcBindClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpProcBindClause = new SgOmpProcBindClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpProcBindClause) , sizeof ( SgOmpProcBindClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpProcBindClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpProcBindClauseStorageClass* storageArray = storageArraySgOmpProcBindClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpProcBindClause ( *storageArray ) ; 
#else
               SgOmpProcBindClause* tmp = new SgOmpProcBindClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpProcBindClause;  
      SgOmpProcBindClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpAtomicClause ); 
     SgOmpAtomicClauseStorageClass* storageArraySgOmpAtomicClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpAtomicClause = new SgOmpAtomicClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpAtomicClause) , sizeof ( SgOmpAtomicClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpAtomicClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpAtomicClauseStorageClass* storageArray = storageArraySgOmpAtomicClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpAtomicClause ( *storageArray ) ; 
#else
               SgOmpAtomicClause* tmp = new SgOmpAtomicClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpAtomicClause;  
      SgOmpAtomicClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpInbranchClause ); 
     SgOmpInbranchClauseStorageClass* storageArraySgOmpInbranchClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpInbranchClause = new SgOmpInbranchClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpInbranchClause) , sizeof ( SgOmpInbranchClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpInbranchClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpInbranchClauseStorageClass* storageArray = storageArraySgOmpInbranchClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpInbranchClause ( *storageArray ) ; 
#else
               SgOmpInbranchClause* tmp = new SgOmpInbranchClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpInbranchClause;  
      SgOmpInbranchClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpNotinbranchClause ); 
     SgOmpNotinbranchClauseStorageClass* storageArraySgOmpNotinbranchClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpNotinbranchClause = new SgOmpNotinbranchClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpNotinbranchClause) , sizeof ( SgOmpNotinbranchClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpNotinbranchClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpNotinbranchClauseStorageClass* storageArray = storageArraySgOmpNotinbranchClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpNotinbranchClause ( *storageArray ) ; 
#else
               SgOmpNotinbranchClause* tmp = new SgOmpNotinbranchClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpNotinbranchClause;  
      SgOmpNotinbranchClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpDependClause ); 
     SgOmpDependClauseStorageClass* storageArraySgOmpDependClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpDependClause = new SgOmpDependClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpDependClause) , sizeof ( SgOmpDependClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpDependClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpDependClauseStorageClass* storageArray = storageArraySgOmpDependClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOmpDependClause ( *storageArray ) ; 
#else
               SgOmpDependClause* tmp = new SgOmpDependClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpDependClause;  
      SgOmpDependClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOpenclAccessModeModifier ); 
     SgOpenclAccessModeModifierStorageClass* storageArraySgOpenclAccessModeModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOpenclAccessModeModifier = new SgOpenclAccessModeModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOpenclAccessModeModifier) , sizeof ( SgOpenclAccessModeModifierStorageClass ) * sizeOfActualPool) ;
          SgOpenclAccessModeModifierStorageClass* storageArray = storageArraySgOpenclAccessModeModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOpenclAccessModeModifier ( *storageArray ) ; 
#else
               SgOpenclAccessModeModifier* tmp = new SgOpenclAccessModeModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOpenclAccessModeModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOpenStatement ); 
     SgOpenStatementStorageClass* storageArraySgOpenStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOpenStatement = new SgOpenStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOpenStatement) , sizeof ( SgOpenStatementStorageClass ) * sizeOfActualPool) ;
        SgOpenStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOpenStatementStorageClass* storageArray = storageArraySgOpenStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOpenStatement ( *storageArray ) ; 
#else
               SgOpenStatement* tmp = new SgOpenStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOpenStatement;  
      SgOpenStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOptions ); 
     SgOptionsStorageClass* storageArraySgOptions = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOptions = new SgOptionsStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOptions) , sizeof ( SgOptionsStorageClass ) * sizeOfActualPool) ;
          SgOptionsStorageClass* storageArray = storageArraySgOptions;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOptions ( *storageArray ) ; 
#else
               SgOptions* tmp = new SgOptions ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOptions;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOrOp ); 
     SgOrOpStorageClass* storageArraySgOrOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOrOp = new SgOrOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOrOp) , sizeof ( SgOrOpStorageClass ) * sizeOfActualPool) ;
        SgOrOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOrOpStorageClass* storageArray = storageArraySgOrOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgOrOp ( *storageArray ) ; 
#else
               SgOrOp* tmp = new SgOrOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOrOp;  
      SgOrOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgParameterStatement ); 
     SgParameterStatementStorageClass* storageArraySgParameterStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgParameterStatement = new SgParameterStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgParameterStatement) , sizeof ( SgParameterStatementStorageClass ) * sizeOfActualPool) ;
        SgParameterStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgParameterStatementStorageClass* storageArray = storageArraySgParameterStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgParameterStatement ( *storageArray ) ; 
#else
               SgParameterStatement* tmp = new SgParameterStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgParameterStatement;  
      SgParameterStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPartialFunctionModifierType ); 
     SgPartialFunctionModifierTypeStorageClass* storageArraySgPartialFunctionModifierType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPartialFunctionModifierType = new SgPartialFunctionModifierTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPartialFunctionModifierType) , sizeof ( SgPartialFunctionModifierTypeStorageClass ) * sizeOfActualPool) ;
        SgPartialFunctionModifierTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPartialFunctionModifierTypeStorageClass* storageArray = storageArraySgPartialFunctionModifierType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPartialFunctionModifierType ( *storageArray ) ; 
#else
               SgPartialFunctionModifierType* tmp = new SgPartialFunctionModifierType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPartialFunctionModifierType;  
      SgPartialFunctionModifierTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPartialFunctionType ); 
     SgPartialFunctionTypeStorageClass* storageArraySgPartialFunctionType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPartialFunctionType = new SgPartialFunctionTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPartialFunctionType) , sizeof ( SgPartialFunctionTypeStorageClass ) * sizeOfActualPool) ;
        SgPartialFunctionTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPartialFunctionTypeStorageClass* storageArray = storageArraySgPartialFunctionType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPartialFunctionType ( *storageArray ) ; 
#else
               SgPartialFunctionType* tmp = new SgPartialFunctionType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPartialFunctionType;  
      SgPartialFunctionTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPassStatement ); 
     SgPassStatementStorageClass* storageArraySgPassStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPassStatement = new SgPassStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPassStatement) , sizeof ( SgPassStatementStorageClass ) * sizeOfActualPool) ;
        SgPassStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPassStatementStorageClass* storageArray = storageArraySgPassStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPassStatement ( *storageArray ) ; 
#else
               SgPassStatement* tmp = new SgPassStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPassStatement;  
      SgPassStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPlusAssignOp ); 
     SgPlusAssignOpStorageClass* storageArraySgPlusAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPlusAssignOp = new SgPlusAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPlusAssignOp) , sizeof ( SgPlusAssignOpStorageClass ) * sizeOfActualPool) ;
        SgPlusAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPlusAssignOpStorageClass* storageArray = storageArraySgPlusAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPlusAssignOp ( *storageArray ) ; 
#else
               SgPlusAssignOp* tmp = new SgPlusAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPlusAssignOp;  
      SgPlusAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPlusPlusOp ); 
     SgPlusPlusOpStorageClass* storageArraySgPlusPlusOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPlusPlusOp = new SgPlusPlusOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPlusPlusOp) , sizeof ( SgPlusPlusOpStorageClass ) * sizeOfActualPool) ;
        SgPlusPlusOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPlusPlusOpStorageClass* storageArray = storageArraySgPlusPlusOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPlusPlusOp ( *storageArray ) ; 
#else
               SgPlusPlusOp* tmp = new SgPlusPlusOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPlusPlusOp;  
      SgPlusPlusOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPntrArrRefExp ); 
     SgPntrArrRefExpStorageClass* storageArraySgPntrArrRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPntrArrRefExp = new SgPntrArrRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPntrArrRefExp) , sizeof ( SgPntrArrRefExpStorageClass ) * sizeOfActualPool) ;
        SgPntrArrRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPntrArrRefExpStorageClass* storageArray = storageArraySgPntrArrRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPntrArrRefExp ( *storageArray ) ; 
#else
               SgPntrArrRefExp* tmp = new SgPntrArrRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPntrArrRefExp;  
      SgPntrArrRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPointerAssignOp ); 
     SgPointerAssignOpStorageClass* storageArraySgPointerAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPointerAssignOp = new SgPointerAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPointerAssignOp) , sizeof ( SgPointerAssignOpStorageClass ) * sizeOfActualPool) ;
        SgPointerAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPointerAssignOpStorageClass* storageArray = storageArraySgPointerAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPointerAssignOp ( *storageArray ) ; 
#else
               SgPointerAssignOp* tmp = new SgPointerAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPointerAssignOp;  
      SgPointerAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPointerDerefExp ); 
     SgPointerDerefExpStorageClass* storageArraySgPointerDerefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPointerDerefExp = new SgPointerDerefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPointerDerefExp) , sizeof ( SgPointerDerefExpStorageClass ) * sizeOfActualPool) ;
        SgPointerDerefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPointerDerefExpStorageClass* storageArray = storageArraySgPointerDerefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPointerDerefExp ( *storageArray ) ; 
#else
               SgPointerDerefExp* tmp = new SgPointerDerefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPointerDerefExp;  
      SgPointerDerefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPointerMemberType ); 
     SgPointerMemberTypeStorageClass* storageArraySgPointerMemberType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPointerMemberType = new SgPointerMemberTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPointerMemberType) , sizeof ( SgPointerMemberTypeStorageClass ) * sizeOfActualPool) ;
        SgPointerMemberTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPointerMemberTypeStorageClass* storageArray = storageArraySgPointerMemberType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPointerMemberType ( *storageArray ) ; 
#else
               SgPointerMemberType* tmp = new SgPointerMemberType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPointerMemberType;  
      SgPointerMemberTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPointerType ); 
     SgPointerTypeStorageClass* storageArraySgPointerType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPointerType = new SgPointerTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPointerType) , sizeof ( SgPointerTypeStorageClass ) * sizeOfActualPool) ;
        SgPointerTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPointerTypeStorageClass* storageArray = storageArraySgPointerType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPointerType ( *storageArray ) ; 
#else
               SgPointerType* tmp = new SgPointerType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPointerType;  
      SgPointerTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPowerOp ); 
     SgPowerOpStorageClass* storageArraySgPowerOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPowerOp = new SgPowerOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPowerOp) , sizeof ( SgPowerOpStorageClass ) * sizeOfActualPool) ;
        SgPowerOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPowerOpStorageClass* storageArray = storageArraySgPowerOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPowerOp ( *storageArray ) ; 
#else
               SgPowerOp* tmp = new SgPowerOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPowerOp;  
      SgPowerOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPragma ); 
     SgPragmaStorageClass* storageArraySgPragma = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPragma = new SgPragmaStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPragma) , sizeof ( SgPragmaStorageClass ) * sizeOfActualPool) ;
        SgPragmaStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPragmaStorageClass* storageArray = storageArraySgPragma;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPragma ( *storageArray ) ; 
#else
               SgPragma* tmp = new SgPragma ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPragma;  
      SgPragmaStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPragmaDeclaration ); 
     SgPragmaDeclarationStorageClass* storageArraySgPragmaDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPragmaDeclaration = new SgPragmaDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPragmaDeclaration) , sizeof ( SgPragmaDeclarationStorageClass ) * sizeOfActualPool) ;
        SgPragmaDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPragmaDeclarationStorageClass* storageArray = storageArraySgPragmaDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPragmaDeclaration ( *storageArray ) ; 
#else
               SgPragmaDeclaration* tmp = new SgPragmaDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPragmaDeclaration;  
      SgPragmaDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPrintStatement ); 
     SgPrintStatementStorageClass* storageArraySgPrintStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPrintStatement = new SgPrintStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPrintStatement) , sizeof ( SgPrintStatementStorageClass ) * sizeOfActualPool) ;
        SgPrintStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPrintStatementStorageClass* storageArray = storageArraySgPrintStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPrintStatement ( *storageArray ) ; 
#else
               SgPrintStatement* tmp = new SgPrintStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPrintStatement;  
      SgPrintStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgProcedureHeaderStatement ); 
     SgProcedureHeaderStatementStorageClass* storageArraySgProcedureHeaderStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgProcedureHeaderStatement = new SgProcedureHeaderStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgProcedureHeaderStatement) , sizeof ( SgProcedureHeaderStatementStorageClass ) * sizeOfActualPool) ;
        SgProcedureHeaderStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgProcedureHeaderStatementStorageClass* storageArray = storageArraySgProcedureHeaderStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgProcedureHeaderStatement ( *storageArray ) ; 
#else
               SgProcedureHeaderStatement* tmp = new SgProcedureHeaderStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgProcedureHeaderStatement;  
      SgProcedureHeaderStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgProgramHeaderStatement ); 
     SgProgramHeaderStatementStorageClass* storageArraySgProgramHeaderStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgProgramHeaderStatement = new SgProgramHeaderStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgProgramHeaderStatement) , sizeof ( SgProgramHeaderStatementStorageClass ) * sizeOfActualPool) ;
        SgProgramHeaderStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgProgramHeaderStatementStorageClass* storageArray = storageArraySgProgramHeaderStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgProgramHeaderStatement ( *storageArray ) ; 
#else
               SgProgramHeaderStatement* tmp = new SgProgramHeaderStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgProgramHeaderStatement;  
      SgProgramHeaderStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgProject ); 
     SgProjectStorageClass* storageArraySgProject = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgProject = new SgProjectStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgProject) , sizeof ( SgProjectStorageClass ) * sizeOfActualPool) ;
        SgProjectStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgProjectStorageClass* storageArray = storageArraySgProject;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgProject ( *storageArray ) ; 
#else
               SgProject* tmp = new SgProject ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgProject;  
      SgProjectStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPseudoDestructorRefExp ); 
     SgPseudoDestructorRefExpStorageClass* storageArraySgPseudoDestructorRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPseudoDestructorRefExp = new SgPseudoDestructorRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPseudoDestructorRefExp) , sizeof ( SgPseudoDestructorRefExpStorageClass ) * sizeOfActualPool) ;
        SgPseudoDestructorRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPseudoDestructorRefExpStorageClass* storageArray = storageArraySgPseudoDestructorRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPseudoDestructorRefExp ( *storageArray ) ; 
#else
               SgPseudoDestructorRefExp* tmp = new SgPseudoDestructorRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPseudoDestructorRefExp;  
      SgPseudoDestructorRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPythonGlobalStmt ); 
     SgPythonGlobalStmtStorageClass* storageArraySgPythonGlobalStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPythonGlobalStmt = new SgPythonGlobalStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPythonGlobalStmt) , sizeof ( SgPythonGlobalStmtStorageClass ) * sizeOfActualPool) ;
        SgPythonGlobalStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPythonGlobalStmtStorageClass* storageArray = storageArraySgPythonGlobalStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPythonGlobalStmt ( *storageArray ) ; 
#else
               SgPythonGlobalStmt* tmp = new SgPythonGlobalStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPythonGlobalStmt;  
      SgPythonGlobalStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPythonPrintStmt ); 
     SgPythonPrintStmtStorageClass* storageArraySgPythonPrintStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPythonPrintStmt = new SgPythonPrintStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPythonPrintStmt) , sizeof ( SgPythonPrintStmtStorageClass ) * sizeOfActualPool) ;
        SgPythonPrintStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPythonPrintStmtStorageClass* storageArray = storageArraySgPythonPrintStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgPythonPrintStmt ( *storageArray ) ; 
#else
               SgPythonPrintStmt* tmp = new SgPythonPrintStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPythonPrintStmt;  
      SgPythonPrintStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgQualifiedName ); 
     SgQualifiedNameStorageClass* storageArraySgQualifiedName = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgQualifiedName = new SgQualifiedNameStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgQualifiedName) , sizeof ( SgQualifiedNameStorageClass ) * sizeOfActualPool) ;
          SgQualifiedNameStorageClass* storageArray = storageArraySgQualifiedName;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgQualifiedName ( *storageArray ) ; 
#else
               SgQualifiedName* tmp = new SgQualifiedName ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgQualifiedName;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgQualifiedNameType ); 
     SgQualifiedNameTypeStorageClass* storageArraySgQualifiedNameType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgQualifiedNameType = new SgQualifiedNameTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgQualifiedNameType) , sizeof ( SgQualifiedNameTypeStorageClass ) * sizeOfActualPool) ;
        SgQualifiedNameTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgQualifiedNameTypeStorageClass* storageArray = storageArraySgQualifiedNameType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgQualifiedNameType ( *storageArray ) ; 
#else
               SgQualifiedNameType* tmp = new SgQualifiedNameType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgQualifiedNameType;  
      SgQualifiedNameTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRangeExp ); 
     SgRangeExpStorageClass* storageArraySgRangeExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRangeExp = new SgRangeExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRangeExp) , sizeof ( SgRangeExpStorageClass ) * sizeOfActualPool) ;
        SgRangeExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRangeExpStorageClass* storageArray = storageArraySgRangeExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRangeExp ( *storageArray ) ; 
#else
               SgRangeExp* tmp = new SgRangeExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRangeExp;  
      SgRangeExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRangeBasedForStatement ); 
     SgRangeBasedForStatementStorageClass* storageArraySgRangeBasedForStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRangeBasedForStatement = new SgRangeBasedForStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRangeBasedForStatement) , sizeof ( SgRangeBasedForStatementStorageClass ) * sizeOfActualPool) ;
        SgRangeBasedForStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRangeBasedForStatementStorageClass* storageArray = storageArraySgRangeBasedForStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRangeBasedForStatement ( *storageArray ) ; 
#else
               SgRangeBasedForStatement* tmp = new SgRangeBasedForStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRangeBasedForStatement;  
      SgRangeBasedForStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgReadStatement ); 
     SgReadStatementStorageClass* storageArraySgReadStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgReadStatement = new SgReadStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgReadStatement) , sizeof ( SgReadStatementStorageClass ) * sizeOfActualPool) ;
        SgReadStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgReadStatementStorageClass* storageArray = storageArraySgReadStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgReadStatement ( *storageArray ) ; 
#else
               SgReadStatement* tmp = new SgReadStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgReadStatement;  
      SgReadStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRealPartOp ); 
     SgRealPartOpStorageClass* storageArraySgRealPartOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRealPartOp = new SgRealPartOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRealPartOp) , sizeof ( SgRealPartOpStorageClass ) * sizeOfActualPool) ;
        SgRealPartOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRealPartOpStorageClass* storageArray = storageArraySgRealPartOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRealPartOp ( *storageArray ) ; 
#else
               SgRealPartOp* tmp = new SgRealPartOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRealPartOp;  
      SgRealPartOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRefExp ); 
     SgRefExpStorageClass* storageArraySgRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRefExp = new SgRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRefExp) , sizeof ( SgRefExpStorageClass ) * sizeOfActualPool) ;
        SgRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRefExpStorageClass* storageArray = storageArraySgRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRefExp ( *storageArray ) ; 
#else
               SgRefExp* tmp = new SgRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRefExp;  
      SgRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgReferenceType ); 
     SgReferenceTypeStorageClass* storageArraySgReferenceType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgReferenceType = new SgReferenceTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgReferenceType) , sizeof ( SgReferenceTypeStorageClass ) * sizeOfActualPool) ;
        SgReferenceTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgReferenceTypeStorageClass* storageArray = storageArraySgReferenceType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgReferenceType ( *storageArray ) ; 
#else
               SgReferenceType* tmp = new SgReferenceType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgReferenceType;  
      SgReferenceTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRemOp ); 
     SgRemOpStorageClass* storageArraySgRemOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRemOp = new SgRemOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRemOp) , sizeof ( SgRemOpStorageClass ) * sizeOfActualPool) ;
        SgRemOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRemOpStorageClass* storageArray = storageArraySgRemOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRemOp ( *storageArray ) ; 
#else
               SgRemOp* tmp = new SgRemOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRemOp;  
      SgRemOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRenamePair ); 
     SgRenamePairStorageClass* storageArraySgRenamePair = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRenamePair = new SgRenamePairStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRenamePair) , sizeof ( SgRenamePairStorageClass ) * sizeOfActualPool) ;
        SgRenamePairStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRenamePairStorageClass* storageArray = storageArraySgRenamePair;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRenamePair ( *storageArray ) ; 
#else
               SgRenamePair* tmp = new SgRenamePair ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRenamePair;  
      SgRenamePairStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRenameSymbol ); 
     SgRenameSymbolStorageClass* storageArraySgRenameSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRenameSymbol = new SgRenameSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRenameSymbol) , sizeof ( SgRenameSymbolStorageClass ) * sizeOfActualPool) ;
        SgRenameSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRenameSymbolStorageClass* storageArray = storageArraySgRenameSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRenameSymbol ( *storageArray ) ; 
#else
               SgRenameSymbol* tmp = new SgRenameSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRenameSymbol;  
      SgRenameSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgReplicationOp ); 
     SgReplicationOpStorageClass* storageArraySgReplicationOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgReplicationOp = new SgReplicationOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgReplicationOp) , sizeof ( SgReplicationOpStorageClass ) * sizeOfActualPool) ;
        SgReplicationOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgReplicationOpStorageClass* storageArray = storageArraySgReplicationOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgReplicationOp ( *storageArray ) ; 
#else
               SgReplicationOp* tmp = new SgReplicationOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgReplicationOp;  
      SgReplicationOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgReturnStmt ); 
     SgReturnStmtStorageClass* storageArraySgReturnStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgReturnStmt = new SgReturnStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgReturnStmt) , sizeof ( SgReturnStmtStorageClass ) * sizeOfActualPool) ;
        SgReturnStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgReturnStmtStorageClass* storageArray = storageArraySgReturnStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgReturnStmt ( *storageArray ) ; 
#else
               SgReturnStmt* tmp = new SgReturnStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgReturnStmt;  
      SgReturnStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRewindStatement ); 
     SgRewindStatementStorageClass* storageArraySgRewindStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRewindStatement = new SgRewindStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRewindStatement) , sizeof ( SgRewindStatementStorageClass ) * sizeOfActualPool) ;
        SgRewindStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRewindStatementStorageClass* storageArray = storageArraySgRewindStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRewindStatement ( *storageArray ) ; 
#else
               SgRewindStatement* tmp = new SgRewindStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRewindStatement;  
      SgRewindStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRshiftAssignOp ); 
     SgRshiftAssignOpStorageClass* storageArraySgRshiftAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRshiftAssignOp = new SgRshiftAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRshiftAssignOp) , sizeof ( SgRshiftAssignOpStorageClass ) * sizeOfActualPool) ;
        SgRshiftAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRshiftAssignOpStorageClass* storageArray = storageArraySgRshiftAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRshiftAssignOp ( *storageArray ) ; 
#else
               SgRshiftAssignOp* tmp = new SgRshiftAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRshiftAssignOp;  
      SgRshiftAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRshiftOp ); 
     SgRshiftOpStorageClass* storageArraySgRshiftOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRshiftOp = new SgRshiftOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRshiftOp) , sizeof ( SgRshiftOpStorageClass ) * sizeOfActualPool) ;
        SgRshiftOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRshiftOpStorageClass* storageArray = storageArraySgRshiftOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRshiftOp ( *storageArray ) ; 
#else
               SgRshiftOp* tmp = new SgRshiftOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRshiftOp;  
      SgRshiftOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRvalueReferenceType ); 
     SgRvalueReferenceTypeStorageClass* storageArraySgRvalueReferenceType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRvalueReferenceType = new SgRvalueReferenceTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRvalueReferenceType) , sizeof ( SgRvalueReferenceTypeStorageClass ) * sizeOfActualPool) ;
        SgRvalueReferenceTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRvalueReferenceTypeStorageClass* storageArray = storageArraySgRvalueReferenceType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRvalueReferenceType ( *storageArray ) ; 
#else
               SgRvalueReferenceType* tmp = new SgRvalueReferenceType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRvalueReferenceType;  
      SgRvalueReferenceTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaUnsignedRshiftAssignOp ); 
     SgJavaUnsignedRshiftAssignOpStorageClass* storageArraySgJavaUnsignedRshiftAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaUnsignedRshiftAssignOp = new SgJavaUnsignedRshiftAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaUnsignedRshiftAssignOp) , sizeof ( SgJavaUnsignedRshiftAssignOpStorageClass ) * sizeOfActualPool) ;
        SgJavaUnsignedRshiftAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaUnsignedRshiftAssignOpStorageClass* storageArray = storageArraySgJavaUnsignedRshiftAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaUnsignedRshiftAssignOp ( *storageArray ) ; 
#else
               SgJavaUnsignedRshiftAssignOp* tmp = new SgJavaUnsignedRshiftAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaUnsignedRshiftAssignOp;  
      SgJavaUnsignedRshiftAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaUnsignedRshiftOp ); 
     SgJavaUnsignedRshiftOpStorageClass* storageArraySgJavaUnsignedRshiftOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaUnsignedRshiftOp = new SgJavaUnsignedRshiftOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaUnsignedRshiftOp) , sizeof ( SgJavaUnsignedRshiftOpStorageClass ) * sizeOfActualPool) ;
        SgJavaUnsignedRshiftOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaUnsignedRshiftOpStorageClass* storageArray = storageArraySgJavaUnsignedRshiftOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaUnsignedRshiftOp ( *storageArray ) ; 
#else
               SgJavaUnsignedRshiftOp* tmp = new SgJavaUnsignedRshiftOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaUnsignedRshiftOp;  
      SgJavaUnsignedRshiftOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgScopeOp ); 
     SgScopeOpStorageClass* storageArraySgScopeOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgScopeOp = new SgScopeOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgScopeOp) , sizeof ( SgScopeOpStorageClass ) * sizeOfActualPool) ;
        SgScopeOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgScopeOpStorageClass* storageArray = storageArraySgScopeOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgScopeOp ( *storageArray ) ; 
#else
               SgScopeOp* tmp = new SgScopeOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgScopeOp;  
      SgScopeOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgScopeStatement ); 
     SgScopeStatementStorageClass* storageArraySgScopeStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgScopeStatement = new SgScopeStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgScopeStatement) , sizeof ( SgScopeStatementStorageClass ) * sizeOfActualPool) ;
        SgScopeStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgScopeStatementStorageClass* storageArray = storageArraySgScopeStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgScopeStatement ( *storageArray ) ; 
#else
               SgScopeStatement* tmp = new SgScopeStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgScopeStatement;  
      SgScopeStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSequenceStatement ); 
     SgSequenceStatementStorageClass* storageArraySgSequenceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSequenceStatement = new SgSequenceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSequenceStatement) , sizeof ( SgSequenceStatementStorageClass ) * sizeOfActualPool) ;
        SgSequenceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSequenceStatementStorageClass* storageArray = storageArraySgSequenceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSequenceStatement ( *storageArray ) ; 
#else
               SgSequenceStatement* tmp = new SgSequenceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSequenceStatement;  
      SgSequenceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSetComprehension ); 
     SgSetComprehensionStorageClass* storageArraySgSetComprehension = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSetComprehension = new SgSetComprehensionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSetComprehension) , sizeof ( SgSetComprehensionStorageClass ) * sizeOfActualPool) ;
        SgSetComprehensionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSetComprehensionStorageClass* storageArray = storageArraySgSetComprehension;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSetComprehension ( *storageArray ) ; 
#else
               SgSetComprehension* tmp = new SgSetComprehension ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSetComprehension;  
      SgSetComprehensionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgShortVal ); 
     SgShortValStorageClass* storageArraySgShortVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgShortVal = new SgShortValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgShortVal) , sizeof ( SgShortValStorageClass ) * sizeOfActualPool) ;
        SgShortValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgShortValStorageClass* storageArray = storageArraySgShortVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgShortVal ( *storageArray ) ; 
#else
               SgShortVal* tmp = new SgShortVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgShortVal;  
      SgShortValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSizeOfOp ); 
     SgSizeOfOpStorageClass* storageArraySgSizeOfOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSizeOfOp = new SgSizeOfOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSizeOfOp) , sizeof ( SgSizeOfOpStorageClass ) * sizeOfActualPool) ;
        SgSizeOfOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSizeOfOpStorageClass* storageArray = storageArraySgSizeOfOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSizeOfOp ( *storageArray ) ; 
#else
               SgSizeOfOp* tmp = new SgSizeOfOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSizeOfOp;  
      SgSizeOfOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAlignOfOp ); 
     SgAlignOfOpStorageClass* storageArraySgAlignOfOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAlignOfOp = new SgAlignOfOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAlignOfOp) , sizeof ( SgAlignOfOpStorageClass ) * sizeOfActualPool) ;
        SgAlignOfOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAlignOfOpStorageClass* storageArray = storageArraySgAlignOfOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAlignOfOp ( *storageArray ) ; 
#else
               SgAlignOfOp* tmp = new SgAlignOfOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAlignOfOp;  
      SgAlignOfOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaInstanceOfOp ); 
     SgJavaInstanceOfOpStorageClass* storageArraySgJavaInstanceOfOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaInstanceOfOp = new SgJavaInstanceOfOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaInstanceOfOp) , sizeof ( SgJavaInstanceOfOpStorageClass ) * sizeOfActualPool) ;
        SgJavaInstanceOfOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaInstanceOfOpStorageClass* storageArray = storageArraySgJavaInstanceOfOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaInstanceOfOp ( *storageArray ) ; 
#else
               SgJavaInstanceOfOp* tmp = new SgJavaInstanceOfOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaInstanceOfOp;  
      SgJavaInstanceOfOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSourceFile ); 
     SgSourceFileStorageClass* storageArraySgSourceFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSourceFile = new SgSourceFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSourceFile) , sizeof ( SgSourceFileStorageClass ) * sizeOfActualPool) ;
        SgSourceFileStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSourceFileStorageClass* storageArray = storageArraySgSourceFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSourceFile ( *storageArray ) ; 
#else
               SgSourceFile* tmp = new SgSourceFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSourceFile;  
      SgSourceFileStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSpaceshipOp ); 
     SgSpaceshipOpStorageClass* storageArraySgSpaceshipOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSpaceshipOp = new SgSpaceshipOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSpaceshipOp) , sizeof ( SgSpaceshipOpStorageClass ) * sizeOfActualPool) ;
        SgSpaceshipOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSpaceshipOpStorageClass* storageArray = storageArraySgSpaceshipOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSpaceshipOp ( *storageArray ) ; 
#else
               SgSpaceshipOp* tmp = new SgSpaceshipOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSpaceshipOp;  
      SgSpaceshipOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSpawnStmt ); 
     SgSpawnStmtStorageClass* storageArraySgSpawnStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSpawnStmt = new SgSpawnStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSpawnStmt) , sizeof ( SgSpawnStmtStorageClass ) * sizeOfActualPool) ;
        SgSpawnStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSpawnStmtStorageClass* storageArray = storageArraySgSpawnStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSpawnStmt ( *storageArray ) ; 
#else
               SgSpawnStmt* tmp = new SgSpawnStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSpawnStmt;  
      SgSpawnStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSyncAllStatement ); 
     SgSyncAllStatementStorageClass* storageArraySgSyncAllStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSyncAllStatement = new SgSyncAllStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSyncAllStatement) , sizeof ( SgSyncAllStatementStorageClass ) * sizeOfActualPool) ;
        SgSyncAllStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSyncAllStatementStorageClass* storageArray = storageArraySgSyncAllStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSyncAllStatement ( *storageArray ) ; 
#else
               SgSyncAllStatement* tmp = new SgSyncAllStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSyncAllStatement;  
      SgSyncAllStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSyncImagesStatement ); 
     SgSyncImagesStatementStorageClass* storageArraySgSyncImagesStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSyncImagesStatement = new SgSyncImagesStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSyncImagesStatement) , sizeof ( SgSyncImagesStatementStorageClass ) * sizeOfActualPool) ;
        SgSyncImagesStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSyncImagesStatementStorageClass* storageArray = storageArraySgSyncImagesStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSyncImagesStatement ( *storageArray ) ; 
#else
               SgSyncImagesStatement* tmp = new SgSyncImagesStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSyncImagesStatement;  
      SgSyncImagesStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSyncMemoryStatement ); 
     SgSyncMemoryStatementStorageClass* storageArraySgSyncMemoryStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSyncMemoryStatement = new SgSyncMemoryStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSyncMemoryStatement) , sizeof ( SgSyncMemoryStatementStorageClass ) * sizeOfActualPool) ;
        SgSyncMemoryStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSyncMemoryStatementStorageClass* storageArray = storageArraySgSyncMemoryStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSyncMemoryStatement ( *storageArray ) ; 
#else
               SgSyncMemoryStatement* tmp = new SgSyncMemoryStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSyncMemoryStatement;  
      SgSyncMemoryStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSyncTeamStatement ); 
     SgSyncTeamStatementStorageClass* storageArraySgSyncTeamStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSyncTeamStatement = new SgSyncTeamStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSyncTeamStatement) , sizeof ( SgSyncTeamStatementStorageClass ) * sizeOfActualPool) ;
        SgSyncTeamStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSyncTeamStatementStorageClass* storageArray = storageArraySgSyncTeamStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSyncTeamStatement ( *storageArray ) ; 
#else
               SgSyncTeamStatement* tmp = new SgSyncTeamStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSyncTeamStatement;  
      SgSyncTeamStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLockStatement ); 
     SgLockStatementStorageClass* storageArraySgLockStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLockStatement = new SgLockStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLockStatement) , sizeof ( SgLockStatementStorageClass ) * sizeOfActualPool) ;
        SgLockStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLockStatementStorageClass* storageArray = storageArraySgLockStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgLockStatement ( *storageArray ) ; 
#else
               SgLockStatement* tmp = new SgLockStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLockStatement;  
      SgLockStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnlockStatement ); 
     SgUnlockStatementStorageClass* storageArraySgUnlockStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnlockStatement = new SgUnlockStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnlockStatement) , sizeof ( SgUnlockStatementStorageClass ) * sizeOfActualPool) ;
        SgUnlockStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnlockStatementStorageClass* storageArray = storageArraySgUnlockStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnlockStatement ( *storageArray ) ; 
#else
               SgUnlockStatement* tmp = new SgUnlockStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnlockStatement;  
      SgUnlockStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaThrowStatement ); 
     SgJavaThrowStatementStorageClass* storageArraySgJavaThrowStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaThrowStatement = new SgJavaThrowStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaThrowStatement) , sizeof ( SgJavaThrowStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaThrowStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaThrowStatementStorageClass* storageArray = storageArraySgJavaThrowStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaThrowStatement ( *storageArray ) ; 
#else
               SgJavaThrowStatement* tmp = new SgJavaThrowStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaThrowStatement;  
      SgJavaThrowStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaForEachStatement ); 
     SgJavaForEachStatementStorageClass* storageArraySgJavaForEachStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaForEachStatement = new SgJavaForEachStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaForEachStatement) , sizeof ( SgJavaForEachStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaForEachStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaForEachStatementStorageClass* storageArray = storageArraySgJavaForEachStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaForEachStatement ( *storageArray ) ; 
#else
               SgJavaForEachStatement* tmp = new SgJavaForEachStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaForEachStatement;  
      SgJavaForEachStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaSynchronizedStatement ); 
     SgJavaSynchronizedStatementStorageClass* storageArraySgJavaSynchronizedStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaSynchronizedStatement = new SgJavaSynchronizedStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaSynchronizedStatement) , sizeof ( SgJavaSynchronizedStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaSynchronizedStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaSynchronizedStatementStorageClass* storageArray = storageArraySgJavaSynchronizedStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaSynchronizedStatement ( *storageArray ) ; 
#else
               SgJavaSynchronizedStatement* tmp = new SgJavaSynchronizedStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaSynchronizedStatement;  
      SgJavaSynchronizedStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaParameterizedType ); 
     SgJavaParameterizedTypeStorageClass* storageArraySgJavaParameterizedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaParameterizedType = new SgJavaParameterizedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaParameterizedType) , sizeof ( SgJavaParameterizedTypeStorageClass ) * sizeOfActualPool) ;
        SgJavaParameterizedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaParameterizedTypeStorageClass* storageArray = storageArraySgJavaParameterizedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaParameterizedType ( *storageArray ) ; 
#else
               SgJavaParameterizedType* tmp = new SgJavaParameterizedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaParameterizedType;  
      SgJavaParameterizedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaWildcardType ); 
     SgJavaWildcardTypeStorageClass* storageArraySgJavaWildcardType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaWildcardType = new SgJavaWildcardTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaWildcardType) , sizeof ( SgJavaWildcardTypeStorageClass ) * sizeOfActualPool) ;
        SgJavaWildcardTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaWildcardTypeStorageClass* storageArray = storageArraySgJavaWildcardType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaWildcardType ( *storageArray ) ; 
#else
               SgJavaWildcardType* tmp = new SgJavaWildcardType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaWildcardType;  
      SgJavaWildcardTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgProcessControlStatement ); 
     SgProcessControlStatementStorageClass* storageArraySgProcessControlStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgProcessControlStatement = new SgProcessControlStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgProcessControlStatement) , sizeof ( SgProcessControlStatementStorageClass ) * sizeOfActualPool) ;
        SgProcessControlStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgProcessControlStatementStorageClass* storageArray = storageArraySgProcessControlStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgProcessControlStatement ( *storageArray ) ; 
#else
               SgProcessControlStatement* tmp = new SgProcessControlStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgProcessControlStatement;  
      SgProcessControlStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSpecialFunctionModifier ); 
     SgSpecialFunctionModifierStorageClass* storageArraySgSpecialFunctionModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSpecialFunctionModifier = new SgSpecialFunctionModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSpecialFunctionModifier) , sizeof ( SgSpecialFunctionModifierStorageClass ) * sizeOfActualPool) ;
        SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSpecialFunctionModifierStorageClass* storageArray = storageArraySgSpecialFunctionModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSpecialFunctionModifier ( *storageArray ) ; 
#else
               SgSpecialFunctionModifier* tmp = new SgSpecialFunctionModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSpecialFunctionModifier;  
      SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStatement ); 
     SgStatementStorageClass* storageArraySgStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStatement = new SgStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStatement) , sizeof ( SgStatementStorageClass ) * sizeOfActualPool) ;
        SgStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStatementStorageClass* storageArray = storageArraySgStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStatement ( *storageArray ) ; 
#else
               SgStatement* tmp = new SgStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStatement;  
      SgStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStaticAssertionDeclaration ); 
     SgStaticAssertionDeclarationStorageClass* storageArraySgStaticAssertionDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStaticAssertionDeclaration = new SgStaticAssertionDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStaticAssertionDeclaration) , sizeof ( SgStaticAssertionDeclarationStorageClass ) * sizeOfActualPool) ;
        SgStaticAssertionDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStaticAssertionDeclarationStorageClass* storageArray = storageArraySgStaticAssertionDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStaticAssertionDeclaration ( *storageArray ) ; 
#else
               SgStaticAssertionDeclaration* tmp = new SgStaticAssertionDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStaticAssertionDeclaration;  
      SgStaticAssertionDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStmtDeclarationStatement ); 
     SgStmtDeclarationStatementStorageClass* storageArraySgStmtDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStmtDeclarationStatement = new SgStmtDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStmtDeclarationStatement) , sizeof ( SgStmtDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgStmtDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStmtDeclarationStatementStorageClass* storageArray = storageArraySgStmtDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStmtDeclarationStatement ( *storageArray ) ; 
#else
               SgStmtDeclarationStatement* tmp = new SgStmtDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStmtDeclarationStatement;  
      SgStmtDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStatementExpression ); 
     SgStatementExpressionStorageClass* storageArraySgStatementExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStatementExpression = new SgStatementExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStatementExpression) , sizeof ( SgStatementExpressionStorageClass ) * sizeOfActualPool) ;
        SgStatementExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStatementExpressionStorageClass* storageArray = storageArraySgStatementExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStatementExpression ( *storageArray ) ; 
#else
               SgStatementExpression* tmp = new SgStatementExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStatementExpression;  
      SgStatementExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStatementFunctionStatement ); 
     SgStatementFunctionStatementStorageClass* storageArraySgStatementFunctionStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStatementFunctionStatement = new SgStatementFunctionStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStatementFunctionStatement) , sizeof ( SgStatementFunctionStatementStorageClass ) * sizeOfActualPool) ;
        SgStatementFunctionStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStatementFunctionStatementStorageClass* storageArray = storageArraySgStatementFunctionStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStatementFunctionStatement ( *storageArray ) ; 
#else
               SgStatementFunctionStatement* tmp = new SgStatementFunctionStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStatementFunctionStatement;  
      SgStatementFunctionStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStorageModifier ); 
     SgStorageModifierStorageClass* storageArraySgStorageModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStorageModifier = new SgStorageModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStorageModifier) , sizeof ( SgStorageModifierStorageClass ) * sizeOfActualPool) ;
          SgStorageModifierStorageClass* storageArray = storageArraySgStorageModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStorageModifier ( *storageArray ) ; 
#else
               SgStorageModifier* tmp = new SgStorageModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStorageModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStringConversion ); 
     SgStringConversionStorageClass* storageArraySgStringConversion = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStringConversion = new SgStringConversionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStringConversion) , sizeof ( SgStringConversionStorageClass ) * sizeOfActualPool) ;
        SgStringConversionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStringConversionStorageClass* storageArray = storageArraySgStringConversion;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStringConversion ( *storageArray ) ; 
#else
               SgStringConversion* tmp = new SgStringConversion ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStringConversion;  
      SgStringConversionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStringKeyedBidirectionalGraph ); 
     SgStringKeyedBidirectionalGraphStorageClass* storageArraySgStringKeyedBidirectionalGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStringKeyedBidirectionalGraph = new SgStringKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStringKeyedBidirectionalGraph) , sizeof ( SgStringKeyedBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
        SgStringKeyedBidirectionalGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStringKeyedBidirectionalGraphStorageClass* storageArray = storageArraySgStringKeyedBidirectionalGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStringKeyedBidirectionalGraph ( *storageArray ) ; 
#else
               SgStringKeyedBidirectionalGraph* tmp = new SgStringKeyedBidirectionalGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStringKeyedBidirectionalGraph;  
      SgStringKeyedBidirectionalGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStringVal ); 
     SgStringValStorageClass* storageArraySgStringVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStringVal = new SgStringValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStringVal) , sizeof ( SgStringValStorageClass ) * sizeOfActualPool) ;
        SgStringValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStringValStorageClass* storageArray = storageArraySgStringVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStringVal ( *storageArray ) ; 
#else
               SgStringVal* tmp = new SgStringVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStringVal;  
      SgStringValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStructureModifier ); 
     SgStructureModifierStorageClass* storageArraySgStructureModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStructureModifier = new SgStructureModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStructureModifier) , sizeof ( SgStructureModifierStorageClass ) * sizeOfActualPool) ;
          SgStructureModifierStorageClass* storageArray = storageArraySgStructureModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgStructureModifier ( *storageArray ) ; 
#else
               SgStructureModifier* tmp = new SgStructureModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStructureModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSubscriptExpression ); 
     SgSubscriptExpressionStorageClass* storageArraySgSubscriptExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSubscriptExpression = new SgSubscriptExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSubscriptExpression) , sizeof ( SgSubscriptExpressionStorageClass ) * sizeOfActualPool) ;
        SgSubscriptExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSubscriptExpressionStorageClass* storageArray = storageArraySgSubscriptExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSubscriptExpression ( *storageArray ) ; 
#else
               SgSubscriptExpression* tmp = new SgSubscriptExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSubscriptExpression;  
      SgSubscriptExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSubtractOp ); 
     SgSubtractOpStorageClass* storageArraySgSubtractOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSubtractOp = new SgSubtractOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSubtractOp) , sizeof ( SgSubtractOpStorageClass ) * sizeOfActualPool) ;
        SgSubtractOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSubtractOpStorageClass* storageArray = storageArraySgSubtractOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSubtractOp ( *storageArray ) ; 
#else
               SgSubtractOp* tmp = new SgSubtractOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSubtractOp;  
      SgSubtractOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSupport ); 
     SgSupportStorageClass* storageArraySgSupport = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSupport = new SgSupportStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSupport) , sizeof ( SgSupportStorageClass ) * sizeOfActualPool) ;
          SgSupportStorageClass* storageArray = storageArraySgSupport;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSupport ( *storageArray ) ; 
#else
               SgSupport* tmp = new SgSupport ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSupport;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSwitchStatement ); 
     SgSwitchStatementStorageClass* storageArraySgSwitchStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSwitchStatement = new SgSwitchStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSwitchStatement) , sizeof ( SgSwitchStatementStorageClass ) * sizeOfActualPool) ;
        SgSwitchStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSwitchStatementStorageClass* storageArray = storageArraySgSwitchStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSwitchStatement ( *storageArray ) ; 
#else
               SgSwitchStatement* tmp = new SgSwitchStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSwitchStatement;  
      SgSwitchStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSymbolTable ); 
     SgSymbolTableStorageClass* storageArraySgSymbolTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSymbolTable = new SgSymbolTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSymbolTable) , sizeof ( SgSymbolTableStorageClass ) * sizeOfActualPool) ;
        SgSymbolTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSymbolTableStorageClass* storageArray = storageArraySgSymbolTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSymbolTable ( *storageArray ) ; 
#else
               SgSymbolTable* tmp = new SgSymbolTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSymbolTable;  
      SgSymbolTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateArgument ); 
     SgTemplateArgumentStorageClass* storageArraySgTemplateArgument = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateArgument = new SgTemplateArgumentStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateArgument) , sizeof ( SgTemplateArgumentStorageClass ) * sizeOfActualPool) ;
          SgTemplateArgumentStorageClass* storageArray = storageArraySgTemplateArgument;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateArgument ( *storageArray ) ; 
#else
               SgTemplateArgument* tmp = new SgTemplateArgument ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateArgument;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateArgumentList ); 
     SgTemplateArgumentListStorageClass* storageArraySgTemplateArgumentList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateArgumentList = new SgTemplateArgumentListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateArgumentList) , sizeof ( SgTemplateArgumentListStorageClass ) * sizeOfActualPool) ;
        SgTemplateArgumentListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateArgumentListStorageClass* storageArray = storageArraySgTemplateArgumentList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateArgumentList ( *storageArray ) ; 
#else
               SgTemplateArgumentList* tmp = new SgTemplateArgumentList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateArgumentList;  
      SgTemplateArgumentListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateDeclaration ); 
     SgTemplateDeclarationStorageClass* storageArraySgTemplateDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateDeclaration = new SgTemplateDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateDeclaration) , sizeof ( SgTemplateDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateDeclarationStorageClass* storageArray = storageArraySgTemplateDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateDeclaration ( *storageArray ) ; 
#else
               SgTemplateDeclaration* tmp = new SgTemplateDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateDeclaration;  
      SgTemplateDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateClassDeclaration ); 
     SgTemplateClassDeclarationStorageClass* storageArraySgTemplateClassDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateClassDeclaration = new SgTemplateClassDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateClassDeclaration) , sizeof ( SgTemplateClassDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateClassDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateClassDeclarationStorageClass* storageArray = storageArraySgTemplateClassDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateClassDeclaration ( *storageArray ) ; 
#else
               SgTemplateClassDeclaration* tmp = new SgTemplateClassDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateClassDeclaration;  
      SgTemplateClassDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateClassSymbol ); 
     SgTemplateClassSymbolStorageClass* storageArraySgTemplateClassSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateClassSymbol = new SgTemplateClassSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateClassSymbol) , sizeof ( SgTemplateClassSymbolStorageClass ) * sizeOfActualPool) ;
        SgTemplateClassSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateClassSymbolStorageClass* storageArray = storageArraySgTemplateClassSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateClassSymbol ( *storageArray ) ; 
#else
               SgTemplateClassSymbol* tmp = new SgTemplateClassSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateClassSymbol;  
      SgTemplateClassSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateFunctionDeclaration ); 
     SgTemplateFunctionDeclarationStorageClass* storageArraySgTemplateFunctionDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateFunctionDeclaration = new SgTemplateFunctionDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateFunctionDeclaration) , sizeof ( SgTemplateFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateFunctionDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateFunctionDeclarationStorageClass* storageArray = storageArraySgTemplateFunctionDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateFunctionDeclaration ( *storageArray ) ; 
#else
               SgTemplateFunctionDeclaration* tmp = new SgTemplateFunctionDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateFunctionDeclaration;  
      SgTemplateFunctionDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateFunctionRefExp ); 
     SgTemplateFunctionRefExpStorageClass* storageArraySgTemplateFunctionRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateFunctionRefExp = new SgTemplateFunctionRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateFunctionRefExp) , sizeof ( SgTemplateFunctionRefExpStorageClass ) * sizeOfActualPool) ;
        SgTemplateFunctionRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateFunctionRefExpStorageClass* storageArray = storageArraySgTemplateFunctionRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateFunctionRefExp ( *storageArray ) ; 
#else
               SgTemplateFunctionRefExp* tmp = new SgTemplateFunctionRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateFunctionRefExp;  
      SgTemplateFunctionRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateFunctionSymbol ); 
     SgTemplateFunctionSymbolStorageClass* storageArraySgTemplateFunctionSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateFunctionSymbol = new SgTemplateFunctionSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateFunctionSymbol) , sizeof ( SgTemplateFunctionSymbolStorageClass ) * sizeOfActualPool) ;
        SgTemplateFunctionSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateFunctionSymbolStorageClass* storageArray = storageArraySgTemplateFunctionSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateFunctionSymbol ( *storageArray ) ; 
#else
               SgTemplateFunctionSymbol* tmp = new SgTemplateFunctionSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateFunctionSymbol;  
      SgTemplateFunctionSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateMemberFunctionDeclaration ); 
     SgTemplateMemberFunctionDeclarationStorageClass* storageArraySgTemplateMemberFunctionDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateMemberFunctionDeclaration = new SgTemplateMemberFunctionDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateMemberFunctionDeclaration) , sizeof ( SgTemplateMemberFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateMemberFunctionDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateMemberFunctionDeclarationStorageClass* storageArray = storageArraySgTemplateMemberFunctionDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateMemberFunctionDeclaration ( *storageArray ) ; 
#else
               SgTemplateMemberFunctionDeclaration* tmp = new SgTemplateMemberFunctionDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateMemberFunctionDeclaration;  
      SgTemplateMemberFunctionDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateMemberFunctionRefExp ); 
     SgTemplateMemberFunctionRefExpStorageClass* storageArraySgTemplateMemberFunctionRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateMemberFunctionRefExp = new SgTemplateMemberFunctionRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateMemberFunctionRefExp) , sizeof ( SgTemplateMemberFunctionRefExpStorageClass ) * sizeOfActualPool) ;
        SgTemplateMemberFunctionRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateMemberFunctionRefExpStorageClass* storageArray = storageArraySgTemplateMemberFunctionRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateMemberFunctionRefExp ( *storageArray ) ; 
#else
               SgTemplateMemberFunctionRefExp* tmp = new SgTemplateMemberFunctionRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateMemberFunctionRefExp;  
      SgTemplateMemberFunctionRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateMemberFunctionSymbol ); 
     SgTemplateMemberFunctionSymbolStorageClass* storageArraySgTemplateMemberFunctionSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateMemberFunctionSymbol = new SgTemplateMemberFunctionSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateMemberFunctionSymbol) , sizeof ( SgTemplateMemberFunctionSymbolStorageClass ) * sizeOfActualPool) ;
        SgTemplateMemberFunctionSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateMemberFunctionSymbolStorageClass* storageArray = storageArraySgTemplateMemberFunctionSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateMemberFunctionSymbol ( *storageArray ) ; 
#else
               SgTemplateMemberFunctionSymbol* tmp = new SgTemplateMemberFunctionSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateMemberFunctionSymbol;  
      SgTemplateMemberFunctionSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateTypedefDeclaration ); 
     SgTemplateTypedefDeclarationStorageClass* storageArraySgTemplateTypedefDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateTypedefDeclaration = new SgTemplateTypedefDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateTypedefDeclaration) , sizeof ( SgTemplateTypedefDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateTypedefDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateTypedefDeclarationStorageClass* storageArray = storageArraySgTemplateTypedefDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateTypedefDeclaration ( *storageArray ) ; 
#else
               SgTemplateTypedefDeclaration* tmp = new SgTemplateTypedefDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateTypedefDeclaration;  
      SgTemplateTypedefDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateTypedefSymbol ); 
     SgTemplateTypedefSymbolStorageClass* storageArraySgTemplateTypedefSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateTypedefSymbol = new SgTemplateTypedefSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateTypedefSymbol) , sizeof ( SgTemplateTypedefSymbolStorageClass ) * sizeOfActualPool) ;
        SgTemplateTypedefSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateTypedefSymbolStorageClass* storageArray = storageArraySgTemplateTypedefSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateTypedefSymbol ( *storageArray ) ; 
#else
               SgTemplateTypedefSymbol* tmp = new SgTemplateTypedefSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateTypedefSymbol;  
      SgTemplateTypedefSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateVariableDeclaration ); 
     SgTemplateVariableDeclarationStorageClass* storageArraySgTemplateVariableDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateVariableDeclaration = new SgTemplateVariableDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateVariableDeclaration) , sizeof ( SgTemplateVariableDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateVariableDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateVariableDeclarationStorageClass* storageArray = storageArraySgTemplateVariableDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateVariableDeclaration ( *storageArray ) ; 
#else
               SgTemplateVariableDeclaration* tmp = new SgTemplateVariableDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateVariableDeclaration;  
      SgTemplateVariableDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateVariableSymbol ); 
     SgTemplateVariableSymbolStorageClass* storageArraySgTemplateVariableSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateVariableSymbol = new SgTemplateVariableSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateVariableSymbol) , sizeof ( SgTemplateVariableSymbolStorageClass ) * sizeOfActualPool) ;
        SgTemplateVariableSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateVariableSymbolStorageClass* storageArray = storageArraySgTemplateVariableSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateVariableSymbol ( *storageArray ) ; 
#else
               SgTemplateVariableSymbol* tmp = new SgTemplateVariableSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateVariableSymbol;  
      SgTemplateVariableSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateClassDefinition ); 
     SgTemplateClassDefinitionStorageClass* storageArraySgTemplateClassDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateClassDefinition = new SgTemplateClassDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateClassDefinition) , sizeof ( SgTemplateClassDefinitionStorageClass ) * sizeOfActualPool) ;
        SgTemplateClassDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateClassDefinitionStorageClass* storageArray = storageArraySgTemplateClassDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateClassDefinition ( *storageArray ) ; 
#else
               SgTemplateClassDefinition* tmp = new SgTemplateClassDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateClassDefinition;  
      SgTemplateClassDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateFunctionDefinition ); 
     SgTemplateFunctionDefinitionStorageClass* storageArraySgTemplateFunctionDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateFunctionDefinition = new SgTemplateFunctionDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateFunctionDefinition) , sizeof ( SgTemplateFunctionDefinitionStorageClass ) * sizeOfActualPool) ;
        SgTemplateFunctionDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateFunctionDefinitionStorageClass* storageArray = storageArraySgTemplateFunctionDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateFunctionDefinition ( *storageArray ) ; 
#else
               SgTemplateFunctionDefinition* tmp = new SgTemplateFunctionDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateFunctionDefinition;  
      SgTemplateFunctionDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationDecl ); 
     SgTemplateInstantiationDeclStorageClass* storageArraySgTemplateInstantiationDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationDecl = new SgTemplateInstantiationDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationDecl) , sizeof ( SgTemplateInstantiationDeclStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationDeclStorageClass* storageArray = storageArraySgTemplateInstantiationDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateInstantiationDecl ( *storageArray ) ; 
#else
               SgTemplateInstantiationDecl* tmp = new SgTemplateInstantiationDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationDecl;  
      SgTemplateInstantiationDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationDefn ); 
     SgTemplateInstantiationDefnStorageClass* storageArraySgTemplateInstantiationDefn = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationDefn = new SgTemplateInstantiationDefnStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationDefn) , sizeof ( SgTemplateInstantiationDefnStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationDefnStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationDefnStorageClass* storageArray = storageArraySgTemplateInstantiationDefn;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateInstantiationDefn ( *storageArray ) ; 
#else
               SgTemplateInstantiationDefn* tmp = new SgTemplateInstantiationDefn ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationDefn;  
      SgTemplateInstantiationDefnStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationDirectiveStatement ); 
     SgTemplateInstantiationDirectiveStatementStorageClass* storageArraySgTemplateInstantiationDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationDirectiveStatement = new SgTemplateInstantiationDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationDirectiveStatement) , sizeof ( SgTemplateInstantiationDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationDirectiveStatementStorageClass* storageArray = storageArraySgTemplateInstantiationDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateInstantiationDirectiveStatement ( *storageArray ) ; 
#else
               SgTemplateInstantiationDirectiveStatement* tmp = new SgTemplateInstantiationDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationDirectiveStatement;  
      SgTemplateInstantiationDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationFunctionDecl ); 
     SgTemplateInstantiationFunctionDeclStorageClass* storageArraySgTemplateInstantiationFunctionDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationFunctionDecl = new SgTemplateInstantiationFunctionDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationFunctionDecl) , sizeof ( SgTemplateInstantiationFunctionDeclStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationFunctionDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationFunctionDeclStorageClass* storageArray = storageArraySgTemplateInstantiationFunctionDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateInstantiationFunctionDecl ( *storageArray ) ; 
#else
               SgTemplateInstantiationFunctionDecl* tmp = new SgTemplateInstantiationFunctionDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationFunctionDecl;  
      SgTemplateInstantiationFunctionDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationMemberFunctionDecl ); 
     SgTemplateInstantiationMemberFunctionDeclStorageClass* storageArraySgTemplateInstantiationMemberFunctionDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationMemberFunctionDecl = new SgTemplateInstantiationMemberFunctionDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationMemberFunctionDecl) , sizeof ( SgTemplateInstantiationMemberFunctionDeclStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationMemberFunctionDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationMemberFunctionDeclStorageClass* storageArray = storageArraySgTemplateInstantiationMemberFunctionDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateInstantiationMemberFunctionDecl ( *storageArray ) ; 
#else
               SgTemplateInstantiationMemberFunctionDecl* tmp = new SgTemplateInstantiationMemberFunctionDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationMemberFunctionDecl;  
      SgTemplateInstantiationMemberFunctionDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationTypedefDeclaration ); 
     SgTemplateInstantiationTypedefDeclarationStorageClass* storageArraySgTemplateInstantiationTypedefDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationTypedefDeclaration = new SgTemplateInstantiationTypedefDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationTypedefDeclaration) , sizeof ( SgTemplateInstantiationTypedefDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationTypedefDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationTypedefDeclarationStorageClass* storageArray = storageArraySgTemplateInstantiationTypedefDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateInstantiationTypedefDeclaration ( *storageArray ) ; 
#else
               SgTemplateInstantiationTypedefDeclaration* tmp = new SgTemplateInstantiationTypedefDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationTypedefDeclaration;  
      SgTemplateInstantiationTypedefDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateParameter ); 
     SgTemplateParameterStorageClass* storageArraySgTemplateParameter = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateParameter = new SgTemplateParameterStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateParameter) , sizeof ( SgTemplateParameterStorageClass ) * sizeOfActualPool) ;
          SgTemplateParameterStorageClass* storageArray = storageArraySgTemplateParameter;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateParameter ( *storageArray ) ; 
#else
               SgTemplateParameter* tmp = new SgTemplateParameter ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateParameter;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateParameterVal ); 
     SgTemplateParameterValStorageClass* storageArraySgTemplateParameterVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateParameterVal = new SgTemplateParameterValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateParameterVal) , sizeof ( SgTemplateParameterValStorageClass ) * sizeOfActualPool) ;
        SgTemplateParameterValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateParameterValStorageClass* storageArray = storageArraySgTemplateParameterVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateParameterVal ( *storageArray ) ; 
#else
               SgTemplateParameterVal* tmp = new SgTemplateParameterVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateParameterVal;  
      SgTemplateParameterValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateParameterList ); 
     SgTemplateParameterListStorageClass* storageArraySgTemplateParameterList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateParameterList = new SgTemplateParameterListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateParameterList) , sizeof ( SgTemplateParameterListStorageClass ) * sizeOfActualPool) ;
        SgTemplateParameterListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateParameterListStorageClass* storageArray = storageArraySgTemplateParameterList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateParameterList ( *storageArray ) ; 
#else
               SgTemplateParameterList* tmp = new SgTemplateParameterList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateParameterList;  
      SgTemplateParameterListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateSymbol ); 
     SgTemplateSymbolStorageClass* storageArraySgTemplateSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateSymbol = new SgTemplateSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateSymbol) , sizeof ( SgTemplateSymbolStorageClass ) * sizeOfActualPool) ;
        SgTemplateSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateSymbolStorageClass* storageArray = storageArraySgTemplateSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateSymbol ( *storageArray ) ; 
#else
               SgTemplateSymbol* tmp = new SgTemplateSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateSymbol;  
      SgTemplateSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateType ); 
     SgTemplateTypeStorageClass* storageArraySgTemplateType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateType = new SgTemplateTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateType) , sizeof ( SgTemplateTypeStorageClass ) * sizeOfActualPool) ;
        SgTemplateTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateTypeStorageClass* storageArray = storageArraySgTemplateType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateType ( *storageArray ) ; 
#else
               SgTemplateType* tmp = new SgTemplateType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateType;  
      SgTemplateTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgThisExp ); 
     SgThisExpStorageClass* storageArraySgThisExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgThisExp = new SgThisExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgThisExp) , sizeof ( SgThisExpStorageClass ) * sizeOfActualPool) ;
        SgThisExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgThisExpStorageClass* storageArray = storageArraySgThisExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgThisExp ( *storageArray ) ; 
#else
               SgThisExp* tmp = new SgThisExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgThisExp;  
      SgThisExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeTraitBuiltinOperator ); 
     SgTypeTraitBuiltinOperatorStorageClass* storageArraySgTypeTraitBuiltinOperator = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeTraitBuiltinOperator = new SgTypeTraitBuiltinOperatorStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeTraitBuiltinOperator) , sizeof ( SgTypeTraitBuiltinOperatorStorageClass ) * sizeOfActualPool) ;
        SgTypeTraitBuiltinOperatorStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeTraitBuiltinOperatorStorageClass* storageArray = storageArraySgTypeTraitBuiltinOperator;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeTraitBuiltinOperator ( *storageArray ) ; 
#else
               SgTypeTraitBuiltinOperator* tmp = new SgTypeTraitBuiltinOperator ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeTraitBuiltinOperator;  
      SgTypeTraitBuiltinOperatorStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSuperExp ); 
     SgSuperExpStorageClass* storageArraySgSuperExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSuperExp = new SgSuperExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSuperExp) , sizeof ( SgSuperExpStorageClass ) * sizeOfActualPool) ;
        SgSuperExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSuperExpStorageClass* storageArray = storageArraySgSuperExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSuperExp ( *storageArray ) ; 
#else
               SgSuperExp* tmp = new SgSuperExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSuperExp;  
      SgSuperExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgThrowOp ); 
     SgThrowOpStorageClass* storageArraySgThrowOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgThrowOp = new SgThrowOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgThrowOp) , sizeof ( SgThrowOpStorageClass ) * sizeOfActualPool) ;
        SgThrowOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgThrowOpStorageClass* storageArray = storageArraySgThrowOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgThrowOp ( *storageArray ) ; 
#else
               SgThrowOp* tmp = new SgThrowOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgThrowOp;  
      SgThrowOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgToken ); 
     SgTokenStorageClass* storageArraySgToken = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgToken = new SgTokenStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgToken) , sizeof ( SgTokenStorageClass ) * sizeOfActualPool) ;
        SgTokenStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTokenStorageClass* storageArray = storageArraySgToken;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgToken ( *storageArray ) ; 
#else
               SgToken* tmp = new SgToken ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgToken;  
      SgTokenStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTryStmt ); 
     SgTryStmtStorageClass* storageArraySgTryStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTryStmt = new SgTryStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTryStmt) , sizeof ( SgTryStmtStorageClass ) * sizeOfActualPool) ;
        SgTryStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTryStmtStorageClass* storageArray = storageArraySgTryStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTryStmt ( *storageArray ) ; 
#else
               SgTryStmt* tmp = new SgTryStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTryStmt;  
      SgTryStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTupleExp ); 
     SgTupleExpStorageClass* storageArraySgTupleExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTupleExp = new SgTupleExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTupleExp) , sizeof ( SgTupleExpStorageClass ) * sizeOfActualPool) ;
        SgTupleExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTupleExpStorageClass* storageArray = storageArraySgTupleExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTupleExp ( *storageArray ) ; 
#else
               SgTupleExp* tmp = new SgTupleExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTupleExp;  
      SgTupleExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgType ); 
     SgTypeStorageClass* storageArraySgType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgType = new SgTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgType) , sizeof ( SgTypeStorageClass ) * sizeOfActualPool) ;
        SgTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeStorageClass* storageArray = storageArraySgType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgType ( *storageArray ) ; 
#else
               SgType* tmp = new SgType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgType;  
      SgTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeBool ); 
     SgTypeBoolStorageClass* storageArraySgTypeBool = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeBool = new SgTypeBoolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeBool) , sizeof ( SgTypeBoolStorageClass ) * sizeOfActualPool) ;
        SgTypeBoolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeBoolStorageClass* storageArray = storageArraySgTypeBool;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeBool ( *storageArray ) ; 
#else
               SgTypeBool* tmp = new SgTypeBool ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeBool;  
      SgTypeBoolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeChar ); 
     SgTypeCharStorageClass* storageArraySgTypeChar = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeChar = new SgTypeCharStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeChar) , sizeof ( SgTypeCharStorageClass ) * sizeOfActualPool) ;
        SgTypeCharStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeCharStorageClass* storageArray = storageArraySgTypeChar;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeChar ( *storageArray ) ; 
#else
               SgTypeChar* tmp = new SgTypeChar ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeChar;  
      SgTypeCharStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeChar16 ); 
     SgTypeChar16StorageClass* storageArraySgTypeChar16 = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeChar16 = new SgTypeChar16StorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeChar16) , sizeof ( SgTypeChar16StorageClass ) * sizeOfActualPool) ;
        SgTypeChar16StorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeChar16StorageClass* storageArray = storageArraySgTypeChar16;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeChar16 ( *storageArray ) ; 
#else
               SgTypeChar16* tmp = new SgTypeChar16 ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeChar16;  
      SgTypeChar16StorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeChar32 ); 
     SgTypeChar32StorageClass* storageArraySgTypeChar32 = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeChar32 = new SgTypeChar32StorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeChar32) , sizeof ( SgTypeChar32StorageClass ) * sizeOfActualPool) ;
        SgTypeChar32StorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeChar32StorageClass* storageArray = storageArraySgTypeChar32;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeChar32 ( *storageArray ) ; 
#else
               SgTypeChar32* tmp = new SgTypeChar32 ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeChar32;  
      SgTypeChar32StorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeComplex ); 
     SgTypeComplexStorageClass* storageArraySgTypeComplex = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeComplex = new SgTypeComplexStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeComplex) , sizeof ( SgTypeComplexStorageClass ) * sizeOfActualPool) ;
        SgTypeComplexStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeComplexStorageClass* storageArray = storageArraySgTypeComplex;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeComplex ( *storageArray ) ; 
#else
               SgTypeComplex* tmp = new SgTypeComplex ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeComplex;  
      SgTypeComplexStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeDefault ); 
     SgTypeDefaultStorageClass* storageArraySgTypeDefault = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeDefault = new SgTypeDefaultStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeDefault) , sizeof ( SgTypeDefaultStorageClass ) * sizeOfActualPool) ;
        SgTypeDefaultStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeDefaultStorageClass* storageArray = storageArraySgTypeDefault;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeDefault ( *storageArray ) ; 
#else
               SgTypeDefault* tmp = new SgTypeDefault ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeDefault;  
      SgTypeDefaultStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeExpression ); 
     SgTypeExpressionStorageClass* storageArraySgTypeExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeExpression = new SgTypeExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeExpression) , sizeof ( SgTypeExpressionStorageClass ) * sizeOfActualPool) ;
        SgTypeExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeExpressionStorageClass* storageArray = storageArraySgTypeExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeExpression ( *storageArray ) ; 
#else
               SgTypeExpression* tmp = new SgTypeExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeExpression;  
      SgTypeExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeLabel ); 
     SgTypeLabelStorageClass* storageArraySgTypeLabel = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeLabel = new SgTypeLabelStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeLabel) , sizeof ( SgTypeLabelStorageClass ) * sizeOfActualPool) ;
        SgTypeLabelStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeLabelStorageClass* storageArray = storageArraySgTypeLabel;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeLabel ( *storageArray ) ; 
#else
               SgTypeLabel* tmp = new SgTypeLabel ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeLabel;  
      SgTypeLabelStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeDouble ); 
     SgTypeDoubleStorageClass* storageArraySgTypeDouble = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeDouble = new SgTypeDoubleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeDouble) , sizeof ( SgTypeDoubleStorageClass ) * sizeOfActualPool) ;
        SgTypeDoubleStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeDoubleStorageClass* storageArray = storageArraySgTypeDouble;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeDouble ( *storageArray ) ; 
#else
               SgTypeDouble* tmp = new SgTypeDouble ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeDouble;  
      SgTypeDoubleStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeEllipse ); 
     SgTypeEllipseStorageClass* storageArraySgTypeEllipse = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeEllipse = new SgTypeEllipseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeEllipse) , sizeof ( SgTypeEllipseStorageClass ) * sizeOfActualPool) ;
        SgTypeEllipseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeEllipseStorageClass* storageArray = storageArraySgTypeEllipse;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeEllipse ( *storageArray ) ; 
#else
               SgTypeEllipse* tmp = new SgTypeEllipse ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeEllipse;  
      SgTypeEllipseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeFixed ); 
     SgTypeFixedStorageClass* storageArraySgTypeFixed = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeFixed = new SgTypeFixedStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeFixed) , sizeof ( SgTypeFixedStorageClass ) * sizeOfActualPool) ;
        SgTypeFixedStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeFixedStorageClass* storageArray = storageArraySgTypeFixed;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeFixed ( *storageArray ) ; 
#else
               SgTypeFixed* tmp = new SgTypeFixed ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeFixed;  
      SgTypeFixedStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeFloat ); 
     SgTypeFloatStorageClass* storageArraySgTypeFloat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeFloat = new SgTypeFloatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeFloat) , sizeof ( SgTypeFloatStorageClass ) * sizeOfActualPool) ;
        SgTypeFloatStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeFloatStorageClass* storageArray = storageArraySgTypeFloat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeFloat ( *storageArray ) ; 
#else
               SgTypeFloat* tmp = new SgTypeFloat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeFloat;  
      SgTypeFloatStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeFloat128 ); 
     SgTypeFloat128StorageClass* storageArraySgTypeFloat128 = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeFloat128 = new SgTypeFloat128StorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeFloat128) , sizeof ( SgTypeFloat128StorageClass ) * sizeOfActualPool) ;
        SgTypeFloat128StorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeFloat128StorageClass* storageArray = storageArraySgTypeFloat128;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeFloat128 ( *storageArray ) ; 
#else
               SgTypeFloat128* tmp = new SgTypeFloat128 ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeFloat128;  
      SgTypeFloat128StorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeFloat80 ); 
     SgTypeFloat80StorageClass* storageArraySgTypeFloat80 = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeFloat80 = new SgTypeFloat80StorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeFloat80) , sizeof ( SgTypeFloat80StorageClass ) * sizeOfActualPool) ;
        SgTypeFloat80StorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeFloat80StorageClass* storageArray = storageArraySgTypeFloat80;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeFloat80 ( *storageArray ) ; 
#else
               SgTypeFloat80* tmp = new SgTypeFloat80 ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeFloat80;  
      SgTypeFloat80StorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeGlobalVoid ); 
     SgTypeGlobalVoidStorageClass* storageArraySgTypeGlobalVoid = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeGlobalVoid = new SgTypeGlobalVoidStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeGlobalVoid) , sizeof ( SgTypeGlobalVoidStorageClass ) * sizeOfActualPool) ;
        SgTypeGlobalVoidStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeGlobalVoidStorageClass* storageArray = storageArraySgTypeGlobalVoid;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeGlobalVoid ( *storageArray ) ; 
#else
               SgTypeGlobalVoid* tmp = new SgTypeGlobalVoid ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeGlobalVoid;  
      SgTypeGlobalVoidStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeIdOp ); 
     SgTypeIdOpStorageClass* storageArraySgTypeIdOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeIdOp = new SgTypeIdOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeIdOp) , sizeof ( SgTypeIdOpStorageClass ) * sizeOfActualPool) ;
        SgTypeIdOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeIdOpStorageClass* storageArray = storageArraySgTypeIdOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeIdOp ( *storageArray ) ; 
#else
               SgTypeIdOp* tmp = new SgTypeIdOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeIdOp;  
      SgTypeIdOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeImaginary ); 
     SgTypeImaginaryStorageClass* storageArraySgTypeImaginary = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeImaginary = new SgTypeImaginaryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeImaginary) , sizeof ( SgTypeImaginaryStorageClass ) * sizeOfActualPool) ;
        SgTypeImaginaryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeImaginaryStorageClass* storageArray = storageArraySgTypeImaginary;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeImaginary ( *storageArray ) ; 
#else
               SgTypeImaginary* tmp = new SgTypeImaginary ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeImaginary;  
      SgTypeImaginaryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeInt ); 
     SgTypeIntStorageClass* storageArraySgTypeInt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeInt = new SgTypeIntStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeInt) , sizeof ( SgTypeIntStorageClass ) * sizeOfActualPool) ;
        SgTypeIntStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeIntStorageClass* storageArray = storageArraySgTypeInt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeInt ( *storageArray ) ; 
#else
               SgTypeInt* tmp = new SgTypeInt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeInt;  
      SgTypeIntStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeLong ); 
     SgTypeLongStorageClass* storageArraySgTypeLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeLong = new SgTypeLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeLong) , sizeof ( SgTypeLongStorageClass ) * sizeOfActualPool) ;
        SgTypeLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeLongStorageClass* storageArray = storageArraySgTypeLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeLong ( *storageArray ) ; 
#else
               SgTypeLong* tmp = new SgTypeLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeLong;  
      SgTypeLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeLongDouble ); 
     SgTypeLongDoubleStorageClass* storageArraySgTypeLongDouble = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeLongDouble = new SgTypeLongDoubleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeLongDouble) , sizeof ( SgTypeLongDoubleStorageClass ) * sizeOfActualPool) ;
        SgTypeLongDoubleStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeLongDoubleStorageClass* storageArray = storageArraySgTypeLongDouble;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeLongDouble ( *storageArray ) ; 
#else
               SgTypeLongDouble* tmp = new SgTypeLongDouble ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeLongDouble;  
      SgTypeLongDoubleStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeLongLong ); 
     SgTypeLongLongStorageClass* storageArraySgTypeLongLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeLongLong = new SgTypeLongLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeLongLong) , sizeof ( SgTypeLongLongStorageClass ) * sizeOfActualPool) ;
        SgTypeLongLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeLongLongStorageClass* storageArray = storageArraySgTypeLongLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeLongLong ( *storageArray ) ; 
#else
               SgTypeLongLong* tmp = new SgTypeLongLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeLongLong;  
      SgTypeLongLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeModifier ); 
     SgTypeModifierStorageClass* storageArraySgTypeModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeModifier = new SgTypeModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeModifier) , sizeof ( SgTypeModifierStorageClass ) * sizeOfActualPool) ;
        SgTypeModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeModifierStorageClass* storageArray = storageArraySgTypeModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeModifier ( *storageArray ) ; 
#else
               SgTypeModifier* tmp = new SgTypeModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeModifier;  
      SgTypeModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeMatrix ); 
     SgTypeMatrixStorageClass* storageArraySgTypeMatrix = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeMatrix = new SgTypeMatrixStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeMatrix) , sizeof ( SgTypeMatrixStorageClass ) * sizeOfActualPool) ;
        SgTypeMatrixStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeMatrixStorageClass* storageArray = storageArraySgTypeMatrix;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeMatrix ( *storageArray ) ; 
#else
               SgTypeMatrix* tmp = new SgTypeMatrix ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeMatrix;  
      SgTypeMatrixStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeTuple ); 
     SgTypeTupleStorageClass* storageArraySgTypeTuple = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeTuple = new SgTypeTupleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeTuple) , sizeof ( SgTypeTupleStorageClass ) * sizeOfActualPool) ;
        SgTypeTupleStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeTupleStorageClass* storageArray = storageArraySgTypeTuple;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeTuple ( *storageArray ) ; 
#else
               SgTypeTuple* tmp = new SgTypeTuple ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeTuple;  
      SgTypeTupleStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeNullptr ); 
     SgTypeNullptrStorageClass* storageArraySgTypeNullptr = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeNullptr = new SgTypeNullptrStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeNullptr) , sizeof ( SgTypeNullptrStorageClass ) * sizeOfActualPool) ;
        SgTypeNullptrStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeNullptrStorageClass* storageArray = storageArraySgTypeNullptr;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeNullptr ( *storageArray ) ; 
#else
               SgTypeNullptr* tmp = new SgTypeNullptr ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeNullptr;  
      SgTypeNullptrStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeOfType ); 
     SgTypeOfTypeStorageClass* storageArraySgTypeOfType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeOfType = new SgTypeOfTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeOfType) , sizeof ( SgTypeOfTypeStorageClass ) * sizeOfActualPool) ;
        SgTypeOfTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeOfTypeStorageClass* storageArray = storageArraySgTypeOfType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeOfType ( *storageArray ) ; 
#else
               SgTypeOfType* tmp = new SgTypeOfType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeOfType;  
      SgTypeOfTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeShort ); 
     SgTypeShortStorageClass* storageArraySgTypeShort = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeShort = new SgTypeShortStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeShort) , sizeof ( SgTypeShortStorageClass ) * sizeOfActualPool) ;
        SgTypeShortStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeShortStorageClass* storageArray = storageArraySgTypeShort;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeShort ( *storageArray ) ; 
#else
               SgTypeShort* tmp = new SgTypeShort ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeShort;  
      SgTypeShortStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSigned128bitInteger ); 
     SgTypeSigned128bitIntegerStorageClass* storageArraySgTypeSigned128bitInteger = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSigned128bitInteger = new SgTypeSigned128bitIntegerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSigned128bitInteger) , sizeof ( SgTypeSigned128bitIntegerStorageClass ) * sizeOfActualPool) ;
        SgTypeSigned128bitIntegerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSigned128bitIntegerStorageClass* storageArray = storageArraySgTypeSigned128bitInteger;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeSigned128bitInteger ( *storageArray ) ; 
#else
               SgTypeSigned128bitInteger* tmp = new SgTypeSigned128bitInteger ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSigned128bitInteger;  
      SgTypeSigned128bitIntegerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedChar ); 
     SgTypeSignedCharStorageClass* storageArraySgTypeSignedChar = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedChar = new SgTypeSignedCharStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedChar) , sizeof ( SgTypeSignedCharStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedCharStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedCharStorageClass* storageArray = storageArraySgTypeSignedChar;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeSignedChar ( *storageArray ) ; 
#else
               SgTypeSignedChar* tmp = new SgTypeSignedChar ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedChar;  
      SgTypeSignedCharStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedInt ); 
     SgTypeSignedIntStorageClass* storageArraySgTypeSignedInt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedInt = new SgTypeSignedIntStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedInt) , sizeof ( SgTypeSignedIntStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedIntStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedIntStorageClass* storageArray = storageArraySgTypeSignedInt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeSignedInt ( *storageArray ) ; 
#else
               SgTypeSignedInt* tmp = new SgTypeSignedInt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedInt;  
      SgTypeSignedIntStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedLong ); 
     SgTypeSignedLongStorageClass* storageArraySgTypeSignedLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedLong = new SgTypeSignedLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedLong) , sizeof ( SgTypeSignedLongStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedLongStorageClass* storageArray = storageArraySgTypeSignedLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeSignedLong ( *storageArray ) ; 
#else
               SgTypeSignedLong* tmp = new SgTypeSignedLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedLong;  
      SgTypeSignedLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedLongLong ); 
     SgTypeSignedLongLongStorageClass* storageArraySgTypeSignedLongLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedLongLong = new SgTypeSignedLongLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedLongLong) , sizeof ( SgTypeSignedLongLongStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedLongLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedLongLongStorageClass* storageArray = storageArraySgTypeSignedLongLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeSignedLongLong ( *storageArray ) ; 
#else
               SgTypeSignedLongLong* tmp = new SgTypeSignedLongLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedLongLong;  
      SgTypeSignedLongLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedShort ); 
     SgTypeSignedShortStorageClass* storageArraySgTypeSignedShort = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedShort = new SgTypeSignedShortStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedShort) , sizeof ( SgTypeSignedShortStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedShortStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedShortStorageClass* storageArray = storageArraySgTypeSignedShort;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeSignedShort ( *storageArray ) ; 
#else
               SgTypeSignedShort* tmp = new SgTypeSignedShort ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedShort;  
      SgTypeSignedShortStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeString ); 
     SgTypeStringStorageClass* storageArraySgTypeString = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeString = new SgTypeStringStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeString) , sizeof ( SgTypeStringStorageClass ) * sizeOfActualPool) ;
        SgTypeStringStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeStringStorageClass* storageArray = storageArraySgTypeString;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeString ( *storageArray ) ; 
#else
               SgTypeString* tmp = new SgTypeString ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeString;  
      SgTypeStringStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnknown ); 
     SgTypeUnknownStorageClass* storageArraySgTypeUnknown = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnknown = new SgTypeUnknownStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnknown) , sizeof ( SgTypeUnknownStorageClass ) * sizeOfActualPool) ;
        SgTypeUnknownStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnknownStorageClass* storageArray = storageArraySgTypeUnknown;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeUnknown ( *storageArray ) ; 
#else
               SgTypeUnknown* tmp = new SgTypeUnknown ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnknown;  
      SgTypeUnknownStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsigned128bitInteger ); 
     SgTypeUnsigned128bitIntegerStorageClass* storageArraySgTypeUnsigned128bitInteger = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsigned128bitInteger = new SgTypeUnsigned128bitIntegerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsigned128bitInteger) , sizeof ( SgTypeUnsigned128bitIntegerStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsigned128bitIntegerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsigned128bitIntegerStorageClass* storageArray = storageArraySgTypeUnsigned128bitInteger;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeUnsigned128bitInteger ( *storageArray ) ; 
#else
               SgTypeUnsigned128bitInteger* tmp = new SgTypeUnsigned128bitInteger ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsigned128bitInteger;  
      SgTypeUnsigned128bitIntegerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedChar ); 
     SgTypeUnsignedCharStorageClass* storageArraySgTypeUnsignedChar = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedChar = new SgTypeUnsignedCharStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedChar) , sizeof ( SgTypeUnsignedCharStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedCharStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedCharStorageClass* storageArray = storageArraySgTypeUnsignedChar;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeUnsignedChar ( *storageArray ) ; 
#else
               SgTypeUnsignedChar* tmp = new SgTypeUnsignedChar ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedChar;  
      SgTypeUnsignedCharStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedInt ); 
     SgTypeUnsignedIntStorageClass* storageArraySgTypeUnsignedInt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedInt = new SgTypeUnsignedIntStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedInt) , sizeof ( SgTypeUnsignedIntStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedIntStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedIntStorageClass* storageArray = storageArraySgTypeUnsignedInt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeUnsignedInt ( *storageArray ) ; 
#else
               SgTypeUnsignedInt* tmp = new SgTypeUnsignedInt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedInt;  
      SgTypeUnsignedIntStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedLong ); 
     SgTypeUnsignedLongStorageClass* storageArraySgTypeUnsignedLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedLong = new SgTypeUnsignedLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedLong) , sizeof ( SgTypeUnsignedLongStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedLongStorageClass* storageArray = storageArraySgTypeUnsignedLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeUnsignedLong ( *storageArray ) ; 
#else
               SgTypeUnsignedLong* tmp = new SgTypeUnsignedLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedLong;  
      SgTypeUnsignedLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedLongLong ); 
     SgTypeUnsignedLongLongStorageClass* storageArraySgTypeUnsignedLongLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedLongLong = new SgTypeUnsignedLongLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedLongLong) , sizeof ( SgTypeUnsignedLongLongStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedLongLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedLongLongStorageClass* storageArray = storageArraySgTypeUnsignedLongLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeUnsignedLongLong ( *storageArray ) ; 
#else
               SgTypeUnsignedLongLong* tmp = new SgTypeUnsignedLongLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedLongLong;  
      SgTypeUnsignedLongLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedShort ); 
     SgTypeUnsignedShortStorageClass* storageArraySgTypeUnsignedShort = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedShort = new SgTypeUnsignedShortStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedShort) , sizeof ( SgTypeUnsignedShortStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedShortStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedShortStorageClass* storageArray = storageArraySgTypeUnsignedShort;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeUnsignedShort ( *storageArray ) ; 
#else
               SgTypeUnsignedShort* tmp = new SgTypeUnsignedShort ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedShort;  
      SgTypeUnsignedShortStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeVoid ); 
     SgTypeVoidStorageClass* storageArraySgTypeVoid = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeVoid = new SgTypeVoidStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeVoid) , sizeof ( SgTypeVoidStorageClass ) * sizeOfActualPool) ;
        SgTypeVoidStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeVoidStorageClass* storageArray = storageArraySgTypeVoid;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeVoid ( *storageArray ) ; 
#else
               SgTypeVoid* tmp = new SgTypeVoid ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeVoid;  
      SgTypeVoidStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeWchar ); 
     SgTypeWcharStorageClass* storageArraySgTypeWchar = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeWchar = new SgTypeWcharStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeWchar) , sizeof ( SgTypeWcharStorageClass ) * sizeOfActualPool) ;
        SgTypeWcharStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeWcharStorageClass* storageArray = storageArraySgTypeWchar;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeWchar ( *storageArray ) ; 
#else
               SgTypeWchar* tmp = new SgTypeWchar ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeWchar;  
      SgTypeWcharStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypedefDeclaration ); 
     SgTypedefDeclarationStorageClass* storageArraySgTypedefDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypedefDeclaration = new SgTypedefDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypedefDeclaration) , sizeof ( SgTypedefDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTypedefDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypedefDeclarationStorageClass* storageArray = storageArraySgTypedefDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypedefDeclaration ( *storageArray ) ; 
#else
               SgTypedefDeclaration* tmp = new SgTypedefDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypedefDeclaration;  
      SgTypedefDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypedefSeq ); 
     SgTypedefSeqStorageClass* storageArraySgTypedefSeq = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypedefSeq = new SgTypedefSeqStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypedefSeq) , sizeof ( SgTypedefSeqStorageClass ) * sizeOfActualPool) ;
        SgTypedefSeqStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypedefSeqStorageClass* storageArray = storageArraySgTypedefSeq;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypedefSeq ( *storageArray ) ; 
#else
               SgTypedefSeq* tmp = new SgTypedefSeq ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypedefSeq;  
      SgTypedefSeqStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypedefSymbol ); 
     SgTypedefSymbolStorageClass* storageArraySgTypedefSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypedefSymbol = new SgTypedefSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypedefSymbol) , sizeof ( SgTypedefSymbolStorageClass ) * sizeOfActualPool) ;
        SgTypedefSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypedefSymbolStorageClass* storageArray = storageArraySgTypedefSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypedefSymbol ( *storageArray ) ; 
#else
               SgTypedefSymbol* tmp = new SgTypedefSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypedefSymbol;  
      SgTypedefSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypedefType ); 
     SgTypedefTypeStorageClass* storageArraySgTypedefType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypedefType = new SgTypedefTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypedefType) , sizeof ( SgTypedefTypeStorageClass ) * sizeOfActualPool) ;
        SgTypedefTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypedefTypeStorageClass* storageArray = storageArraySgTypedefType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypedefType ( *storageArray ) ; 
#else
               SgTypedefType* tmp = new SgTypedefType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypedefType;  
      SgTypedefTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUPC_AccessModifier ); 
     SgUPC_AccessModifierStorageClass* storageArraySgUPC_AccessModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUPC_AccessModifier = new SgUPC_AccessModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUPC_AccessModifier) , sizeof ( SgUPC_AccessModifierStorageClass ) * sizeOfActualPool) ;
          SgUPC_AccessModifierStorageClass* storageArray = storageArraySgUPC_AccessModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUPC_AccessModifier ( *storageArray ) ; 
#else
               SgUPC_AccessModifier* tmp = new SgUPC_AccessModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUPC_AccessModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnaryAddOp ); 
     SgUnaryAddOpStorageClass* storageArraySgUnaryAddOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnaryAddOp = new SgUnaryAddOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnaryAddOp) , sizeof ( SgUnaryAddOpStorageClass ) * sizeOfActualPool) ;
        SgUnaryAddOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnaryAddOpStorageClass* storageArray = storageArraySgUnaryAddOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnaryAddOp ( *storageArray ) ; 
#else
               SgUnaryAddOp* tmp = new SgUnaryAddOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnaryAddOp;  
      SgUnaryAddOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnaryOp ); 
     SgUnaryOpStorageClass* storageArraySgUnaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnaryOp = new SgUnaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnaryOp) , sizeof ( SgUnaryOpStorageClass ) * sizeOfActualPool) ;
        SgUnaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnaryOpStorageClass* storageArray = storageArraySgUnaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnaryOp ( *storageArray ) ; 
#else
               SgUnaryOp* tmp = new SgUnaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnaryOp;  
      SgUnaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUndefDirectiveStatement ); 
     SgUndefDirectiveStatementStorageClass* storageArraySgUndefDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUndefDirectiveStatement = new SgUndefDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUndefDirectiveStatement) , sizeof ( SgUndefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgUndefDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUndefDirectiveStatementStorageClass* storageArray = storageArraySgUndefDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUndefDirectiveStatement ( *storageArray ) ; 
#else
               SgUndefDirectiveStatement* tmp = new SgUndefDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUndefDirectiveStatement;  
      SgUndefDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUndirectedGraphEdge ); 
     SgUndirectedGraphEdgeStorageClass* storageArraySgUndirectedGraphEdge = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUndirectedGraphEdge = new SgUndirectedGraphEdgeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUndirectedGraphEdge) , sizeof ( SgUndirectedGraphEdgeStorageClass ) * sizeOfActualPool) ;
        SgUndirectedGraphEdgeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUndirectedGraphEdgeStorageClass* storageArray = storageArraySgUndirectedGraphEdge;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUndirectedGraphEdge ( *storageArray ) ; 
#else
               SgUndirectedGraphEdge* tmp = new SgUndirectedGraphEdge ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUndirectedGraphEdge;  
      SgUndirectedGraphEdgeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnknownArrayOrFunctionReference ); 
     SgUnknownArrayOrFunctionReferenceStorageClass* storageArraySgUnknownArrayOrFunctionReference = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnknownArrayOrFunctionReference = new SgUnknownArrayOrFunctionReferenceStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnknownArrayOrFunctionReference) , sizeof ( SgUnknownArrayOrFunctionReferenceStorageClass ) * sizeOfActualPool) ;
        SgUnknownArrayOrFunctionReferenceStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnknownArrayOrFunctionReferenceStorageClass* storageArray = storageArraySgUnknownArrayOrFunctionReference;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnknownArrayOrFunctionReference ( *storageArray ) ; 
#else
               SgUnknownArrayOrFunctionReference* tmp = new SgUnknownArrayOrFunctionReference ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnknownArrayOrFunctionReference;  
      SgUnknownArrayOrFunctionReferenceStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnknownFile ); 
     SgUnknownFileStorageClass* storageArraySgUnknownFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnknownFile = new SgUnknownFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnknownFile) , sizeof ( SgUnknownFileStorageClass ) * sizeOfActualPool) ;
        SgUnknownFileStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnknownFileStorageClass* storageArray = storageArraySgUnknownFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnknownFile ( *storageArray ) ; 
#else
               SgUnknownFile* tmp = new SgUnknownFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnknownFile;  
      SgUnknownFileStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnparse_Info ); 
     SgUnparse_InfoStorageClass* storageArraySgUnparse_Info = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnparse_Info = new SgUnparse_InfoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnparse_Info) , sizeof ( SgUnparse_InfoStorageClass ) * sizeOfActualPool) ;
        SgUnparse_InfoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnparse_InfoStorageClass* storageArray = storageArraySgUnparse_Info;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnparse_Info ( *storageArray ) ; 
#else
               SgUnparse_Info* tmp = new SgUnparse_Info ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnparse_Info;  
      SgUnparse_InfoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedCharVal ); 
     SgUnsignedCharValStorageClass* storageArraySgUnsignedCharVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedCharVal = new SgUnsignedCharValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedCharVal) , sizeof ( SgUnsignedCharValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedCharValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedCharValStorageClass* storageArray = storageArraySgUnsignedCharVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnsignedCharVal ( *storageArray ) ; 
#else
               SgUnsignedCharVal* tmp = new SgUnsignedCharVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedCharVal;  
      SgUnsignedCharValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedIntVal ); 
     SgUnsignedIntValStorageClass* storageArraySgUnsignedIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedIntVal = new SgUnsignedIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedIntVal) , sizeof ( SgUnsignedIntValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedIntValStorageClass* storageArray = storageArraySgUnsignedIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnsignedIntVal ( *storageArray ) ; 
#else
               SgUnsignedIntVal* tmp = new SgUnsignedIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedIntVal;  
      SgUnsignedIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedLongLongIntVal ); 
     SgUnsignedLongLongIntValStorageClass* storageArraySgUnsignedLongLongIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedLongLongIntVal = new SgUnsignedLongLongIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedLongLongIntVal) , sizeof ( SgUnsignedLongLongIntValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedLongLongIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedLongLongIntValStorageClass* storageArray = storageArraySgUnsignedLongLongIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnsignedLongLongIntVal ( *storageArray ) ; 
#else
               SgUnsignedLongLongIntVal* tmp = new SgUnsignedLongLongIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedLongLongIntVal;  
      SgUnsignedLongLongIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedLongVal ); 
     SgUnsignedLongValStorageClass* storageArraySgUnsignedLongVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedLongVal = new SgUnsignedLongValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedLongVal) , sizeof ( SgUnsignedLongValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedLongValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedLongValStorageClass* storageArray = storageArraySgUnsignedLongVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnsignedLongVal ( *storageArray ) ; 
#else
               SgUnsignedLongVal* tmp = new SgUnsignedLongVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedLongVal;  
      SgUnsignedLongValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedShortVal ); 
     SgUnsignedShortValStorageClass* storageArraySgUnsignedShortVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedShortVal = new SgUnsignedShortValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedShortVal) , sizeof ( SgUnsignedShortValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedShortValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedShortValStorageClass* storageArray = storageArraySgUnsignedShortVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUnsignedShortVal ( *storageArray ) ; 
#else
               SgUnsignedShortVal* tmp = new SgUnsignedShortVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedShortVal;  
      SgUnsignedShortValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcBarrierStatement ); 
     SgUpcBarrierStatementStorageClass* storageArraySgUpcBarrierStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcBarrierStatement = new SgUpcBarrierStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcBarrierStatement) , sizeof ( SgUpcBarrierStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcBarrierStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcBarrierStatementStorageClass* storageArray = storageArraySgUpcBarrierStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcBarrierStatement ( *storageArray ) ; 
#else
               SgUpcBarrierStatement* tmp = new SgUpcBarrierStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcBarrierStatement;  
      SgUpcBarrierStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcBlocksizeofExpression ); 
     SgUpcBlocksizeofExpressionStorageClass* storageArraySgUpcBlocksizeofExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcBlocksizeofExpression = new SgUpcBlocksizeofExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcBlocksizeofExpression) , sizeof ( SgUpcBlocksizeofExpressionStorageClass ) * sizeOfActualPool) ;
        SgUpcBlocksizeofExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcBlocksizeofExpressionStorageClass* storageArray = storageArraySgUpcBlocksizeofExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcBlocksizeofExpression ( *storageArray ) ; 
#else
               SgUpcBlocksizeofExpression* tmp = new SgUpcBlocksizeofExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcBlocksizeofExpression;  
      SgUpcBlocksizeofExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcElemsizeofExpression ); 
     SgUpcElemsizeofExpressionStorageClass* storageArraySgUpcElemsizeofExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcElemsizeofExpression = new SgUpcElemsizeofExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcElemsizeofExpression) , sizeof ( SgUpcElemsizeofExpressionStorageClass ) * sizeOfActualPool) ;
        SgUpcElemsizeofExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcElemsizeofExpressionStorageClass* storageArray = storageArraySgUpcElemsizeofExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcElemsizeofExpression ( *storageArray ) ; 
#else
               SgUpcElemsizeofExpression* tmp = new SgUpcElemsizeofExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcElemsizeofExpression;  
      SgUpcElemsizeofExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcFenceStatement ); 
     SgUpcFenceStatementStorageClass* storageArraySgUpcFenceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcFenceStatement = new SgUpcFenceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcFenceStatement) , sizeof ( SgUpcFenceStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcFenceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcFenceStatementStorageClass* storageArray = storageArraySgUpcFenceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcFenceStatement ( *storageArray ) ; 
#else
               SgUpcFenceStatement* tmp = new SgUpcFenceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcFenceStatement;  
      SgUpcFenceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcForAllStatement ); 
     SgUpcForAllStatementStorageClass* storageArraySgUpcForAllStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcForAllStatement = new SgUpcForAllStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcForAllStatement) , sizeof ( SgUpcForAllStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcForAllStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcForAllStatementStorageClass* storageArray = storageArraySgUpcForAllStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcForAllStatement ( *storageArray ) ; 
#else
               SgUpcForAllStatement* tmp = new SgUpcForAllStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcForAllStatement;  
      SgUpcForAllStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcLocalsizeofExpression ); 
     SgUpcLocalsizeofExpressionStorageClass* storageArraySgUpcLocalsizeofExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcLocalsizeofExpression = new SgUpcLocalsizeofExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcLocalsizeofExpression) , sizeof ( SgUpcLocalsizeofExpressionStorageClass ) * sizeOfActualPool) ;
        SgUpcLocalsizeofExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcLocalsizeofExpressionStorageClass* storageArray = storageArraySgUpcLocalsizeofExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcLocalsizeofExpression ( *storageArray ) ; 
#else
               SgUpcLocalsizeofExpression* tmp = new SgUpcLocalsizeofExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcLocalsizeofExpression;  
      SgUpcLocalsizeofExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcMythread ); 
     SgUpcMythreadStorageClass* storageArraySgUpcMythread = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcMythread = new SgUpcMythreadStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcMythread) , sizeof ( SgUpcMythreadStorageClass ) * sizeOfActualPool) ;
        SgUpcMythreadStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcMythreadStorageClass* storageArray = storageArraySgUpcMythread;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcMythread ( *storageArray ) ; 
#else
               SgUpcMythread* tmp = new SgUpcMythread ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcMythread;  
      SgUpcMythreadStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcNotifyStatement ); 
     SgUpcNotifyStatementStorageClass* storageArraySgUpcNotifyStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcNotifyStatement = new SgUpcNotifyStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcNotifyStatement) , sizeof ( SgUpcNotifyStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcNotifyStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcNotifyStatementStorageClass* storageArray = storageArraySgUpcNotifyStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcNotifyStatement ( *storageArray ) ; 
#else
               SgUpcNotifyStatement* tmp = new SgUpcNotifyStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcNotifyStatement;  
      SgUpcNotifyStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcThreads ); 
     SgUpcThreadsStorageClass* storageArraySgUpcThreads = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcThreads = new SgUpcThreadsStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcThreads) , sizeof ( SgUpcThreadsStorageClass ) * sizeOfActualPool) ;
        SgUpcThreadsStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcThreadsStorageClass* storageArray = storageArraySgUpcThreads;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcThreads ( *storageArray ) ; 
#else
               SgUpcThreads* tmp = new SgUpcThreads ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcThreads;  
      SgUpcThreadsStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcWaitStatement ); 
     SgUpcWaitStatementStorageClass* storageArraySgUpcWaitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcWaitStatement = new SgUpcWaitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcWaitStatement) , sizeof ( SgUpcWaitStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcWaitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcWaitStatementStorageClass* storageArray = storageArraySgUpcWaitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUpcWaitStatement ( *storageArray ) ; 
#else
               SgUpcWaitStatement* tmp = new SgUpcWaitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcWaitStatement;  
      SgUpcWaitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUseStatement ); 
     SgUseStatementStorageClass* storageArraySgUseStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUseStatement = new SgUseStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUseStatement) , sizeof ( SgUseStatementStorageClass ) * sizeOfActualPool) ;
        SgUseStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUseStatementStorageClass* storageArray = storageArraySgUseStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUseStatement ( *storageArray ) ; 
#else
               SgUseStatement* tmp = new SgUseStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUseStatement;  
      SgUseStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUserDefinedBinaryOp ); 
     SgUserDefinedBinaryOpStorageClass* storageArraySgUserDefinedBinaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUserDefinedBinaryOp = new SgUserDefinedBinaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUserDefinedBinaryOp) , sizeof ( SgUserDefinedBinaryOpStorageClass ) * sizeOfActualPool) ;
        SgUserDefinedBinaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUserDefinedBinaryOpStorageClass* storageArray = storageArraySgUserDefinedBinaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUserDefinedBinaryOp ( *storageArray ) ; 
#else
               SgUserDefinedBinaryOp* tmp = new SgUserDefinedBinaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUserDefinedBinaryOp;  
      SgUserDefinedBinaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUserDefinedUnaryOp ); 
     SgUserDefinedUnaryOpStorageClass* storageArraySgUserDefinedUnaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUserDefinedUnaryOp = new SgUserDefinedUnaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUserDefinedUnaryOp) , sizeof ( SgUserDefinedUnaryOpStorageClass ) * sizeOfActualPool) ;
        SgUserDefinedUnaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUserDefinedUnaryOpStorageClass* storageArray = storageArraySgUserDefinedUnaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUserDefinedUnaryOp ( *storageArray ) ; 
#else
               SgUserDefinedUnaryOp* tmp = new SgUserDefinedUnaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUserDefinedUnaryOp;  
      SgUserDefinedUnaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUsingDeclarationStatement ); 
     SgUsingDeclarationStatementStorageClass* storageArraySgUsingDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUsingDeclarationStatement = new SgUsingDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUsingDeclarationStatement) , sizeof ( SgUsingDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgUsingDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUsingDeclarationStatementStorageClass* storageArray = storageArraySgUsingDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUsingDeclarationStatement ( *storageArray ) ; 
#else
               SgUsingDeclarationStatement* tmp = new SgUsingDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUsingDeclarationStatement;  
      SgUsingDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUsingDirectiveStatement ); 
     SgUsingDirectiveStatementStorageClass* storageArraySgUsingDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUsingDirectiveStatement = new SgUsingDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUsingDirectiveStatement) , sizeof ( SgUsingDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgUsingDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUsingDirectiveStatementStorageClass* storageArray = storageArraySgUsingDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgUsingDirectiveStatement ( *storageArray ) ; 
#else
               SgUsingDirectiveStatement* tmp = new SgUsingDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUsingDirectiveStatement;  
      SgUsingDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgValueExp ); 
     SgValueExpStorageClass* storageArraySgValueExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgValueExp = new SgValueExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgValueExp) , sizeof ( SgValueExpStorageClass ) * sizeOfActualPool) ;
        SgValueExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgValueExpStorageClass* storageArray = storageArraySgValueExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgValueExp ( *storageArray ) ; 
#else
               SgValueExp* tmp = new SgValueExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgValueExp;  
      SgValueExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgCopyOp ); 
     SgVarArgCopyOpStorageClass* storageArraySgVarArgCopyOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgCopyOp = new SgVarArgCopyOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgCopyOp) , sizeof ( SgVarArgCopyOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgCopyOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgCopyOpStorageClass* storageArray = storageArraySgVarArgCopyOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVarArgCopyOp ( *storageArray ) ; 
#else
               SgVarArgCopyOp* tmp = new SgVarArgCopyOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgCopyOp;  
      SgVarArgCopyOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgEndOp ); 
     SgVarArgEndOpStorageClass* storageArraySgVarArgEndOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgEndOp = new SgVarArgEndOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgEndOp) , sizeof ( SgVarArgEndOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgEndOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgEndOpStorageClass* storageArray = storageArraySgVarArgEndOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVarArgEndOp ( *storageArray ) ; 
#else
               SgVarArgEndOp* tmp = new SgVarArgEndOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgEndOp;  
      SgVarArgEndOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgOp ); 
     SgVarArgOpStorageClass* storageArraySgVarArgOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgOp = new SgVarArgOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgOp) , sizeof ( SgVarArgOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgOpStorageClass* storageArray = storageArraySgVarArgOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVarArgOp ( *storageArray ) ; 
#else
               SgVarArgOp* tmp = new SgVarArgOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgOp;  
      SgVarArgOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgStartOneOperandOp ); 
     SgVarArgStartOneOperandOpStorageClass* storageArraySgVarArgStartOneOperandOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgStartOneOperandOp = new SgVarArgStartOneOperandOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgStartOneOperandOp) , sizeof ( SgVarArgStartOneOperandOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgStartOneOperandOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgStartOneOperandOpStorageClass* storageArray = storageArraySgVarArgStartOneOperandOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVarArgStartOneOperandOp ( *storageArray ) ; 
#else
               SgVarArgStartOneOperandOp* tmp = new SgVarArgStartOneOperandOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgStartOneOperandOp;  
      SgVarArgStartOneOperandOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgStartOp ); 
     SgVarArgStartOpStorageClass* storageArraySgVarArgStartOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgStartOp = new SgVarArgStartOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgStartOp) , sizeof ( SgVarArgStartOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgStartOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgStartOpStorageClass* storageArray = storageArraySgVarArgStartOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVarArgStartOp ( *storageArray ) ; 
#else
               SgVarArgStartOp* tmp = new SgVarArgStartOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgStartOp;  
      SgVarArgStartOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarRefExp ); 
     SgVarRefExpStorageClass* storageArraySgVarRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarRefExp = new SgVarRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarRefExp) , sizeof ( SgVarRefExpStorageClass ) * sizeOfActualPool) ;
        SgVarRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarRefExpStorageClass* storageArray = storageArraySgVarRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVarRefExp ( *storageArray ) ; 
#else
               SgVarRefExp* tmp = new SgVarRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarRefExp;  
      SgVarRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariableDeclaration ); 
     SgVariableDeclarationStorageClass* storageArraySgVariableDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariableDeclaration = new SgVariableDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariableDeclaration) , sizeof ( SgVariableDeclarationStorageClass ) * sizeOfActualPool) ;
        SgVariableDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariableDeclarationStorageClass* storageArray = storageArraySgVariableDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVariableDeclaration ( *storageArray ) ; 
#else
               SgVariableDeclaration* tmp = new SgVariableDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariableDeclaration;  
      SgVariableDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariableDefinition ); 
     SgVariableDefinitionStorageClass* storageArraySgVariableDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariableDefinition = new SgVariableDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariableDefinition) , sizeof ( SgVariableDefinitionStorageClass ) * sizeOfActualPool) ;
        SgVariableDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariableDefinitionStorageClass* storageArray = storageArraySgVariableDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVariableDefinition ( *storageArray ) ; 
#else
               SgVariableDefinition* tmp = new SgVariableDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariableDefinition;  
      SgVariableDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariableSymbol ); 
     SgVariableSymbolStorageClass* storageArraySgVariableSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariableSymbol = new SgVariableSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariableSymbol) , sizeof ( SgVariableSymbolStorageClass ) * sizeOfActualPool) ;
        SgVariableSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariableSymbolStorageClass* storageArray = storageArraySgVariableSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVariableSymbol ( *storageArray ) ; 
#else
               SgVariableSymbol* tmp = new SgVariableSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariableSymbol;  
      SgVariableSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariantExpression ); 
     SgVariantExpressionStorageClass* storageArraySgVariantExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariantExpression = new SgVariantExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariantExpression) , sizeof ( SgVariantExpressionStorageClass ) * sizeOfActualPool) ;
        SgVariantExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariantExpressionStorageClass* storageArray = storageArraySgVariantExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVariantExpression ( *storageArray ) ; 
#else
               SgVariantExpression* tmp = new SgVariantExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariantExpression;  
      SgVariantExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariantStatement ); 
     SgVariantStatementStorageClass* storageArraySgVariantStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariantStatement = new SgVariantStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariantStatement) , sizeof ( SgVariantStatementStorageClass ) * sizeOfActualPool) ;
        SgVariantStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariantStatementStorageClass* storageArray = storageArraySgVariantStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVariantStatement ( *storageArray ) ; 
#else
               SgVariantStatement* tmp = new SgVariantStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariantStatement;  
      SgVariantStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVoidVal ); 
     SgVoidValStorageClass* storageArraySgVoidVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVoidVal = new SgVoidValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVoidVal) , sizeof ( SgVoidValStorageClass ) * sizeOfActualPool) ;
        SgVoidValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVoidValStorageClass* storageArray = storageArraySgVoidVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgVoidVal ( *storageArray ) ; 
#else
               SgVoidVal* tmp = new SgVoidVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVoidVal;  
      SgVoidValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWaitStatement ); 
     SgWaitStatementStorageClass* storageArraySgWaitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWaitStatement = new SgWaitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWaitStatement) , sizeof ( SgWaitStatementStorageClass ) * sizeOfActualPool) ;
        SgWaitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWaitStatementStorageClass* storageArray = storageArraySgWaitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgWaitStatement ( *storageArray ) ; 
#else
               SgWaitStatement* tmp = new SgWaitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWaitStatement;  
      SgWaitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWarningDirectiveStatement ); 
     SgWarningDirectiveStatementStorageClass* storageArraySgWarningDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWarningDirectiveStatement = new SgWarningDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWarningDirectiveStatement) , sizeof ( SgWarningDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgWarningDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWarningDirectiveStatementStorageClass* storageArray = storageArraySgWarningDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgWarningDirectiveStatement ( *storageArray ) ; 
#else
               SgWarningDirectiveStatement* tmp = new SgWarningDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWarningDirectiveStatement;  
      SgWarningDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWithStatement ); 
     SgWithStatementStorageClass* storageArraySgWithStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWithStatement = new SgWithStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWithStatement) , sizeof ( SgWithStatementStorageClass ) * sizeOfActualPool) ;
        SgWithStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWithStatementStorageClass* storageArray = storageArraySgWithStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgWithStatement ( *storageArray ) ; 
#else
               SgWithStatement* tmp = new SgWithStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWithStatement;  
      SgWithStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWcharVal ); 
     SgWcharValStorageClass* storageArraySgWcharVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWcharVal = new SgWcharValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWcharVal) , sizeof ( SgWcharValStorageClass ) * sizeOfActualPool) ;
        SgWcharValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWcharValStorageClass* storageArray = storageArraySgWcharVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgWcharVal ( *storageArray ) ; 
#else
               SgWcharVal* tmp = new SgWcharVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWcharVal;  
      SgWcharValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWhereStatement ); 
     SgWhereStatementStorageClass* storageArraySgWhereStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWhereStatement = new SgWhereStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWhereStatement) , sizeof ( SgWhereStatementStorageClass ) * sizeOfActualPool) ;
        SgWhereStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWhereStatementStorageClass* storageArray = storageArraySgWhereStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgWhereStatement ( *storageArray ) ; 
#else
               SgWhereStatement* tmp = new SgWhereStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWhereStatement;  
      SgWhereStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWhileStmt ); 
     SgWhileStmtStorageClass* storageArraySgWhileStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWhileStmt = new SgWhileStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWhileStmt) , sizeof ( SgWhileStmtStorageClass ) * sizeOfActualPool) ;
        SgWhileStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWhileStmtStorageClass* storageArray = storageArraySgWhileStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgWhileStmt ( *storageArray ) ; 
#else
               SgWhileStmt* tmp = new SgWhileStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWhileStmt;  
      SgWhileStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWriteStatement ); 
     SgWriteStatementStorageClass* storageArraySgWriteStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWriteStatement = new SgWriteStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWriteStatement) , sizeof ( SgWriteStatementStorageClass ) * sizeOfActualPool) ;
        SgWriteStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWriteStatementStorageClass* storageArray = storageArraySgWriteStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgWriteStatement ( *storageArray ) ; 
#else
               SgWriteStatement* tmp = new SgWriteStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWriteStatement;  
      SgWriteStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgXorAssignOp ); 
     SgXorAssignOpStorageClass* storageArraySgXorAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgXorAssignOp = new SgXorAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgXorAssignOp) , sizeof ( SgXorAssignOpStorageClass ) * sizeOfActualPool) ;
        SgXorAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgXorAssignOpStorageClass* storageArray = storageArraySgXorAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgXorAssignOp ( *storageArray ) ; 
#else
               SgXorAssignOp* tmp = new SgXorAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgXorAssignOp;  
      SgXorAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgYieldExpression ); 
     SgYieldExpressionStorageClass* storageArraySgYieldExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgYieldExpression = new SgYieldExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgYieldExpression) , sizeof ( SgYieldExpressionStorageClass ) * sizeOfActualPool) ;
        SgYieldExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgYieldExpressionStorageClass* storageArray = storageArraySgYieldExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgYieldExpression ( *storageArray ) ; 
#else
               SgYieldExpression* tmp = new SgYieldExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgYieldExpression;  
      SgYieldExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_Sg_File_Info ); 
     Sg_File_InfoStorageClass* storageArraySg_File_Info = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySg_File_Info = new Sg_File_InfoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySg_File_Info) , sizeof ( Sg_File_InfoStorageClass ) * sizeOfActualPool) ;
        Sg_File_InfoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          Sg_File_InfoStorageClass* storageArray = storageArraySg_File_Info;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new Sg_File_Info ( *storageArray ) ; 
#else
               Sg_File_Info* tmp = new Sg_File_Info ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySg_File_Info;  
      Sg_File_InfoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeCAFTeam ); 
     SgTypeCAFTeamStorageClass* storageArraySgTypeCAFTeam = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeCAFTeam = new SgTypeCAFTeamStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeCAFTeam) , sizeof ( SgTypeCAFTeamStorageClass ) * sizeOfActualPool) ;
        SgTypeCAFTeamStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeCAFTeamStorageClass* storageArray = storageArraySgTypeCAFTeam;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeCAFTeam ( *storageArray ) ; 
#else
               SgTypeCAFTeam* tmp = new SgTypeCAFTeam ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeCAFTeam;  
      SgTypeCAFTeamStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCAFWithTeamStatement ); 
     SgCAFWithTeamStatementStorageClass* storageArraySgCAFWithTeamStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCAFWithTeamStatement = new SgCAFWithTeamStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCAFWithTeamStatement) , sizeof ( SgCAFWithTeamStatementStorageClass ) * sizeOfActualPool) ;
        SgCAFWithTeamStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCAFWithTeamStatementStorageClass* storageArray = storageArraySgCAFWithTeamStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCAFWithTeamStatement ( *storageArray ) ; 
#else
               SgCAFWithTeamStatement* tmp = new SgCAFWithTeamStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCAFWithTeamStatement;  
      SgCAFWithTeamStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCAFCoExpression ); 
     SgCAFCoExpressionStorageClass* storageArraySgCAFCoExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCAFCoExpression = new SgCAFCoExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCAFCoExpression) , sizeof ( SgCAFCoExpressionStorageClass ) * sizeOfActualPool) ;
        SgCAFCoExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCAFCoExpressionStorageClass* storageArray = storageArraySgCAFCoExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCAFCoExpression ( *storageArray ) ; 
#else
               SgCAFCoExpression* tmp = new SgCAFCoExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCAFCoExpression;  
      SgCAFCoExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCallExpression ); 
     SgCallExpressionStorageClass* storageArraySgCallExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCallExpression = new SgCallExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCallExpression) , sizeof ( SgCallExpressionStorageClass ) * sizeOfActualPool) ;
        SgCallExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCallExpressionStorageClass* storageArray = storageArraySgCallExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgCallExpression ( *storageArray ) ; 
#else
               SgCallExpression* tmp = new SgCallExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCallExpression;  
      SgCallExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeCrayPointer ); 
     SgTypeCrayPointerStorageClass* storageArraySgTypeCrayPointer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeCrayPointer = new SgTypeCrayPointerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeCrayPointer) , sizeof ( SgTypeCrayPointerStorageClass ) * sizeOfActualPool) ;
        SgTypeCrayPointerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeCrayPointerStorageClass* storageArray = storageArraySgTypeCrayPointer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeCrayPointer ( *storageArray ) ; 
#else
               SgTypeCrayPointer* tmp = new SgTypeCrayPointer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeCrayPointer;  
      SgTypeCrayPointerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaImportStatement ); 
     SgJavaImportStatementStorageClass* storageArraySgJavaImportStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaImportStatement = new SgJavaImportStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaImportStatement) , sizeof ( SgJavaImportStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaImportStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaImportStatementStorageClass* storageArray = storageArraySgJavaImportStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaImportStatement ( *storageArray ) ; 
#else
               SgJavaImportStatement* tmp = new SgJavaImportStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaImportStatement;  
      SgJavaImportStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaPackageDeclaration ); 
     SgJavaPackageDeclarationStorageClass* storageArraySgJavaPackageDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaPackageDeclaration = new SgJavaPackageDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaPackageDeclaration) , sizeof ( SgJavaPackageDeclarationStorageClass ) * sizeOfActualPool) ;
        SgJavaPackageDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaPackageDeclarationStorageClass* storageArray = storageArraySgJavaPackageDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaPackageDeclaration ( *storageArray ) ; 
#else
               SgJavaPackageDeclaration* tmp = new SgJavaPackageDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaPackageDeclaration;  
      SgJavaPackageDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaPackageStatement ); 
     SgJavaPackageStatementStorageClass* storageArraySgJavaPackageStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaPackageStatement = new SgJavaPackageStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaPackageStatement) , sizeof ( SgJavaPackageStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaPackageStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaPackageStatementStorageClass* storageArray = storageArraySgJavaPackageStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaPackageStatement ( *storageArray ) ; 
#else
               SgJavaPackageStatement* tmp = new SgJavaPackageStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaPackageStatement;  
      SgJavaPackageStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaImportStatementList ); 
     SgJavaImportStatementListStorageClass* storageArraySgJavaImportStatementList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaImportStatementList = new SgJavaImportStatementListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaImportStatementList) , sizeof ( SgJavaImportStatementListStorageClass ) * sizeOfActualPool) ;
        SgJavaImportStatementListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaImportStatementListStorageClass* storageArray = storageArraySgJavaImportStatementList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaImportStatementList ( *storageArray ) ; 
#else
               SgJavaImportStatementList* tmp = new SgJavaImportStatementList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaImportStatementList;  
      SgJavaImportStatementListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaClassDeclarationList ); 
     SgJavaClassDeclarationListStorageClass* storageArraySgJavaClassDeclarationList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaClassDeclarationList = new SgJavaClassDeclarationListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaClassDeclarationList) , sizeof ( SgJavaClassDeclarationListStorageClass ) * sizeOfActualPool) ;
        SgJavaClassDeclarationListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaClassDeclarationListStorageClass* storageArray = storageArraySgJavaClassDeclarationList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaClassDeclarationList ( *storageArray ) ; 
#else
               SgJavaClassDeclarationList* tmp = new SgJavaClassDeclarationList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaClassDeclarationList;  
      SgJavaClassDeclarationListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaMemberValuePair ); 
     SgJavaMemberValuePairStorageClass* storageArraySgJavaMemberValuePair = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaMemberValuePair = new SgJavaMemberValuePairStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaMemberValuePair) , sizeof ( SgJavaMemberValuePairStorageClass ) * sizeOfActualPool) ;
        SgJavaMemberValuePairStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaMemberValuePairStorageClass* storageArray = storageArraySgJavaMemberValuePair;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaMemberValuePair ( *storageArray ) ; 
#else
               SgJavaMemberValuePair* tmp = new SgJavaMemberValuePair ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaMemberValuePair;  
      SgJavaMemberValuePairStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaAnnotation ); 
     SgJavaAnnotationStorageClass* storageArraySgJavaAnnotation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaAnnotation = new SgJavaAnnotationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaAnnotation) , sizeof ( SgJavaAnnotationStorageClass ) * sizeOfActualPool) ;
        SgJavaAnnotationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaAnnotationStorageClass* storageArray = storageArraySgJavaAnnotation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaAnnotation ( *storageArray ) ; 
#else
               SgJavaAnnotation* tmp = new SgJavaAnnotation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaAnnotation;  
      SgJavaAnnotationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaMarkerAnnotation ); 
     SgJavaMarkerAnnotationStorageClass* storageArraySgJavaMarkerAnnotation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaMarkerAnnotation = new SgJavaMarkerAnnotationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaMarkerAnnotation) , sizeof ( SgJavaMarkerAnnotationStorageClass ) * sizeOfActualPool) ;
        SgJavaMarkerAnnotationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaMarkerAnnotationStorageClass* storageArray = storageArraySgJavaMarkerAnnotation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaMarkerAnnotation ( *storageArray ) ; 
#else
               SgJavaMarkerAnnotation* tmp = new SgJavaMarkerAnnotation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaMarkerAnnotation;  
      SgJavaMarkerAnnotationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaSingleMemberAnnotation ); 
     SgJavaSingleMemberAnnotationStorageClass* storageArraySgJavaSingleMemberAnnotation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaSingleMemberAnnotation = new SgJavaSingleMemberAnnotationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaSingleMemberAnnotation) , sizeof ( SgJavaSingleMemberAnnotationStorageClass ) * sizeOfActualPool) ;
        SgJavaSingleMemberAnnotationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaSingleMemberAnnotationStorageClass* storageArray = storageArraySgJavaSingleMemberAnnotation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaSingleMemberAnnotation ( *storageArray ) ; 
#else
               SgJavaSingleMemberAnnotation* tmp = new SgJavaSingleMemberAnnotation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaSingleMemberAnnotation;  
      SgJavaSingleMemberAnnotationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaNormalAnnotation ); 
     SgJavaNormalAnnotationStorageClass* storageArraySgJavaNormalAnnotation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaNormalAnnotation = new SgJavaNormalAnnotationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaNormalAnnotation) , sizeof ( SgJavaNormalAnnotationStorageClass ) * sizeOfActualPool) ;
        SgJavaNormalAnnotationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaNormalAnnotationStorageClass* storageArray = storageArraySgJavaNormalAnnotation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaNormalAnnotation ( *storageArray ) ; 
#else
               SgJavaNormalAnnotation* tmp = new SgJavaNormalAnnotation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaNormalAnnotation;  
      SgJavaNormalAnnotationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaTypeExpression ); 
     SgJavaTypeExpressionStorageClass* storageArraySgJavaTypeExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaTypeExpression = new SgJavaTypeExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaTypeExpression) , sizeof ( SgJavaTypeExpressionStorageClass ) * sizeOfActualPool) ;
        SgJavaTypeExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaTypeExpressionStorageClass* storageArray = storageArraySgJavaTypeExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaTypeExpression ( *storageArray ) ; 
#else
               SgJavaTypeExpression* tmp = new SgJavaTypeExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaTypeExpression;  
      SgJavaTypeExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaQualifiedType ); 
     SgJavaQualifiedTypeStorageClass* storageArraySgJavaQualifiedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaQualifiedType = new SgJavaQualifiedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaQualifiedType) , sizeof ( SgJavaQualifiedTypeStorageClass ) * sizeOfActualPool) ;
        SgJavaQualifiedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaQualifiedTypeStorageClass* storageArray = storageArraySgJavaQualifiedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaQualifiedType ( *storageArray ) ; 
#else
               SgJavaQualifiedType* tmp = new SgJavaQualifiedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaQualifiedType;  
      SgJavaQualifiedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassExp ); 
     SgClassExpStorageClass* storageArraySgClassExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassExp = new SgClassExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassExp) , sizeof ( SgClassExpStorageClass ) * sizeOfActualPool) ;
        SgClassExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassExpStorageClass* storageArray = storageArraySgClassExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgClassExp ( *storageArray ) ; 
#else
               SgClassExp* tmp = new SgClassExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassExp;  
      SgClassExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaUnionType ); 
     SgJavaUnionTypeStorageClass* storageArraySgJavaUnionType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaUnionType = new SgJavaUnionTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaUnionType) , sizeof ( SgJavaUnionTypeStorageClass ) * sizeOfActualPool) ;
        SgJavaUnionTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaUnionTypeStorageClass* storageArray = storageArraySgJavaUnionType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaUnionType ( *storageArray ) ; 
#else
               SgJavaUnionType* tmp = new SgJavaUnionType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaUnionType;  
      SgJavaUnionTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaParameterType ); 
     SgJavaParameterTypeStorageClass* storageArraySgJavaParameterType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaParameterType = new SgJavaParameterTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaParameterType) , sizeof ( SgJavaParameterTypeStorageClass ) * sizeOfActualPool) ;
        SgJavaParameterTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaParameterTypeStorageClass* storageArray = storageArraySgJavaParameterType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJavaParameterType ( *storageArray ) ; 
#else
               SgJavaParameterType* tmp = new SgJavaParameterType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaParameterType;  
      SgJavaParameterTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsyncStmt ); 
     SgAsyncStmtStorageClass* storageArraySgAsyncStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsyncStmt = new SgAsyncStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsyncStmt) , sizeof ( SgAsyncStmtStorageClass ) * sizeOfActualPool) ;
        SgAsyncStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsyncStmtStorageClass* storageArray = storageArraySgAsyncStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsyncStmt ( *storageArray ) ; 
#else
               SgAsyncStmt* tmp = new SgAsyncStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsyncStmt;  
      SgAsyncStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFinishStmt ); 
     SgFinishStmtStorageClass* storageArraySgFinishStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFinishStmt = new SgFinishStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFinishStmt) , sizeof ( SgFinishStmtStorageClass ) * sizeOfActualPool) ;
        SgFinishStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFinishStmtStorageClass* storageArray = storageArraySgFinishStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFinishStmt ( *storageArray ) ; 
#else
               SgFinishStmt* tmp = new SgFinishStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFinishStmt;  
      SgFinishStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAtStmt ); 
     SgAtStmtStorageClass* storageArraySgAtStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAtStmt = new SgAtStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAtStmt) , sizeof ( SgAtStmtStorageClass ) * sizeOfActualPool) ;
        SgAtStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAtStmtStorageClass* storageArray = storageArraySgAtStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAtStmt ( *storageArray ) ; 
#else
               SgAtStmt* tmp = new SgAtStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAtStmt;  
      SgAtStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAtomicStmt ); 
     SgAtomicStmtStorageClass* storageArraySgAtomicStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAtomicStmt = new SgAtomicStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAtomicStmt) , sizeof ( SgAtomicStmtStorageClass ) * sizeOfActualPool) ;
        SgAtomicStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAtomicStmtStorageClass* storageArray = storageArraySgAtomicStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAtomicStmt ( *storageArray ) ; 
#else
               SgAtomicStmt* tmp = new SgAtomicStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAtomicStmt;  
      SgAtomicStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWhenStmt ); 
     SgWhenStmtStorageClass* storageArraySgWhenStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWhenStmt = new SgWhenStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWhenStmt) , sizeof ( SgWhenStmtStorageClass ) * sizeOfActualPool) ;
        SgWhenStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWhenStmtStorageClass* storageArray = storageArraySgWhenStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgWhenStmt ( *storageArray ) ; 
#else
               SgWhenStmt* tmp = new SgWhenStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWhenStmt;  
      SgWhenStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAtExp ); 
     SgAtExpStorageClass* storageArraySgAtExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAtExp = new SgAtExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAtExp) , sizeof ( SgAtExpStorageClass ) * sizeOfActualPool) ;
        SgAtExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAtExpStorageClass* storageArray = storageArraySgAtExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAtExp ( *storageArray ) ; 
#else
               SgAtExp* tmp = new SgAtExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAtExp;  
      SgAtExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFinishExp ); 
     SgFinishExpStorageClass* storageArraySgFinishExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFinishExp = new SgFinishExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFinishExp) , sizeof ( SgFinishExpStorageClass ) * sizeOfActualPool) ;
        SgFinishExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFinishExpStorageClass* storageArray = storageArraySgFinishExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFinishExp ( *storageArray ) ; 
#else
               SgFinishExp* tmp = new SgFinishExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFinishExp;  
      SgFinishExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgHereExp ); 
     SgHereExpStorageClass* storageArraySgHereExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgHereExp = new SgHereExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgHereExp) , sizeof ( SgHereExpStorageClass ) * sizeOfActualPool) ;
        SgHereExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgHereExpStorageClass* storageArray = storageArraySgHereExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgHereExp ( *storageArray ) ; 
#else
               SgHereExp* tmp = new SgHereExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgHereExp;  
      SgHereExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDotDotExp ); 
     SgDotDotExpStorageClass* storageArraySgDotDotExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDotDotExp = new SgDotDotExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDotDotExp) , sizeof ( SgDotDotExpStorageClass ) * sizeOfActualPool) ;
        SgDotDotExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDotDotExpStorageClass* storageArray = storageArraySgDotDotExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgDotDotExp ( *storageArray ) ; 
#else
               SgDotDotExp* tmp = new SgDotDotExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDotDotExp;  
      SgDotDotExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNullInstruction ); 
     SgAsmNullInstructionStorageClass* storageArraySgAsmNullInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNullInstruction = new SgAsmNullInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNullInstruction) , sizeof ( SgAsmNullInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmNullInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNullInstructionStorageClass* storageArray = storageArraySgAsmNullInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmNullInstruction ( *storageArray ) ; 
#else
               SgAsmNullInstruction* tmp = new SgAsmNullInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNullInstruction;  
      SgAsmNullInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaComponentClause ); 
     SgAdaComponentClauseStorageClass* storageArraySgAdaComponentClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaComponentClause = new SgAdaComponentClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaComponentClause) , sizeof ( SgAdaComponentClauseStorageClass ) * sizeOfActualPool) ;
        SgAdaComponentClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaComponentClauseStorageClass* storageArray = storageArraySgAdaComponentClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaComponentClause ( *storageArray ) ; 
#else
               SgAdaComponentClause* tmp = new SgAdaComponentClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaComponentClause;  
      SgAdaComponentClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaIndexConstraint ); 
     SgAdaIndexConstraintStorageClass* storageArraySgAdaIndexConstraint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaIndexConstraint = new SgAdaIndexConstraintStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaIndexConstraint) , sizeof ( SgAdaIndexConstraintStorageClass ) * sizeOfActualPool) ;
        SgAdaIndexConstraintStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaIndexConstraintStorageClass* storageArray = storageArraySgAdaIndexConstraint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaIndexConstraint ( *storageArray ) ; 
#else
               SgAdaIndexConstraint* tmp = new SgAdaIndexConstraint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaIndexConstraint;  
      SgAdaIndexConstraintStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaModularType ); 
     SgAdaModularTypeStorageClass* storageArraySgAdaModularType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaModularType = new SgAdaModularTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaModularType) , sizeof ( SgAdaModularTypeStorageClass ) * sizeOfActualPool) ;
        SgAdaModularTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaModularTypeStorageClass* storageArray = storageArraySgAdaModularType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaModularType ( *storageArray ) ; 
#else
               SgAdaModularType* tmp = new SgAdaModularType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaModularType;  
      SgAdaModularTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaRepresentationClause ); 
     SgAdaRepresentationClauseStorageClass* storageArraySgAdaRepresentationClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaRepresentationClause = new SgAdaRepresentationClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaRepresentationClause) , sizeof ( SgAdaRepresentationClauseStorageClass ) * sizeOfActualPool) ;
        SgAdaRepresentationClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaRepresentationClauseStorageClass* storageArray = storageArraySgAdaRepresentationClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaRepresentationClause ( *storageArray ) ; 
#else
               SgAdaRepresentationClause* tmp = new SgAdaRepresentationClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaRepresentationClause;  
      SgAdaRepresentationClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaFunctionRenamingDecl ); 
     SgAdaFunctionRenamingDeclStorageClass* storageArraySgAdaFunctionRenamingDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaFunctionRenamingDecl = new SgAdaFunctionRenamingDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaFunctionRenamingDecl) , sizeof ( SgAdaFunctionRenamingDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaFunctionRenamingDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaFunctionRenamingDeclStorageClass* storageArray = storageArraySgAdaFunctionRenamingDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaFunctionRenamingDecl ( *storageArray ) ; 
#else
               SgAdaFunctionRenamingDecl* tmp = new SgAdaFunctionRenamingDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaFunctionRenamingDecl;  
      SgAdaFunctionRenamingDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaSelectStmt ); 
     SgAdaSelectStmtStorageClass* storageArraySgAdaSelectStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaSelectStmt = new SgAdaSelectStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaSelectStmt) , sizeof ( SgAdaSelectStmtStorageClass ) * sizeOfActualPool) ;
        SgAdaSelectStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaSelectStmtStorageClass* storageArray = storageArraySgAdaSelectStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaSelectStmt ( *storageArray ) ; 
#else
               SgAdaSelectStmt* tmp = new SgAdaSelectStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaSelectStmt;  
      SgAdaSelectStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaSelectAlternativeStmt ); 
     SgAdaSelectAlternativeStmtStorageClass* storageArraySgAdaSelectAlternativeStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaSelectAlternativeStmt = new SgAdaSelectAlternativeStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaSelectAlternativeStmt) , sizeof ( SgAdaSelectAlternativeStmtStorageClass ) * sizeOfActualPool) ;
        SgAdaSelectAlternativeStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaSelectAlternativeStmtStorageClass* storageArray = storageArraySgAdaSelectAlternativeStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaSelectAlternativeStmt ( *storageArray ) ; 
#else
               SgAdaSelectAlternativeStmt* tmp = new SgAdaSelectAlternativeStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaSelectAlternativeStmt;  
      SgAdaSelectAlternativeStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaTerminateStmt ); 
     SgAdaTerminateStmtStorageClass* storageArraySgAdaTerminateStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaTerminateStmt = new SgAdaTerminateStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaTerminateStmt) , sizeof ( SgAdaTerminateStmtStorageClass ) * sizeOfActualPool) ;
        SgAdaTerminateStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaTerminateStmtStorageClass* storageArray = storageArraySgAdaTerminateStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaTerminateStmt ( *storageArray ) ; 
#else
               SgAdaTerminateStmt* tmp = new SgAdaTerminateStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaTerminateStmt;  
      SgAdaTerminateStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmAarch32Coprocessor ); 
     SgAsmAarch32CoprocessorStorageClass* storageArraySgAsmAarch32Coprocessor = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmAarch32Coprocessor = new SgAsmAarch32CoprocessorStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmAarch32Coprocessor) , sizeof ( SgAsmAarch32CoprocessorStorageClass ) * sizeOfActualPool) ;
        SgAsmAarch32CoprocessorStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmAarch32CoprocessorStorageClass* storageArray = storageArraySgAsmAarch32Coprocessor;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmAarch32Coprocessor ( *storageArray ) ; 
#else
               SgAsmAarch32Coprocessor* tmp = new SgAsmAarch32Coprocessor ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmAarch32Coprocessor;  
      SgAsmAarch32CoprocessorStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaAttributeClause ); 
     SgAdaAttributeClauseStorageClass* storageArraySgAdaAttributeClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaAttributeClause = new SgAdaAttributeClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaAttributeClause) , sizeof ( SgAdaAttributeClauseStorageClass ) * sizeOfActualPool) ;
        SgAdaAttributeClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaAttributeClauseStorageClass* storageArray = storageArraySgAdaAttributeClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaAttributeClause ( *storageArray ) ; 
#else
               SgAdaAttributeClause* tmp = new SgAdaAttributeClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaAttributeClause;  
      SgAdaAttributeClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryConcat ); 
     SgAsmBinaryConcatStorageClass* storageArraySgAsmBinaryConcat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryConcat = new SgAsmBinaryConcatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryConcat) , sizeof ( SgAsmBinaryConcatStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryConcatStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryConcatStorageClass* storageArray = storageArraySgAsmBinaryConcat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryConcat ( *storageArray ) ; 
#else
               SgAsmBinaryConcat* tmp = new SgAsmBinaryConcat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryConcat;  
      SgAsmBinaryConcatStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmByteOrder ); 
     SgAsmByteOrderStorageClass* storageArraySgAsmByteOrder = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmByteOrder = new SgAsmByteOrderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmByteOrder) , sizeof ( SgAsmByteOrderStorageClass ) * sizeOfActualPool) ;
        SgAsmByteOrderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmByteOrderStorageClass* storageArray = storageArraySgAsmByteOrder;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmByteOrder ( *storageArray ) ; 
#else
               SgAsmByteOrder* tmp = new SgAsmByteOrder ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmByteOrder;  
      SgAsmByteOrderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaDerivedType ); 
     SgAdaDerivedTypeStorageClass* storageArraySgAdaDerivedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaDerivedType = new SgAdaDerivedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaDerivedType) , sizeof ( SgAdaDerivedTypeStorageClass ) * sizeOfActualPool) ;
        SgAdaDerivedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaDerivedTypeStorageClass* storageArray = storageArraySgAdaDerivedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaDerivedType ( *storageArray ) ; 
#else
               SgAdaDerivedType* tmp = new SgAdaDerivedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaDerivedType;  
      SgAdaDerivedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaAttributeExp ); 
     SgAdaAttributeExpStorageClass* storageArraySgAdaAttributeExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaAttributeExp = new SgAdaAttributeExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaAttributeExp) , sizeof ( SgAdaAttributeExpStorageClass ) * sizeOfActualPool) ;
        SgAdaAttributeExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaAttributeExpStorageClass* storageArray = storageArraySgAdaAttributeExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaAttributeExp ( *storageArray ) ; 
#else
               SgAdaAttributeExp* tmp = new SgAdaAttributeExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaAttributeExp;  
      SgAdaAttributeExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaEnumRepresentationClause ); 
     SgAdaEnumRepresentationClauseStorageClass* storageArraySgAdaEnumRepresentationClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaEnumRepresentationClause = new SgAdaEnumRepresentationClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaEnumRepresentationClause) , sizeof ( SgAdaEnumRepresentationClauseStorageClass ) * sizeOfActualPool) ;
        SgAdaEnumRepresentationClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaEnumRepresentationClauseStorageClass* storageArray = storageArraySgAdaEnumRepresentationClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaEnumRepresentationClause ( *storageArray ) ; 
#else
               SgAdaEnumRepresentationClause* tmp = new SgAdaEnumRepresentationClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaEnumRepresentationClause;  
      SgAdaEnumRepresentationClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryPreupdate ); 
     SgAsmBinaryPreupdateStorageClass* storageArraySgAsmBinaryPreupdate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryPreupdate = new SgAsmBinaryPreupdateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryPreupdate) , sizeof ( SgAsmBinaryPreupdateStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryPreupdateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryPreupdateStorageClass* storageArray = storageArraySgAsmBinaryPreupdate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryPreupdate ( *storageArray ) ; 
#else
               SgAsmBinaryPreupdate* tmp = new SgAsmBinaryPreupdate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryPreupdate;  
      SgAsmBinaryPreupdateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryPostupdate ); 
     SgAsmBinaryPostupdateStorageClass* storageArraySgAsmBinaryPostupdate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryPostupdate = new SgAsmBinaryPostupdateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryPostupdate) , sizeof ( SgAsmBinaryPostupdateStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryPostupdateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryPostupdateStorageClass* storageArray = storageArraySgAsmBinaryPostupdate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmBinaryPostupdate ( *storageArray ) ; 
#else
               SgAsmBinaryPostupdate* tmp = new SgAsmBinaryPostupdate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryPostupdate;  
      SgAsmBinaryPostupdateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaOthersExp ); 
     SgAdaOthersExpStorageClass* storageArraySgAdaOthersExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaOthersExp = new SgAdaOthersExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaOthersExp) , sizeof ( SgAdaOthersExpStorageClass ) * sizeOfActualPool) ;
        SgAdaOthersExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaOthersExpStorageClass* storageArray = storageArraySgAdaOthersExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaOthersExp ( *storageArray ) ; 
#else
               SgAdaOthersExp* tmp = new SgAdaOthersExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaOthersExp;  
      SgAdaOthersExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaRenamingSymbol ); 
     SgAdaRenamingSymbolStorageClass* storageArraySgAdaRenamingSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaRenamingSymbol = new SgAdaRenamingSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaRenamingSymbol) , sizeof ( SgAdaRenamingSymbolStorageClass ) * sizeOfActualPool) ;
        SgAdaRenamingSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaRenamingSymbolStorageClass* storageArray = storageArraySgAdaRenamingSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaRenamingSymbol ( *storageArray ) ; 
#else
               SgAdaRenamingSymbol* tmp = new SgAdaRenamingSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaRenamingSymbol;  
      SgAdaRenamingSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaRenamingRefExp ); 
     SgAdaRenamingRefExpStorageClass* storageArraySgAdaRenamingRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaRenamingRefExp = new SgAdaRenamingRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaRenamingRefExp) , sizeof ( SgAdaRenamingRefExpStorageClass ) * sizeOfActualPool) ;
        SgAdaRenamingRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaRenamingRefExpStorageClass* storageArray = storageArraySgAdaRenamingRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaRenamingRefExp ( *storageArray ) ; 
#else
               SgAdaRenamingRefExp* tmp = new SgAdaRenamingRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaRenamingRefExp;  
      SgAdaRenamingRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaGenericDecl ); 
     SgAdaGenericDeclStorageClass* storageArraySgAdaGenericDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaGenericDecl = new SgAdaGenericDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaGenericDecl) , sizeof ( SgAdaGenericDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaGenericDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaGenericDeclStorageClass* storageArray = storageArraySgAdaGenericDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaGenericDecl ( *storageArray ) ; 
#else
               SgAdaGenericDecl* tmp = new SgAdaGenericDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaGenericDecl;  
      SgAdaGenericDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaGenericDefn ); 
     SgAdaGenericDefnStorageClass* storageArraySgAdaGenericDefn = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaGenericDefn = new SgAdaGenericDefnStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaGenericDefn) , sizeof ( SgAdaGenericDefnStorageClass ) * sizeOfActualPool) ;
        SgAdaGenericDefnStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaGenericDefnStorageClass* storageArray = storageArraySgAdaGenericDefn;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaGenericDefn ( *storageArray ) ; 
#else
               SgAdaGenericDefn* tmp = new SgAdaGenericDefn ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaGenericDefn;  
      SgAdaGenericDefnStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaFormalType ); 
     SgAdaFormalTypeStorageClass* storageArraySgAdaFormalType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaFormalType = new SgAdaFormalTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaFormalType) , sizeof ( SgAdaFormalTypeStorageClass ) * sizeOfActualPool) ;
        SgAdaFormalTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaFormalTypeStorageClass* storageArray = storageArraySgAdaFormalType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaFormalType ( *storageArray ) ; 
#else
               SgAdaFormalType* tmp = new SgAdaFormalType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaFormalType;  
      SgAdaFormalTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaGenericSymbol ); 
     SgAdaGenericSymbolStorageClass* storageArraySgAdaGenericSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaGenericSymbol = new SgAdaGenericSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaGenericSymbol) , sizeof ( SgAdaGenericSymbolStorageClass ) * sizeOfActualPool) ;
        SgAdaGenericSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaGenericSymbolStorageClass* storageArray = storageArraySgAdaGenericSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaGenericSymbol ( *storageArray ) ; 
#else
               SgAdaGenericSymbol* tmp = new SgAdaGenericSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaGenericSymbol;  
      SgAdaGenericSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaFormalTypeDecl ); 
     SgAdaFormalTypeDeclStorageClass* storageArraySgAdaFormalTypeDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaFormalTypeDecl = new SgAdaFormalTypeDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaFormalTypeDecl) , sizeof ( SgAdaFormalTypeDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaFormalTypeDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaFormalTypeDeclStorageClass* storageArray = storageArraySgAdaFormalTypeDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaFormalTypeDecl ( *storageArray ) ; 
#else
               SgAdaFormalTypeDecl* tmp = new SgAdaFormalTypeDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaFormalTypeDecl;  
      SgAdaFormalTypeDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaUnitRefExp ); 
     SgAdaUnitRefExpStorageClass* storageArraySgAdaUnitRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaUnitRefExp = new SgAdaUnitRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaUnitRefExp) , sizeof ( SgAdaUnitRefExpStorageClass ) * sizeOfActualPool) ;
        SgAdaUnitRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaUnitRefExpStorageClass* storageArray = storageArraySgAdaUnitRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaUnitRefExp ( *storageArray ) ; 
#else
               SgAdaUnitRefExp* tmp = new SgAdaUnitRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaUnitRefExp;  
      SgAdaUnitRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaDiscriminatedTypeDecl ); 
     SgAdaDiscriminatedTypeDeclStorageClass* storageArraySgAdaDiscriminatedTypeDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaDiscriminatedTypeDecl = new SgAdaDiscriminatedTypeDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaDiscriminatedTypeDecl) , sizeof ( SgAdaDiscriminatedTypeDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaDiscriminatedTypeDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaDiscriminatedTypeDeclStorageClass* storageArray = storageArraySgAdaDiscriminatedTypeDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaDiscriminatedTypeDecl ( *storageArray ) ; 
#else
               SgAdaDiscriminatedTypeDecl* tmp = new SgAdaDiscriminatedTypeDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaDiscriminatedTypeDecl;  
      SgAdaDiscriminatedTypeDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaDiscriminatedType ); 
     SgAdaDiscriminatedTypeStorageClass* storageArraySgAdaDiscriminatedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaDiscriminatedType = new SgAdaDiscriminatedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaDiscriminatedType) , sizeof ( SgAdaDiscriminatedTypeStorageClass ) * sizeOfActualPool) ;
        SgAdaDiscriminatedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaDiscriminatedTypeStorageClass* storageArray = storageArraySgAdaDiscriminatedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaDiscriminatedType ( *storageArray ) ; 
#else
               SgAdaDiscriminatedType* tmp = new SgAdaDiscriminatedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaDiscriminatedType;  
      SgAdaDiscriminatedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaDiscriminantConstraint ); 
     SgAdaDiscriminantConstraintStorageClass* storageArraySgAdaDiscriminantConstraint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaDiscriminantConstraint = new SgAdaDiscriminantConstraintStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaDiscriminantConstraint) , sizeof ( SgAdaDiscriminantConstraintStorageClass ) * sizeOfActualPool) ;
        SgAdaDiscriminantConstraintStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaDiscriminantConstraintStorageClass* storageArray = storageArraySgAdaDiscriminantConstraint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaDiscriminantConstraint ( *storageArray ) ; 
#else
               SgAdaDiscriminantConstraint* tmp = new SgAdaDiscriminantConstraint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaDiscriminantConstraint;  
      SgAdaDiscriminantConstraintStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaGenericInstanceDecl ); 
     SgAdaGenericInstanceDeclStorageClass* storageArraySgAdaGenericInstanceDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaGenericInstanceDecl = new SgAdaGenericInstanceDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaGenericInstanceDecl) , sizeof ( SgAdaGenericInstanceDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaGenericInstanceDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaGenericInstanceDeclStorageClass* storageArray = storageArraySgAdaGenericInstanceDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaGenericInstanceDecl ( *storageArray ) ; 
#else
               SgAdaGenericInstanceDecl* tmp = new SgAdaGenericInstanceDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaGenericInstanceDecl;  
      SgAdaGenericInstanceDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaUnscopedBlock ); 
     SgAdaUnscopedBlockStorageClass* storageArraySgAdaUnscopedBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaUnscopedBlock = new SgAdaUnscopedBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaUnscopedBlock) , sizeof ( SgAdaUnscopedBlockStorageClass ) * sizeOfActualPool) ;
        SgAdaUnscopedBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaUnscopedBlockStorageClass* storageArray = storageArraySgAdaUnscopedBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaUnscopedBlock ( *storageArray ) ; 
#else
               SgAdaUnscopedBlock* tmp = new SgAdaUnscopedBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaUnscopedBlock;  
      SgAdaUnscopedBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaInheritedFunctionSymbol ); 
     SgAdaInheritedFunctionSymbolStorageClass* storageArraySgAdaInheritedFunctionSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaInheritedFunctionSymbol = new SgAdaInheritedFunctionSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaInheritedFunctionSymbol) , sizeof ( SgAdaInheritedFunctionSymbolStorageClass ) * sizeOfActualPool) ;
        SgAdaInheritedFunctionSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaInheritedFunctionSymbolStorageClass* storageArray = storageArraySgAdaInheritedFunctionSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaInheritedFunctionSymbol ( *storageArray ) ; 
#else
               SgAdaInheritedFunctionSymbol* tmp = new SgAdaInheritedFunctionSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaInheritedFunctionSymbol;  
      SgAdaInheritedFunctionSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaProtectedBody ); 
     SgAdaProtectedBodyStorageClass* storageArraySgAdaProtectedBody = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaProtectedBody = new SgAdaProtectedBodyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaProtectedBody) , sizeof ( SgAdaProtectedBodyStorageClass ) * sizeOfActualPool) ;
        SgAdaProtectedBodyStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaProtectedBodyStorageClass* storageArray = storageArraySgAdaProtectedBody;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaProtectedBody ( *storageArray ) ; 
#else
               SgAdaProtectedBody* tmp = new SgAdaProtectedBody ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaProtectedBody;  
      SgAdaProtectedBodyStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaProtectedBodyDecl ); 
     SgAdaProtectedBodyDeclStorageClass* storageArraySgAdaProtectedBodyDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaProtectedBodyDecl = new SgAdaProtectedBodyDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaProtectedBodyDecl) , sizeof ( SgAdaProtectedBodyDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaProtectedBodyDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaProtectedBodyDeclStorageClass* storageArray = storageArraySgAdaProtectedBodyDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaProtectedBodyDecl ( *storageArray ) ; 
#else
               SgAdaProtectedBodyDecl* tmp = new SgAdaProtectedBodyDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaProtectedBodyDecl;  
      SgAdaProtectedBodyDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaProtectedSpec ); 
     SgAdaProtectedSpecStorageClass* storageArraySgAdaProtectedSpec = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaProtectedSpec = new SgAdaProtectedSpecStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaProtectedSpec) , sizeof ( SgAdaProtectedSpecStorageClass ) * sizeOfActualPool) ;
        SgAdaProtectedSpecStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaProtectedSpecStorageClass* storageArray = storageArraySgAdaProtectedSpec;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaProtectedSpec ( *storageArray ) ; 
#else
               SgAdaProtectedSpec* tmp = new SgAdaProtectedSpec ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaProtectedSpec;  
      SgAdaProtectedSpecStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaProtectedSpecDecl ); 
     SgAdaProtectedSpecDeclStorageClass* storageArraySgAdaProtectedSpecDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaProtectedSpecDecl = new SgAdaProtectedSpecDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaProtectedSpecDecl) , sizeof ( SgAdaProtectedSpecDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaProtectedSpecDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaProtectedSpecDeclStorageClass* storageArray = storageArraySgAdaProtectedSpecDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaProtectedSpecDecl ( *storageArray ) ; 
#else
               SgAdaProtectedSpecDecl* tmp = new SgAdaProtectedSpecDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaProtectedSpecDecl;  
      SgAdaProtectedSpecDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaProtectedSymbol ); 
     SgAdaProtectedSymbolStorageClass* storageArraySgAdaProtectedSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaProtectedSymbol = new SgAdaProtectedSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaProtectedSymbol) , sizeof ( SgAdaProtectedSymbolStorageClass ) * sizeOfActualPool) ;
        SgAdaProtectedSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaProtectedSymbolStorageClass* storageArray = storageArraySgAdaProtectedSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaProtectedSymbol ( *storageArray ) ; 
#else
               SgAdaProtectedSymbol* tmp = new SgAdaProtectedSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaProtectedSymbol;  
      SgAdaProtectedSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaProtectedRefExp ); 
     SgAdaProtectedRefExpStorageClass* storageArraySgAdaProtectedRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaProtectedRefExp = new SgAdaProtectedRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaProtectedRefExp) , sizeof ( SgAdaProtectedRefExpStorageClass ) * sizeOfActualPool) ;
        SgAdaProtectedRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaProtectedRefExpStorageClass* storageArray = storageArraySgAdaProtectedRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaProtectedRefExp ( *storageArray ) ; 
#else
               SgAdaProtectedRefExp* tmp = new SgAdaProtectedRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaProtectedRefExp;  
      SgAdaProtectedRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaProtectedType ); 
     SgAdaProtectedTypeStorageClass* storageArraySgAdaProtectedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaProtectedType = new SgAdaProtectedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaProtectedType) , sizeof ( SgAdaProtectedTypeStorageClass ) * sizeOfActualPool) ;
        SgAdaProtectedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaProtectedTypeStorageClass* storageArray = storageArraySgAdaProtectedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaProtectedType ( *storageArray ) ; 
#else
               SgAdaProtectedType* tmp = new SgAdaProtectedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaProtectedType;  
      SgAdaProtectedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaProtectedTypeDecl ); 
     SgAdaProtectedTypeDeclStorageClass* storageArraySgAdaProtectedTypeDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaProtectedTypeDecl = new SgAdaProtectedTypeDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaProtectedTypeDecl) , sizeof ( SgAdaProtectedTypeDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaProtectedTypeDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaProtectedTypeDeclStorageClass* storageArray = storageArraySgAdaProtectedTypeDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaProtectedTypeDecl ( *storageArray ) ; 
#else
               SgAdaProtectedTypeDecl* tmp = new SgAdaProtectedTypeDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaProtectedTypeDecl;  
      SgAdaProtectedTypeDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaDigitsConstraint ); 
     SgAdaDigitsConstraintStorageClass* storageArraySgAdaDigitsConstraint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaDigitsConstraint = new SgAdaDigitsConstraintStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaDigitsConstraint) , sizeof ( SgAdaDigitsConstraintStorageClass ) * sizeOfActualPool) ;
        SgAdaDigitsConstraintStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaDigitsConstraintStorageClass* storageArray = storageArraySgAdaDigitsConstraint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaDigitsConstraint ( *storageArray ) ; 
#else
               SgAdaDigitsConstraint* tmp = new SgAdaDigitsConstraint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaDigitsConstraint;  
      SgAdaDigitsConstraintStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaAncestorInitializer ); 
     SgAdaAncestorInitializerStorageClass* storageArraySgAdaAncestorInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaAncestorInitializer = new SgAdaAncestorInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaAncestorInitializer) , sizeof ( SgAdaAncestorInitializerStorageClass ) * sizeOfActualPool) ;
        SgAdaAncestorInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaAncestorInitializerStorageClass* storageArray = storageArraySgAdaAncestorInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaAncestorInitializer ( *storageArray ) ; 
#else
               SgAdaAncestorInitializer* tmp = new SgAdaAncestorInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaAncestorInitializer;  
      SgAdaAncestorInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaDeltaConstraint ); 
     SgAdaDeltaConstraintStorageClass* storageArraySgAdaDeltaConstraint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaDeltaConstraint = new SgAdaDeltaConstraintStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaDeltaConstraint) , sizeof ( SgAdaDeltaConstraintStorageClass ) * sizeOfActualPool) ;
        SgAdaDeltaConstraintStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaDeltaConstraintStorageClass* storageArray = storageArraySgAdaDeltaConstraint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaDeltaConstraint ( *storageArray ) ; 
#else
               SgAdaDeltaConstraint* tmp = new SgAdaDeltaConstraint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaDeltaConstraint;  
      SgAdaDeltaConstraintStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaSubroutineType ); 
     SgAdaSubroutineTypeStorageClass* storageArraySgAdaSubroutineType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaSubroutineType = new SgAdaSubroutineTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaSubroutineType) , sizeof ( SgAdaSubroutineTypeStorageClass ) * sizeOfActualPool) ;
        SgAdaSubroutineTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaSubroutineTypeStorageClass* storageArray = storageArraySgAdaSubroutineType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaSubroutineType ( *storageArray ) ; 
#else
               SgAdaSubroutineType* tmp = new SgAdaSubroutineType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaSubroutineType;  
      SgAdaSubroutineTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaGenericInstanceSymbol ); 
     SgAdaGenericInstanceSymbolStorageClass* storageArraySgAdaGenericInstanceSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaGenericInstanceSymbol = new SgAdaGenericInstanceSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaGenericInstanceSymbol) , sizeof ( SgAdaGenericInstanceSymbolStorageClass ) * sizeOfActualPool) ;
        SgAdaGenericInstanceSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaGenericInstanceSymbolStorageClass* storageArray = storageArraySgAdaGenericInstanceSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaGenericInstanceSymbol ( *storageArray ) ; 
#else
               SgAdaGenericInstanceSymbol* tmp = new SgAdaGenericInstanceSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaGenericInstanceSymbol;  
      SgAdaGenericInstanceSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaFormalPackageDecl ); 
     SgAdaFormalPackageDeclStorageClass* storageArraySgAdaFormalPackageDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaFormalPackageDecl = new SgAdaFormalPackageDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaFormalPackageDecl) , sizeof ( SgAdaFormalPackageDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaFormalPackageDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaFormalPackageDeclStorageClass* storageArray = storageArraySgAdaFormalPackageDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaFormalPackageDecl ( *storageArray ) ; 
#else
               SgAdaFormalPackageDecl* tmp = new SgAdaFormalPackageDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaFormalPackageDecl;  
      SgAdaFormalPackageDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaFormalPackageSymbol ); 
     SgAdaFormalPackageSymbolStorageClass* storageArraySgAdaFormalPackageSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaFormalPackageSymbol = new SgAdaFormalPackageSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaFormalPackageSymbol) , sizeof ( SgAdaFormalPackageSymbolStorageClass ) * sizeOfActualPool) ;
        SgAdaFormalPackageSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaFormalPackageSymbolStorageClass* storageArray = storageArraySgAdaFormalPackageSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaFormalPackageSymbol ( *storageArray ) ; 
#else
               SgAdaFormalPackageSymbol* tmp = new SgAdaFormalPackageSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaFormalPackageSymbol;  
      SgAdaFormalPackageSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmAttributeTable ); 
     SgAsmJvmAttributeTableStorageClass* storageArraySgAsmJvmAttributeTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmAttributeTable = new SgAsmJvmAttributeTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmAttributeTable) , sizeof ( SgAsmJvmAttributeTableStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmAttributeTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmAttributeTableStorageClass* storageArray = storageArraySgAsmJvmAttributeTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmAttributeTable ( *storageArray ) ; 
#else
               SgAsmJvmAttributeTable* tmp = new SgAsmJvmAttributeTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmAttributeTable;  
      SgAsmJvmAttributeTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmMethodTable ); 
     SgAsmJvmMethodTableStorageClass* storageArraySgAsmJvmMethodTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmMethodTable = new SgAsmJvmMethodTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmMethodTable) , sizeof ( SgAsmJvmMethodTableStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmMethodTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmMethodTableStorageClass* storageArray = storageArraySgAsmJvmMethodTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmMethodTable ( *storageArray ) ; 
#else
               SgAsmJvmMethodTable* tmp = new SgAsmJvmMethodTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmMethodTable;  
      SgAsmJvmMethodTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmField ); 
     SgAsmJvmFieldStorageClass* storageArraySgAsmJvmField = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmField = new SgAsmJvmFieldStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmField) , sizeof ( SgAsmJvmFieldStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmFieldStorageClass* storageArray = storageArraySgAsmJvmField;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmField ( *storageArray ) ; 
#else
               SgAsmJvmField* tmp = new SgAsmJvmField ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmField;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmFieldTable ); 
     SgAsmJvmFieldTableStorageClass* storageArraySgAsmJvmFieldTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmFieldTable = new SgAsmJvmFieldTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmFieldTable) , sizeof ( SgAsmJvmFieldTableStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmFieldTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmFieldTableStorageClass* storageArray = storageArraySgAsmJvmFieldTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmFieldTable ( *storageArray ) ; 
#else
               SgAsmJvmFieldTable* tmp = new SgAsmJvmFieldTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmFieldTable;  
      SgAsmJvmFieldTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmExceptionHandler ); 
     SgAsmJvmExceptionHandlerStorageClass* storageArraySgAsmJvmExceptionHandler = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmExceptionHandler = new SgAsmJvmExceptionHandlerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmExceptionHandler) , sizeof ( SgAsmJvmExceptionHandlerStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmExceptionHandlerStorageClass* storageArray = storageArraySgAsmJvmExceptionHandler;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmExceptionHandler ( *storageArray ) ; 
#else
               SgAsmJvmExceptionHandler* tmp = new SgAsmJvmExceptionHandler ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmExceptionHandler;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmExceptionTable ); 
     SgAsmJvmExceptionTableStorageClass* storageArraySgAsmJvmExceptionTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmExceptionTable = new SgAsmJvmExceptionTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmExceptionTable) , sizeof ( SgAsmJvmExceptionTableStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmExceptionTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmExceptionTableStorageClass* storageArray = storageArraySgAsmJvmExceptionTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmExceptionTable ( *storageArray ) ; 
#else
               SgAsmJvmExceptionTable* tmp = new SgAsmJvmExceptionTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmExceptionTable;  
      SgAsmJvmExceptionTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmClass ); 
     SgAsmJvmClassStorageClass* storageArraySgAsmJvmClass = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmClass = new SgAsmJvmClassStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmClass) , sizeof ( SgAsmJvmClassStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmClassStorageClass* storageArray = storageArraySgAsmJvmClass;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmClass ( *storageArray ) ; 
#else
               SgAsmJvmClass* tmp = new SgAsmJvmClass ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmClass;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmLineNumberEntry ); 
     SgAsmJvmLineNumberEntryStorageClass* storageArraySgAsmJvmLineNumberEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmLineNumberEntry = new SgAsmJvmLineNumberEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmLineNumberEntry) , sizeof ( SgAsmJvmLineNumberEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmLineNumberEntryStorageClass* storageArray = storageArraySgAsmJvmLineNumberEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmLineNumberEntry ( *storageArray ) ; 
#else
               SgAsmJvmLineNumberEntry* tmp = new SgAsmJvmLineNumberEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmLineNumberEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmLineNumberTable ); 
     SgAsmJvmLineNumberTableStorageClass* storageArraySgAsmJvmLineNumberTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmLineNumberTable = new SgAsmJvmLineNumberTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmLineNumberTable) , sizeof ( SgAsmJvmLineNumberTableStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmLineNumberTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmLineNumberTableStorageClass* storageArray = storageArraySgAsmJvmLineNumberTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmLineNumberTable ( *storageArray ) ; 
#else
               SgAsmJvmLineNumberTable* tmp = new SgAsmJvmLineNumberTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmLineNumberTable;  
      SgAsmJvmLineNumberTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmInnerClassesEntry ); 
     SgAsmJvmInnerClassesEntryStorageClass* storageArraySgAsmJvmInnerClassesEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmInnerClassesEntry = new SgAsmJvmInnerClassesEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmInnerClassesEntry) , sizeof ( SgAsmJvmInnerClassesEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmInnerClassesEntryStorageClass* storageArray = storageArraySgAsmJvmInnerClassesEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmInnerClassesEntry ( *storageArray ) ; 
#else
               SgAsmJvmInnerClassesEntry* tmp = new SgAsmJvmInnerClassesEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmInnerClassesEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmInnerClasses ); 
     SgAsmJvmInnerClassesStorageClass* storageArraySgAsmJvmInnerClasses = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmInnerClasses = new SgAsmJvmInnerClassesStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmInnerClasses) , sizeof ( SgAsmJvmInnerClassesStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmInnerClassesStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmInnerClassesStorageClass* storageArray = storageArraySgAsmJvmInnerClasses;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmInnerClasses ( *storageArray ) ; 
#else
               SgAsmJvmInnerClasses* tmp = new SgAsmJvmInnerClasses ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmInnerClasses;  
      SgAsmJvmInnerClassesStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilInstruction ); 
     SgAsmCilInstructionStorageClass* storageArraySgAsmCilInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilInstruction = new SgAsmCilInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilInstruction) , sizeof ( SgAsmCilInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmCilInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilInstructionStorageClass* storageArray = storageArraySgAsmCilInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilInstruction ( *storageArray ) ; 
#else
               SgAsmCilInstruction* tmp = new SgAsmCilInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilInstruction;  
      SgAsmCilInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStackExpression ); 
     SgAsmStackExpressionStorageClass* storageArraySgAsmStackExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStackExpression = new SgAsmStackExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStackExpression) , sizeof ( SgAsmStackExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmStackExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStackExpressionStorageClass* storageArray = storageArraySgAsmStackExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmStackExpression ( *storageArray ) ; 
#else
               SgAsmStackExpression* tmp = new SgAsmStackExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStackExpression;  
      SgAsmStackExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmEnclosingMethod ); 
     SgAsmJvmEnclosingMethodStorageClass* storageArraySgAsmJvmEnclosingMethod = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmEnclosingMethod = new SgAsmJvmEnclosingMethodStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmEnclosingMethod) , sizeof ( SgAsmJvmEnclosingMethodStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmEnclosingMethodStorageClass* storageArray = storageArraySgAsmJvmEnclosingMethod;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmEnclosingMethod ( *storageArray ) ; 
#else
               SgAsmJvmEnclosingMethod* tmp = new SgAsmJvmEnclosingMethod ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmEnclosingMethod;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaNullConstraint ); 
     SgAdaNullConstraintStorageClass* storageArraySgAdaNullConstraint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaNullConstraint = new SgAdaNullConstraintStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaNullConstraint) , sizeof ( SgAdaNullConstraintStorageClass ) * sizeOfActualPool) ;
        SgAdaNullConstraintStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaNullConstraintStorageClass* storageArray = storageArraySgAdaNullConstraint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaNullConstraint ( *storageArray ) ; 
#else
               SgAdaNullConstraint* tmp = new SgAdaNullConstraint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaNullConstraint;  
      SgAdaNullConstraintStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmModuleMainClass ); 
     SgAsmJvmModuleMainClassStorageClass* storageArraySgAsmJvmModuleMainClass = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmModuleMainClass = new SgAsmJvmModuleMainClassStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmModuleMainClass) , sizeof ( SgAsmJvmModuleMainClassStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmModuleMainClassStorageClass* storageArray = storageArraySgAsmJvmModuleMainClass;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmModuleMainClass ( *storageArray ) ; 
#else
               SgAsmJvmModuleMainClass* tmp = new SgAsmJvmModuleMainClass ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmModuleMainClass;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmInstructionList ); 
     SgAsmInstructionListStorageClass* storageArraySgAsmInstructionList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmInstructionList = new SgAsmInstructionListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmInstructionList) , sizeof ( SgAsmInstructionListStorageClass ) * sizeOfActualPool) ;
        SgAsmInstructionListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmInstructionListStorageClass* storageArray = storageArraySgAsmInstructionList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmInstructionList ( *storageArray ) ; 
#else
               SgAsmInstructionList* tmp = new SgAsmInstructionList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmInstructionList;  
      SgAsmInstructionListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilNode ); 
     SgAsmCilNodeStorageClass* storageArraySgAsmCilNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilNode = new SgAsmCilNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilNode) , sizeof ( SgAsmCilNodeStorageClass ) * sizeOfActualPool) ;
          SgAsmCilNodeStorageClass* storageArray = storageArraySgAsmCilNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilNode ( *storageArray ) ; 
#else
               SgAsmCilNode* tmp = new SgAsmCilNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilNode;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssembly ); 
     SgAsmCilAssemblyStorageClass* storageArraySgAsmCilAssembly = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssembly = new SgAsmCilAssemblyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssembly) , sizeof ( SgAsmCilAssemblyStorageClass ) * sizeOfActualPool) ;
          SgAsmCilAssemblyStorageClass* storageArray = storageArraySgAsmCilAssembly;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssembly ( *storageArray ) ; 
#else
               SgAsmCilAssembly* tmp = new SgAsmCilAssembly ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssembly;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyOS ); 
     SgAsmCilAssemblyOSStorageClass* storageArraySgAsmCilAssemblyOS = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyOS = new SgAsmCilAssemblyOSStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyOS) , sizeof ( SgAsmCilAssemblyOSStorageClass ) * sizeOfActualPool) ;
          SgAsmCilAssemblyOSStorageClass* storageArray = storageArraySgAsmCilAssemblyOS;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyOS ( *storageArray ) ; 
#else
               SgAsmCilAssemblyOS* tmp = new SgAsmCilAssemblyOS ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyOS;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyProcessor ); 
     SgAsmCilAssemblyProcessorStorageClass* storageArraySgAsmCilAssemblyProcessor = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyProcessor = new SgAsmCilAssemblyProcessorStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyProcessor) , sizeof ( SgAsmCilAssemblyProcessorStorageClass ) * sizeOfActualPool) ;
          SgAsmCilAssemblyProcessorStorageClass* storageArray = storageArraySgAsmCilAssemblyProcessor;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyProcessor ( *storageArray ) ; 
#else
               SgAsmCilAssemblyProcessor* tmp = new SgAsmCilAssemblyProcessor ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyProcessor;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyRef ); 
     SgAsmCilAssemblyRefStorageClass* storageArraySgAsmCilAssemblyRef = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyRef = new SgAsmCilAssemblyRefStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyRef) , sizeof ( SgAsmCilAssemblyRefStorageClass ) * sizeOfActualPool) ;
          SgAsmCilAssemblyRefStorageClass* storageArray = storageArraySgAsmCilAssemblyRef;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyRef ( *storageArray ) ; 
#else
               SgAsmCilAssemblyRef* tmp = new SgAsmCilAssemblyRef ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyRef;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyRefOS ); 
     SgAsmCilAssemblyRefOSStorageClass* storageArraySgAsmCilAssemblyRefOS = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyRefOS = new SgAsmCilAssemblyRefOSStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyRefOS) , sizeof ( SgAsmCilAssemblyRefOSStorageClass ) * sizeOfActualPool) ;
          SgAsmCilAssemblyRefOSStorageClass* storageArray = storageArraySgAsmCilAssemblyRefOS;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyRefOS ( *storageArray ) ; 
#else
               SgAsmCilAssemblyRefOS* tmp = new SgAsmCilAssemblyRefOS ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyRefOS;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyRefProcessor ); 
     SgAsmCilAssemblyRefProcessorStorageClass* storageArraySgAsmCilAssemblyRefProcessor = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyRefProcessor = new SgAsmCilAssemblyRefProcessorStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyRefProcessor) , sizeof ( SgAsmCilAssemblyRefProcessorStorageClass ) * sizeOfActualPool) ;
          SgAsmCilAssemblyRefProcessorStorageClass* storageArray = storageArraySgAsmCilAssemblyRefProcessor;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyRefProcessor ( *storageArray ) ; 
#else
               SgAsmCilAssemblyRefProcessor* tmp = new SgAsmCilAssemblyRefProcessor ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyRefProcessor;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilClassLayout ); 
     SgAsmCilClassLayoutStorageClass* storageArraySgAsmCilClassLayout = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilClassLayout = new SgAsmCilClassLayoutStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilClassLayout) , sizeof ( SgAsmCilClassLayoutStorageClass ) * sizeOfActualPool) ;
          SgAsmCilClassLayoutStorageClass* storageArray = storageArraySgAsmCilClassLayout;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilClassLayout ( *storageArray ) ; 
#else
               SgAsmCilClassLayout* tmp = new SgAsmCilClassLayout ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilClassLayout;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilConstant ); 
     SgAsmCilConstantStorageClass* storageArraySgAsmCilConstant = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilConstant = new SgAsmCilConstantStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilConstant) , sizeof ( SgAsmCilConstantStorageClass ) * sizeOfActualPool) ;
          SgAsmCilConstantStorageClass* storageArray = storageArraySgAsmCilConstant;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilConstant ( *storageArray ) ; 
#else
               SgAsmCilConstant* tmp = new SgAsmCilConstant ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilConstant;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilCustomAttribute ); 
     SgAsmCilCustomAttributeStorageClass* storageArraySgAsmCilCustomAttribute = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilCustomAttribute = new SgAsmCilCustomAttributeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilCustomAttribute) , sizeof ( SgAsmCilCustomAttributeStorageClass ) * sizeOfActualPool) ;
          SgAsmCilCustomAttributeStorageClass* storageArray = storageArraySgAsmCilCustomAttribute;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilCustomAttribute ( *storageArray ) ; 
#else
               SgAsmCilCustomAttribute* tmp = new SgAsmCilCustomAttribute ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilCustomAttribute;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilDeclSecurity ); 
     SgAsmCilDeclSecurityStorageClass* storageArraySgAsmCilDeclSecurity = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilDeclSecurity = new SgAsmCilDeclSecurityStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilDeclSecurity) , sizeof ( SgAsmCilDeclSecurityStorageClass ) * sizeOfActualPool) ;
          SgAsmCilDeclSecurityStorageClass* storageArray = storageArraySgAsmCilDeclSecurity;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilDeclSecurity ( *storageArray ) ; 
#else
               SgAsmCilDeclSecurity* tmp = new SgAsmCilDeclSecurity ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilDeclSecurity;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilEvent ); 
     SgAsmCilEventStorageClass* storageArraySgAsmCilEvent = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilEvent = new SgAsmCilEventStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilEvent) , sizeof ( SgAsmCilEventStorageClass ) * sizeOfActualPool) ;
          SgAsmCilEventStorageClass* storageArray = storageArraySgAsmCilEvent;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilEvent ( *storageArray ) ; 
#else
               SgAsmCilEvent* tmp = new SgAsmCilEvent ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilEvent;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilEventMap ); 
     SgAsmCilEventMapStorageClass* storageArraySgAsmCilEventMap = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilEventMap = new SgAsmCilEventMapStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilEventMap) , sizeof ( SgAsmCilEventMapStorageClass ) * sizeOfActualPool) ;
          SgAsmCilEventMapStorageClass* storageArray = storageArraySgAsmCilEventMap;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilEventMap ( *storageArray ) ; 
#else
               SgAsmCilEventMap* tmp = new SgAsmCilEventMap ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilEventMap;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilExportedType ); 
     SgAsmCilExportedTypeStorageClass* storageArraySgAsmCilExportedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilExportedType = new SgAsmCilExportedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilExportedType) , sizeof ( SgAsmCilExportedTypeStorageClass ) * sizeOfActualPool) ;
          SgAsmCilExportedTypeStorageClass* storageArray = storageArraySgAsmCilExportedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilExportedType ( *storageArray ) ; 
#else
               SgAsmCilExportedType* tmp = new SgAsmCilExportedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilExportedType;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilField ); 
     SgAsmCilFieldStorageClass* storageArraySgAsmCilField = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilField = new SgAsmCilFieldStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilField) , sizeof ( SgAsmCilFieldStorageClass ) * sizeOfActualPool) ;
          SgAsmCilFieldStorageClass* storageArray = storageArraySgAsmCilField;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilField ( *storageArray ) ; 
#else
               SgAsmCilField* tmp = new SgAsmCilField ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilField;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilFieldLayout ); 
     SgAsmCilFieldLayoutStorageClass* storageArraySgAsmCilFieldLayout = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilFieldLayout = new SgAsmCilFieldLayoutStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilFieldLayout) , sizeof ( SgAsmCilFieldLayoutStorageClass ) * sizeOfActualPool) ;
          SgAsmCilFieldLayoutStorageClass* storageArray = storageArraySgAsmCilFieldLayout;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilFieldLayout ( *storageArray ) ; 
#else
               SgAsmCilFieldLayout* tmp = new SgAsmCilFieldLayout ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilFieldLayout;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilFieldMarshal ); 
     SgAsmCilFieldMarshalStorageClass* storageArraySgAsmCilFieldMarshal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilFieldMarshal = new SgAsmCilFieldMarshalStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilFieldMarshal) , sizeof ( SgAsmCilFieldMarshalStorageClass ) * sizeOfActualPool) ;
          SgAsmCilFieldMarshalStorageClass* storageArray = storageArraySgAsmCilFieldMarshal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilFieldMarshal ( *storageArray ) ; 
#else
               SgAsmCilFieldMarshal* tmp = new SgAsmCilFieldMarshal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilFieldMarshal;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilFieldRVA ); 
     SgAsmCilFieldRVAStorageClass* storageArraySgAsmCilFieldRVA = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilFieldRVA = new SgAsmCilFieldRVAStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilFieldRVA) , sizeof ( SgAsmCilFieldRVAStorageClass ) * sizeOfActualPool) ;
          SgAsmCilFieldRVAStorageClass* storageArray = storageArraySgAsmCilFieldRVA;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilFieldRVA ( *storageArray ) ; 
#else
               SgAsmCilFieldRVA* tmp = new SgAsmCilFieldRVA ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilFieldRVA;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilFile ); 
     SgAsmCilFileStorageClass* storageArraySgAsmCilFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilFile = new SgAsmCilFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilFile) , sizeof ( SgAsmCilFileStorageClass ) * sizeOfActualPool) ;
          SgAsmCilFileStorageClass* storageArray = storageArraySgAsmCilFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilFile ( *storageArray ) ; 
#else
               SgAsmCilFile* tmp = new SgAsmCilFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilFile;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilGenericParam ); 
     SgAsmCilGenericParamStorageClass* storageArraySgAsmCilGenericParam = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilGenericParam = new SgAsmCilGenericParamStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilGenericParam) , sizeof ( SgAsmCilGenericParamStorageClass ) * sizeOfActualPool) ;
          SgAsmCilGenericParamStorageClass* storageArray = storageArraySgAsmCilGenericParam;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilGenericParam ( *storageArray ) ; 
#else
               SgAsmCilGenericParam* tmp = new SgAsmCilGenericParam ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilGenericParam;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilGenericParamConstraint ); 
     SgAsmCilGenericParamConstraintStorageClass* storageArraySgAsmCilGenericParamConstraint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilGenericParamConstraint = new SgAsmCilGenericParamConstraintStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilGenericParamConstraint) , sizeof ( SgAsmCilGenericParamConstraintStorageClass ) * sizeOfActualPool) ;
          SgAsmCilGenericParamConstraintStorageClass* storageArray = storageArraySgAsmCilGenericParamConstraint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilGenericParamConstraint ( *storageArray ) ; 
#else
               SgAsmCilGenericParamConstraint* tmp = new SgAsmCilGenericParamConstraint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilGenericParamConstraint;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilImplMap ); 
     SgAsmCilImplMapStorageClass* storageArraySgAsmCilImplMap = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilImplMap = new SgAsmCilImplMapStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilImplMap) , sizeof ( SgAsmCilImplMapStorageClass ) * sizeOfActualPool) ;
          SgAsmCilImplMapStorageClass* storageArray = storageArraySgAsmCilImplMap;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilImplMap ( *storageArray ) ; 
#else
               SgAsmCilImplMap* tmp = new SgAsmCilImplMap ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilImplMap;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilInterfaceImpl ); 
     SgAsmCilInterfaceImplStorageClass* storageArraySgAsmCilInterfaceImpl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilInterfaceImpl = new SgAsmCilInterfaceImplStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilInterfaceImpl) , sizeof ( SgAsmCilInterfaceImplStorageClass ) * sizeOfActualPool) ;
          SgAsmCilInterfaceImplStorageClass* storageArray = storageArraySgAsmCilInterfaceImpl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilInterfaceImpl ( *storageArray ) ; 
#else
               SgAsmCilInterfaceImpl* tmp = new SgAsmCilInterfaceImpl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilInterfaceImpl;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilManifestResource ); 
     SgAsmCilManifestResourceStorageClass* storageArraySgAsmCilManifestResource = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilManifestResource = new SgAsmCilManifestResourceStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilManifestResource) , sizeof ( SgAsmCilManifestResourceStorageClass ) * sizeOfActualPool) ;
          SgAsmCilManifestResourceStorageClass* storageArray = storageArraySgAsmCilManifestResource;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilManifestResource ( *storageArray ) ; 
#else
               SgAsmCilManifestResource* tmp = new SgAsmCilManifestResource ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilManifestResource;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMemberRef ); 
     SgAsmCilMemberRefStorageClass* storageArraySgAsmCilMemberRef = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMemberRef = new SgAsmCilMemberRefStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMemberRef) , sizeof ( SgAsmCilMemberRefStorageClass ) * sizeOfActualPool) ;
          SgAsmCilMemberRefStorageClass* storageArray = storageArraySgAsmCilMemberRef;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMemberRef ( *storageArray ) ; 
#else
               SgAsmCilMemberRef* tmp = new SgAsmCilMemberRef ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMemberRef;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMethodDef ); 
     SgAsmCilMethodDefStorageClass* storageArraySgAsmCilMethodDef = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMethodDef = new SgAsmCilMethodDefStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMethodDef) , sizeof ( SgAsmCilMethodDefStorageClass ) * sizeOfActualPool) ;
        SgAsmCilMethodDefStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilMethodDefStorageClass* storageArray = storageArraySgAsmCilMethodDef;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMethodDef ( *storageArray ) ; 
#else
               SgAsmCilMethodDef* tmp = new SgAsmCilMethodDef ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMethodDef;  
      SgAsmCilMethodDefStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMethodImpl ); 
     SgAsmCilMethodImplStorageClass* storageArraySgAsmCilMethodImpl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMethodImpl = new SgAsmCilMethodImplStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMethodImpl) , sizeof ( SgAsmCilMethodImplStorageClass ) * sizeOfActualPool) ;
          SgAsmCilMethodImplStorageClass* storageArray = storageArraySgAsmCilMethodImpl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMethodImpl ( *storageArray ) ; 
#else
               SgAsmCilMethodImpl* tmp = new SgAsmCilMethodImpl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMethodImpl;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMethodSemantics ); 
     SgAsmCilMethodSemanticsStorageClass* storageArraySgAsmCilMethodSemantics = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMethodSemantics = new SgAsmCilMethodSemanticsStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMethodSemantics) , sizeof ( SgAsmCilMethodSemanticsStorageClass ) * sizeOfActualPool) ;
          SgAsmCilMethodSemanticsStorageClass* storageArray = storageArraySgAsmCilMethodSemantics;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMethodSemantics ( *storageArray ) ; 
#else
               SgAsmCilMethodSemantics* tmp = new SgAsmCilMethodSemantics ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMethodSemantics;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMethodSpec ); 
     SgAsmCilMethodSpecStorageClass* storageArraySgAsmCilMethodSpec = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMethodSpec = new SgAsmCilMethodSpecStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMethodSpec) , sizeof ( SgAsmCilMethodSpecStorageClass ) * sizeOfActualPool) ;
          SgAsmCilMethodSpecStorageClass* storageArray = storageArraySgAsmCilMethodSpec;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMethodSpec ( *storageArray ) ; 
#else
               SgAsmCilMethodSpec* tmp = new SgAsmCilMethodSpec ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMethodSpec;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilModule ); 
     SgAsmCilModuleStorageClass* storageArraySgAsmCilModule = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilModule = new SgAsmCilModuleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilModule) , sizeof ( SgAsmCilModuleStorageClass ) * sizeOfActualPool) ;
          SgAsmCilModuleStorageClass* storageArray = storageArraySgAsmCilModule;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilModule ( *storageArray ) ; 
#else
               SgAsmCilModule* tmp = new SgAsmCilModule ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilModule;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilModuleRef ); 
     SgAsmCilModuleRefStorageClass* storageArraySgAsmCilModuleRef = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilModuleRef = new SgAsmCilModuleRefStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilModuleRef) , sizeof ( SgAsmCilModuleRefStorageClass ) * sizeOfActualPool) ;
          SgAsmCilModuleRefStorageClass* storageArray = storageArraySgAsmCilModuleRef;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilModuleRef ( *storageArray ) ; 
#else
               SgAsmCilModuleRef* tmp = new SgAsmCilModuleRef ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilModuleRef;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilNestedClass ); 
     SgAsmCilNestedClassStorageClass* storageArraySgAsmCilNestedClass = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilNestedClass = new SgAsmCilNestedClassStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilNestedClass) , sizeof ( SgAsmCilNestedClassStorageClass ) * sizeOfActualPool) ;
          SgAsmCilNestedClassStorageClass* storageArray = storageArraySgAsmCilNestedClass;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilNestedClass ( *storageArray ) ; 
#else
               SgAsmCilNestedClass* tmp = new SgAsmCilNestedClass ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilNestedClass;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilParam ); 
     SgAsmCilParamStorageClass* storageArraySgAsmCilParam = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilParam = new SgAsmCilParamStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilParam) , sizeof ( SgAsmCilParamStorageClass ) * sizeOfActualPool) ;
          SgAsmCilParamStorageClass* storageArray = storageArraySgAsmCilParam;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilParam ( *storageArray ) ; 
#else
               SgAsmCilParam* tmp = new SgAsmCilParam ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilParam;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilProperty ); 
     SgAsmCilPropertyStorageClass* storageArraySgAsmCilProperty = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilProperty = new SgAsmCilPropertyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilProperty) , sizeof ( SgAsmCilPropertyStorageClass ) * sizeOfActualPool) ;
          SgAsmCilPropertyStorageClass* storageArray = storageArraySgAsmCilProperty;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilProperty ( *storageArray ) ; 
#else
               SgAsmCilProperty* tmp = new SgAsmCilProperty ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilProperty;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilPropertyMap ); 
     SgAsmCilPropertyMapStorageClass* storageArraySgAsmCilPropertyMap = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilPropertyMap = new SgAsmCilPropertyMapStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilPropertyMap) , sizeof ( SgAsmCilPropertyMapStorageClass ) * sizeOfActualPool) ;
          SgAsmCilPropertyMapStorageClass* storageArray = storageArraySgAsmCilPropertyMap;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilPropertyMap ( *storageArray ) ; 
#else
               SgAsmCilPropertyMap* tmp = new SgAsmCilPropertyMap ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilPropertyMap;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilStandAloneSig ); 
     SgAsmCilStandAloneSigStorageClass* storageArraySgAsmCilStandAloneSig = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilStandAloneSig = new SgAsmCilStandAloneSigStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilStandAloneSig) , sizeof ( SgAsmCilStandAloneSigStorageClass ) * sizeOfActualPool) ;
          SgAsmCilStandAloneSigStorageClass* storageArray = storageArraySgAsmCilStandAloneSig;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilStandAloneSig ( *storageArray ) ; 
#else
               SgAsmCilStandAloneSig* tmp = new SgAsmCilStandAloneSig ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilStandAloneSig;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilTypeDef ); 
     SgAsmCilTypeDefStorageClass* storageArraySgAsmCilTypeDef = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilTypeDef = new SgAsmCilTypeDefStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilTypeDef) , sizeof ( SgAsmCilTypeDefStorageClass ) * sizeOfActualPool) ;
          SgAsmCilTypeDefStorageClass* storageArray = storageArraySgAsmCilTypeDef;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilTypeDef ( *storageArray ) ; 
#else
               SgAsmCilTypeDef* tmp = new SgAsmCilTypeDef ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilTypeDef;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilTypeRef ); 
     SgAsmCilTypeRefStorageClass* storageArraySgAsmCilTypeRef = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilTypeRef = new SgAsmCilTypeRefStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilTypeRef) , sizeof ( SgAsmCilTypeRefStorageClass ) * sizeOfActualPool) ;
          SgAsmCilTypeRefStorageClass* storageArray = storageArraySgAsmCilTypeRef;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilTypeRef ( *storageArray ) ; 
#else
               SgAsmCilTypeRef* tmp = new SgAsmCilTypeRef ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilTypeRef;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilTypeSpec ); 
     SgAsmCilTypeSpecStorageClass* storageArraySgAsmCilTypeSpec = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilTypeSpec = new SgAsmCilTypeSpecStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilTypeSpec) , sizeof ( SgAsmCilTypeSpecStorageClass ) * sizeOfActualPool) ;
          SgAsmCilTypeSpecStorageClass* storageArray = storageArraySgAsmCilTypeSpec;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilTypeSpec ( *storageArray ) ; 
#else
               SgAsmCilTypeSpec* tmp = new SgAsmCilTypeSpec ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilTypeSpec;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaParameterList ); 
     SgAdaParameterListStorageClass* storageArraySgAdaParameterList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaParameterList = new SgAdaParameterListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaParameterList) , sizeof ( SgAdaParameterListStorageClass ) * sizeOfActualPool) ;
        SgAdaParameterListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaParameterListStorageClass* storageArray = storageArraySgAdaParameterList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaParameterList ( *storageArray ) ; 
#else
               SgAdaParameterList* tmp = new SgAdaParameterList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaParameterList;  
      SgAdaParameterListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMetadata ); 
     SgAsmCilMetadataStorageClass* storageArraySgAsmCilMetadata = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMetadata = new SgAsmCilMetadataStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMetadata) , sizeof ( SgAsmCilMetadataStorageClass ) * sizeOfActualPool) ;
          SgAsmCilMetadataStorageClass* storageArray = storageArraySgAsmCilMetadata;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMetadata ( *storageArray ) ; 
#else
               SgAsmCilMetadata* tmp = new SgAsmCilMetadata ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMetadata;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMetadataRoot ); 
     SgAsmCilMetadataRootStorageClass* storageArraySgAsmCilMetadataRoot = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMetadataRoot = new SgAsmCilMetadataRootStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMetadataRoot) , sizeof ( SgAsmCilMetadataRootStorageClass ) * sizeOfActualPool) ;
        SgAsmCilMetadataRootStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilMetadataRootStorageClass* storageArray = storageArraySgAsmCilMetadataRoot;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMetadataRoot ( *storageArray ) ; 
#else
               SgAsmCilMetadataRoot* tmp = new SgAsmCilMetadataRoot ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMetadataRoot;  
      SgAsmCilMetadataRootStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilDataStream ); 
     SgAsmCilDataStreamStorageClass* storageArraySgAsmCilDataStream = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilDataStream = new SgAsmCilDataStreamStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilDataStream) , sizeof ( SgAsmCilDataStreamStorageClass ) * sizeOfActualPool) ;
        SgAsmCilDataStreamStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilDataStreamStorageClass* storageArray = storageArraySgAsmCilDataStream;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilDataStream ( *storageArray ) ; 
#else
               SgAsmCilDataStream* tmp = new SgAsmCilDataStream ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilDataStream;  
      SgAsmCilDataStreamStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMetadataHeap ); 
     SgAsmCilMetadataHeapStorageClass* storageArraySgAsmCilMetadataHeap = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMetadataHeap = new SgAsmCilMetadataHeapStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMetadataHeap) , sizeof ( SgAsmCilMetadataHeapStorageClass ) * sizeOfActualPool) ;
        SgAsmCilMetadataHeapStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilMetadataHeapStorageClass* storageArray = storageArraySgAsmCilMetadataHeap;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMetadataHeap ( *storageArray ) ; 
#else
               SgAsmCilMetadataHeap* tmp = new SgAsmCilMetadataHeap ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMetadataHeap;  
      SgAsmCilMetadataHeapStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilUint8Heap ); 
     SgAsmCilUint8HeapStorageClass* storageArraySgAsmCilUint8Heap = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilUint8Heap = new SgAsmCilUint8HeapStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilUint8Heap) , sizeof ( SgAsmCilUint8HeapStorageClass ) * sizeOfActualPool) ;
        SgAsmCilUint8HeapStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilUint8HeapStorageClass* storageArray = storageArraySgAsmCilUint8Heap;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilUint8Heap ( *storageArray ) ; 
#else
               SgAsmCilUint8Heap* tmp = new SgAsmCilUint8Heap ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilUint8Heap;  
      SgAsmCilUint8HeapStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilUint32Heap ); 
     SgAsmCilUint32HeapStorageClass* storageArraySgAsmCilUint32Heap = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilUint32Heap = new SgAsmCilUint32HeapStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilUint32Heap) , sizeof ( SgAsmCilUint32HeapStorageClass ) * sizeOfActualPool) ;
        SgAsmCilUint32HeapStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilUint32HeapStorageClass* storageArray = storageArraySgAsmCilUint32Heap;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilUint32Heap ( *storageArray ) ; 
#else
               SgAsmCilUint32Heap* tmp = new SgAsmCilUint32Heap ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilUint32Heap;  
      SgAsmCilUint32HeapStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCliHeader ); 
     SgAsmCliHeaderStorageClass* storageArraySgAsmCliHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCliHeader = new SgAsmCliHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCliHeader) , sizeof ( SgAsmCliHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmCliHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCliHeaderStorageClass* storageArray = storageArraySgAsmCliHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCliHeader ( *storageArray ) ; 
#else
               SgAsmCliHeader* tmp = new SgAsmCliHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCliHeader;  
      SgAsmCliHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaVariantDecl ); 
     SgAdaVariantDeclStorageClass* storageArraySgAdaVariantDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaVariantDecl = new SgAdaVariantDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaVariantDecl) , sizeof ( SgAdaVariantDeclStorageClass ) * sizeOfActualPool) ;
        SgAdaVariantDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaVariantDeclStorageClass* storageArray = storageArraySgAdaVariantDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaVariantDecl ( *storageArray ) ; 
#else
               SgAdaVariantDecl* tmp = new SgAdaVariantDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaVariantDecl;  
      SgAdaVariantDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAdaVariantWhenStmt ); 
     SgAdaVariantWhenStmtStorageClass* storageArraySgAdaVariantWhenStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAdaVariantWhenStmt = new SgAdaVariantWhenStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAdaVariantWhenStmt) , sizeof ( SgAdaVariantWhenStmtStorageClass ) * sizeOfActualPool) ;
        SgAdaVariantWhenStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAdaVariantWhenStmtStorageClass* storageArray = storageArraySgAdaVariantWhenStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAdaVariantWhenStmt ( *storageArray ) ; 
#else
               SgAdaVariantWhenStmt* tmp = new SgAdaVariantWhenStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAdaVariantWhenStmt;  
      SgAdaVariantWhenStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyTable ); 
     SgAsmCilAssemblyTableStorageClass* storageArraySgAsmCilAssemblyTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyTable = new SgAsmCilAssemblyTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyTable) , sizeof ( SgAsmCilAssemblyTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilAssemblyTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilAssemblyTableStorageClass* storageArray = storageArraySgAsmCilAssemblyTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyTable ( *storageArray ) ; 
#else
               SgAsmCilAssemblyTable* tmp = new SgAsmCilAssemblyTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyTable;  
      SgAsmCilAssemblyTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyOSTable ); 
     SgAsmCilAssemblyOSTableStorageClass* storageArraySgAsmCilAssemblyOSTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyOSTable = new SgAsmCilAssemblyOSTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyOSTable) , sizeof ( SgAsmCilAssemblyOSTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilAssemblyOSTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilAssemblyOSTableStorageClass* storageArray = storageArraySgAsmCilAssemblyOSTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyOSTable ( *storageArray ) ; 
#else
               SgAsmCilAssemblyOSTable* tmp = new SgAsmCilAssemblyOSTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyOSTable;  
      SgAsmCilAssemblyOSTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyProcessorTable ); 
     SgAsmCilAssemblyProcessorTableStorageClass* storageArraySgAsmCilAssemblyProcessorTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyProcessorTable = new SgAsmCilAssemblyProcessorTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyProcessorTable) , sizeof ( SgAsmCilAssemblyProcessorTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilAssemblyProcessorTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilAssemblyProcessorTableStorageClass* storageArray = storageArraySgAsmCilAssemblyProcessorTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyProcessorTable ( *storageArray ) ; 
#else
               SgAsmCilAssemblyProcessorTable* tmp = new SgAsmCilAssemblyProcessorTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyProcessorTable;  
      SgAsmCilAssemblyProcessorTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyRefTable ); 
     SgAsmCilAssemblyRefTableStorageClass* storageArraySgAsmCilAssemblyRefTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyRefTable = new SgAsmCilAssemblyRefTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyRefTable) , sizeof ( SgAsmCilAssemblyRefTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilAssemblyRefTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilAssemblyRefTableStorageClass* storageArray = storageArraySgAsmCilAssemblyRefTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyRefTable ( *storageArray ) ; 
#else
               SgAsmCilAssemblyRefTable* tmp = new SgAsmCilAssemblyRefTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyRefTable;  
      SgAsmCilAssemblyRefTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyRefOSTable ); 
     SgAsmCilAssemblyRefOSTableStorageClass* storageArraySgAsmCilAssemblyRefOSTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyRefOSTable = new SgAsmCilAssemblyRefOSTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyRefOSTable) , sizeof ( SgAsmCilAssemblyRefOSTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilAssemblyRefOSTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilAssemblyRefOSTableStorageClass* storageArray = storageArraySgAsmCilAssemblyRefOSTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyRefOSTable ( *storageArray ) ; 
#else
               SgAsmCilAssemblyRefOSTable* tmp = new SgAsmCilAssemblyRefOSTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyRefOSTable;  
      SgAsmCilAssemblyRefOSTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilAssemblyRefProcessorTable ); 
     SgAsmCilAssemblyRefProcessorTableStorageClass* storageArraySgAsmCilAssemblyRefProcessorTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilAssemblyRefProcessorTable = new SgAsmCilAssemblyRefProcessorTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilAssemblyRefProcessorTable) , sizeof ( SgAsmCilAssemblyRefProcessorTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilAssemblyRefProcessorTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilAssemblyRefProcessorTableStorageClass* storageArray = storageArraySgAsmCilAssemblyRefProcessorTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilAssemblyRefProcessorTable ( *storageArray ) ; 
#else
               SgAsmCilAssemblyRefProcessorTable* tmp = new SgAsmCilAssemblyRefProcessorTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilAssemblyRefProcessorTable;  
      SgAsmCilAssemblyRefProcessorTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilClassLayoutTable ); 
     SgAsmCilClassLayoutTableStorageClass* storageArraySgAsmCilClassLayoutTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilClassLayoutTable = new SgAsmCilClassLayoutTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilClassLayoutTable) , sizeof ( SgAsmCilClassLayoutTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilClassLayoutTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilClassLayoutTableStorageClass* storageArray = storageArraySgAsmCilClassLayoutTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilClassLayoutTable ( *storageArray ) ; 
#else
               SgAsmCilClassLayoutTable* tmp = new SgAsmCilClassLayoutTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilClassLayoutTable;  
      SgAsmCilClassLayoutTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilConstantTable ); 
     SgAsmCilConstantTableStorageClass* storageArraySgAsmCilConstantTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilConstantTable = new SgAsmCilConstantTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilConstantTable) , sizeof ( SgAsmCilConstantTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilConstantTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilConstantTableStorageClass* storageArray = storageArraySgAsmCilConstantTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilConstantTable ( *storageArray ) ; 
#else
               SgAsmCilConstantTable* tmp = new SgAsmCilConstantTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilConstantTable;  
      SgAsmCilConstantTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilCustomAttributeTable ); 
     SgAsmCilCustomAttributeTableStorageClass* storageArraySgAsmCilCustomAttributeTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilCustomAttributeTable = new SgAsmCilCustomAttributeTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilCustomAttributeTable) , sizeof ( SgAsmCilCustomAttributeTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilCustomAttributeTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilCustomAttributeTableStorageClass* storageArray = storageArraySgAsmCilCustomAttributeTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilCustomAttributeTable ( *storageArray ) ; 
#else
               SgAsmCilCustomAttributeTable* tmp = new SgAsmCilCustomAttributeTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilCustomAttributeTable;  
      SgAsmCilCustomAttributeTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilDeclSecurityTable ); 
     SgAsmCilDeclSecurityTableStorageClass* storageArraySgAsmCilDeclSecurityTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilDeclSecurityTable = new SgAsmCilDeclSecurityTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilDeclSecurityTable) , sizeof ( SgAsmCilDeclSecurityTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilDeclSecurityTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilDeclSecurityTableStorageClass* storageArray = storageArraySgAsmCilDeclSecurityTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilDeclSecurityTable ( *storageArray ) ; 
#else
               SgAsmCilDeclSecurityTable* tmp = new SgAsmCilDeclSecurityTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilDeclSecurityTable;  
      SgAsmCilDeclSecurityTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilEventTable ); 
     SgAsmCilEventTableStorageClass* storageArraySgAsmCilEventTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilEventTable = new SgAsmCilEventTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilEventTable) , sizeof ( SgAsmCilEventTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilEventTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilEventTableStorageClass* storageArray = storageArraySgAsmCilEventTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilEventTable ( *storageArray ) ; 
#else
               SgAsmCilEventTable* tmp = new SgAsmCilEventTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilEventTable;  
      SgAsmCilEventTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilEventMapTable ); 
     SgAsmCilEventMapTableStorageClass* storageArraySgAsmCilEventMapTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilEventMapTable = new SgAsmCilEventMapTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilEventMapTable) , sizeof ( SgAsmCilEventMapTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilEventMapTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilEventMapTableStorageClass* storageArray = storageArraySgAsmCilEventMapTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilEventMapTable ( *storageArray ) ; 
#else
               SgAsmCilEventMapTable* tmp = new SgAsmCilEventMapTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilEventMapTable;  
      SgAsmCilEventMapTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilExportedTypeTable ); 
     SgAsmCilExportedTypeTableStorageClass* storageArraySgAsmCilExportedTypeTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilExportedTypeTable = new SgAsmCilExportedTypeTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilExportedTypeTable) , sizeof ( SgAsmCilExportedTypeTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilExportedTypeTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilExportedTypeTableStorageClass* storageArray = storageArraySgAsmCilExportedTypeTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilExportedTypeTable ( *storageArray ) ; 
#else
               SgAsmCilExportedTypeTable* tmp = new SgAsmCilExportedTypeTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilExportedTypeTable;  
      SgAsmCilExportedTypeTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilFieldTable ); 
     SgAsmCilFieldTableStorageClass* storageArraySgAsmCilFieldTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilFieldTable = new SgAsmCilFieldTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilFieldTable) , sizeof ( SgAsmCilFieldTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilFieldTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilFieldTableStorageClass* storageArray = storageArraySgAsmCilFieldTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilFieldTable ( *storageArray ) ; 
#else
               SgAsmCilFieldTable* tmp = new SgAsmCilFieldTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilFieldTable;  
      SgAsmCilFieldTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilFieldLayoutTable ); 
     SgAsmCilFieldLayoutTableStorageClass* storageArraySgAsmCilFieldLayoutTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilFieldLayoutTable = new SgAsmCilFieldLayoutTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilFieldLayoutTable) , sizeof ( SgAsmCilFieldLayoutTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilFieldLayoutTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilFieldLayoutTableStorageClass* storageArray = storageArraySgAsmCilFieldLayoutTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilFieldLayoutTable ( *storageArray ) ; 
#else
               SgAsmCilFieldLayoutTable* tmp = new SgAsmCilFieldLayoutTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilFieldLayoutTable;  
      SgAsmCilFieldLayoutTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilFieldMarshalTable ); 
     SgAsmCilFieldMarshalTableStorageClass* storageArraySgAsmCilFieldMarshalTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilFieldMarshalTable = new SgAsmCilFieldMarshalTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilFieldMarshalTable) , sizeof ( SgAsmCilFieldMarshalTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilFieldMarshalTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilFieldMarshalTableStorageClass* storageArray = storageArraySgAsmCilFieldMarshalTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilFieldMarshalTable ( *storageArray ) ; 
#else
               SgAsmCilFieldMarshalTable* tmp = new SgAsmCilFieldMarshalTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilFieldMarshalTable;  
      SgAsmCilFieldMarshalTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilFieldRVATable ); 
     SgAsmCilFieldRVATableStorageClass* storageArraySgAsmCilFieldRVATable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilFieldRVATable = new SgAsmCilFieldRVATableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilFieldRVATable) , sizeof ( SgAsmCilFieldRVATableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilFieldRVATableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilFieldRVATableStorageClass* storageArray = storageArraySgAsmCilFieldRVATable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilFieldRVATable ( *storageArray ) ; 
#else
               SgAsmCilFieldRVATable* tmp = new SgAsmCilFieldRVATable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilFieldRVATable;  
      SgAsmCilFieldRVATableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilFileTable ); 
     SgAsmCilFileTableStorageClass* storageArraySgAsmCilFileTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilFileTable = new SgAsmCilFileTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilFileTable) , sizeof ( SgAsmCilFileTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilFileTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilFileTableStorageClass* storageArray = storageArraySgAsmCilFileTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilFileTable ( *storageArray ) ; 
#else
               SgAsmCilFileTable* tmp = new SgAsmCilFileTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilFileTable;  
      SgAsmCilFileTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilGenericParamTable ); 
     SgAsmCilGenericParamTableStorageClass* storageArraySgAsmCilGenericParamTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilGenericParamTable = new SgAsmCilGenericParamTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilGenericParamTable) , sizeof ( SgAsmCilGenericParamTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilGenericParamTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilGenericParamTableStorageClass* storageArray = storageArraySgAsmCilGenericParamTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilGenericParamTable ( *storageArray ) ; 
#else
               SgAsmCilGenericParamTable* tmp = new SgAsmCilGenericParamTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilGenericParamTable;  
      SgAsmCilGenericParamTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilGenericParamConstraintTable ); 
     SgAsmCilGenericParamConstraintTableStorageClass* storageArraySgAsmCilGenericParamConstraintTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilGenericParamConstraintTable = new SgAsmCilGenericParamConstraintTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilGenericParamConstraintTable) , sizeof ( SgAsmCilGenericParamConstraintTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilGenericParamConstraintTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilGenericParamConstraintTableStorageClass* storageArray = storageArraySgAsmCilGenericParamConstraintTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilGenericParamConstraintTable ( *storageArray ) ; 
#else
               SgAsmCilGenericParamConstraintTable* tmp = new SgAsmCilGenericParamConstraintTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilGenericParamConstraintTable;  
      SgAsmCilGenericParamConstraintTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilImplMapTable ); 
     SgAsmCilImplMapTableStorageClass* storageArraySgAsmCilImplMapTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilImplMapTable = new SgAsmCilImplMapTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilImplMapTable) , sizeof ( SgAsmCilImplMapTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilImplMapTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilImplMapTableStorageClass* storageArray = storageArraySgAsmCilImplMapTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilImplMapTable ( *storageArray ) ; 
#else
               SgAsmCilImplMapTable* tmp = new SgAsmCilImplMapTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilImplMapTable;  
      SgAsmCilImplMapTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilInterfaceImplTable ); 
     SgAsmCilInterfaceImplTableStorageClass* storageArraySgAsmCilInterfaceImplTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilInterfaceImplTable = new SgAsmCilInterfaceImplTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilInterfaceImplTable) , sizeof ( SgAsmCilInterfaceImplTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilInterfaceImplTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilInterfaceImplTableStorageClass* storageArray = storageArraySgAsmCilInterfaceImplTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilInterfaceImplTable ( *storageArray ) ; 
#else
               SgAsmCilInterfaceImplTable* tmp = new SgAsmCilInterfaceImplTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilInterfaceImplTable;  
      SgAsmCilInterfaceImplTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilManifestResourceTable ); 
     SgAsmCilManifestResourceTableStorageClass* storageArraySgAsmCilManifestResourceTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilManifestResourceTable = new SgAsmCilManifestResourceTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilManifestResourceTable) , sizeof ( SgAsmCilManifestResourceTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilManifestResourceTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilManifestResourceTableStorageClass* storageArray = storageArraySgAsmCilManifestResourceTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilManifestResourceTable ( *storageArray ) ; 
#else
               SgAsmCilManifestResourceTable* tmp = new SgAsmCilManifestResourceTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilManifestResourceTable;  
      SgAsmCilManifestResourceTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMemberRefTable ); 
     SgAsmCilMemberRefTableStorageClass* storageArraySgAsmCilMemberRefTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMemberRefTable = new SgAsmCilMemberRefTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMemberRefTable) , sizeof ( SgAsmCilMemberRefTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilMemberRefTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilMemberRefTableStorageClass* storageArray = storageArraySgAsmCilMemberRefTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMemberRefTable ( *storageArray ) ; 
#else
               SgAsmCilMemberRefTable* tmp = new SgAsmCilMemberRefTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMemberRefTable;  
      SgAsmCilMemberRefTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMethodDefTable ); 
     SgAsmCilMethodDefTableStorageClass* storageArraySgAsmCilMethodDefTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMethodDefTable = new SgAsmCilMethodDefTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMethodDefTable) , sizeof ( SgAsmCilMethodDefTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilMethodDefTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilMethodDefTableStorageClass* storageArray = storageArraySgAsmCilMethodDefTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMethodDefTable ( *storageArray ) ; 
#else
               SgAsmCilMethodDefTable* tmp = new SgAsmCilMethodDefTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMethodDefTable;  
      SgAsmCilMethodDefTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMethodImplTable ); 
     SgAsmCilMethodImplTableStorageClass* storageArraySgAsmCilMethodImplTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMethodImplTable = new SgAsmCilMethodImplTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMethodImplTable) , sizeof ( SgAsmCilMethodImplTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilMethodImplTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilMethodImplTableStorageClass* storageArray = storageArraySgAsmCilMethodImplTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMethodImplTable ( *storageArray ) ; 
#else
               SgAsmCilMethodImplTable* tmp = new SgAsmCilMethodImplTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMethodImplTable;  
      SgAsmCilMethodImplTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMethodSemanticsTable ); 
     SgAsmCilMethodSemanticsTableStorageClass* storageArraySgAsmCilMethodSemanticsTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMethodSemanticsTable = new SgAsmCilMethodSemanticsTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMethodSemanticsTable) , sizeof ( SgAsmCilMethodSemanticsTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilMethodSemanticsTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilMethodSemanticsTableStorageClass* storageArray = storageArraySgAsmCilMethodSemanticsTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMethodSemanticsTable ( *storageArray ) ; 
#else
               SgAsmCilMethodSemanticsTable* tmp = new SgAsmCilMethodSemanticsTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMethodSemanticsTable;  
      SgAsmCilMethodSemanticsTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMethodSpecTable ); 
     SgAsmCilMethodSpecTableStorageClass* storageArraySgAsmCilMethodSpecTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMethodSpecTable = new SgAsmCilMethodSpecTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMethodSpecTable) , sizeof ( SgAsmCilMethodSpecTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilMethodSpecTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilMethodSpecTableStorageClass* storageArray = storageArraySgAsmCilMethodSpecTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMethodSpecTable ( *storageArray ) ; 
#else
               SgAsmCilMethodSpecTable* tmp = new SgAsmCilMethodSpecTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMethodSpecTable;  
      SgAsmCilMethodSpecTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilModuleTable ); 
     SgAsmCilModuleTableStorageClass* storageArraySgAsmCilModuleTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilModuleTable = new SgAsmCilModuleTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilModuleTable) , sizeof ( SgAsmCilModuleTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilModuleTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilModuleTableStorageClass* storageArray = storageArraySgAsmCilModuleTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilModuleTable ( *storageArray ) ; 
#else
               SgAsmCilModuleTable* tmp = new SgAsmCilModuleTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilModuleTable;  
      SgAsmCilModuleTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilModuleRefTable ); 
     SgAsmCilModuleRefTableStorageClass* storageArraySgAsmCilModuleRefTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilModuleRefTable = new SgAsmCilModuleRefTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilModuleRefTable) , sizeof ( SgAsmCilModuleRefTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilModuleRefTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilModuleRefTableStorageClass* storageArray = storageArraySgAsmCilModuleRefTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilModuleRefTable ( *storageArray ) ; 
#else
               SgAsmCilModuleRefTable* tmp = new SgAsmCilModuleRefTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilModuleRefTable;  
      SgAsmCilModuleRefTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilNestedClassTable ); 
     SgAsmCilNestedClassTableStorageClass* storageArraySgAsmCilNestedClassTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilNestedClassTable = new SgAsmCilNestedClassTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilNestedClassTable) , sizeof ( SgAsmCilNestedClassTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilNestedClassTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilNestedClassTableStorageClass* storageArray = storageArraySgAsmCilNestedClassTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilNestedClassTable ( *storageArray ) ; 
#else
               SgAsmCilNestedClassTable* tmp = new SgAsmCilNestedClassTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilNestedClassTable;  
      SgAsmCilNestedClassTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilParamTable ); 
     SgAsmCilParamTableStorageClass* storageArraySgAsmCilParamTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilParamTable = new SgAsmCilParamTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilParamTable) , sizeof ( SgAsmCilParamTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilParamTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilParamTableStorageClass* storageArray = storageArraySgAsmCilParamTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilParamTable ( *storageArray ) ; 
#else
               SgAsmCilParamTable* tmp = new SgAsmCilParamTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilParamTable;  
      SgAsmCilParamTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilPropertyTable ); 
     SgAsmCilPropertyTableStorageClass* storageArraySgAsmCilPropertyTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilPropertyTable = new SgAsmCilPropertyTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilPropertyTable) , sizeof ( SgAsmCilPropertyTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilPropertyTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilPropertyTableStorageClass* storageArray = storageArraySgAsmCilPropertyTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilPropertyTable ( *storageArray ) ; 
#else
               SgAsmCilPropertyTable* tmp = new SgAsmCilPropertyTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilPropertyTable;  
      SgAsmCilPropertyTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilPropertyMapTable ); 
     SgAsmCilPropertyMapTableStorageClass* storageArraySgAsmCilPropertyMapTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilPropertyMapTable = new SgAsmCilPropertyMapTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilPropertyMapTable) , sizeof ( SgAsmCilPropertyMapTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilPropertyMapTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilPropertyMapTableStorageClass* storageArray = storageArraySgAsmCilPropertyMapTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilPropertyMapTable ( *storageArray ) ; 
#else
               SgAsmCilPropertyMapTable* tmp = new SgAsmCilPropertyMapTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilPropertyMapTable;  
      SgAsmCilPropertyMapTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilStandAloneSigTable ); 
     SgAsmCilStandAloneSigTableStorageClass* storageArraySgAsmCilStandAloneSigTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilStandAloneSigTable = new SgAsmCilStandAloneSigTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilStandAloneSigTable) , sizeof ( SgAsmCilStandAloneSigTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilStandAloneSigTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilStandAloneSigTableStorageClass* storageArray = storageArraySgAsmCilStandAloneSigTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilStandAloneSigTable ( *storageArray ) ; 
#else
               SgAsmCilStandAloneSigTable* tmp = new SgAsmCilStandAloneSigTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilStandAloneSigTable;  
      SgAsmCilStandAloneSigTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilTypeDefTable ); 
     SgAsmCilTypeDefTableStorageClass* storageArraySgAsmCilTypeDefTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilTypeDefTable = new SgAsmCilTypeDefTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilTypeDefTable) , sizeof ( SgAsmCilTypeDefTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilTypeDefTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilTypeDefTableStorageClass* storageArray = storageArraySgAsmCilTypeDefTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilTypeDefTable ( *storageArray ) ; 
#else
               SgAsmCilTypeDefTable* tmp = new SgAsmCilTypeDefTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilTypeDefTable;  
      SgAsmCilTypeDefTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilTypeRefTable ); 
     SgAsmCilTypeRefTableStorageClass* storageArraySgAsmCilTypeRefTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilTypeRefTable = new SgAsmCilTypeRefTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilTypeRefTable) , sizeof ( SgAsmCilTypeRefTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilTypeRefTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilTypeRefTableStorageClass* storageArray = storageArraySgAsmCilTypeRefTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilTypeRefTable ( *storageArray ) ; 
#else
               SgAsmCilTypeRefTable* tmp = new SgAsmCilTypeRefTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilTypeRefTable;  
      SgAsmCilTypeRefTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilTypeSpecTable ); 
     SgAsmCilTypeSpecTableStorageClass* storageArraySgAsmCilTypeSpecTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilTypeSpecTable = new SgAsmCilTypeSpecTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilTypeSpecTable) , sizeof ( SgAsmCilTypeSpecTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCilTypeSpecTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilTypeSpecTableStorageClass* storageArray = storageArraySgAsmCilTypeSpecTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilTypeSpecTable ( *storageArray ) ; 
#else
               SgAsmCilTypeSpecTable* tmp = new SgAsmCilTypeSpecTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilTypeSpecTable;  
      SgAsmCilTypeSpecTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJvmComposite ); 
     SgJvmCompositeStorageClass* storageArraySgJvmComposite = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJvmComposite = new SgJvmCompositeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJvmComposite) , sizeof ( SgJvmCompositeStorageClass ) * sizeOfActualPool) ;
        SgJvmCompositeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJvmCompositeStorageClass* storageArray = storageArraySgJvmComposite;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJvmComposite ( *storageArray ) ; 
#else
               SgJvmComposite* tmp = new SgJvmComposite ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJvmComposite;  
      SgJvmCompositeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFortranContinueStmt ); 
     SgFortranContinueStmtStorageClass* storageArraySgFortranContinueStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFortranContinueStmt = new SgFortranContinueStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFortranContinueStmt) , sizeof ( SgFortranContinueStmtStorageClass ) * sizeOfActualPool) ;
        SgFortranContinueStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFortranContinueStmtStorageClass* storageArray = storageArraySgFortranContinueStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgFortranContinueStmt ( *storageArray ) ; 
#else
               SgFortranContinueStmt* tmp = new SgFortranContinueStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFortranContinueStmt;  
      SgFortranContinueStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmStackMapTable ); 
     SgAsmJvmStackMapTableStorageClass* storageArraySgAsmJvmStackMapTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmStackMapTable = new SgAsmJvmStackMapTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmStackMapTable) , sizeof ( SgAsmJvmStackMapTableStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmStackMapTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmStackMapTableStorageClass* storageArray = storageArraySgAsmJvmStackMapTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmStackMapTable ( *storageArray ) ; 
#else
               SgAsmJvmStackMapTable* tmp = new SgAsmJvmStackMapTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmStackMapTable;  
      SgAsmJvmStackMapTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmStackMapFrame ); 
     SgAsmJvmStackMapFrameStorageClass* storageArraySgAsmJvmStackMapFrame = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmStackMapFrame = new SgAsmJvmStackMapFrameStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmStackMapFrame) , sizeof ( SgAsmJvmStackMapFrameStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmStackMapFrameStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmStackMapFrameStorageClass* storageArray = storageArraySgAsmJvmStackMapFrame;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmStackMapFrame ( *storageArray ) ; 
#else
               SgAsmJvmStackMapFrame* tmp = new SgAsmJvmStackMapFrame ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmStackMapFrame;  
      SgAsmJvmStackMapFrameStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmStackMapVerificationType ); 
     SgAsmJvmStackMapVerificationTypeStorageClass* storageArraySgAsmJvmStackMapVerificationType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmStackMapVerificationType = new SgAsmJvmStackMapVerificationTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmStackMapVerificationType) , sizeof ( SgAsmJvmStackMapVerificationTypeStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmStackMapVerificationTypeStorageClass* storageArray = storageArraySgAsmJvmStackMapVerificationType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmStackMapVerificationType ( *storageArray ) ; 
#else
               SgAsmJvmStackMapVerificationType* tmp = new SgAsmJvmStackMapVerificationType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmStackMapVerificationType;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmBootstrapMethod ); 
     SgAsmJvmBootstrapMethodStorageClass* storageArraySgAsmJvmBootstrapMethod = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmBootstrapMethod = new SgAsmJvmBootstrapMethodStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmBootstrapMethod) , sizeof ( SgAsmJvmBootstrapMethodStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmBootstrapMethodStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmBootstrapMethodStorageClass* storageArray = storageArraySgAsmJvmBootstrapMethod;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmBootstrapMethod ( *storageArray ) ; 
#else
               SgAsmJvmBootstrapMethod* tmp = new SgAsmJvmBootstrapMethod ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmBootstrapMethod;  
      SgAsmJvmBootstrapMethodStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmBootstrapMethods ); 
     SgAsmJvmBootstrapMethodsStorageClass* storageArraySgAsmJvmBootstrapMethods = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmBootstrapMethods = new SgAsmJvmBootstrapMethodsStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmBootstrapMethods) , sizeof ( SgAsmJvmBootstrapMethodsStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmBootstrapMethodsStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmBootstrapMethodsStorageClass* storageArray = storageArraySgAsmJvmBootstrapMethods;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmBootstrapMethods ( *storageArray ) ; 
#else
               SgAsmJvmBootstrapMethods* tmp = new SgAsmJvmBootstrapMethods ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmBootstrapMethods;  
      SgAsmJvmBootstrapMethodsStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmExceptions ); 
     SgAsmJvmExceptionsStorageClass* storageArraySgAsmJvmExceptions = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmExceptions = new SgAsmJvmExceptionsStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmExceptions) , sizeof ( SgAsmJvmExceptionsStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmExceptionsStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmExceptionsStorageClass* storageArray = storageArraySgAsmJvmExceptions;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmExceptions ( *storageArray ) ; 
#else
               SgAsmJvmExceptions* tmp = new SgAsmJvmExceptions ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmExceptions;  
      SgAsmJvmExceptionsStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmNestMembers ); 
     SgAsmJvmNestMembersStorageClass* storageArraySgAsmJvmNestMembers = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmNestMembers = new SgAsmJvmNestMembersStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmNestMembers) , sizeof ( SgAsmJvmNestMembersStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmNestMembersStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmNestMembersStorageClass* storageArray = storageArraySgAsmJvmNestMembers;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmNestMembers ( *storageArray ) ; 
#else
               SgAsmJvmNestMembers* tmp = new SgAsmJvmNestMembers ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmNestMembers;  
      SgAsmJvmNestMembersStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmNestHost ); 
     SgAsmJvmNestHostStorageClass* storageArraySgAsmJvmNestHost = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmNestHost = new SgAsmJvmNestHostStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmNestHost) , sizeof ( SgAsmJvmNestHostStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmNestHostStorageClass* storageArray = storageArraySgAsmJvmNestHost;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmNestHost ( *storageArray ) ; 
#else
               SgAsmJvmNestHost* tmp = new SgAsmJvmNestHost ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmNestHost;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJovialLabelDeclaration ); 
     SgJovialLabelDeclarationStorageClass* storageArraySgJovialLabelDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJovialLabelDeclaration = new SgJovialLabelDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJovialLabelDeclaration) , sizeof ( SgJovialLabelDeclarationStorageClass ) * sizeOfActualPool) ;
        SgJovialLabelDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJovialLabelDeclarationStorageClass* storageArray = storageArraySgJovialLabelDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgJovialLabelDeclaration ( *storageArray ) ; 
#else
               SgJovialLabelDeclaration* tmp = new SgJovialLabelDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJovialLabelDeclaration;  
      SgJovialLabelDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmLocalVariableEntry ); 
     SgAsmJvmLocalVariableEntryStorageClass* storageArraySgAsmJvmLocalVariableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmLocalVariableEntry = new SgAsmJvmLocalVariableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmLocalVariableEntry) , sizeof ( SgAsmJvmLocalVariableEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmLocalVariableEntryStorageClass* storageArray = storageArraySgAsmJvmLocalVariableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmLocalVariableEntry ( *storageArray ) ; 
#else
               SgAsmJvmLocalVariableEntry* tmp = new SgAsmJvmLocalVariableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmLocalVariableEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmLocalVariableTable ); 
     SgAsmJvmLocalVariableTableStorageClass* storageArraySgAsmJvmLocalVariableTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmLocalVariableTable = new SgAsmJvmLocalVariableTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmLocalVariableTable) , sizeof ( SgAsmJvmLocalVariableTableStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmLocalVariableTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmLocalVariableTableStorageClass* storageArray = storageArraySgAsmJvmLocalVariableTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmLocalVariableTable ( *storageArray ) ; 
#else
               SgAsmJvmLocalVariableTable* tmp = new SgAsmJvmLocalVariableTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmLocalVariableTable;  
      SgAsmJvmLocalVariableTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmLocalVariableTypeEntry ); 
     SgAsmJvmLocalVariableTypeEntryStorageClass* storageArraySgAsmJvmLocalVariableTypeEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmLocalVariableTypeEntry = new SgAsmJvmLocalVariableTypeEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmLocalVariableTypeEntry) , sizeof ( SgAsmJvmLocalVariableTypeEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmLocalVariableTypeEntryStorageClass* storageArray = storageArraySgAsmJvmLocalVariableTypeEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmLocalVariableTypeEntry ( *storageArray ) ; 
#else
               SgAsmJvmLocalVariableTypeEntry* tmp = new SgAsmJvmLocalVariableTypeEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmLocalVariableTypeEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmLocalVariableTypeTable ); 
     SgAsmJvmLocalVariableTypeTableStorageClass* storageArraySgAsmJvmLocalVariableTypeTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmLocalVariableTypeTable = new SgAsmJvmLocalVariableTypeTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmLocalVariableTypeTable) , sizeof ( SgAsmJvmLocalVariableTypeTableStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmLocalVariableTypeTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmLocalVariableTypeTableStorageClass* storageArray = storageArraySgAsmJvmLocalVariableTypeTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmLocalVariableTypeTable ( *storageArray ) ; 
#else
               SgAsmJvmLocalVariableTypeTable* tmp = new SgAsmJvmLocalVariableTypeTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmLocalVariableTypeTable;  
      SgAsmJvmLocalVariableTypeTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUserInstruction ); 
     SgAsmUserInstructionStorageClass* storageArraySgAsmUserInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUserInstruction = new SgAsmUserInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUserInstruction) , sizeof ( SgAsmUserInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmUserInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUserInstructionStorageClass* storageArray = storageArraySgAsmUserInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmUserInstruction ( *storageArray ) ; 
#else
               SgAsmUserInstruction* tmp = new SgAsmUserInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUserInstruction;  
      SgAsmUserInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmMethodParameters ); 
     SgAsmJvmMethodParametersStorageClass* storageArraySgAsmJvmMethodParameters = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmMethodParameters = new SgAsmJvmMethodParametersStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmMethodParameters) , sizeof ( SgAsmJvmMethodParametersStorageClass ) * sizeOfActualPool) ;
        SgAsmJvmMethodParametersStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmJvmMethodParametersStorageClass* storageArray = storageArraySgAsmJvmMethodParameters;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmMethodParameters ( *storageArray ) ; 
#else
               SgAsmJvmMethodParameters* tmp = new SgAsmJvmMethodParameters ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmMethodParameters;  
      SgAsmJvmMethodParametersStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmMethodParametersEntry ); 
     SgAsmJvmMethodParametersEntryStorageClass* storageArraySgAsmJvmMethodParametersEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmMethodParametersEntry = new SgAsmJvmMethodParametersEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmMethodParametersEntry) , sizeof ( SgAsmJvmMethodParametersEntryStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmMethodParametersEntryStorageClass* storageArray = storageArraySgAsmJvmMethodParametersEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmMethodParametersEntry ( *storageArray ) ; 
#else
               SgAsmJvmMethodParametersEntry* tmp = new SgAsmJvmMethodParametersEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmMethodParametersEntry;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmVoidType ); 
     SgAsmVoidTypeStorageClass* storageArraySgAsmVoidType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmVoidType = new SgAsmVoidTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmVoidType) , sizeof ( SgAsmVoidTypeStorageClass ) * sizeOfActualPool) ;
          SgAsmVoidTypeStorageClass* storageArray = storageArraySgAsmVoidType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmVoidType ( *storageArray ) ; 
#else
               SgAsmVoidType* tmp = new SgAsmVoidType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmVoidType;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPointerType ); 
     SgAsmPointerTypeStorageClass* storageArraySgAsmPointerType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPointerType = new SgAsmPointerTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPointerType) , sizeof ( SgAsmPointerTypeStorageClass ) * sizeOfActualPool) ;
          SgAsmPointerTypeStorageClass* storageArray = storageArraySgAsmPointerType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmPointerType ( *storageArray ) ; 
#else
               SgAsmPointerType* tmp = new SgAsmPointerType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPointerType;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRangeType ); 
     SgRangeTypeStorageClass* storageArraySgRangeType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRangeType = new SgRangeTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRangeType) , sizeof ( SgRangeTypeStorageClass ) * sizeOfActualPool) ;
        SgRangeTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRangeTypeStorageClass* storageArray = storageArraySgRangeType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgRangeType ( *storageArray ) ; 
#else
               SgRangeType* tmp = new SgRangeType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRangeType;  
      SgRangeTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilExceptionData ); 
     SgAsmCilExceptionDataStorageClass* storageArraySgAsmCilExceptionData = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilExceptionData = new SgAsmCilExceptionDataStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilExceptionData) , sizeof ( SgAsmCilExceptionDataStorageClass ) * sizeOfActualPool) ;
          SgAsmCilExceptionDataStorageClass* storageArray = storageArraySgAsmCilExceptionData;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilExceptionData ( *storageArray ) ; 
#else
               SgAsmCilExceptionData* tmp = new SgAsmCilExceptionData ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilExceptionData;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilMethodData ); 
     SgAsmCilMethodDataStorageClass* storageArraySgAsmCilMethodData = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilMethodData = new SgAsmCilMethodDataStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilMethodData) , sizeof ( SgAsmCilMethodDataStorageClass ) * sizeOfActualPool) ;
        SgAsmCilMethodDataStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilMethodDataStorageClass* storageArray = storageArraySgAsmCilMethodData;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilMethodData ( *storageArray ) ; 
#else
               SgAsmCilMethodData* tmp = new SgAsmCilMethodData ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilMethodData;  
      SgAsmCilMethodDataStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateVariableInstantiation ); 
     SgTemplateVariableInstantiationStorageClass* storageArraySgTemplateVariableInstantiation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateVariableInstantiation = new SgTemplateVariableInstantiationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateVariableInstantiation) , sizeof ( SgTemplateVariableInstantiationStorageClass ) * sizeOfActualPool) ;
        SgTemplateVariableInstantiationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateVariableInstantiationStorageClass* storageArray = storageArraySgTemplateVariableInstantiation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTemplateVariableInstantiation ( *storageArray ) ; 
#else
               SgTemplateVariableInstantiation* tmp = new SgTemplateVariableInstantiation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateVariableInstantiation;  
      SgTemplateVariableInstantiationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgReferenceExp ); 
     SgReferenceExpStorageClass* storageArraySgReferenceExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgReferenceExp = new SgReferenceExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgReferenceExp) , sizeof ( SgReferenceExpStorageClass ) * sizeOfActualPool) ;
        SgReferenceExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgReferenceExpStorageClass* storageArray = storageArraySgReferenceExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgReferenceExp ( *storageArray ) ; 
#else
               SgReferenceExp* tmp = new SgReferenceExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgReferenceExp;  
      SgReferenceExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeRefExp ); 
     SgTypeRefExpStorageClass* storageArraySgTypeRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeRefExp = new SgTypeRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeRefExp) , sizeof ( SgTypeRefExpStorageClass ) * sizeOfActualPool) ;
        SgTypeRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeRefExpStorageClass* storageArray = storageArraySgTypeRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeRefExp ( *storageArray ) ; 
#else
               SgTypeRefExp* tmp = new SgTypeRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeRefExp;  
      SgTypeRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgScopedRefExp ); 
     SgScopedRefExpStorageClass* storageArraySgScopedRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgScopedRefExp = new SgScopedRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgScopedRefExp) , sizeof ( SgScopedRefExpStorageClass ) * sizeOfActualPool) ;
        SgScopedRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgScopedRefExpStorageClass* storageArray = storageArraySgScopedRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgScopedRefExp ( *storageArray ) ; 
#else
               SgScopedRefExp* tmp = new SgScopedRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgScopedRefExp;  
      SgScopedRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgScopedType ); 
     SgScopedTypeStorageClass* storageArraySgScopedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgScopedType = new SgScopedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgScopedType) , sizeof ( SgScopedTypeStorageClass ) * sizeOfActualPool) ;
        SgScopedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgScopedTypeStorageClass* storageArray = storageArraySgScopedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgScopedType ( *storageArray ) ; 
#else
               SgScopedType* tmp = new SgScopedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgScopedType;  
      SgScopedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSymbol ); 
     SgTypeSymbolStorageClass* storageArraySgTypeSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSymbol = new SgTypeSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSymbol) , sizeof ( SgTypeSymbolStorageClass ) * sizeOfActualPool) ;
        SgTypeSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSymbolStorageClass* storageArray = storageArraySgTypeSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgTypeSymbol ( *storageArray ) ; 
#else
               SgTypeSymbol* tmp = new SgTypeSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSymbol;  
      SgTypeSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmSynthetic ); 
     SgAsmJvmSyntheticStorageClass* storageArraySgAsmJvmSynthetic = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmSynthetic = new SgAsmJvmSyntheticStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmSynthetic) , sizeof ( SgAsmJvmSyntheticStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmSyntheticStorageClass* storageArray = storageArraySgAsmJvmSynthetic;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmSynthetic ( *storageArray ) ; 
#else
               SgAsmJvmSynthetic* tmp = new SgAsmJvmSynthetic ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmSynthetic;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmJvmDeprecated ); 
     SgAsmJvmDeprecatedStorageClass* storageArraySgAsmJvmDeprecated = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmJvmDeprecated = new SgAsmJvmDeprecatedStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmJvmDeprecated) , sizeof ( SgAsmJvmDeprecatedStorageClass ) * sizeOfActualPool) ;
          SgAsmJvmDeprecatedStorageClass* storageArray = storageArraySgAsmJvmDeprecated;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmJvmDeprecated ( *storageArray ) ; 
#else
               SgAsmJvmDeprecated* tmp = new SgAsmJvmDeprecated ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmJvmDeprecated;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSignedCharVal ); 
     SgSignedCharValStorageClass* storageArraySgSignedCharVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSignedCharVal = new SgSignedCharValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSignedCharVal) , sizeof ( SgSignedCharValStorageClass ) * sizeOfActualPool) ;
        SgSignedCharValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSignedCharValStorageClass* storageArray = storageArraySgSignedCharVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgSignedCharVal ( *storageArray ) ; 
#else
               SgSignedCharVal* tmp = new SgSignedCharVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSignedCharVal;  
      SgSignedCharValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCilErrorHeap ); 
     SgAsmCilErrorHeapStorageClass* storageArraySgAsmCilErrorHeap = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCilErrorHeap = new SgAsmCilErrorHeapStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCilErrorHeap) , sizeof ( SgAsmCilErrorHeapStorageClass ) * sizeOfActualPool) ;
        SgAsmCilErrorHeapStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCilErrorHeapStorageClass* storageArray = storageArraySgAsmCilErrorHeap;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
#ifdef NDEBUG
               new SgAsmCilErrorHeap ( *storageArray ) ; 
#else
               SgAsmCilErrorHeap* tmp = new SgAsmCilErrorHeap ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
#endif
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCilErrorHeap;  
      SgAsmCilErrorHeapStorageClass :: deleteStaticDataOfEasyStorageClasses();



/* #line 791 "/workspace/generated/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

     }

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() rebuild AST (part 3):");

     for ( int i = 0; i < totalNumberOfIRNodes; ++i)
        {
          listOfMemoryPoolSizes[i] += getPoolSizeOfNewAst(i);
        }
     listOfMemoryPoolSizes[totalNumberOfIRNodes] += getTotalNumberOfNodesOfNewAst();

     freepointersOfCurrentAstAreSetToGlobalIndices = false;
     std::string endString = "ROSE_AST_BINARY_END";
     char* endChar = new char [ endString.size() + 1];
     endChar[ endString.size() ] = '\0';
     inFile.read ( endChar , endString.size() );
     assert (inFile);
     assert ( string(endChar) == endString );
     delete [] endChar;
     }

     SgProject* returnPointer = actualRebuildAst->getRootOfAst();
     assert ( returnPointer != NULL );
     
#if FILE_IO_EXTRA_CHECK
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() FILE_IO_EXTRA_CHECK:");

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries .... " << std::endl;

#if FILE_IO_MEMORY_POOL_CHECK
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     memoryCheckingTraversal.traverseMemoryPool();
#endif
#endif

     return returnPointer;
   }

/* JH (01/03/2006) This method reads an AST in binary format from the file 
*/
SgProject*
AST_FILE_IO :: readASTFromFile ( std::string fileName )
  {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::readASTFromFile() time (sec) = ");
 
     std::ifstream inFile;
     inFile.open ( fileName.c_str(), std::ios::in | std::ios::binary );
     if ( !inFile )
        {
          std::cout << "Problems opening file " << fileName << " for reading AST!" << std::endl;
          exit(-1);
        }
     SgProject* returnPointer = AST_FILE_IO::readASTFromStream(inFile);

     inFile.close() ;

     return returnPointer;
   }

SgProject*
AST_FILE_IO :: readASTFromString ( const std::string& s )
  {
    std::istringstream inFile(s);
    return AST_FILE_IO::readASTFromStream(inFile);
  }


// DQ (2/27/2010): Reset the AST File I/O data structures to permit writing a file after the reading and merging of files.
void
AST_FILE_IO::reset()
   {
  // This function reset the static data in AST_FILE_IO so that files read can 
  // be written out again (e.g. after a merge of reading multiple files).

     freepointersOfCurrentAstAreSetToGlobalIndices = false;

     for (int i = 0; i < V_SgNumVariants; i++)
        {
       // listOfMemoryPoolSizes[i] = 0;
        }

     registeredAttributes.clear();

     for (size_t i = 0; i < vectorOfASTs.size(); i++)
        {
          vectorOfASTs[i] = NULL;
        }
     vectorOfASTs.clear();

     actualRebuildAst = NULL;
   }


// DQ (2/27/2010): Show what the values are for debugging (e.g. write after read).
void
AST_FILE_IO::display(const std::string & label)
   {
  // This function is useful for viewing the static (private) data member in the AST_FILE_IO class.

     printf ("In AST_FILE_IO::display (label = %s) \n",label.c_str());

     printf ("freepointersOfCurrentAstAreSetToGlobalIndices = %s \n",freepointersOfCurrentAstAreSetToGlobalIndices ? "true" : "false");

     int numberOfDifferentIRnodes = 0;
     for (int i = 0; i < V_SgNumVariants; i++)
        {
          if (listOfMemoryPoolSizes[i] > 0)
             {
               printf ("listOfMemoryPoolSizes [%s] = %lu \n",roseGlobalVariantNameList[i],listOfMemoryPoolSizes[i]);
               numberOfDifferentIRnodes++;
             }
        }
     printf ("Number of different types of IR nodes = %d \n",numberOfDifferentIRnodes);

     printf ("registeredAttributes.size() = %" PRIuPTR " \n",registeredAttributes.size());
     for (std::map <std::string,CONSTRUCTOR>::iterator i = registeredAttributes.begin(); i != registeredAttributes.end(); i++)
        {
       // This is a map of strings to function pointers (registered pack and unpack functions).
          printf ("i->first = %s  i->second = member function \n",i->first.c_str());
        }

     printf ("vectorOfASTs.size() = %" PRIuPTR " \n",vectorOfASTs.size());
     for (size_t i = 0; i < vectorOfASTs.size(); i++)
        {
       // This is a map of strings to function pointers (registered pack and unpack functions).
          printf ("vectorOfASTs[%" PRIuPTR "] = %p \n",i,vectorOfASTs[i]);
        }

     printf ("actualRebuildAst = %p \n",actualRebuildAst);
   }


