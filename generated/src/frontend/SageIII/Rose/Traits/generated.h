#ifndef Rose_Traits_generated_h
#define Rose_Traits_generated_h
namespace Rose {
namespace Traits {
namespace generated {
// Class: AccessModifier
template <> struct describe_field_t<SgAccessModifier,SgAccessModifier::access_modifier_enum,&SgAccessModifier::p_modifier> {
  using parent = SgAccessModifier;
  using field_type = SgAccessModifier::access_modifier_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgAccessModifier::access_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAccessModifier::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAccessModifier, SgAccessModifier::access_modifier_enum SgAccessModifier::*, &SgAccessModifier::p_modifier>;
};
template <> struct describe_node_t<SgAccessModifier> {
  using node = SgAccessModifier;
  using base = SgModifier;
  static constexpr char const * const name{"AccessModifier"};
  static constexpr unsigned long variant{1};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAccessModifier,SgAccessModifier::access_modifier_enum,&SgAccessModifier::p_modifier>>;
};
template <> struct node_from_variant_t<1> { using type = SgAccessModifier; };

// Class: ActualArgumentExpression
template <> struct describe_field_t<SgActualArgumentExpression,SgName,&SgActualArgumentExpression::p_argument_name> {
  using parent = SgActualArgumentExpression;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"argument_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgActualArgumentExpression::p_argument_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgActualArgumentExpression, SgName SgActualArgumentExpression::*, &SgActualArgumentExpression::p_argument_name>;
};
template <> struct describe_field_t<SgActualArgumentExpression,SgExpression*,&SgActualArgumentExpression::p_expression> {
  using parent = SgActualArgumentExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgActualArgumentExpression::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgActualArgumentExpression, SgExpression* SgActualArgumentExpression::*, &SgActualArgumentExpression::p_expression>;
};
template <> struct describe_node_t<SgActualArgumentExpression> {
  using node = SgActualArgumentExpression;
  using base = SgExpression;
  static constexpr char const * const name{"ActualArgumentExpression"};
  static constexpr unsigned long variant{2};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgActualArgumentExpression,SgName,&SgActualArgumentExpression::p_argument_name>, describe_field_t<SgActualArgumentExpression,SgExpression*,&SgActualArgumentExpression::p_expression>>;
};
template <> struct node_from_variant_t<2> { using type = SgActualArgumentExpression; };

// Class: AbsOp
template <> struct describe_node_t<SgAbsOp> {
  using node = SgAbsOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"AbsOp"};
  static constexpr unsigned long variant{3};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<3> { using type = SgAbsOp; };

// Class: AdaAccessType
template <> struct describe_field_t<SgAdaAccessType,SgType*,&SgAdaAccessType::p_base_type> {
  using parent = SgAdaAccessType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAccessType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAccessType, SgType* SgAdaAccessType::*, &SgAdaAccessType::p_base_type>;
};
template <> struct describe_field_t<SgAdaAccessType,bool,&SgAdaAccessType::p_is_general_access> {
  using parent = SgAdaAccessType;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"is_general_access"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaAccessType::p_is_general_access};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAccessType, bool SgAdaAccessType::*, &SgAdaAccessType::p_is_general_access>;
};
template <> struct describe_field_t<SgAdaAccessType,bool,&SgAdaAccessType::p_is_anonymous> {
  using parent = SgAdaAccessType;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"is_anonymous"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaAccessType::p_is_anonymous};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAccessType, bool SgAdaAccessType::*, &SgAdaAccessType::p_is_anonymous>;
};
template <> struct describe_node_t<SgAdaAccessType> {
  using node = SgAdaAccessType;
  using base = SgType;
  static constexpr char const * const name{"AdaAccessType"};
  static constexpr unsigned long variant{4};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaAccessType,SgType*,&SgAdaAccessType::p_base_type>, describe_field_t<SgAdaAccessType,bool,&SgAdaAccessType::p_is_general_access>, describe_field_t<SgAdaAccessType,bool,&SgAdaAccessType::p_is_anonymous>>;
};
template <> struct node_from_variant_t<4> { using type = SgAdaAccessType; };

// Class: AdaAcceptStmt
template <> struct describe_field_t<SgAdaAcceptStmt,SgFunctionParameterScope*,&SgAdaAcceptStmt::p_parameterScope> {
  using parent = SgAdaAcceptStmt;
  using field_type = SgFunctionParameterScope*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"parameterScope"};
  static constexpr char const * const typestr{"SgFunctionParameterScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaAcceptStmt::p_parameterScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAcceptStmt, SgFunctionParameterScope* SgAdaAcceptStmt::*, &SgAdaAcceptStmt::p_parameterScope>;
};
template <> struct describe_field_t<SgAdaAcceptStmt,SgFunctionParameterList*,&SgAdaAcceptStmt::p_parameterList> {
  using parent = SgAdaAcceptStmt;
  using field_type = SgFunctionParameterList*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"parameterList"};
  static constexpr char const * const typestr{"SgFunctionParameterList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAcceptStmt::p_parameterList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAcceptStmt, SgFunctionParameterList* SgAdaAcceptStmt::*, &SgAdaAcceptStmt::p_parameterList>;
};
template <> struct describe_field_t<SgAdaAcceptStmt,SgExpression*,&SgAdaAcceptStmt::p_entry> {
  using parent = SgAdaAcceptStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"entry"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAcceptStmt::p_entry};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAcceptStmt, SgExpression* SgAdaAcceptStmt::*, &SgAdaAcceptStmt::p_entry>;
};
template <> struct describe_field_t<SgAdaAcceptStmt,SgExpression*,&SgAdaAcceptStmt::p_index> {
  using parent = SgAdaAcceptStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAcceptStmt::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAcceptStmt, SgExpression* SgAdaAcceptStmt::*, &SgAdaAcceptStmt::p_index>;
};
template <> struct describe_field_t<SgAdaAcceptStmt,SgStatement*,&SgAdaAcceptStmt::p_body> {
  using parent = SgAdaAcceptStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAcceptStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAcceptStmt, SgStatement* SgAdaAcceptStmt::*, &SgAdaAcceptStmt::p_body>;
};
template <> struct describe_node_t<SgAdaAcceptStmt> {
  using node = SgAdaAcceptStmt;
  using base = SgScopeStatement;
  static constexpr char const * const name{"AdaAcceptStmt"};
  static constexpr unsigned long variant{5};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaAcceptStmt,SgFunctionParameterScope*,&SgAdaAcceptStmt::p_parameterScope>, describe_field_t<SgAdaAcceptStmt,SgFunctionParameterList*,&SgAdaAcceptStmt::p_parameterList>, describe_field_t<SgAdaAcceptStmt,SgExpression*,&SgAdaAcceptStmt::p_entry>, describe_field_t<SgAdaAcceptStmt,SgExpression*,&SgAdaAcceptStmt::p_index>, describe_field_t<SgAdaAcceptStmt,SgStatement*,&SgAdaAcceptStmt::p_body>>;
};
template <> struct node_from_variant_t<5> { using type = SgAdaAcceptStmt; };

// Class: AdaDelayStmt
template <> struct describe_field_t<SgAdaDelayStmt,SgExpression*,&SgAdaDelayStmt::p_time> {
  using parent = SgAdaDelayStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"time"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaDelayStmt::p_time};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDelayStmt, SgExpression* SgAdaDelayStmt::*, &SgAdaDelayStmt::p_time>;
};
template <> struct describe_field_t<SgAdaDelayStmt,bool,&SgAdaDelayStmt::p_isRelative> {
  using parent = SgAdaDelayStmt;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"isRelative"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaDelayStmt::p_isRelative};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDelayStmt, bool SgAdaDelayStmt::*, &SgAdaDelayStmt::p_isRelative>;
};
template <> struct describe_node_t<SgAdaDelayStmt> {
  using node = SgAdaDelayStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AdaDelayStmt"};
  static constexpr unsigned long variant{6};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaDelayStmt,SgExpression*,&SgAdaDelayStmt::p_time>, describe_field_t<SgAdaDelayStmt,bool,&SgAdaDelayStmt::p_isRelative>>;
};
template <> struct node_from_variant_t<6> { using type = SgAdaDelayStmt; };

// Class: AdaEntryDecl
template <> struct describe_field_t<SgAdaEntryDecl,SgInitializedName*,&SgAdaEntryDecl::p_entryIndex> {
  using parent = SgAdaEntryDecl;
  using field_type = SgInitializedName*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entryIndex"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaEntryDecl::p_entryIndex};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaEntryDecl, SgInitializedName* SgAdaEntryDecl::*, &SgAdaEntryDecl::p_entryIndex>;
};
template <> struct describe_field_t<SgAdaEntryDecl,SgExpression*,&SgAdaEntryDecl::p_entryBarrier> {
  using parent = SgAdaEntryDecl;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"entryBarrier"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaEntryDecl::p_entryBarrier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaEntryDecl, SgExpression* SgAdaEntryDecl::*, &SgAdaEntryDecl::p_entryBarrier>;
};
template <> struct describe_node_t<SgAdaEntryDecl> {
  using node = SgAdaEntryDecl;
  using base = SgFunctionDeclaration;
  static constexpr char const * const name{"AdaEntryDecl"};
  static constexpr unsigned long variant{7};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaEntryDecl,SgInitializedName*,&SgAdaEntryDecl::p_entryIndex>, describe_field_t<SgAdaEntryDecl,SgExpression*,&SgAdaEntryDecl::p_entryBarrier>>;
};
template <> struct node_from_variant_t<7> { using type = SgAdaEntryDecl; };

// Class: AdaExitStmt
template <> struct describe_field_t<SgAdaExitStmt,SgStatement*,&SgAdaExitStmt::p_loop> {
  using parent = SgAdaExitStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"loop"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaExitStmt::p_loop};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaExitStmt, SgStatement* SgAdaExitStmt::*, &SgAdaExitStmt::p_loop>;
};
template <> struct describe_field_t<SgAdaExitStmt,SgExpression*,&SgAdaExitStmt::p_condition> {
  using parent = SgAdaExitStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"condition"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaExitStmt::p_condition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaExitStmt, SgExpression* SgAdaExitStmt::*, &SgAdaExitStmt::p_condition>;
};
template <> struct describe_field_t<SgAdaExitStmt,bool,&SgAdaExitStmt::p_explicitLoopName> {
  using parent = SgAdaExitStmt;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"explicitLoopName"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaExitStmt::p_explicitLoopName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaExitStmt, bool SgAdaExitStmt::*, &SgAdaExitStmt::p_explicitLoopName>;
};
template <> struct describe_node_t<SgAdaExitStmt> {
  using node = SgAdaExitStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AdaExitStmt"};
  static constexpr unsigned long variant{8};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaExitStmt,SgStatement*,&SgAdaExitStmt::p_loop>, describe_field_t<SgAdaExitStmt,SgExpression*,&SgAdaExitStmt::p_condition>, describe_field_t<SgAdaExitStmt,bool,&SgAdaExitStmt::p_explicitLoopName>>;
};
template <> struct node_from_variant_t<8> { using type = SgAdaExitStmt; };

// Class: AdaDiscreteType
template <> struct describe_node_t<SgAdaDiscreteType> {
  using node = SgAdaDiscreteType;
  using base = SgType;
  static constexpr char const * const name{"AdaDiscreteType"};
  static constexpr unsigned long variant{9};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<9> { using type = SgAdaDiscreteType; };

// Class: AdaFloatVal
template <> struct describe_field_t<SgAdaFloatVal,std::string,&SgAdaFloatVal::p_valueString> {
  using parent = SgAdaFloatVal;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFloatVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFloatVal, std::string SgAdaFloatVal::*, &SgAdaFloatVal::p_valueString>;
};
template <> struct describe_node_t<SgAdaFloatVal> {
  using node = SgAdaFloatVal;
  using base = SgValueExp;
  static constexpr char const * const name{"AdaFloatVal"};
  static constexpr unsigned long variant{10};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaFloatVal,std::string,&SgAdaFloatVal::p_valueString>>;
};
template <> struct node_from_variant_t<10> { using type = SgAdaFloatVal; };

// Class: AdaLoopStmt
template <> struct describe_field_t<SgAdaLoopStmt,SgBasicBlock*,&SgAdaLoopStmt::p_body> {
  using parent = SgAdaLoopStmt;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaLoopStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaLoopStmt, SgBasicBlock* SgAdaLoopStmt::*, &SgAdaLoopStmt::p_body>;
};
template <> struct describe_field_t<SgAdaLoopStmt,std::string,&SgAdaLoopStmt::p_string_label> {
  using parent = SgAdaLoopStmt;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaLoopStmt::p_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaLoopStmt, std::string SgAdaLoopStmt::*, &SgAdaLoopStmt::p_string_label>;
};
template <> struct describe_node_t<SgAdaLoopStmt> {
  using node = SgAdaLoopStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AdaLoopStmt"};
  static constexpr unsigned long variant{11};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaLoopStmt,SgBasicBlock*,&SgAdaLoopStmt::p_body>, describe_field_t<SgAdaLoopStmt,std::string,&SgAdaLoopStmt::p_string_label>>;
};
template <> struct node_from_variant_t<11> { using type = SgAdaLoopStmt; };

// Class: AdaPackageBody
template <> struct describe_field_t<SgAdaPackageBody,SgStatementPtrList,&SgAdaPackageBody::p_statements> {
  using parent = SgAdaPackageBody;
  using field_type = SgStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"statements"};
  static constexpr char const * const typestr{"SgStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaPackageBody::p_statements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageBody, SgStatementPtrList SgAdaPackageBody::*, &SgAdaPackageBody::p_statements>;
};
template <> struct describe_node_t<SgAdaPackageBody> {
  using node = SgAdaPackageBody;
  using base = SgScopeStatement;
  static constexpr char const * const name{"AdaPackageBody"};
  static constexpr unsigned long variant{12};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaPackageBody,SgStatementPtrList,&SgAdaPackageBody::p_statements>>;
};
template <> struct node_from_variant_t<12> { using type = SgAdaPackageBody; };

// Class: AdaPackageBodyDecl
template <> struct describe_field_t<SgAdaPackageBodyDecl,SgName,&SgAdaPackageBodyDecl::p_name> {
  using parent = SgAdaPackageBodyDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaPackageBodyDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageBodyDecl, SgName SgAdaPackageBodyDecl::*, &SgAdaPackageBodyDecl::p_name>;
};
template <> struct describe_field_t<SgAdaPackageBodyDecl,SgAdaPackageBody*,&SgAdaPackageBodyDecl::p_definition> {
  using parent = SgAdaPackageBodyDecl;
  using field_type = SgAdaPackageBody*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgAdaPackageBody*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaPackageBodyDecl::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageBodyDecl, SgAdaPackageBody* SgAdaPackageBodyDecl::*, &SgAdaPackageBodyDecl::p_definition>;
};
template <> struct describe_field_t<SgAdaPackageBodyDecl,SgScopeStatement*,&SgAdaPackageBodyDecl::p_scope> {
  using parent = SgAdaPackageBodyDecl;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaPackageBodyDecl::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageBodyDecl, SgScopeStatement* SgAdaPackageBodyDecl::*, &SgAdaPackageBodyDecl::p_scope>;
};
template <> struct describe_field_t<SgAdaPackageBodyDecl,SgAdaPackageSpecDecl*,&SgAdaPackageBodyDecl::p_spec> {
  using parent = SgAdaPackageBodyDecl;
  using field_type = SgAdaPackageSpecDecl*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"spec"};
  static constexpr char const * const typestr{"SgAdaPackageSpecDecl*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaPackageBodyDecl::p_spec};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageBodyDecl, SgAdaPackageSpecDecl* SgAdaPackageBodyDecl::*, &SgAdaPackageBodyDecl::p_spec>;
};
template <> struct describe_node_t<SgAdaPackageBodyDecl> {
  using node = SgAdaPackageBodyDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaPackageBodyDecl"};
  static constexpr unsigned long variant{13};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaPackageBodyDecl,SgName,&SgAdaPackageBodyDecl::p_name>, describe_field_t<SgAdaPackageBodyDecl,SgAdaPackageBody*,&SgAdaPackageBodyDecl::p_definition>, describe_field_t<SgAdaPackageBodyDecl,SgScopeStatement*,&SgAdaPackageBodyDecl::p_scope>, describe_field_t<SgAdaPackageBodyDecl,SgAdaPackageSpecDecl*,&SgAdaPackageBodyDecl::p_spec>>;
};
template <> struct node_from_variant_t<13> { using type = SgAdaPackageBodyDecl; };

// Class: AdaPackageSpec
template <> struct describe_field_t<SgAdaPackageSpec,bool,&SgAdaPackageSpec::p_hasPrivate> {
  using parent = SgAdaPackageSpec;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"hasPrivate"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaPackageSpec::p_hasPrivate};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageSpec, bool SgAdaPackageSpec::*, &SgAdaPackageSpec::p_hasPrivate>;
};
template <> struct describe_field_t<SgAdaPackageSpec,SgDeclarationStatementPtrList,&SgAdaPackageSpec::p_declarations> {
  using parent = SgAdaPackageSpec;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"declarations"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaPackageSpec::p_declarations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageSpec, SgDeclarationStatementPtrList SgAdaPackageSpec::*, &SgAdaPackageSpec::p_declarations>;
};
template <> struct describe_node_t<SgAdaPackageSpec> {
  using node = SgAdaPackageSpec;
  using base = SgScopeStatement;
  static constexpr char const * const name{"AdaPackageSpec"};
  static constexpr unsigned long variant{14};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaPackageSpec,bool,&SgAdaPackageSpec::p_hasPrivate>, describe_field_t<SgAdaPackageSpec,SgDeclarationStatementPtrList,&SgAdaPackageSpec::p_declarations>>;
};
template <> struct node_from_variant_t<14> { using type = SgAdaPackageSpec; };

// Class: AdaPackageSpecDecl
template <> struct describe_field_t<SgAdaPackageSpecDecl,SgName,&SgAdaPackageSpecDecl::p_name> {
  using parent = SgAdaPackageSpecDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaPackageSpecDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageSpecDecl, SgName SgAdaPackageSpecDecl::*, &SgAdaPackageSpecDecl::p_name>;
};
template <> struct describe_field_t<SgAdaPackageSpecDecl,SgAdaPackageSpec*,&SgAdaPackageSpecDecl::p_definition> {
  using parent = SgAdaPackageSpecDecl;
  using field_type = SgAdaPackageSpec*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgAdaPackageSpec*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaPackageSpecDecl::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageSpecDecl, SgAdaPackageSpec* SgAdaPackageSpecDecl::*, &SgAdaPackageSpecDecl::p_definition>;
};
template <> struct describe_field_t<SgAdaPackageSpecDecl,SgScopeStatement*,&SgAdaPackageSpecDecl::p_scope> {
  using parent = SgAdaPackageSpecDecl;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaPackageSpecDecl::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageSpecDecl, SgScopeStatement* SgAdaPackageSpecDecl::*, &SgAdaPackageSpecDecl::p_scope>;
};
template <> struct describe_field_t<SgAdaPackageSpecDecl,SgAdaPackageBodyDecl*,&SgAdaPackageSpecDecl::p_body> {
  using parent = SgAdaPackageSpecDecl;
  using field_type = SgAdaPackageBodyDecl*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAdaPackageBodyDecl*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaPackageSpecDecl::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageSpecDecl, SgAdaPackageBodyDecl* SgAdaPackageSpecDecl::*, &SgAdaPackageSpecDecl::p_body>;
};
template <> struct describe_node_t<SgAdaPackageSpecDecl> {
  using node = SgAdaPackageSpecDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaPackageSpecDecl"};
  static constexpr unsigned long variant{15};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaPackageSpecDecl,SgName,&SgAdaPackageSpecDecl::p_name>, describe_field_t<SgAdaPackageSpecDecl,SgAdaPackageSpec*,&SgAdaPackageSpecDecl::p_definition>, describe_field_t<SgAdaPackageSpecDecl,SgScopeStatement*,&SgAdaPackageSpecDecl::p_scope>, describe_field_t<SgAdaPackageSpecDecl,SgAdaPackageBodyDecl*,&SgAdaPackageSpecDecl::p_body>>;
};
template <> struct node_from_variant_t<15> { using type = SgAdaPackageSpecDecl; };

// Class: AdaPackageSymbol
template <> struct describe_field_t<SgAdaPackageSymbol,SgDeclarationStatement*,&SgAdaPackageSymbol::p_declaration> {
  using parent = SgAdaPackageSymbol;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaPackageSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaPackageSymbol, SgDeclarationStatement* SgAdaPackageSymbol::*, &SgAdaPackageSymbol::p_declaration>;
};
template <> struct describe_node_t<SgAdaPackageSymbol> {
  using node = SgAdaPackageSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AdaPackageSymbol"};
  static constexpr unsigned long variant{16};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaPackageSymbol,SgDeclarationStatement*,&SgAdaPackageSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<16> { using type = SgAdaPackageSymbol; };

// Class: AdaRangeConstraint
template <> struct describe_field_t<SgAdaRangeConstraint,SgExpression*,&SgAdaRangeConstraint::p_range> {
  using parent = SgAdaRangeConstraint;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"range"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaRangeConstraint::p_range};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaRangeConstraint, SgExpression* SgAdaRangeConstraint::*, &SgAdaRangeConstraint::p_range>;
};
template <> struct describe_node_t<SgAdaRangeConstraint> {
  using node = SgAdaRangeConstraint;
  using base = SgAdaTypeConstraint;
  static constexpr char const * const name{"AdaRangeConstraint"};
  static constexpr unsigned long variant{17};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaRangeConstraint,SgExpression*,&SgAdaRangeConstraint::p_range>>;
};
template <> struct node_from_variant_t<17> { using type = SgAdaRangeConstraint; };

// Class: AdaRenamingDecl
template <> struct describe_field_t<SgAdaRenamingDecl,SgName,&SgAdaRenamingDecl::p_name> {
  using parent = SgAdaRenamingDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaRenamingDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaRenamingDecl, SgName SgAdaRenamingDecl::*, &SgAdaRenamingDecl::p_name>;
};
template <> struct describe_field_t<SgAdaRenamingDecl,SgExpression*,&SgAdaRenamingDecl::p_renamed> {
  using parent = SgAdaRenamingDecl;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"renamed"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaRenamingDecl::p_renamed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaRenamingDecl, SgExpression* SgAdaRenamingDecl::*, &SgAdaRenamingDecl::p_renamed>;
};
template <> struct describe_field_t<SgAdaRenamingDecl,SgType*,&SgAdaRenamingDecl::p_type> {
  using parent = SgAdaRenamingDecl;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaRenamingDecl::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaRenamingDecl, SgType* SgAdaRenamingDecl::*, &SgAdaRenamingDecl::p_type>;
};
template <> struct describe_node_t<SgAdaRenamingDecl> {
  using node = SgAdaRenamingDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaRenamingDecl"};
  static constexpr unsigned long variant{18};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaRenamingDecl,SgName,&SgAdaRenamingDecl::p_name>, describe_field_t<SgAdaRenamingDecl,SgExpression*,&SgAdaRenamingDecl::p_renamed>, describe_field_t<SgAdaRenamingDecl,SgType*,&SgAdaRenamingDecl::p_type>>;
};
template <> struct node_from_variant_t<18> { using type = SgAdaRenamingDecl; };

// Class: AdaSubtype
template <> struct describe_field_t<SgAdaSubtype,SgType*,&SgAdaSubtype::p_base_type> {
  using parent = SgAdaSubtype;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSubtype::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSubtype, SgType* SgAdaSubtype::*, &SgAdaSubtype::p_base_type>;
};
template <> struct describe_field_t<SgAdaSubtype,SgAdaTypeConstraint*,&SgAdaSubtype::p_constraint> {
  using parent = SgAdaSubtype;
  using field_type = SgAdaTypeConstraint*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"constraint"};
  static constexpr char const * const typestr{"SgAdaTypeConstraint*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSubtype::p_constraint};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSubtype, SgAdaTypeConstraint* SgAdaSubtype::*, &SgAdaSubtype::p_constraint>;
};
template <> struct describe_field_t<SgAdaSubtype,bool,&SgAdaSubtype::p_fromRootType> {
  using parent = SgAdaSubtype;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"fromRootType"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaSubtype::p_fromRootType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSubtype, bool SgAdaSubtype::*, &SgAdaSubtype::p_fromRootType>;
};
template <> struct describe_node_t<SgAdaSubtype> {
  using node = SgAdaSubtype;
  using base = SgType;
  static constexpr char const * const name{"AdaSubtype"};
  static constexpr unsigned long variant{19};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaSubtype,SgType*,&SgAdaSubtype::p_base_type>, describe_field_t<SgAdaSubtype,SgAdaTypeConstraint*,&SgAdaSubtype::p_constraint>, describe_field_t<SgAdaSubtype,bool,&SgAdaSubtype::p_fromRootType>>;
};
template <> struct node_from_variant_t<19> { using type = SgAdaSubtype; };

// Class: AdaTaskBody
template <> struct describe_field_t<SgAdaTaskBody,SgAdaTaskSpec*,&SgAdaTaskBody::p_spec> {
  using parent = SgAdaTaskBody;
  using field_type = SgAdaTaskSpec*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"spec"};
  static constexpr char const * const typestr{"SgAdaTaskSpec*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskBody::p_spec};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskBody, SgAdaTaskSpec* SgAdaTaskBody::*, &SgAdaTaskBody::p_spec>;
};
template <> struct describe_field_t<SgAdaTaskBody,SgStatementPtrList,&SgAdaTaskBody::p_statements> {
  using parent = SgAdaTaskBody;
  using field_type = SgStatementPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"statements"};
  static constexpr char const * const typestr{"SgStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaTaskBody::p_statements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskBody, SgStatementPtrList SgAdaTaskBody::*, &SgAdaTaskBody::p_statements>;
};
template <> struct describe_node_t<SgAdaTaskBody> {
  using node = SgAdaTaskBody;
  using base = SgScopeStatement;
  static constexpr char const * const name{"AdaTaskBody"};
  static constexpr unsigned long variant{20};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaTaskBody,SgAdaTaskSpec*,&SgAdaTaskBody::p_spec>, describe_field_t<SgAdaTaskBody,SgStatementPtrList,&SgAdaTaskBody::p_statements>>;
};
template <> struct node_from_variant_t<20> { using type = SgAdaTaskBody; };

// Class: AdaTaskBodyDecl
template <> struct describe_field_t<SgAdaTaskBodyDecl,SgName,&SgAdaTaskBodyDecl::p_name> {
  using parent = SgAdaTaskBodyDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskBodyDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskBodyDecl, SgName SgAdaTaskBodyDecl::*, &SgAdaTaskBodyDecl::p_name>;
};
template <> struct describe_field_t<SgAdaTaskBodyDecl,SgDeclarationStatement*,&SgAdaTaskBodyDecl::p_specificationDeclaration> {
  using parent = SgAdaTaskBodyDecl;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"specificationDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskBodyDecl::p_specificationDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskBodyDecl, SgDeclarationStatement* SgAdaTaskBodyDecl::*, &SgAdaTaskBodyDecl::p_specificationDeclaration>;
};
template <> struct describe_field_t<SgAdaTaskBodyDecl,SgAdaTaskBody*,&SgAdaTaskBodyDecl::p_definition> {
  using parent = SgAdaTaskBodyDecl;
  using field_type = SgAdaTaskBody*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgAdaTaskBody*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaTaskBodyDecl::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskBodyDecl, SgAdaTaskBody* SgAdaTaskBodyDecl::*, &SgAdaTaskBodyDecl::p_definition>;
};
template <> struct describe_node_t<SgAdaTaskBodyDecl> {
  using node = SgAdaTaskBodyDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaTaskBodyDecl"};
  static constexpr unsigned long variant{21};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaTaskBodyDecl,SgName,&SgAdaTaskBodyDecl::p_name>, describe_field_t<SgAdaTaskBodyDecl,SgDeclarationStatement*,&SgAdaTaskBodyDecl::p_specificationDeclaration>, describe_field_t<SgAdaTaskBodyDecl,SgAdaTaskBody*,&SgAdaTaskBodyDecl::p_definition>>;
};
template <> struct node_from_variant_t<21> { using type = SgAdaTaskBodyDecl; };

// Class: AdaTaskSpec
template <> struct describe_field_t<SgAdaTaskSpec,SgAdaTaskBody*,&SgAdaTaskSpec::p_body> {
  using parent = SgAdaTaskSpec;
  using field_type = SgAdaTaskBody*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAdaTaskBody*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskSpec::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskSpec, SgAdaTaskBody* SgAdaTaskSpec::*, &SgAdaTaskSpec::p_body>;
};
template <> struct describe_field_t<SgAdaTaskSpec,SgDeclarationStatementPtrList,&SgAdaTaskSpec::p_declarations> {
  using parent = SgAdaTaskSpec;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"declarations"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaTaskSpec::p_declarations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskSpec, SgDeclarationStatementPtrList SgAdaTaskSpec::*, &SgAdaTaskSpec::p_declarations>;
};
template <> struct describe_field_t<SgAdaTaskSpec,bool,&SgAdaTaskSpec::p_hasPrivate> {
  using parent = SgAdaTaskSpec;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"hasPrivate"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskSpec::p_hasPrivate};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskSpec, bool SgAdaTaskSpec::*, &SgAdaTaskSpec::p_hasPrivate>;
};
template <> struct describe_node_t<SgAdaTaskSpec> {
  using node = SgAdaTaskSpec;
  using base = SgScopeStatement;
  static constexpr char const * const name{"AdaTaskSpec"};
  static constexpr unsigned long variant{22};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaTaskSpec,SgAdaTaskBody*,&SgAdaTaskSpec::p_body>, describe_field_t<SgAdaTaskSpec,SgDeclarationStatementPtrList,&SgAdaTaskSpec::p_declarations>, describe_field_t<SgAdaTaskSpec,bool,&SgAdaTaskSpec::p_hasPrivate>>;
};
template <> struct node_from_variant_t<22> { using type = SgAdaTaskSpec; };

// Class: AdaTaskSpecDecl
template <> struct describe_field_t<SgAdaTaskSpecDecl,SgName,&SgAdaTaskSpecDecl::p_name> {
  using parent = SgAdaTaskSpecDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskSpecDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskSpecDecl, SgName SgAdaTaskSpecDecl::*, &SgAdaTaskSpecDecl::p_name>;
};
template <> struct describe_field_t<SgAdaTaskSpecDecl,SgAdaTaskSpec*,&SgAdaTaskSpecDecl::p_definition> {
  using parent = SgAdaTaskSpecDecl;
  using field_type = SgAdaTaskSpec*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgAdaTaskSpec*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaTaskSpecDecl::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskSpecDecl, SgAdaTaskSpec* SgAdaTaskSpecDecl::*, &SgAdaTaskSpecDecl::p_definition>;
};
template <> struct describe_field_t<SgAdaTaskSpecDecl,SgAdaTaskType*,&SgAdaTaskSpecDecl::p_type> {
  using parent = SgAdaTaskSpecDecl;
  using field_type = SgAdaTaskType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAdaTaskType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskSpecDecl::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskSpecDecl, SgAdaTaskType* SgAdaTaskSpecDecl::*, &SgAdaTaskSpecDecl::p_type>;
};
template <> struct describe_node_t<SgAdaTaskSpecDecl> {
  using node = SgAdaTaskSpecDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaTaskSpecDecl"};
  static constexpr unsigned long variant{23};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaTaskSpecDecl,SgName,&SgAdaTaskSpecDecl::p_name>, describe_field_t<SgAdaTaskSpecDecl,SgAdaTaskSpec*,&SgAdaTaskSpecDecl::p_definition>, describe_field_t<SgAdaTaskSpecDecl,SgAdaTaskType*,&SgAdaTaskSpecDecl::p_type>>;
};
template <> struct node_from_variant_t<23> { using type = SgAdaTaskSpecDecl; };

// Class: AdaTaskSymbol
template <> struct describe_field_t<SgAdaTaskSymbol,SgDeclarationStatement*,&SgAdaTaskSymbol::p_declaration> {
  using parent = SgAdaTaskSymbol;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaTaskSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskSymbol, SgDeclarationStatement* SgAdaTaskSymbol::*, &SgAdaTaskSymbol::p_declaration>;
};
template <> struct describe_node_t<SgAdaTaskSymbol> {
  using node = SgAdaTaskSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AdaTaskSymbol"};
  static constexpr unsigned long variant{24};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaTaskSymbol,SgDeclarationStatement*,&SgAdaTaskSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<24> { using type = SgAdaTaskSymbol; };

// Class: AdaTaskRefExp
template <> struct describe_field_t<SgAdaTaskRefExp,SgAdaTaskSymbol*,&SgAdaTaskRefExp::p_symbol> {
  using parent = SgAdaTaskRefExp;
  using field_type = SgAdaTaskSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgAdaTaskSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskRefExp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskRefExp, SgAdaTaskSymbol* SgAdaTaskRefExp::*, &SgAdaTaskRefExp::p_symbol>;
};
template <> struct describe_node_t<SgAdaTaskRefExp> {
  using node = SgAdaTaskRefExp;
  using base = SgExpression;
  static constexpr char const * const name{"AdaTaskRefExp"};
  static constexpr unsigned long variant{25};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaTaskRefExp,SgAdaTaskSymbol*,&SgAdaTaskRefExp::p_symbol>>;
};
template <> struct node_from_variant_t<25> { using type = SgAdaTaskRefExp; };

// Class: AdaTaskType
template <> struct describe_node_t<SgAdaTaskType> {
  using node = SgAdaTaskType;
  using base = SgNamedType;
  static constexpr char const * const name{"AdaTaskType"};
  static constexpr unsigned long variant{26};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<26> { using type = SgAdaTaskType; };

// Class: AdaTaskTypeDecl
template <> struct describe_field_t<SgAdaTaskTypeDecl,SgName,&SgAdaTaskTypeDecl::p_name> {
  using parent = SgAdaTaskTypeDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskTypeDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskTypeDecl, SgName SgAdaTaskTypeDecl::*, &SgAdaTaskTypeDecl::p_name>;
};
template <> struct describe_field_t<SgAdaTaskTypeDecl,SgAdaTaskSpec*,&SgAdaTaskTypeDecl::p_definition> {
  using parent = SgAdaTaskTypeDecl;
  using field_type = SgAdaTaskSpec*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgAdaTaskSpec*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaTaskTypeDecl::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskTypeDecl, SgAdaTaskSpec* SgAdaTaskTypeDecl::*, &SgAdaTaskTypeDecl::p_definition>;
};
template <> struct describe_field_t<SgAdaTaskTypeDecl,SgAdaTaskType*,&SgAdaTaskTypeDecl::p_type> {
  using parent = SgAdaTaskTypeDecl;
  using field_type = SgAdaTaskType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAdaTaskType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskTypeDecl::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskTypeDecl, SgAdaTaskType* SgAdaTaskTypeDecl::*, &SgAdaTaskTypeDecl::p_type>;
};
template <> struct describe_field_t<SgAdaTaskTypeDecl,SgScopeStatement*,&SgAdaTaskTypeDecl::p_scope> {
  using parent = SgAdaTaskTypeDecl;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaTaskTypeDecl::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaTaskTypeDecl, SgScopeStatement* SgAdaTaskTypeDecl::*, &SgAdaTaskTypeDecl::p_scope>;
};
template <> struct describe_node_t<SgAdaTaskTypeDecl> {
  using node = SgAdaTaskTypeDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaTaskTypeDecl"};
  static constexpr unsigned long variant{27};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaTaskTypeDecl,SgName,&SgAdaTaskTypeDecl::p_name>, describe_field_t<SgAdaTaskTypeDecl,SgAdaTaskSpec*,&SgAdaTaskTypeDecl::p_definition>, describe_field_t<SgAdaTaskTypeDecl,SgAdaTaskType*,&SgAdaTaskTypeDecl::p_type>, describe_field_t<SgAdaTaskTypeDecl,SgScopeStatement*,&SgAdaTaskTypeDecl::p_scope>>;
};
template <> struct node_from_variant_t<27> { using type = SgAdaTaskTypeDecl; };

// Class: AdaTypeConstraint
template <> struct describe_node_t<SgAdaTypeConstraint> {
  using node = SgAdaTypeConstraint;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"AdaTypeConstraint"};
  static constexpr unsigned long variant{28};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAdaRangeConstraint, SgAdaIndexConstraint, SgAdaDigitsConstraint, SgAdaDeltaConstraint, SgAdaDiscriminantConstraint, SgAdaNullConstraint>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<28> { using type = SgAdaTypeConstraint; };

// Class: AddOp
template <> struct describe_node_t<SgAddOp> {
  using node = SgAddOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"AddOp"};
  static constexpr unsigned long variant{29};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<29> { using type = SgAddOp; };

// Class: AddressOfOp
template <> struct describe_field_t<SgAddressOfOp,SgExpression*,&SgAddressOfOp::p_originalExpressionTree> {
  using parent = SgAddressOfOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"originalExpressionTree"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAddressOfOp::p_originalExpressionTree};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAddressOfOp, SgExpression* SgAddressOfOp::*, &SgAddressOfOp::p_originalExpressionTree>;
};
template <> struct describe_node_t<SgAddressOfOp> {
  using node = SgAddressOfOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"AddressOfOp"};
  static constexpr unsigned long variant{30};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAddressOfOp,SgExpression*,&SgAddressOfOp::p_originalExpressionTree>>;
};
template <> struct node_from_variant_t<30> { using type = SgAddressOfOp; };

// Class: AggregateInitializer
template <> struct describe_field_t<SgAggregateInitializer,SgExprListExp*,&SgAggregateInitializer::p_initializers> {
  using parent = SgAggregateInitializer;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"initializers"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAggregateInitializer::p_initializers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAggregateInitializer, SgExprListExp* SgAggregateInitializer::*, &SgAggregateInitializer::p_initializers>;
};
template <> struct describe_field_t<SgAggregateInitializer,SgType*,&SgAggregateInitializer::p_expression_type> {
  using parent = SgAggregateInitializer;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAggregateInitializer::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAggregateInitializer, SgType* SgAggregateInitializer::*, &SgAggregateInitializer::p_expression_type>;
};
template <> struct describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_need_explicit_braces> {
  using parent = SgAggregateInitializer;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"need_explicit_braces"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAggregateInitializer::p_need_explicit_braces};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAggregateInitializer, bool SgAggregateInitializer::*, &SgAggregateInitializer::p_need_explicit_braces>;
};
template <> struct describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_uses_compound_literal> {
  using parent = SgAggregateInitializer;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"uses_compound_literal"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAggregateInitializer::p_uses_compound_literal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAggregateInitializer, bool SgAggregateInitializer::*, &SgAggregateInitializer::p_uses_compound_literal>;
};
template <> struct describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_requiresGlobalNameQualificationOnType> {
  using parent = SgAggregateInitializer;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"requiresGlobalNameQualificationOnType"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAggregateInitializer::p_requiresGlobalNameQualificationOnType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAggregateInitializer, bool SgAggregateInitializer::*, &SgAggregateInitializer::p_requiresGlobalNameQualificationOnType>;
};
template <> struct describe_field_t<SgAggregateInitializer,int,&SgAggregateInitializer::p_name_qualification_length_for_type> {
  using parent = SgAggregateInitializer;
  using field_type = int;
  static constexpr size_t position{5};
  static constexpr char const * const name{"name_qualification_length_for_type"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAggregateInitializer::p_name_qualification_length_for_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAggregateInitializer, int SgAggregateInitializer::*, &SgAggregateInitializer::p_name_qualification_length_for_type>;
};
template <> struct describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_type_elaboration_required_for_type> {
  using parent = SgAggregateInitializer;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"type_elaboration_required_for_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAggregateInitializer::p_type_elaboration_required_for_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAggregateInitializer, bool SgAggregateInitializer::*, &SgAggregateInitializer::p_type_elaboration_required_for_type>;
};
template <> struct describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_global_qualification_required_for_type> {
  using parent = SgAggregateInitializer;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"global_qualification_required_for_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAggregateInitializer::p_global_qualification_required_for_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAggregateInitializer, bool SgAggregateInitializer::*, &SgAggregateInitializer::p_global_qualification_required_for_type>;
};
template <> struct describe_field_t<SgAggregateInitializer,SgExpression*,&SgAggregateInitializer::p_originalExpressionTree> {
  using parent = SgAggregateInitializer;
  using field_type = SgExpression*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"originalExpressionTree"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAggregateInitializer::p_originalExpressionTree};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAggregateInitializer, SgExpression* SgAggregateInitializer::*, &SgAggregateInitializer::p_originalExpressionTree>;
};
template <> struct describe_node_t<SgAggregateInitializer> {
  using node = SgAggregateInitializer;
  using base = SgInitializer;
  static constexpr char const * const name{"AggregateInitializer"};
  static constexpr unsigned long variant{31};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAggregateInitializer,SgExprListExp*,&SgAggregateInitializer::p_initializers>, describe_field_t<SgAggregateInitializer,SgType*,&SgAggregateInitializer::p_expression_type>, describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_need_explicit_braces>, describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_uses_compound_literal>, describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_requiresGlobalNameQualificationOnType>, describe_field_t<SgAggregateInitializer,int,&SgAggregateInitializer::p_name_qualification_length_for_type>, describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_type_elaboration_required_for_type>, describe_field_t<SgAggregateInitializer,bool,&SgAggregateInitializer::p_global_qualification_required_for_type>, describe_field_t<SgAggregateInitializer,SgExpression*,&SgAggregateInitializer::p_originalExpressionTree>>;
};
template <> struct node_from_variant_t<31> { using type = SgAggregateInitializer; };

// Class: AliasSymbol
template <> struct describe_field_t<SgAliasSymbol,SgSymbol*,&SgAliasSymbol::p_alias> {
  using parent = SgAliasSymbol;
  using field_type = SgSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"alias"};
  static constexpr char const * const typestr{"SgSymbol*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAliasSymbol::p_alias};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAliasSymbol, SgSymbol* SgAliasSymbol::*, &SgAliasSymbol::p_alias>;
};
template <> struct describe_field_t<SgAliasSymbol,bool,&SgAliasSymbol::p_isRenamed> {
  using parent = SgAliasSymbol;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"isRenamed"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAliasSymbol::p_isRenamed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAliasSymbol, bool SgAliasSymbol::*, &SgAliasSymbol::p_isRenamed>;
};
template <> struct describe_field_t<SgAliasSymbol,SgName,&SgAliasSymbol::p_new_name> {
  using parent = SgAliasSymbol;
  using field_type = SgName;
  static constexpr size_t position{2};
  static constexpr char const * const name{"new_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAliasSymbol::p_new_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAliasSymbol, SgName SgAliasSymbol::*, &SgAliasSymbol::p_new_name>;
};
template <> struct describe_field_t<SgAliasSymbol,SgNodePtrList,&SgAliasSymbol::p_causal_nodes> {
  using parent = SgAliasSymbol;
  using field_type = SgNodePtrList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"causal_nodes"};
  static constexpr char const * const typestr{"SgNodePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAliasSymbol::p_causal_nodes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAliasSymbol, SgNodePtrList SgAliasSymbol::*, &SgAliasSymbol::p_causal_nodes>;
};
template <> struct describe_node_t<SgAliasSymbol> {
  using node = SgAliasSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AliasSymbol"};
  static constexpr unsigned long variant{32};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAliasSymbol,SgSymbol*,&SgAliasSymbol::p_alias>, describe_field_t<SgAliasSymbol,bool,&SgAliasSymbol::p_isRenamed>, describe_field_t<SgAliasSymbol,SgName,&SgAliasSymbol::p_new_name>, describe_field_t<SgAliasSymbol,SgNodePtrList,&SgAliasSymbol::p_causal_nodes>>;
};
template <> struct node_from_variant_t<32> { using type = SgAliasSymbol; };

// Class: AllocateStatement
template <> struct describe_field_t<SgAllocateStatement,SgExprListExp*,&SgAllocateStatement::p_expr_list> {
  using parent = SgAllocateStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expr_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAllocateStatement::p_expr_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAllocateStatement, SgExprListExp* SgAllocateStatement::*, &SgAllocateStatement::p_expr_list>;
};
template <> struct describe_field_t<SgAllocateStatement,SgExpression*,&SgAllocateStatement::p_stat_expression> {
  using parent = SgAllocateStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"stat_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAllocateStatement::p_stat_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAllocateStatement, SgExpression* SgAllocateStatement::*, &SgAllocateStatement::p_stat_expression>;
};
template <> struct describe_field_t<SgAllocateStatement,SgExpression*,&SgAllocateStatement::p_errmsg_expression> {
  using parent = SgAllocateStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"errmsg_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAllocateStatement::p_errmsg_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAllocateStatement, SgExpression* SgAllocateStatement::*, &SgAllocateStatement::p_errmsg_expression>;
};
template <> struct describe_field_t<SgAllocateStatement,SgExpression*,&SgAllocateStatement::p_source_expression> {
  using parent = SgAllocateStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"source_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAllocateStatement::p_source_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAllocateStatement, SgExpression* SgAllocateStatement::*, &SgAllocateStatement::p_source_expression>;
};
template <> struct describe_node_t<SgAllocateStatement> {
  using node = SgAllocateStatement;
  using base = SgStatement;
  static constexpr char const * const name{"AllocateStatement"};
  static constexpr unsigned long variant{33};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAllocateStatement,SgExprListExp*,&SgAllocateStatement::p_expr_list>, describe_field_t<SgAllocateStatement,SgExpression*,&SgAllocateStatement::p_stat_expression>, describe_field_t<SgAllocateStatement,SgExpression*,&SgAllocateStatement::p_errmsg_expression>, describe_field_t<SgAllocateStatement,SgExpression*,&SgAllocateStatement::p_source_expression>>;
};
template <> struct node_from_variant_t<33> { using type = SgAllocateStatement; };

// Class: AndAssignOp
template <> struct describe_node_t<SgAndAssignOp> {
  using node = SgAndAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"AndAssignOp"};
  static constexpr unsigned long variant{34};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<34> { using type = SgAndAssignOp; };

// Class: AndOp
template <> struct describe_node_t<SgAndOp> {
  using node = SgAndOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"AndOp"};
  static constexpr unsigned long variant{35};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<35> { using type = SgAndOp; };

// Class: ArithmeticIfStatement
template <> struct describe_field_t<SgArithmeticIfStatement,SgExpression*,&SgArithmeticIfStatement::p_conditional> {
  using parent = SgArithmeticIfStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"conditional"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgArithmeticIfStatement::p_conditional};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArithmeticIfStatement, SgExpression* SgArithmeticIfStatement::*, &SgArithmeticIfStatement::p_conditional>;
};
template <> struct describe_field_t<SgArithmeticIfStatement,SgLabelRefExp*,&SgArithmeticIfStatement::p_less_label> {
  using parent = SgArithmeticIfStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"less_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgArithmeticIfStatement::p_less_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArithmeticIfStatement, SgLabelRefExp* SgArithmeticIfStatement::*, &SgArithmeticIfStatement::p_less_label>;
};
template <> struct describe_field_t<SgArithmeticIfStatement,SgLabelRefExp*,&SgArithmeticIfStatement::p_equal_label> {
  using parent = SgArithmeticIfStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"equal_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgArithmeticIfStatement::p_equal_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArithmeticIfStatement, SgLabelRefExp* SgArithmeticIfStatement::*, &SgArithmeticIfStatement::p_equal_label>;
};
template <> struct describe_field_t<SgArithmeticIfStatement,SgLabelRefExp*,&SgArithmeticIfStatement::p_greater_label> {
  using parent = SgArithmeticIfStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"greater_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgArithmeticIfStatement::p_greater_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArithmeticIfStatement, SgLabelRefExp* SgArithmeticIfStatement::*, &SgArithmeticIfStatement::p_greater_label>;
};
template <> struct describe_node_t<SgArithmeticIfStatement> {
  using node = SgArithmeticIfStatement;
  using base = SgStatement;
  static constexpr char const * const name{"ArithmeticIfStatement"};
  static constexpr unsigned long variant{36};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgArithmeticIfStatement,SgExpression*,&SgArithmeticIfStatement::p_conditional>, describe_field_t<SgArithmeticIfStatement,SgLabelRefExp*,&SgArithmeticIfStatement::p_less_label>, describe_field_t<SgArithmeticIfStatement,SgLabelRefExp*,&SgArithmeticIfStatement::p_equal_label>, describe_field_t<SgArithmeticIfStatement,SgLabelRefExp*,&SgArithmeticIfStatement::p_greater_label>>;
};
template <> struct node_from_variant_t<36> { using type = SgArithmeticIfStatement; };

// Class: ArrayType
template <> struct describe_field_t<SgArrayType,SgType*,&SgArrayType::p_base_type> {
  using parent = SgArrayType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgArrayType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArrayType, SgType* SgArrayType::*, &SgArrayType::p_base_type>;
};
template <> struct describe_field_t<SgArrayType,SgExpression*,&SgArrayType::p_index> {
  using parent = SgArrayType;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgArrayType::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArrayType, SgExpression* SgArrayType::*, &SgArrayType::p_index>;
};
template <> struct describe_field_t<SgArrayType,SgExprListExp*,&SgArrayType::p_dim_info> {
  using parent = SgArrayType;
  using field_type = SgExprListExp*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"dim_info"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgArrayType::p_dim_info};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArrayType, SgExprListExp* SgArrayType::*, &SgArrayType::p_dim_info>;
};
template <> struct describe_field_t<SgArrayType,int,&SgArrayType::p_rank> {
  using parent = SgArrayType;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"rank"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgArrayType::p_rank};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArrayType, int SgArrayType::*, &SgArrayType::p_rank>;
};
template <> struct describe_field_t<SgArrayType,int,&SgArrayType::p_number_of_elements> {
  using parent = SgArrayType;
  using field_type = int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"number_of_elements"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgArrayType::p_number_of_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArrayType, int SgArrayType::*, &SgArrayType::p_number_of_elements>;
};
template <> struct describe_field_t<SgArrayType,bool,&SgArrayType::p_is_variable_length_array> {
  using parent = SgArrayType;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"is_variable_length_array"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgArrayType::p_is_variable_length_array};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgArrayType, bool SgArrayType::*, &SgArrayType::p_is_variable_length_array>;
};
template <> struct describe_node_t<SgArrayType> {
  using node = SgArrayType;
  using base = SgType;
  static constexpr char const * const name{"ArrayType"};
  static constexpr unsigned long variant{37};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgArrayType,SgType*,&SgArrayType::p_base_type>, describe_field_t<SgArrayType,SgExpression*,&SgArrayType::p_index>, describe_field_t<SgArrayType,SgExprListExp*,&SgArrayType::p_dim_info>, describe_field_t<SgArrayType,int,&SgArrayType::p_rank>, describe_field_t<SgArrayType,int,&SgArrayType::p_number_of_elements>, describe_field_t<SgArrayType,bool,&SgArrayType::p_is_variable_length_array>>;
};
template <> struct node_from_variant_t<37> { using type = SgArrayType; };

// Class: ArrowExp
template <> struct describe_node_t<SgArrowExp> {
  using node = SgArrowExp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"ArrowExp"};
  static constexpr unsigned long variant{38};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<38> { using type = SgArrowExp; };

// Class: ArrowStarOp
template <> struct describe_node_t<SgArrowStarOp> {
  using node = SgArrowStarOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"ArrowStarOp"};
  static constexpr unsigned long variant{39};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<39> { using type = SgArrowStarOp; };

// Class: AsmBasicString
template <> struct describe_field_t<SgAsmBasicString,std::string,&SgAsmBasicString::p_string> {
  using parent = SgAsmBasicString;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBasicString::p_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBasicString, std::string SgAsmBasicString::*, &SgAsmBasicString::p_string>;
};
template <> struct describe_node_t<SgAsmBasicString> {
  using node = SgAsmBasicString;
  using base = SgAsmGenericString;
  static constexpr char const * const name{"AsmBasicString"};
  static constexpr unsigned long variant{46};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmBasicString,std::string,&SgAsmBasicString::p_string>>;
};
template <> struct node_from_variant_t<46> { using type = SgAsmBasicString; };

// Class: AsmBinaryAdd
template <> struct describe_node_t<SgAsmBinaryAdd> {
  using node = SgAsmBinaryAdd;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryAdd"};
  static constexpr unsigned long variant{47};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<47> { using type = SgAsmBinaryAdd; };

// Class: AsmBinaryAsr
template <> struct describe_node_t<SgAsmBinaryAsr> {
  using node = SgAsmBinaryAsr;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryAsr"};
  static constexpr unsigned long variant{50};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<50> { using type = SgAsmBinaryAsr; };

// Class: AsmBinaryDivide
template <> struct describe_node_t<SgAsmBinaryDivide> {
  using node = SgAsmBinaryDivide;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryDivide"};
  static constexpr unsigned long variant{51};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<51> { using type = SgAsmBinaryDivide; };

// Class: AsmBinaryExpression
template <> struct describe_field_t<SgAsmBinaryExpression,SgAsmExpression*,&SgAsmBinaryExpression::p_lhs> {
  using parent = SgAsmBinaryExpression;
  using field_type = SgAsmExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lhs"};
  static constexpr char const * const typestr{"SgAsmExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmBinaryExpression::p_lhs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBinaryExpression, SgAsmExpression* SgAsmBinaryExpression::*, &SgAsmBinaryExpression::p_lhs>;
};
template <> struct describe_field_t<SgAsmBinaryExpression,SgAsmExpression*,&SgAsmBinaryExpression::p_rhs> {
  using parent = SgAsmBinaryExpression;
  using field_type = SgAsmExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"rhs"};
  static constexpr char const * const typestr{"SgAsmExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmBinaryExpression::p_rhs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBinaryExpression, SgAsmExpression* SgAsmBinaryExpression::*, &SgAsmBinaryExpression::p_rhs>;
};
template <> struct describe_node_t<SgAsmBinaryExpression> {
  using node = SgAsmBinaryExpression;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmBinaryExpression"};
  static constexpr unsigned long variant{52};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmBinaryAdd, SgAsmBinaryAsr, SgAsmBinaryConcat, SgAsmBinaryDivide, SgAsmBinaryLsl, SgAsmBinaryLsr, SgAsmBinaryMod, SgAsmBinaryMsl, SgAsmBinaryMultiply, SgAsmBinaryPostupdate, SgAsmBinaryPreupdate, SgAsmBinaryRor, SgAsmBinarySubtract>;
  using fields_t = mp::List<describe_field_t<SgAsmBinaryExpression,SgAsmExpression*,&SgAsmBinaryExpression::p_lhs>, describe_field_t<SgAsmBinaryExpression,SgAsmExpression*,&SgAsmBinaryExpression::p_rhs>>;
};
template <> struct node_from_variant_t<52> { using type = SgAsmBinaryExpression; };

// Class: AsmBinaryLsl
template <> struct describe_node_t<SgAsmBinaryLsl> {
  using node = SgAsmBinaryLsl;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryLsl"};
  static constexpr unsigned long variant{53};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<53> { using type = SgAsmBinaryLsl; };

// Class: AsmBinaryLsr
template <> struct describe_node_t<SgAsmBinaryLsr> {
  using node = SgAsmBinaryLsr;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryLsr"};
  static constexpr unsigned long variant{54};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<54> { using type = SgAsmBinaryLsr; };

// Class: AsmBinaryMod
template <> struct describe_node_t<SgAsmBinaryMod> {
  using node = SgAsmBinaryMod;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryMod"};
  static constexpr unsigned long variant{55};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<55> { using type = SgAsmBinaryMod; };

// Class: AsmBinaryMsl
template <> struct describe_node_t<SgAsmBinaryMsl> {
  using node = SgAsmBinaryMsl;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryMsl"};
  static constexpr unsigned long variant{56};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<56> { using type = SgAsmBinaryMsl; };

// Class: AsmBinaryMultiply
template <> struct describe_node_t<SgAsmBinaryMultiply> {
  using node = SgAsmBinaryMultiply;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryMultiply"};
  static constexpr unsigned long variant{57};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<57> { using type = SgAsmBinaryMultiply; };

// Class: AsmBinaryRor
template <> struct describe_node_t<SgAsmBinaryRor> {
  using node = SgAsmBinaryRor;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryRor"};
  static constexpr unsigned long variant{58};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<58> { using type = SgAsmBinaryRor; };

// Class: AsmBinarySubtract
template <> struct describe_node_t<SgAsmBinarySubtract> {
  using node = SgAsmBinarySubtract;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinarySubtract"};
  static constexpr unsigned long variant{59};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<59> { using type = SgAsmBinarySubtract; };

// Class: AsmBlock
template <> struct describe_field_t<SgAsmBlock,Rose::BinaryAnalysis::Address,&SgAsmBlock::p_id> {
  using parent = SgAsmBlock;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{0};
  static constexpr char const * const name{"id"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBlock::p_id};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBlock, Rose::BinaryAnalysis::Address SgAsmBlock::*, &SgAsmBlock::p_id>;
};
template <> struct describe_field_t<SgAsmBlock,unsigned,&SgAsmBlock::p_reason> {
  using parent = SgAsmBlock;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"reason"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBlock::p_reason};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBlock, unsigned SgAsmBlock::*, &SgAsmBlock::p_reason>;
};
template <> struct describe_field_t<SgAsmBlock,SgAsmStatementPtrList,&SgAsmBlock::p_statementList> {
  using parent = SgAsmBlock;
  using field_type = SgAsmStatementPtrList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"statementList"};
  static constexpr char const * const typestr{"SgAsmStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmBlock::p_statementList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBlock, SgAsmStatementPtrList SgAsmBlock::*, &SgAsmBlock::p_statementList>;
};
template <> struct describe_field_t<SgAsmBlock,SgAsmIntegerValuePtrList,&SgAsmBlock::p_successors> {
  using parent = SgAsmBlock;
  using field_type = SgAsmIntegerValuePtrList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"successors"};
  static constexpr char const * const typestr{"SgAsmIntegerValuePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBlock::p_successors};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBlock, SgAsmIntegerValuePtrList SgAsmBlock::*, &SgAsmBlock::p_successors>;
};
template <> struct describe_field_t<SgAsmBlock,bool,&SgAsmBlock::p_successorsComplete> {
  using parent = SgAsmBlock;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"successorsComplete"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBlock::p_successorsComplete};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBlock, bool SgAsmBlock::*, &SgAsmBlock::p_successorsComplete>;
};
template <> struct describe_field_t<SgAsmBlock,SgAsmBlock*,&SgAsmBlock::p_immediateDominator> {
  using parent = SgAsmBlock;
  using field_type = SgAsmBlock*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"immediateDominator"};
  static constexpr char const * const typestr{"SgAsmBlock*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBlock::p_immediateDominator};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBlock, SgAsmBlock* SgAsmBlock::*, &SgAsmBlock::p_immediateDominator>;
};
template <> struct describe_field_t<SgAsmBlock,size_t,&SgAsmBlock::p_cachedVertex> {
  using parent = SgAsmBlock;
  using field_type = size_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"cachedVertex"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBlock::p_cachedVertex};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBlock, size_t SgAsmBlock::*, &SgAsmBlock::p_cachedVertex>;
};
template <> struct describe_field_t<SgAsmBlock,double,&SgAsmBlock::p_codeLikelihood> {
  using parent = SgAsmBlock;
  using field_type = double;
  static constexpr size_t position{7};
  static constexpr char const * const name{"codeLikelihood"};
  static constexpr char const * const typestr{"double"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBlock::p_codeLikelihood};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBlock, double SgAsmBlock::*, &SgAsmBlock::p_codeLikelihood>;
};
template <> struct describe_field_t<SgAsmBlock,int64_t,&SgAsmBlock::p_stackDeltaOut> {
  using parent = SgAsmBlock;
  using field_type = int64_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"stackDeltaOut"};
  static constexpr char const * const typestr{"int64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBlock::p_stackDeltaOut};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBlock, int64_t SgAsmBlock::*, &SgAsmBlock::p_stackDeltaOut>;
};
template <> struct describe_node_t<SgAsmBlock> {
  using node = SgAsmBlock;
  using base = SgAsmStatement;
  static constexpr char const * const name{"AsmBlock"};
  static constexpr unsigned long variant{62};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmBlock,Rose::BinaryAnalysis::Address,&SgAsmBlock::p_id>, describe_field_t<SgAsmBlock,unsigned,&SgAsmBlock::p_reason>, describe_field_t<SgAsmBlock,SgAsmStatementPtrList,&SgAsmBlock::p_statementList>, describe_field_t<SgAsmBlock,SgAsmIntegerValuePtrList,&SgAsmBlock::p_successors>, describe_field_t<SgAsmBlock,bool,&SgAsmBlock::p_successorsComplete>, describe_field_t<SgAsmBlock,SgAsmBlock*,&SgAsmBlock::p_immediateDominator>, describe_field_t<SgAsmBlock,size_t,&SgAsmBlock::p_cachedVertex>, describe_field_t<SgAsmBlock,double,&SgAsmBlock::p_codeLikelihood>, describe_field_t<SgAsmBlock,int64_t,&SgAsmBlock::p_stackDeltaOut>>;
};
template <> struct node_from_variant_t<62> { using type = SgAsmBlock; };

// Class: AsmCoffStrtab
template <> struct describe_node_t<SgAsmCoffStrtab> {
  using node = SgAsmCoffStrtab;
  using base = SgAsmGenericStrtab;
  static constexpr char const * const name{"AsmCoffStrtab"};
  static constexpr unsigned long variant{63};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<63> { using type = SgAsmCoffStrtab; };

// Class: AsmCoffSymbol
template <> struct describe_field_t<SgAsmCoffSymbol,std::string,&SgAsmCoffSymbol::p_st_name> {
  using parent = SgAsmCoffSymbol;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"st_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbol::p_st_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbol, std::string SgAsmCoffSymbol::*, &SgAsmCoffSymbol::p_st_name>;
};
template <> struct describe_field_t<SgAsmCoffSymbol,Rose::BinaryAnalysis::Address,&SgAsmCoffSymbol::p_st_name_offset> {
  using parent = SgAsmCoffSymbol;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{1};
  static constexpr char const * const name{"st_name_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbol::p_st_name_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbol, Rose::BinaryAnalysis::Address SgAsmCoffSymbol::*, &SgAsmCoffSymbol::p_st_name_offset>;
};
template <> struct describe_field_t<SgAsmCoffSymbol,int,&SgAsmCoffSymbol::p_st_section_num> {
  using parent = SgAsmCoffSymbol;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"st_section_num"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbol::p_st_section_num};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbol, int SgAsmCoffSymbol::*, &SgAsmCoffSymbol::p_st_section_num>;
};
template <> struct describe_field_t<SgAsmCoffSymbol,unsigned,&SgAsmCoffSymbol::p_st_type> {
  using parent = SgAsmCoffSymbol;
  using field_type = unsigned;
  static constexpr size_t position{3};
  static constexpr char const * const name{"st_type"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbol::p_st_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbol, unsigned SgAsmCoffSymbol::*, &SgAsmCoffSymbol::p_st_type>;
};
template <> struct describe_field_t<SgAsmCoffSymbol,unsigned,&SgAsmCoffSymbol::p_st_storage_class> {
  using parent = SgAsmCoffSymbol;
  using field_type = unsigned;
  static constexpr size_t position{4};
  static constexpr char const * const name{"st_storage_class"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbol::p_st_storage_class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbol, unsigned SgAsmCoffSymbol::*, &SgAsmCoffSymbol::p_st_storage_class>;
};
template <> struct describe_field_t<SgAsmCoffSymbol,unsigned,&SgAsmCoffSymbol::p_st_num_aux_entries> {
  using parent = SgAsmCoffSymbol;
  using field_type = unsigned;
  static constexpr size_t position{5};
  static constexpr char const * const name{"st_num_aux_entries"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbol::p_st_num_aux_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbol, unsigned SgAsmCoffSymbol::*, &SgAsmCoffSymbol::p_st_num_aux_entries>;
};
template <> struct describe_field_t<SgAsmCoffSymbol,SgUnsignedCharList,&SgAsmCoffSymbol::p_auxiliaryData> {
  using parent = SgAsmCoffSymbol;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{6};
  static constexpr char const * const name{"auxiliaryData"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbol::p_auxiliaryData};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbol, SgUnsignedCharList SgAsmCoffSymbol::*, &SgAsmCoffSymbol::p_auxiliaryData>;
};
template <> struct describe_node_t<SgAsmCoffSymbol> {
  using node = SgAsmCoffSymbol;
  using base = SgAsmGenericSymbol;
  static constexpr char const * const name{"AsmCoffSymbol"};
  static constexpr unsigned long variant{64};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCoffSymbol,std::string,&SgAsmCoffSymbol::p_st_name>, describe_field_t<SgAsmCoffSymbol,Rose::BinaryAnalysis::Address,&SgAsmCoffSymbol::p_st_name_offset>, describe_field_t<SgAsmCoffSymbol,int,&SgAsmCoffSymbol::p_st_section_num>, describe_field_t<SgAsmCoffSymbol,unsigned,&SgAsmCoffSymbol::p_st_type>, describe_field_t<SgAsmCoffSymbol,unsigned,&SgAsmCoffSymbol::p_st_storage_class>, describe_field_t<SgAsmCoffSymbol,unsigned,&SgAsmCoffSymbol::p_st_num_aux_entries>, describe_field_t<SgAsmCoffSymbol,SgUnsignedCharList,&SgAsmCoffSymbol::p_auxiliaryData>>;
};
template <> struct node_from_variant_t<64> { using type = SgAsmCoffSymbol; };

// Class: AsmCoffSymbolList
template <> struct describe_field_t<SgAsmCoffSymbolList,SgAsmCoffSymbolPtrList,&SgAsmCoffSymbolList::p_symbols> {
  using parent = SgAsmCoffSymbolList;
  using field_type = SgAsmCoffSymbolPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbols"};
  static constexpr char const * const typestr{"SgAsmCoffSymbolPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbolList::p_symbols};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbolList, SgAsmCoffSymbolPtrList SgAsmCoffSymbolList::*, &SgAsmCoffSymbolList::p_symbols>;
};
template <> struct describe_node_t<SgAsmCoffSymbolList> {
  using node = SgAsmCoffSymbolList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmCoffSymbolList"};
  static constexpr unsigned long variant{65};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCoffSymbolList,SgAsmCoffSymbolPtrList,&SgAsmCoffSymbolList::p_symbols>>;
};
template <> struct node_from_variant_t<65> { using type = SgAsmCoffSymbolList; };

// Class: AsmCoffSymbolTable
template <> struct describe_field_t<SgAsmCoffSymbolTable,SgAsmGenericSection*,&SgAsmCoffSymbolTable::p_strtab> {
  using parent = SgAsmCoffSymbolTable;
  using field_type = SgAsmGenericSection*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"strtab"};
  static constexpr char const * const typestr{"SgAsmGenericSection*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbolTable::p_strtab};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbolTable, SgAsmGenericSection* SgAsmCoffSymbolTable::*, &SgAsmCoffSymbolTable::p_strtab>;
};
template <> struct describe_field_t<SgAsmCoffSymbolTable,SgAsmCoffSymbolList*,&SgAsmCoffSymbolTable::p_symbols> {
  using parent = SgAsmCoffSymbolTable;
  using field_type = SgAsmCoffSymbolList*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"symbols"};
  static constexpr char const * const typestr{"SgAsmCoffSymbolList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCoffSymbolTable::p_symbols};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCoffSymbolTable, SgAsmCoffSymbolList* SgAsmCoffSymbolTable::*, &SgAsmCoffSymbolTable::p_symbols>;
};
template <> struct describe_node_t<SgAsmCoffSymbolTable> {
  using node = SgAsmCoffSymbolTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmCoffSymbolTable"};
  static constexpr unsigned long variant{66};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCoffSymbolTable,SgAsmGenericSection*,&SgAsmCoffSymbolTable::p_strtab>, describe_field_t<SgAsmCoffSymbolTable,SgAsmCoffSymbolList*,&SgAsmCoffSymbolTable::p_symbols>>;
};
template <> struct node_from_variant_t<66> { using type = SgAsmCoffSymbolTable; };

// Class: AsmCommonSubExpression
template <> struct describe_field_t<SgAsmCommonSubExpression,SgAsmExpression*,&SgAsmCommonSubExpression::p_subexpression> {
  using parent = SgAsmCommonSubExpression;
  using field_type = SgAsmExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"subexpression"};
  static constexpr char const * const typestr{"SgAsmExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCommonSubExpression::p_subexpression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCommonSubExpression, SgAsmExpression* SgAsmCommonSubExpression::*, &SgAsmCommonSubExpression::p_subexpression>;
};
template <> struct describe_node_t<SgAsmCommonSubExpression> {
  using node = SgAsmCommonSubExpression;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmCommonSubExpression"};
  static constexpr unsigned long variant{67};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCommonSubExpression,SgAsmExpression*,&SgAsmCommonSubExpression::p_subexpression>>;
};
template <> struct node_from_variant_t<67> { using type = SgAsmCommonSubExpression; };

// Class: AsmControlFlagsExpression
template <> struct describe_field_t<SgAsmControlFlagsExpression,unsigned long,&SgAsmControlFlagsExpression::p_bitFlags> {
  using parent = SgAsmControlFlagsExpression;
  using field_type = unsigned long;
  static constexpr size_t position{0};
  static constexpr char const * const name{"bitFlags"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmControlFlagsExpression::p_bitFlags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmControlFlagsExpression, unsigned long SgAsmControlFlagsExpression::*, &SgAsmControlFlagsExpression::p_bitFlags>;
};
template <> struct describe_node_t<SgAsmControlFlagsExpression> {
  using node = SgAsmControlFlagsExpression;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmControlFlagsExpression"};
  static constexpr unsigned long variant{68};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmControlFlagsExpression,unsigned long,&SgAsmControlFlagsExpression::p_bitFlags>>;
};
template <> struct node_from_variant_t<68> { using type = SgAsmControlFlagsExpression; };

// Class: AsmConstantExpression
template <> struct describe_field_t<SgAsmConstantExpression,Sawyer::Container::BitVector,&SgAsmConstantExpression::p_bitVector> {
  using parent = SgAsmConstantExpression;
  using field_type = Sawyer::Container::BitVector;
  static constexpr size_t position{0};
  static constexpr char const * const name{"bitVector"};
  static constexpr char const * const typestr{"Sawyer::Container::BitVector"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmConstantExpression::p_bitVector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmConstantExpression, Sawyer::Container::BitVector SgAsmConstantExpression::*, &SgAsmConstantExpression::p_bitVector>;
};
template <> struct describe_node_t<SgAsmConstantExpression> {
  using node = SgAsmConstantExpression;
  using base = SgAsmValueExpression;
  static constexpr char const * const name{"AsmConstantExpression"};
  static constexpr unsigned long variant{69};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmFloatValueExpression, SgAsmIntegerValueExpression>;
  using fields_t = mp::List<describe_field_t<SgAsmConstantExpression,Sawyer::Container::BitVector,&SgAsmConstantExpression::p_bitVector>>;
};
template <> struct node_from_variant_t<69> { using type = SgAsmConstantExpression; };

// Class: AsmDOSExtendedHeader
template <> struct describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res1> {
  using parent = SgAsmDOSExtendedHeader;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"e_res1"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSExtendedHeader::p_e_res1};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSExtendedHeader, unsigned SgAsmDOSExtendedHeader::*, &SgAsmDOSExtendedHeader::p_e_res1>;
};
template <> struct describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_oemid> {
  using parent = SgAsmDOSExtendedHeader;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"e_oemid"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSExtendedHeader::p_e_oemid};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSExtendedHeader, unsigned SgAsmDOSExtendedHeader::*, &SgAsmDOSExtendedHeader::p_e_oemid>;
};
template <> struct describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_oeminfo> {
  using parent = SgAsmDOSExtendedHeader;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"e_oeminfo"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSExtendedHeader::p_e_oeminfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSExtendedHeader, unsigned SgAsmDOSExtendedHeader::*, &SgAsmDOSExtendedHeader::p_e_oeminfo>;
};
template <> struct describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res2> {
  using parent = SgAsmDOSExtendedHeader;
  using field_type = unsigned;
  static constexpr size_t position{3};
  static constexpr char const * const name{"e_res2"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSExtendedHeader::p_e_res2};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSExtendedHeader, unsigned SgAsmDOSExtendedHeader::*, &SgAsmDOSExtendedHeader::p_e_res2>;
};
template <> struct describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res3> {
  using parent = SgAsmDOSExtendedHeader;
  using field_type = unsigned;
  static constexpr size_t position{4};
  static constexpr char const * const name{"e_res3"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSExtendedHeader::p_e_res3};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSExtendedHeader, unsigned SgAsmDOSExtendedHeader::*, &SgAsmDOSExtendedHeader::p_e_res3>;
};
template <> struct describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res4> {
  using parent = SgAsmDOSExtendedHeader;
  using field_type = unsigned;
  static constexpr size_t position{5};
  static constexpr char const * const name{"e_res4"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSExtendedHeader::p_e_res4};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSExtendedHeader, unsigned SgAsmDOSExtendedHeader::*, &SgAsmDOSExtendedHeader::p_e_res4>;
};
template <> struct describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res5> {
  using parent = SgAsmDOSExtendedHeader;
  using field_type = unsigned;
  static constexpr size_t position{6};
  static constexpr char const * const name{"e_res5"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSExtendedHeader::p_e_res5};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSExtendedHeader, unsigned SgAsmDOSExtendedHeader::*, &SgAsmDOSExtendedHeader::p_e_res5>;
};
template <> struct describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res6> {
  using parent = SgAsmDOSExtendedHeader;
  using field_type = unsigned;
  static constexpr size_t position{7};
  static constexpr char const * const name{"e_res6"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSExtendedHeader::p_e_res6};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSExtendedHeader, unsigned SgAsmDOSExtendedHeader::*, &SgAsmDOSExtendedHeader::p_e_res6>;
};
template <> struct describe_field_t<SgAsmDOSExtendedHeader,Rose::BinaryAnalysis::Address,&SgAsmDOSExtendedHeader::p_e_lfanew> {
  using parent = SgAsmDOSExtendedHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{8};
  static constexpr char const * const name{"e_lfanew"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSExtendedHeader::p_e_lfanew};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSExtendedHeader, Rose::BinaryAnalysis::Address SgAsmDOSExtendedHeader::*, &SgAsmDOSExtendedHeader::p_e_lfanew>;
};
template <> struct describe_node_t<SgAsmDOSExtendedHeader> {
  using node = SgAsmDOSExtendedHeader;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmDOSExtendedHeader"};
  static constexpr unsigned long variant{70};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res1>, describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_oemid>, describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_oeminfo>, describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res2>, describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res3>, describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res4>, describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res5>, describe_field_t<SgAsmDOSExtendedHeader,unsigned,&SgAsmDOSExtendedHeader::p_e_res6>, describe_field_t<SgAsmDOSExtendedHeader,Rose::BinaryAnalysis::Address,&SgAsmDOSExtendedHeader::p_e_lfanew>>;
};
template <> struct node_from_variant_t<70> { using type = SgAsmDOSExtendedHeader; };

// Class: AsmDOSFileHeader
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_last_page_size> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"e_last_page_size"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_last_page_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_last_page_size>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_total_pages> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"e_total_pages"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_total_pages};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_total_pages>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_nrelocs> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"e_nrelocs"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_nrelocs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_nrelocs>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_header_paragraphs> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"e_header_paragraphs"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_header_paragraphs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_header_paragraphs>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_minalloc> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"e_minalloc"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_minalloc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_minalloc>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_maxalloc> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"e_maxalloc"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_maxalloc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_maxalloc>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_ss> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"e_ss"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_ss};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_ss>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_sp> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{7};
  static constexpr char const * const name{"e_sp"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_sp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_sp>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_cksum> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"e_cksum"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_cksum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_cksum>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_ip> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{9};
  static constexpr char const * const name{"e_ip"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_ip};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_ip>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_cs> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{10};
  static constexpr char const * const name{"e_cs"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_cs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_cs>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_overlay> {
  using parent = SgAsmDOSFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{11};
  static constexpr char const * const name{"e_overlay"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_overlay};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, uint16_t SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_overlay>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,Rose::BinaryAnalysis::Address,&SgAsmDOSFileHeader::p_e_relocs_offset> {
  using parent = SgAsmDOSFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{12};
  static constexpr char const * const name{"e_relocs_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_relocs_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, Rose::BinaryAnalysis::Address SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_relocs_offset>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,unsigned,&SgAsmDOSFileHeader::p_e_res1> {
  using parent = SgAsmDOSFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{13};
  static constexpr char const * const name{"e_res1"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_e_res1};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, unsigned SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_e_res1>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,SgAsmGenericSection*,&SgAsmDOSFileHeader::p_relocs> {
  using parent = SgAsmDOSFileHeader;
  using field_type = SgAsmGenericSection*;
  static constexpr size_t position{14};
  static constexpr char const * const name{"relocs"};
  static constexpr char const * const typestr{"SgAsmGenericSection*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_relocs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, SgAsmGenericSection* SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_relocs>;
};
template <> struct describe_field_t<SgAsmDOSFileHeader,SgAsmGenericSection*,&SgAsmDOSFileHeader::p_rm_section> {
  using parent = SgAsmDOSFileHeader;
  using field_type = SgAsmGenericSection*;
  static constexpr size_t position{15};
  static constexpr char const * const name{"rm_section"};
  static constexpr char const * const typestr{"SgAsmGenericSection*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDOSFileHeader::p_rm_section};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDOSFileHeader, SgAsmGenericSection* SgAsmDOSFileHeader::*, &SgAsmDOSFileHeader::p_rm_section>;
};
template <> struct describe_node_t<SgAsmDOSFileHeader> {
  using node = SgAsmDOSFileHeader;
  using base = SgAsmGenericHeader;
  static constexpr char const * const name{"AsmDOSFileHeader"};
  static constexpr unsigned long variant{71};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_last_page_size>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_total_pages>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_nrelocs>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_header_paragraphs>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_minalloc>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_maxalloc>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_ss>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_sp>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_cksum>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_ip>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_cs>, describe_field_t<SgAsmDOSFileHeader,uint16_t,&SgAsmDOSFileHeader::p_e_overlay>, describe_field_t<SgAsmDOSFileHeader,Rose::BinaryAnalysis::Address,&SgAsmDOSFileHeader::p_e_relocs_offset>, describe_field_t<SgAsmDOSFileHeader,unsigned,&SgAsmDOSFileHeader::p_e_res1>, describe_field_t<SgAsmDOSFileHeader,SgAsmGenericSection*,&SgAsmDOSFileHeader::p_relocs>, describe_field_t<SgAsmDOSFileHeader,SgAsmGenericSection*,&SgAsmDOSFileHeader::p_rm_section>>;
};
template <> struct node_from_variant_t<71> { using type = SgAsmDOSFileHeader; };

// Class: AsmSynthesizedDataStructureDeclaration
template <> struct describe_node_t<SgAsmSynthesizedDataStructureDeclaration> {
  using node = SgAsmSynthesizedDataStructureDeclaration;
  using base = SgAsmSynthesizedDeclaration;
  static constexpr char const * const name{"AsmSynthesizedDataStructureDeclaration"};
  static constexpr unsigned long variant{72};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<72> { using type = SgAsmSynthesizedDataStructureDeclaration; };

// Class: AsmSynthesizedDeclaration
template <> struct describe_node_t<SgAsmSynthesizedDeclaration> {
  using node = SgAsmSynthesizedDeclaration;
  using base = SgAsmStatement;
  static constexpr char const * const name{"AsmSynthesizedDeclaration"};
  static constexpr unsigned long variant{73};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmFunction, SgAsmSynthesizedDataStructureDeclaration, SgAsmSynthesizedFieldDeclaration>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<73> { using type = SgAsmSynthesizedDeclaration; };

// Class: AsmDirectRegisterExpression
template <> struct describe_node_t<SgAsmDirectRegisterExpression> {
  using node = SgAsmDirectRegisterExpression;
  using base = SgAsmRegisterReferenceExpression;
  static constexpr char const * const name{"AsmDirectRegisterExpression"};
  static constexpr unsigned long variant{74};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<74> { using type = SgAsmDirectRegisterExpression; };

// Class: AsmDwarfAccessDeclaration
template <> struct describe_node_t<SgAsmDwarfAccessDeclaration> {
  using node = SgAsmDwarfAccessDeclaration;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfAccessDeclaration"};
  static constexpr unsigned long variant{75};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<75> { using type = SgAsmDwarfAccessDeclaration; };

// Class: AsmDwarfArrayType
template <> struct describe_field_t<SgAsmDwarfArrayType,SgAsmDwarfConstructList*,&SgAsmDwarfArrayType::p_body> {
  using parent = SgAsmDwarfArrayType;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfArrayType::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfArrayType, SgAsmDwarfConstructList* SgAsmDwarfArrayType::*, &SgAsmDwarfArrayType::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfArrayType> {
  using node = SgAsmDwarfArrayType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfArrayType"};
  static constexpr unsigned long variant{76};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfArrayType,SgAsmDwarfConstructList*,&SgAsmDwarfArrayType::p_body>>;
};
template <> struct node_from_variant_t<76> { using type = SgAsmDwarfArrayType; };

// Class: AsmDwarfBaseType
template <> struct describe_node_t<SgAsmDwarfBaseType> {
  using node = SgAsmDwarfBaseType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfBaseType"};
  static constexpr unsigned long variant{77};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<77> { using type = SgAsmDwarfBaseType; };

// Class: AsmDwarfCatchBlock
template <> struct describe_node_t<SgAsmDwarfCatchBlock> {
  using node = SgAsmDwarfCatchBlock;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfCatchBlock"};
  static constexpr unsigned long variant{78};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<78> { using type = SgAsmDwarfCatchBlock; };

// Class: AsmDwarfClassTemplate
template <> struct describe_node_t<SgAsmDwarfClassTemplate> {
  using node = SgAsmDwarfClassTemplate;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfClassTemplate"};
  static constexpr unsigned long variant{79};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<79> { using type = SgAsmDwarfClassTemplate; };

// Class: AsmDwarfClassType
template <> struct describe_field_t<SgAsmDwarfClassType,SgAsmDwarfConstructList*,&SgAsmDwarfClassType::p_body> {
  using parent = SgAsmDwarfClassType;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfClassType::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfClassType, SgAsmDwarfConstructList* SgAsmDwarfClassType::*, &SgAsmDwarfClassType::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfClassType> {
  using node = SgAsmDwarfClassType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfClassType"};
  static constexpr unsigned long variant{80};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfClassType,SgAsmDwarfConstructList*,&SgAsmDwarfClassType::p_body>>;
};
template <> struct node_from_variant_t<80> { using type = SgAsmDwarfClassType; };

// Class: AsmDwarfCommonBlock
template <> struct describe_field_t<SgAsmDwarfCommonBlock,SgAsmDwarfConstructList*,&SgAsmDwarfCommonBlock::p_body> {
  using parent = SgAsmDwarfCommonBlock;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfCommonBlock::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCommonBlock, SgAsmDwarfConstructList* SgAsmDwarfCommonBlock::*, &SgAsmDwarfCommonBlock::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfCommonBlock> {
  using node = SgAsmDwarfCommonBlock;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfCommonBlock"};
  static constexpr unsigned long variant{81};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfCommonBlock,SgAsmDwarfConstructList*,&SgAsmDwarfCommonBlock::p_body>>;
};
template <> struct node_from_variant_t<81> { using type = SgAsmDwarfCommonBlock; };

// Class: AsmDwarfCommonInclusion
template <> struct describe_node_t<SgAsmDwarfCommonInclusion> {
  using node = SgAsmDwarfCommonInclusion;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfCommonInclusion"};
  static constexpr unsigned long variant{82};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<82> { using type = SgAsmDwarfCommonInclusion; };

// Class: AsmDwarfCompilationUnit
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,std::string,&SgAsmDwarfCompilationUnit::p_producer> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"producer"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_producer};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, std::string SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_producer>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,std::string,&SgAsmDwarfCompilationUnit::p_language> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"language"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_language};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, std::string SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_language>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_low_pc> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = uint64_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"low_pc"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_low_pc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, uint64_t SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_low_pc>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_hi_pc> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = uint64_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"hi_pc"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_hi_pc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, uint64_t SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_hi_pc>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,int,&SgAsmDwarfCompilationUnit::p_version_stamp> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"version_stamp"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_version_stamp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, int SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_version_stamp>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_abbrev_offset> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = uint64_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"abbrev_offset"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_abbrev_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, uint64_t SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_abbrev_offset>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_address_size> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = uint64_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"address_size"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_address_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, uint64_t SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_address_size>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_offset_length> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = uint64_t;
  static constexpr size_t position{7};
  static constexpr char const * const name{"offset_length"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_offset_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, uint64_t SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_offset_length>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,SgAsmDwarfLineList*,&SgAsmDwarfCompilationUnit::p_line_info> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = SgAsmDwarfLineList*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"line_info"};
  static constexpr char const * const typestr{"SgAsmDwarfLineList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_line_info};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, SgAsmDwarfLineList* SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_line_info>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,SgAsmDwarfConstructList*,&SgAsmDwarfCompilationUnit::p_language_constructs> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"language_constructs"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_language_constructs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, SgAsmDwarfConstructList* SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_language_constructs>;
};
template <> struct describe_field_t<SgAsmDwarfCompilationUnit,SgAsmDwarfMacroList*,&SgAsmDwarfCompilationUnit::p_macro_info> {
  using parent = SgAsmDwarfCompilationUnit;
  using field_type = SgAsmDwarfMacroList*;
  static constexpr size_t position{10};
  static constexpr char const * const name{"macro_info"};
  static constexpr char const * const typestr{"SgAsmDwarfMacroList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnit::p_macro_info};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnit, SgAsmDwarfMacroList* SgAsmDwarfCompilationUnit::*, &SgAsmDwarfCompilationUnit::p_macro_info>;
};
template <> struct describe_node_t<SgAsmDwarfCompilationUnit> {
  using node = SgAsmDwarfCompilationUnit;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfCompilationUnit"};
  static constexpr unsigned long variant{83};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfCompilationUnit,std::string,&SgAsmDwarfCompilationUnit::p_producer>, describe_field_t<SgAsmDwarfCompilationUnit,std::string,&SgAsmDwarfCompilationUnit::p_language>, describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_low_pc>, describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_hi_pc>, describe_field_t<SgAsmDwarfCompilationUnit,int,&SgAsmDwarfCompilationUnit::p_version_stamp>, describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_abbrev_offset>, describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_address_size>, describe_field_t<SgAsmDwarfCompilationUnit,uint64_t,&SgAsmDwarfCompilationUnit::p_offset_length>, describe_field_t<SgAsmDwarfCompilationUnit,SgAsmDwarfLineList*,&SgAsmDwarfCompilationUnit::p_line_info>, describe_field_t<SgAsmDwarfCompilationUnit,SgAsmDwarfConstructList*,&SgAsmDwarfCompilationUnit::p_language_constructs>, describe_field_t<SgAsmDwarfCompilationUnit,SgAsmDwarfMacroList*,&SgAsmDwarfCompilationUnit::p_macro_info>>;
};
template <> struct node_from_variant_t<83> { using type = SgAsmDwarfCompilationUnit; };

// Class: AsmDwarfCompilationUnitList
template <> struct describe_field_t<SgAsmDwarfCompilationUnitList,SgAsmDwarfCompilationUnitPtrList,&SgAsmDwarfCompilationUnitList::p_cu_list> {
  using parent = SgAsmDwarfCompilationUnitList;
  using field_type = SgAsmDwarfCompilationUnitPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"cu_list"};
  static constexpr char const * const typestr{"SgAsmDwarfCompilationUnitPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfCompilationUnitList::p_cu_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfCompilationUnitList, SgAsmDwarfCompilationUnitPtrList SgAsmDwarfCompilationUnitList::*, &SgAsmDwarfCompilationUnitList::p_cu_list>;
};
template <> struct describe_node_t<SgAsmDwarfCompilationUnitList> {
  using node = SgAsmDwarfCompilationUnitList;
  using base = SgAsmDwarfInformation;
  static constexpr char const * const name{"AsmDwarfCompilationUnitList"};
  static constexpr unsigned long variant{84};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfCompilationUnitList,SgAsmDwarfCompilationUnitPtrList,&SgAsmDwarfCompilationUnitList::p_cu_list>>;
};
template <> struct node_from_variant_t<84> { using type = SgAsmDwarfCompilationUnitList; };

// Class: AsmDwarfCondition
template <> struct describe_node_t<SgAsmDwarfCondition> {
  using node = SgAsmDwarfCondition;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfCondition"};
  static constexpr unsigned long variant{85};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<85> { using type = SgAsmDwarfCondition; };

// Class: AsmDwarfConstType
template <> struct describe_node_t<SgAsmDwarfConstType> {
  using node = SgAsmDwarfConstType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfConstType"};
  static constexpr unsigned long variant{86};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<86> { using type = SgAsmDwarfConstType; };

// Class: AsmDwarfConstant
template <> struct describe_node_t<SgAsmDwarfConstant> {
  using node = SgAsmDwarfConstant;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfConstant"};
  static constexpr unsigned long variant{87};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<87> { using type = SgAsmDwarfConstant; };

// Class: AsmDwarfConstruct
template <> struct describe_field_t<SgAsmDwarfConstruct,int,&SgAsmDwarfConstruct::p_nesting_level> {
  using parent = SgAsmDwarfConstruct;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"nesting_level"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfConstruct::p_nesting_level};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfConstruct, int SgAsmDwarfConstruct::*, &SgAsmDwarfConstruct::p_nesting_level>;
};
template <> struct describe_field_t<SgAsmDwarfConstruct,uint64_t,&SgAsmDwarfConstruct::p_offset> {
  using parent = SgAsmDwarfConstruct;
  using field_type = uint64_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"offset"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfConstruct::p_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfConstruct, uint64_t SgAsmDwarfConstruct::*, &SgAsmDwarfConstruct::p_offset>;
};
template <> struct describe_field_t<SgAsmDwarfConstruct,uint64_t,&SgAsmDwarfConstruct::p_overall_offset> {
  using parent = SgAsmDwarfConstruct;
  using field_type = uint64_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"overall_offset"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfConstruct::p_overall_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfConstruct, uint64_t SgAsmDwarfConstruct::*, &SgAsmDwarfConstruct::p_overall_offset>;
};
template <> struct describe_field_t<SgAsmDwarfConstruct,std::string,&SgAsmDwarfConstruct::p_name> {
  using parent = SgAsmDwarfConstruct;
  using field_type = std::string;
  static constexpr size_t position{3};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfConstruct::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfConstruct, std::string SgAsmDwarfConstruct::*, &SgAsmDwarfConstruct::p_name>;
};
template <> struct describe_field_t<SgAsmDwarfConstruct,SgAsmDwarfLine*,&SgAsmDwarfConstruct::p_source_position> {
  using parent = SgAsmDwarfConstruct;
  using field_type = SgAsmDwarfLine*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"source_position"};
  static constexpr char const * const typestr{"SgAsmDwarfLine*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfConstruct::p_source_position};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfConstruct, SgAsmDwarfLine* SgAsmDwarfConstruct::*, &SgAsmDwarfConstruct::p_source_position>;
};
template <> struct describe_node_t<SgAsmDwarfConstruct> {
  using node = SgAsmDwarfConstruct;
  using base = SgAsmDwarfInformation;
  static constexpr char const * const name{"AsmDwarfConstruct"};
  static constexpr unsigned long variant{88};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmDwarfAccessDeclaration, SgAsmDwarfArrayType, SgAsmDwarfBaseType, SgAsmDwarfCatchBlock, SgAsmDwarfClassTemplate, SgAsmDwarfClassType, SgAsmDwarfCommonBlock, SgAsmDwarfCommonInclusion, SgAsmDwarfCompilationUnit, SgAsmDwarfCondition, SgAsmDwarfConstant, SgAsmDwarfConstType, SgAsmDwarfDwarfProcedure, SgAsmDwarfEntryPoint, SgAsmDwarfEnumerationType, SgAsmDwarfEnumerator, SgAsmDwarfFileType, SgAsmDwarfFormalParameter, SgAsmDwarfFormatLabel, SgAsmDwarfFriend, SgAsmDwarfFunctionTemplate, SgAsmDwarfImportedDeclaration, SgAsmDwarfImportedModule, SgAsmDwarfImportedUnit, SgAsmDwarfInheritance, SgAsmDwarfInlinedSubroutine, SgAsmDwarfInterfaceType, SgAsmDwarfLabel, SgAsmDwarfLexicalBlock, SgAsmDwarfMember, SgAsmDwarfModule, SgAsmDwarfMutableType, SgAsmDwarfNamelist, SgAsmDwarfNamelistItem, SgAsmDwarfNamespace, SgAsmDwarfPackedType, SgAsmDwarfPartialUnit, SgAsmDwarfPointerType, SgAsmDwarfPtrToMemberType, SgAsmDwarfReferenceType, SgAsmDwarfRestrictType, SgAsmDwarfSetType, SgAsmDwarfSharedType, SgAsmDwarfStringType, SgAsmDwarfStructureType, SgAsmDwarfSubprogram, SgAsmDwarfSubrangeType, SgAsmDwarfSubroutineType, SgAsmDwarfTemplateTypeParameter, SgAsmDwarfTemplateValueParameter, SgAsmDwarfThrownType, SgAsmDwarfTryBlock, SgAsmDwarfTypedef, SgAsmDwarfUnionType, SgAsmDwarfUnknownConstruct, SgAsmDwarfUnspecifiedParameters, SgAsmDwarfUnspecifiedType, SgAsmDwarfUpcRelaxedType, SgAsmDwarfUpcSharedType, SgAsmDwarfUpcStrictType, SgAsmDwarfVariable, SgAsmDwarfVariant, SgAsmDwarfVariantPart, SgAsmDwarfVolatileType, SgAsmDwarfWithStmt>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfConstruct,int,&SgAsmDwarfConstruct::p_nesting_level>, describe_field_t<SgAsmDwarfConstruct,uint64_t,&SgAsmDwarfConstruct::p_offset>, describe_field_t<SgAsmDwarfConstruct,uint64_t,&SgAsmDwarfConstruct::p_overall_offset>, describe_field_t<SgAsmDwarfConstruct,std::string,&SgAsmDwarfConstruct::p_name>, describe_field_t<SgAsmDwarfConstruct,SgAsmDwarfLine*,&SgAsmDwarfConstruct::p_source_position>>;
};
template <> struct node_from_variant_t<88> { using type = SgAsmDwarfConstruct; };

// Class: AsmDwarfConstructList
template <> struct describe_field_t<SgAsmDwarfConstructList,SgAsmDwarfConstructPtrList,&SgAsmDwarfConstructList::p_list> {
  using parent = SgAsmDwarfConstructList;
  using field_type = SgAsmDwarfConstructPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"list"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfConstructList::p_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfConstructList, SgAsmDwarfConstructPtrList SgAsmDwarfConstructList::*, &SgAsmDwarfConstructList::p_list>;
};
template <> struct describe_node_t<SgAsmDwarfConstructList> {
  using node = SgAsmDwarfConstructList;
  using base = SgAsmDwarfInformation;
  static constexpr char const * const name{"AsmDwarfConstructList"};
  static constexpr unsigned long variant{89};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfConstructList,SgAsmDwarfConstructPtrList,&SgAsmDwarfConstructList::p_list>>;
};
template <> struct node_from_variant_t<89> { using type = SgAsmDwarfConstructList; };

// Class: AsmDwarfDwarfProcedure
template <> struct describe_node_t<SgAsmDwarfDwarfProcedure> {
  using node = SgAsmDwarfDwarfProcedure;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfDwarfProcedure"};
  static constexpr unsigned long variant{90};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<90> { using type = SgAsmDwarfDwarfProcedure; };

// Class: AsmDwarfEntryPoint
template <> struct describe_node_t<SgAsmDwarfEntryPoint> {
  using node = SgAsmDwarfEntryPoint;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfEntryPoint"};
  static constexpr unsigned long variant{91};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<91> { using type = SgAsmDwarfEntryPoint; };

// Class: AsmDwarfEnumerationType
template <> struct describe_field_t<SgAsmDwarfEnumerationType,SgAsmDwarfConstructList*,&SgAsmDwarfEnumerationType::p_body> {
  using parent = SgAsmDwarfEnumerationType;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfEnumerationType::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfEnumerationType, SgAsmDwarfConstructList* SgAsmDwarfEnumerationType::*, &SgAsmDwarfEnumerationType::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfEnumerationType> {
  using node = SgAsmDwarfEnumerationType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfEnumerationType"};
  static constexpr unsigned long variant{92};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfEnumerationType,SgAsmDwarfConstructList*,&SgAsmDwarfEnumerationType::p_body>>;
};
template <> struct node_from_variant_t<92> { using type = SgAsmDwarfEnumerationType; };

// Class: AsmDwarfEnumerator
template <> struct describe_node_t<SgAsmDwarfEnumerator> {
  using node = SgAsmDwarfEnumerator;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfEnumerator"};
  static constexpr unsigned long variant{93};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<93> { using type = SgAsmDwarfEnumerator; };

// Class: AsmDwarfFileType
template <> struct describe_node_t<SgAsmDwarfFileType> {
  using node = SgAsmDwarfFileType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfFileType"};
  static constexpr unsigned long variant{94};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<94> { using type = SgAsmDwarfFileType; };

// Class: AsmDwarfFormalParameter
template <> struct describe_node_t<SgAsmDwarfFormalParameter> {
  using node = SgAsmDwarfFormalParameter;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfFormalParameter"};
  static constexpr unsigned long variant{95};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<95> { using type = SgAsmDwarfFormalParameter; };

// Class: AsmDwarfFormatLabel
template <> struct describe_node_t<SgAsmDwarfFormatLabel> {
  using node = SgAsmDwarfFormatLabel;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfFormatLabel"};
  static constexpr unsigned long variant{96};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<96> { using type = SgAsmDwarfFormatLabel; };

// Class: AsmDwarfFriend
template <> struct describe_node_t<SgAsmDwarfFriend> {
  using node = SgAsmDwarfFriend;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfFriend"};
  static constexpr unsigned long variant{97};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<97> { using type = SgAsmDwarfFriend; };

// Class: AsmDwarfFunctionTemplate
template <> struct describe_node_t<SgAsmDwarfFunctionTemplate> {
  using node = SgAsmDwarfFunctionTemplate;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfFunctionTemplate"};
  static constexpr unsigned long variant{98};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<98> { using type = SgAsmDwarfFunctionTemplate; };

// Class: AsmDwarfImportedDeclaration
template <> struct describe_node_t<SgAsmDwarfImportedDeclaration> {
  using node = SgAsmDwarfImportedDeclaration;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfImportedDeclaration"};
  static constexpr unsigned long variant{99};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<99> { using type = SgAsmDwarfImportedDeclaration; };

// Class: AsmDwarfImportedModule
template <> struct describe_node_t<SgAsmDwarfImportedModule> {
  using node = SgAsmDwarfImportedModule;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfImportedModule"};
  static constexpr unsigned long variant{100};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<100> { using type = SgAsmDwarfImportedModule; };

// Class: AsmDwarfImportedUnit
template <> struct describe_node_t<SgAsmDwarfImportedUnit> {
  using node = SgAsmDwarfImportedUnit;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfImportedUnit"};
  static constexpr unsigned long variant{101};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<101> { using type = SgAsmDwarfImportedUnit; };

// Class: AsmDwarfInformation
template <> struct describe_node_t<SgAsmDwarfInformation> {
  using node = SgAsmDwarfInformation;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmDwarfInformation"};
  static constexpr unsigned long variant{102};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmDwarfCompilationUnitList, SgAsmDwarfConstruct, SgAsmDwarfConstructList, SgAsmDwarfLine, SgAsmDwarfLineList, SgAsmDwarfMacro, SgAsmDwarfMacroList>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<102> { using type = SgAsmDwarfInformation; };

// Class: AsmDwarfInheritance
template <> struct describe_node_t<SgAsmDwarfInheritance> {
  using node = SgAsmDwarfInheritance;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfInheritance"};
  static constexpr unsigned long variant{103};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<103> { using type = SgAsmDwarfInheritance; };

// Class: AsmDwarfInlinedSubroutine
template <> struct describe_field_t<SgAsmDwarfInlinedSubroutine,SgAsmDwarfConstructList*,&SgAsmDwarfInlinedSubroutine::p_body> {
  using parent = SgAsmDwarfInlinedSubroutine;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfInlinedSubroutine::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfInlinedSubroutine, SgAsmDwarfConstructList* SgAsmDwarfInlinedSubroutine::*, &SgAsmDwarfInlinedSubroutine::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfInlinedSubroutine> {
  using node = SgAsmDwarfInlinedSubroutine;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfInlinedSubroutine"};
  static constexpr unsigned long variant{104};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfInlinedSubroutine,SgAsmDwarfConstructList*,&SgAsmDwarfInlinedSubroutine::p_body>>;
};
template <> struct node_from_variant_t<104> { using type = SgAsmDwarfInlinedSubroutine; };

// Class: AsmDwarfInterfaceType
template <> struct describe_node_t<SgAsmDwarfInterfaceType> {
  using node = SgAsmDwarfInterfaceType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfInterfaceType"};
  static constexpr unsigned long variant{105};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<105> { using type = SgAsmDwarfInterfaceType; };

// Class: AsmDwarfLabel
template <> struct describe_node_t<SgAsmDwarfLabel> {
  using node = SgAsmDwarfLabel;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfLabel"};
  static constexpr unsigned long variant{106};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<106> { using type = SgAsmDwarfLabel; };

// Class: AsmDwarfLexicalBlock
template <> struct describe_field_t<SgAsmDwarfLexicalBlock,SgAsmDwarfConstructList*,&SgAsmDwarfLexicalBlock::p_body> {
  using parent = SgAsmDwarfLexicalBlock;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfLexicalBlock::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfLexicalBlock, SgAsmDwarfConstructList* SgAsmDwarfLexicalBlock::*, &SgAsmDwarfLexicalBlock::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfLexicalBlock> {
  using node = SgAsmDwarfLexicalBlock;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfLexicalBlock"};
  static constexpr unsigned long variant{107};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfLexicalBlock,SgAsmDwarfConstructList*,&SgAsmDwarfLexicalBlock::p_body>>;
};
template <> struct node_from_variant_t<107> { using type = SgAsmDwarfLexicalBlock; };

// Class: AsmDwarfLine
template <> struct describe_field_t<SgAsmDwarfLine,uint64_t,&SgAsmDwarfLine::p_address> {
  using parent = SgAsmDwarfLine;
  using field_type = uint64_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"address"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfLine::p_address};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfLine, uint64_t SgAsmDwarfLine::*, &SgAsmDwarfLine::p_address>;
};
template <> struct describe_field_t<SgAsmDwarfLine,int,&SgAsmDwarfLine::p_file_id> {
  using parent = SgAsmDwarfLine;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"file_id"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfLine::p_file_id};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfLine, int SgAsmDwarfLine::*, &SgAsmDwarfLine::p_file_id>;
};
template <> struct describe_field_t<SgAsmDwarfLine,int,&SgAsmDwarfLine::p_line> {
  using parent = SgAsmDwarfLine;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"line"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfLine::p_line};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfLine, int SgAsmDwarfLine::*, &SgAsmDwarfLine::p_line>;
};
template <> struct describe_field_t<SgAsmDwarfLine,int,&SgAsmDwarfLine::p_column> {
  using parent = SgAsmDwarfLine;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"column"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfLine::p_column};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfLine, int SgAsmDwarfLine::*, &SgAsmDwarfLine::p_column>;
};
template <> struct describe_node_t<SgAsmDwarfLine> {
  using node = SgAsmDwarfLine;
  using base = SgAsmDwarfInformation;
  static constexpr char const * const name{"AsmDwarfLine"};
  static constexpr unsigned long variant{108};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfLine,uint64_t,&SgAsmDwarfLine::p_address>, describe_field_t<SgAsmDwarfLine,int,&SgAsmDwarfLine::p_file_id>, describe_field_t<SgAsmDwarfLine,int,&SgAsmDwarfLine::p_line>, describe_field_t<SgAsmDwarfLine,int,&SgAsmDwarfLine::p_column>>;
};
template <> struct node_from_variant_t<108> { using type = SgAsmDwarfLine; };

// Class: AsmDwarfLineList
template <> struct describe_field_t<SgAsmDwarfLineList,SgAsmDwarfLinePtrList,&SgAsmDwarfLineList::p_line_list> {
  using parent = SgAsmDwarfLineList;
  using field_type = SgAsmDwarfLinePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"line_list"};
  static constexpr char const * const typestr{"SgAsmDwarfLinePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfLineList::p_line_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfLineList, SgAsmDwarfLinePtrList SgAsmDwarfLineList::*, &SgAsmDwarfLineList::p_line_list>;
};
template <> struct describe_node_t<SgAsmDwarfLineList> {
  using node = SgAsmDwarfLineList;
  using base = SgAsmDwarfInformation;
  static constexpr char const * const name{"AsmDwarfLineList"};
  static constexpr unsigned long variant{109};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfLineList,SgAsmDwarfLinePtrList,&SgAsmDwarfLineList::p_line_list>>;
};
template <> struct node_from_variant_t<109> { using type = SgAsmDwarfLineList; };

// Class: AsmDwarfMacro
template <> struct describe_field_t<SgAsmDwarfMacro,std::string,&SgAsmDwarfMacro::p_macro_string> {
  using parent = SgAsmDwarfMacro;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"macro_string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmDwarfMacro::p_macro_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfMacro, std::string SgAsmDwarfMacro::*, &SgAsmDwarfMacro::p_macro_string>;
};
template <> struct describe_node_t<SgAsmDwarfMacro> {
  using node = SgAsmDwarfMacro;
  using base = SgAsmDwarfInformation;
  static constexpr char const * const name{"AsmDwarfMacro"};
  static constexpr unsigned long variant{110};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfMacro,std::string,&SgAsmDwarfMacro::p_macro_string>>;
};
template <> struct node_from_variant_t<110> { using type = SgAsmDwarfMacro; };

// Class: AsmDwarfMacroList
template <> struct describe_field_t<SgAsmDwarfMacroList,SgAsmDwarfMacroPtrList,&SgAsmDwarfMacroList::p_macro_list> {
  using parent = SgAsmDwarfMacroList;
  using field_type = SgAsmDwarfMacroPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"macro_list"};
  static constexpr char const * const typestr{"SgAsmDwarfMacroPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfMacroList::p_macro_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfMacroList, SgAsmDwarfMacroPtrList SgAsmDwarfMacroList::*, &SgAsmDwarfMacroList::p_macro_list>;
};
template <> struct describe_node_t<SgAsmDwarfMacroList> {
  using node = SgAsmDwarfMacroList;
  using base = SgAsmDwarfInformation;
  static constexpr char const * const name{"AsmDwarfMacroList"};
  static constexpr unsigned long variant{111};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfMacroList,SgAsmDwarfMacroPtrList,&SgAsmDwarfMacroList::p_macro_list>>;
};
template <> struct node_from_variant_t<111> { using type = SgAsmDwarfMacroList; };

// Class: AsmDwarfMember
template <> struct describe_node_t<SgAsmDwarfMember> {
  using node = SgAsmDwarfMember;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfMember"};
  static constexpr unsigned long variant{112};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<112> { using type = SgAsmDwarfMember; };

// Class: AsmDwarfModule
template <> struct describe_node_t<SgAsmDwarfModule> {
  using node = SgAsmDwarfModule;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfModule"};
  static constexpr unsigned long variant{113};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<113> { using type = SgAsmDwarfModule; };

// Class: AsmDwarfMutableType
template <> struct describe_node_t<SgAsmDwarfMutableType> {
  using node = SgAsmDwarfMutableType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfMutableType"};
  static constexpr unsigned long variant{114};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<114> { using type = SgAsmDwarfMutableType; };

// Class: AsmDwarfNamelist
template <> struct describe_node_t<SgAsmDwarfNamelist> {
  using node = SgAsmDwarfNamelist;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfNamelist"};
  static constexpr unsigned long variant{115};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<115> { using type = SgAsmDwarfNamelist; };

// Class: AsmDwarfNamelistItem
template <> struct describe_node_t<SgAsmDwarfNamelistItem> {
  using node = SgAsmDwarfNamelistItem;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfNamelistItem"};
  static constexpr unsigned long variant{116};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<116> { using type = SgAsmDwarfNamelistItem; };

// Class: AsmDwarfNamespace
template <> struct describe_field_t<SgAsmDwarfNamespace,SgAsmDwarfConstructList*,&SgAsmDwarfNamespace::p_body> {
  using parent = SgAsmDwarfNamespace;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfNamespace::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfNamespace, SgAsmDwarfConstructList* SgAsmDwarfNamespace::*, &SgAsmDwarfNamespace::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfNamespace> {
  using node = SgAsmDwarfNamespace;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfNamespace"};
  static constexpr unsigned long variant{117};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfNamespace,SgAsmDwarfConstructList*,&SgAsmDwarfNamespace::p_body>>;
};
template <> struct node_from_variant_t<117> { using type = SgAsmDwarfNamespace; };

// Class: AsmDwarfPackedType
template <> struct describe_node_t<SgAsmDwarfPackedType> {
  using node = SgAsmDwarfPackedType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfPackedType"};
  static constexpr unsigned long variant{118};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<118> { using type = SgAsmDwarfPackedType; };

// Class: AsmDwarfPartialUnit
template <> struct describe_node_t<SgAsmDwarfPartialUnit> {
  using node = SgAsmDwarfPartialUnit;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfPartialUnit"};
  static constexpr unsigned long variant{119};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<119> { using type = SgAsmDwarfPartialUnit; };

// Class: AsmDwarfPointerType
template <> struct describe_node_t<SgAsmDwarfPointerType> {
  using node = SgAsmDwarfPointerType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfPointerType"};
  static constexpr unsigned long variant{120};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<120> { using type = SgAsmDwarfPointerType; };

// Class: AsmDwarfPtrToMemberType
template <> struct describe_node_t<SgAsmDwarfPtrToMemberType> {
  using node = SgAsmDwarfPtrToMemberType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfPtrToMemberType"};
  static constexpr unsigned long variant{121};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<121> { using type = SgAsmDwarfPtrToMemberType; };

// Class: AsmDwarfReferenceType
template <> struct describe_node_t<SgAsmDwarfReferenceType> {
  using node = SgAsmDwarfReferenceType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfReferenceType"};
  static constexpr unsigned long variant{122};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<122> { using type = SgAsmDwarfReferenceType; };

// Class: AsmDwarfRestrictType
template <> struct describe_node_t<SgAsmDwarfRestrictType> {
  using node = SgAsmDwarfRestrictType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfRestrictType"};
  static constexpr unsigned long variant{123};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<123> { using type = SgAsmDwarfRestrictType; };

// Class: AsmDwarfSetType
template <> struct describe_node_t<SgAsmDwarfSetType> {
  using node = SgAsmDwarfSetType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfSetType"};
  static constexpr unsigned long variant{124};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<124> { using type = SgAsmDwarfSetType; };

// Class: AsmDwarfSharedType
template <> struct describe_node_t<SgAsmDwarfSharedType> {
  using node = SgAsmDwarfSharedType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfSharedType"};
  static constexpr unsigned long variant{125};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<125> { using type = SgAsmDwarfSharedType; };

// Class: AsmDwarfStringType
template <> struct describe_node_t<SgAsmDwarfStringType> {
  using node = SgAsmDwarfStringType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfStringType"};
  static constexpr unsigned long variant{126};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<126> { using type = SgAsmDwarfStringType; };

// Class: AsmDwarfStructureType
template <> struct describe_field_t<SgAsmDwarfStructureType,SgAsmDwarfConstructList*,&SgAsmDwarfStructureType::p_body> {
  using parent = SgAsmDwarfStructureType;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfStructureType::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfStructureType, SgAsmDwarfConstructList* SgAsmDwarfStructureType::*, &SgAsmDwarfStructureType::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfStructureType> {
  using node = SgAsmDwarfStructureType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfStructureType"};
  static constexpr unsigned long variant{127};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfStructureType,SgAsmDwarfConstructList*,&SgAsmDwarfStructureType::p_body>>;
};
template <> struct node_from_variant_t<127> { using type = SgAsmDwarfStructureType; };

// Class: AsmDwarfSubprogram
template <> struct describe_field_t<SgAsmDwarfSubprogram,SgAsmDwarfConstructList*,&SgAsmDwarfSubprogram::p_body> {
  using parent = SgAsmDwarfSubprogram;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfSubprogram::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfSubprogram, SgAsmDwarfConstructList* SgAsmDwarfSubprogram::*, &SgAsmDwarfSubprogram::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfSubprogram> {
  using node = SgAsmDwarfSubprogram;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfSubprogram"};
  static constexpr unsigned long variant{128};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfSubprogram,SgAsmDwarfConstructList*,&SgAsmDwarfSubprogram::p_body>>;
};
template <> struct node_from_variant_t<128> { using type = SgAsmDwarfSubprogram; };

// Class: AsmDwarfSubrangeType
template <> struct describe_node_t<SgAsmDwarfSubrangeType> {
  using node = SgAsmDwarfSubrangeType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfSubrangeType"};
  static constexpr unsigned long variant{129};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<129> { using type = SgAsmDwarfSubrangeType; };

// Class: AsmDwarfSubroutineType
template <> struct describe_field_t<SgAsmDwarfSubroutineType,SgAsmDwarfConstructList*,&SgAsmDwarfSubroutineType::p_body> {
  using parent = SgAsmDwarfSubroutineType;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfSubroutineType::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfSubroutineType, SgAsmDwarfConstructList* SgAsmDwarfSubroutineType::*, &SgAsmDwarfSubroutineType::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfSubroutineType> {
  using node = SgAsmDwarfSubroutineType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfSubroutineType"};
  static constexpr unsigned long variant{130};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfSubroutineType,SgAsmDwarfConstructList*,&SgAsmDwarfSubroutineType::p_body>>;
};
template <> struct node_from_variant_t<130> { using type = SgAsmDwarfSubroutineType; };

// Class: AsmDwarfTemplateTypeParameter
template <> struct describe_node_t<SgAsmDwarfTemplateTypeParameter> {
  using node = SgAsmDwarfTemplateTypeParameter;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfTemplateTypeParameter"};
  static constexpr unsigned long variant{131};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<131> { using type = SgAsmDwarfTemplateTypeParameter; };

// Class: AsmDwarfTemplateValueParameter
template <> struct describe_node_t<SgAsmDwarfTemplateValueParameter> {
  using node = SgAsmDwarfTemplateValueParameter;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfTemplateValueParameter"};
  static constexpr unsigned long variant{132};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<132> { using type = SgAsmDwarfTemplateValueParameter; };

// Class: AsmDwarfThrownType
template <> struct describe_node_t<SgAsmDwarfThrownType> {
  using node = SgAsmDwarfThrownType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfThrownType"};
  static constexpr unsigned long variant{133};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<133> { using type = SgAsmDwarfThrownType; };

// Class: AsmDwarfTryBlock
template <> struct describe_node_t<SgAsmDwarfTryBlock> {
  using node = SgAsmDwarfTryBlock;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfTryBlock"};
  static constexpr unsigned long variant{134};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<134> { using type = SgAsmDwarfTryBlock; };

// Class: AsmDwarfTypedef
template <> struct describe_node_t<SgAsmDwarfTypedef> {
  using node = SgAsmDwarfTypedef;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfTypedef"};
  static constexpr unsigned long variant{135};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<135> { using type = SgAsmDwarfTypedef; };

// Class: AsmDwarfUnionType
template <> struct describe_field_t<SgAsmDwarfUnionType,SgAsmDwarfConstructList*,&SgAsmDwarfUnionType::p_body> {
  using parent = SgAsmDwarfUnionType;
  using field_type = SgAsmDwarfConstructList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmDwarfConstructList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmDwarfUnionType::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmDwarfUnionType, SgAsmDwarfConstructList* SgAsmDwarfUnionType::*, &SgAsmDwarfUnionType::p_body>;
};
template <> struct describe_node_t<SgAsmDwarfUnionType> {
  using node = SgAsmDwarfUnionType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfUnionType"};
  static constexpr unsigned long variant{136};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmDwarfUnionType,SgAsmDwarfConstructList*,&SgAsmDwarfUnionType::p_body>>;
};
template <> struct node_from_variant_t<136> { using type = SgAsmDwarfUnionType; };

// Class: AsmDwarfUnknownConstruct
template <> struct describe_node_t<SgAsmDwarfUnknownConstruct> {
  using node = SgAsmDwarfUnknownConstruct;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfUnknownConstruct"};
  static constexpr unsigned long variant{137};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<137> { using type = SgAsmDwarfUnknownConstruct; };

// Class: AsmDwarfUnspecifiedParameters
template <> struct describe_node_t<SgAsmDwarfUnspecifiedParameters> {
  using node = SgAsmDwarfUnspecifiedParameters;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfUnspecifiedParameters"};
  static constexpr unsigned long variant{138};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<138> { using type = SgAsmDwarfUnspecifiedParameters; };

// Class: AsmDwarfUnspecifiedType
template <> struct describe_node_t<SgAsmDwarfUnspecifiedType> {
  using node = SgAsmDwarfUnspecifiedType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfUnspecifiedType"};
  static constexpr unsigned long variant{139};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<139> { using type = SgAsmDwarfUnspecifiedType; };

// Class: AsmDwarfUpcRelaxedType
template <> struct describe_node_t<SgAsmDwarfUpcRelaxedType> {
  using node = SgAsmDwarfUpcRelaxedType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfUpcRelaxedType"};
  static constexpr unsigned long variant{140};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<140> { using type = SgAsmDwarfUpcRelaxedType; };

// Class: AsmDwarfUpcSharedType
template <> struct describe_node_t<SgAsmDwarfUpcSharedType> {
  using node = SgAsmDwarfUpcSharedType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfUpcSharedType"};
  static constexpr unsigned long variant{141};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<141> { using type = SgAsmDwarfUpcSharedType; };

// Class: AsmDwarfUpcStrictType
template <> struct describe_node_t<SgAsmDwarfUpcStrictType> {
  using node = SgAsmDwarfUpcStrictType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfUpcStrictType"};
  static constexpr unsigned long variant{142};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<142> { using type = SgAsmDwarfUpcStrictType; };

// Class: AsmDwarfVariable
template <> struct describe_node_t<SgAsmDwarfVariable> {
  using node = SgAsmDwarfVariable;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfVariable"};
  static constexpr unsigned long variant{143};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<143> { using type = SgAsmDwarfVariable; };

// Class: AsmDwarfVariant
template <> struct describe_node_t<SgAsmDwarfVariant> {
  using node = SgAsmDwarfVariant;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfVariant"};
  static constexpr unsigned long variant{144};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<144> { using type = SgAsmDwarfVariant; };

// Class: AsmDwarfVariantPart
template <> struct describe_node_t<SgAsmDwarfVariantPart> {
  using node = SgAsmDwarfVariantPart;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfVariantPart"};
  static constexpr unsigned long variant{145};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<145> { using type = SgAsmDwarfVariantPart; };

// Class: AsmDwarfVolatileType
template <> struct describe_node_t<SgAsmDwarfVolatileType> {
  using node = SgAsmDwarfVolatileType;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfVolatileType"};
  static constexpr unsigned long variant{146};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<146> { using type = SgAsmDwarfVolatileType; };

// Class: AsmDwarfWithStmt
template <> struct describe_node_t<SgAsmDwarfWithStmt> {
  using node = SgAsmDwarfWithStmt;
  using base = SgAsmDwarfConstruct;
  static constexpr char const * const name{"AsmDwarfWithStmt"};
  static constexpr unsigned long variant{147};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<147> { using type = SgAsmDwarfWithStmt; };

// Class: AsmElfDynamicEntry
template <> struct describe_field_t<SgAsmElfDynamicEntry,SgAsmElfDynamicEntry::EntryType,&SgAsmElfDynamicEntry::p_d_tag> {
  using parent = SgAsmElfDynamicEntry;
  using field_type = SgAsmElfDynamicEntry::EntryType;
  static constexpr size_t position{0};
  static constexpr char const * const name{"d_tag"};
  static constexpr char const * const typestr{"SgAsmElfDynamicEntry::EntryType"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfDynamicEntry::p_d_tag};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfDynamicEntry, SgAsmElfDynamicEntry::EntryType SgAsmElfDynamicEntry::*, &SgAsmElfDynamicEntry::p_d_tag>;
};
template <> struct describe_field_t<SgAsmElfDynamicEntry,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmElfDynamicEntry::p_d_val> {
  using parent = SgAsmElfDynamicEntry;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{1};
  static constexpr char const * const name{"d_val"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfDynamicEntry::p_d_val};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfDynamicEntry, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmElfDynamicEntry::*, &SgAsmElfDynamicEntry::p_d_val>;
};
template <> struct describe_field_t<SgAsmElfDynamicEntry,SgAsmGenericString*,&SgAsmElfDynamicEntry::p_name> {
  using parent = SgAsmElfDynamicEntry;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfDynamicEntry::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfDynamicEntry, SgAsmGenericString* SgAsmElfDynamicEntry::*, &SgAsmElfDynamicEntry::p_name>;
};
template <> struct describe_field_t<SgAsmElfDynamicEntry,SgUnsignedCharList,&SgAsmElfDynamicEntry::p_extra> {
  using parent = SgAsmElfDynamicEntry;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"extra"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfDynamicEntry::p_extra};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfDynamicEntry, SgUnsignedCharList SgAsmElfDynamicEntry::*, &SgAsmElfDynamicEntry::p_extra>;
};
template <> struct describe_node_t<SgAsmElfDynamicEntry> {
  using node = SgAsmElfDynamicEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfDynamicEntry"};
  static constexpr unsigned long variant{148};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfDynamicEntry,SgAsmElfDynamicEntry::EntryType,&SgAsmElfDynamicEntry::p_d_tag>, describe_field_t<SgAsmElfDynamicEntry,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmElfDynamicEntry::p_d_val>, describe_field_t<SgAsmElfDynamicEntry,SgAsmGenericString*,&SgAsmElfDynamicEntry::p_name>, describe_field_t<SgAsmElfDynamicEntry,SgUnsignedCharList,&SgAsmElfDynamicEntry::p_extra>>;
};
template <> struct node_from_variant_t<148> { using type = SgAsmElfDynamicEntry; };

// Class: AsmElfDynamicEntryList
template <> struct describe_field_t<SgAsmElfDynamicEntryList,SgAsmElfDynamicEntryPtrList,&SgAsmElfDynamicEntryList::p_entries> {
  using parent = SgAsmElfDynamicEntryList;
  using field_type = SgAsmElfDynamicEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfDynamicEntryPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfDynamicEntryList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfDynamicEntryList, SgAsmElfDynamicEntryPtrList SgAsmElfDynamicEntryList::*, &SgAsmElfDynamicEntryList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfDynamicEntryList> {
  using node = SgAsmElfDynamicEntryList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfDynamicEntryList"};
  static constexpr unsigned long variant{149};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfDynamicEntryList,SgAsmElfDynamicEntryPtrList,&SgAsmElfDynamicEntryList::p_entries>>;
};
template <> struct node_from_variant_t<149> { using type = SgAsmElfDynamicEntryList; };

// Class: AsmElfDynamicSection
template <> struct describe_field_t<SgAsmElfDynamicSection,SgAsmElfDynamicEntryList*,&SgAsmElfDynamicSection::p_entries> {
  using parent = SgAsmElfDynamicSection;
  using field_type = SgAsmElfDynamicEntryList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfDynamicEntryList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfDynamicSection::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfDynamicSection, SgAsmElfDynamicEntryList* SgAsmElfDynamicSection::*, &SgAsmElfDynamicSection::p_entries>;
};
template <> struct describe_node_t<SgAsmElfDynamicSection> {
  using node = SgAsmElfDynamicSection;
  using base = SgAsmElfSection;
  static constexpr char const * const name{"AsmElfDynamicSection"};
  static constexpr unsigned long variant{150};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfDynamicSection,SgAsmElfDynamicEntryList*,&SgAsmElfDynamicSection::p_entries>>;
};
template <> struct node_from_variant_t<150> { using type = SgAsmElfDynamicSection; };

// Class: AsmElfEHFrameEntryCI
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,int,&SgAsmElfEHFrameEntryCI::p_version> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"version"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_version};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, int SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_version>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,std::string,&SgAsmElfEHFrameEntryCI::p_augmentation_string> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"augmentation_string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_augmentation_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, std::string SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_augmentation_string>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,uint64_t,&SgAsmElfEHFrameEntryCI::p_eh_data> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = uint64_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"eh_data"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_eh_data};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, uint64_t SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_eh_data>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,uint64_t,&SgAsmElfEHFrameEntryCI::p_code_alignment_factor> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = uint64_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"code_alignment_factor"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_code_alignment_factor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, uint64_t SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_code_alignment_factor>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,int64_t,&SgAsmElfEHFrameEntryCI::p_data_alignment_factor> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = int64_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"data_alignment_factor"};
  static constexpr char const * const typestr{"int64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_data_alignment_factor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, int64_t SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_data_alignment_factor>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,uint64_t,&SgAsmElfEHFrameEntryCI::p_augmentation_data_length> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = uint64_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"augmentation_data_length"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_augmentation_data_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, uint64_t SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_augmentation_data_length>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,int,&SgAsmElfEHFrameEntryCI::p_lsda_encoding> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = int;
  static constexpr size_t position{6};
  static constexpr char const * const name{"lsda_encoding"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_lsda_encoding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, int SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_lsda_encoding>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,int,&SgAsmElfEHFrameEntryCI::p_prh_encoding> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = int;
  static constexpr size_t position{7};
  static constexpr char const * const name{"prh_encoding"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_prh_encoding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, int SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_prh_encoding>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,unsigned,&SgAsmElfEHFrameEntryCI::p_prh_arg> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = unsigned;
  static constexpr size_t position{8};
  static constexpr char const * const name{"prh_arg"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_prh_arg};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, unsigned SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_prh_arg>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,Rose::BinaryAnalysis::Address,&SgAsmElfEHFrameEntryCI::p_prh_addr> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{9};
  static constexpr char const * const name{"prh_addr"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_prh_addr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, Rose::BinaryAnalysis::Address SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_prh_addr>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,int,&SgAsmElfEHFrameEntryCI::p_addr_encoding> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = int;
  static constexpr size_t position{10};
  static constexpr char const * const name{"addr_encoding"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_addr_encoding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, int SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_addr_encoding>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,bool,&SgAsmElfEHFrameEntryCI::p_sig_frame> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"sig_frame"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_sig_frame};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, bool SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_sig_frame>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,SgUnsignedCharList,&SgAsmElfEHFrameEntryCI::p_instructions> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{12};
  static constexpr char const * const name{"instructions"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_instructions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, SgUnsignedCharList SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_instructions>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryCI,SgAsmElfEHFrameEntryFDList*,&SgAsmElfEHFrameEntryCI::p_fd_entries> {
  using parent = SgAsmElfEHFrameEntryCI;
  using field_type = SgAsmElfEHFrameEntryFDList*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"fd_entries"};
  static constexpr char const * const typestr{"SgAsmElfEHFrameEntryFDList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCI::p_fd_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCI, SgAsmElfEHFrameEntryFDList* SgAsmElfEHFrameEntryCI::*, &SgAsmElfEHFrameEntryCI::p_fd_entries>;
};
template <> struct describe_node_t<SgAsmElfEHFrameEntryCI> {
  using node = SgAsmElfEHFrameEntryCI;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfEHFrameEntryCI"};
  static constexpr unsigned long variant{151};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfEHFrameEntryCI,int,&SgAsmElfEHFrameEntryCI::p_version>, describe_field_t<SgAsmElfEHFrameEntryCI,std::string,&SgAsmElfEHFrameEntryCI::p_augmentation_string>, describe_field_t<SgAsmElfEHFrameEntryCI,uint64_t,&SgAsmElfEHFrameEntryCI::p_eh_data>, describe_field_t<SgAsmElfEHFrameEntryCI,uint64_t,&SgAsmElfEHFrameEntryCI::p_code_alignment_factor>, describe_field_t<SgAsmElfEHFrameEntryCI,int64_t,&SgAsmElfEHFrameEntryCI::p_data_alignment_factor>, describe_field_t<SgAsmElfEHFrameEntryCI,uint64_t,&SgAsmElfEHFrameEntryCI::p_augmentation_data_length>, describe_field_t<SgAsmElfEHFrameEntryCI,int,&SgAsmElfEHFrameEntryCI::p_lsda_encoding>, describe_field_t<SgAsmElfEHFrameEntryCI,int,&SgAsmElfEHFrameEntryCI::p_prh_encoding>, describe_field_t<SgAsmElfEHFrameEntryCI,unsigned,&SgAsmElfEHFrameEntryCI::p_prh_arg>, describe_field_t<SgAsmElfEHFrameEntryCI,Rose::BinaryAnalysis::Address,&SgAsmElfEHFrameEntryCI::p_prh_addr>, describe_field_t<SgAsmElfEHFrameEntryCI,int,&SgAsmElfEHFrameEntryCI::p_addr_encoding>, describe_field_t<SgAsmElfEHFrameEntryCI,bool,&SgAsmElfEHFrameEntryCI::p_sig_frame>, describe_field_t<SgAsmElfEHFrameEntryCI,SgUnsignedCharList,&SgAsmElfEHFrameEntryCI::p_instructions>, describe_field_t<SgAsmElfEHFrameEntryCI,SgAsmElfEHFrameEntryFDList*,&SgAsmElfEHFrameEntryCI::p_fd_entries>>;
};
template <> struct node_from_variant_t<151> { using type = SgAsmElfEHFrameEntryCI; };

// Class: AsmElfEHFrameEntryCIList
template <> struct describe_field_t<SgAsmElfEHFrameEntryCIList,SgAsmElfEHFrameEntryCIPtrList,&SgAsmElfEHFrameEntryCIList::p_entries> {
  using parent = SgAsmElfEHFrameEntryCIList;
  using field_type = SgAsmElfEHFrameEntryCIPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfEHFrameEntryCIPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryCIList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryCIList, SgAsmElfEHFrameEntryCIPtrList SgAsmElfEHFrameEntryCIList::*, &SgAsmElfEHFrameEntryCIList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfEHFrameEntryCIList> {
  using node = SgAsmElfEHFrameEntryCIList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfEHFrameEntryCIList"};
  static constexpr unsigned long variant{152};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfEHFrameEntryCIList,SgAsmElfEHFrameEntryCIPtrList,&SgAsmElfEHFrameEntryCIList::p_entries>>;
};
template <> struct node_from_variant_t<152> { using type = SgAsmElfEHFrameEntryCIList; };

// Class: AsmElfEHFrameEntryFD
template <> struct describe_field_t<SgAsmElfEHFrameEntryFD,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmElfEHFrameEntryFD::p_begin_rva> {
  using parent = SgAsmElfEHFrameEntryFD;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{0};
  static constexpr char const * const name{"begin_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryFD::p_begin_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryFD, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmElfEHFrameEntryFD::*, &SgAsmElfEHFrameEntryFD::p_begin_rva>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryFD,Rose::BinaryAnalysis::Address,&SgAsmElfEHFrameEntryFD::p_size> {
  using parent = SgAsmElfEHFrameEntryFD;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{1};
  static constexpr char const * const name{"size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryFD::p_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryFD, Rose::BinaryAnalysis::Address SgAsmElfEHFrameEntryFD::*, &SgAsmElfEHFrameEntryFD::p_size>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryFD,SgUnsignedCharList,&SgAsmElfEHFrameEntryFD::p_augmentation_data> {
  using parent = SgAsmElfEHFrameEntryFD;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"augmentation_data"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryFD::p_augmentation_data};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryFD, SgUnsignedCharList SgAsmElfEHFrameEntryFD::*, &SgAsmElfEHFrameEntryFD::p_augmentation_data>;
};
template <> struct describe_field_t<SgAsmElfEHFrameEntryFD,SgUnsignedCharList,&SgAsmElfEHFrameEntryFD::p_instructions> {
  using parent = SgAsmElfEHFrameEntryFD;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"instructions"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryFD::p_instructions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryFD, SgUnsignedCharList SgAsmElfEHFrameEntryFD::*, &SgAsmElfEHFrameEntryFD::p_instructions>;
};
template <> struct describe_node_t<SgAsmElfEHFrameEntryFD> {
  using node = SgAsmElfEHFrameEntryFD;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfEHFrameEntryFD"};
  static constexpr unsigned long variant{153};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfEHFrameEntryFD,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmElfEHFrameEntryFD::p_begin_rva>, describe_field_t<SgAsmElfEHFrameEntryFD,Rose::BinaryAnalysis::Address,&SgAsmElfEHFrameEntryFD::p_size>, describe_field_t<SgAsmElfEHFrameEntryFD,SgUnsignedCharList,&SgAsmElfEHFrameEntryFD::p_augmentation_data>, describe_field_t<SgAsmElfEHFrameEntryFD,SgUnsignedCharList,&SgAsmElfEHFrameEntryFD::p_instructions>>;
};
template <> struct node_from_variant_t<153> { using type = SgAsmElfEHFrameEntryFD; };

// Class: AsmElfEHFrameEntryFDList
template <> struct describe_field_t<SgAsmElfEHFrameEntryFDList,SgAsmElfEHFrameEntryFDPtrList,&SgAsmElfEHFrameEntryFDList::p_entries> {
  using parent = SgAsmElfEHFrameEntryFDList;
  using field_type = SgAsmElfEHFrameEntryFDPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfEHFrameEntryFDPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameEntryFDList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameEntryFDList, SgAsmElfEHFrameEntryFDPtrList SgAsmElfEHFrameEntryFDList::*, &SgAsmElfEHFrameEntryFDList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfEHFrameEntryFDList> {
  using node = SgAsmElfEHFrameEntryFDList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfEHFrameEntryFDList"};
  static constexpr unsigned long variant{154};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfEHFrameEntryFDList,SgAsmElfEHFrameEntryFDPtrList,&SgAsmElfEHFrameEntryFDList::p_entries>>;
};
template <> struct node_from_variant_t<154> { using type = SgAsmElfEHFrameEntryFDList; };

// Class: AsmElfEHFrameSection
template <> struct describe_field_t<SgAsmElfEHFrameSection,SgAsmElfEHFrameEntryCIList*,&SgAsmElfEHFrameSection::p_ci_entries> {
  using parent = SgAsmElfEHFrameSection;
  using field_type = SgAsmElfEHFrameEntryCIList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"ci_entries"};
  static constexpr char const * const typestr{"SgAsmElfEHFrameEntryCIList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfEHFrameSection::p_ci_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfEHFrameSection, SgAsmElfEHFrameEntryCIList* SgAsmElfEHFrameSection::*, &SgAsmElfEHFrameSection::p_ci_entries>;
};
template <> struct describe_node_t<SgAsmElfEHFrameSection> {
  using node = SgAsmElfEHFrameSection;
  using base = SgAsmElfSection;
  static constexpr char const * const name{"AsmElfEHFrameSection"};
  static constexpr unsigned long variant{155};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfEHFrameSection,SgAsmElfEHFrameEntryCIList*,&SgAsmElfEHFrameSection::p_ci_entries>>;
};
template <> struct node_from_variant_t<155> { using type = SgAsmElfEHFrameSection; };

// Class: AsmElfFileHeader
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned char,&SgAsmElfFileHeader::p_e_ident_file_class> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned char;
  static constexpr size_t position{0};
  static constexpr char const * const name{"e_ident_file_class"};
  static constexpr char const * const typestr{"unsigned char"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_ident_file_class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned char SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_ident_file_class>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned char,&SgAsmElfFileHeader::p_e_ident_data_encoding> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned char;
  static constexpr size_t position{1};
  static constexpr char const * const name{"e_ident_data_encoding"};
  static constexpr char const * const typestr{"unsigned char"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_ident_data_encoding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned char SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_ident_data_encoding>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned char,&SgAsmElfFileHeader::p_e_ident_file_version> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned char;
  static constexpr size_t position{2};
  static constexpr char const * const name{"e_ident_file_version"};
  static constexpr char const * const typestr{"unsigned char"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_ident_file_version};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned char SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_ident_file_version>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,SgUnsignedCharList,&SgAsmElfFileHeader::p_e_ident_padding> {
  using parent = SgAsmElfFileHeader;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"e_ident_padding"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_ident_padding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, SgUnsignedCharList SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_ident_padding>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_type> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned long;
  static constexpr size_t position{4};
  static constexpr char const * const name{"e_type"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned long SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_type>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_machine> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned long;
  static constexpr size_t position{5};
  static constexpr char const * const name{"e_machine"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_machine};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned long SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_machine>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_flags> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned long;
  static constexpr size_t position{6};
  static constexpr char const * const name{"e_flags"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned long SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_flags>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_ehsize> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned long;
  static constexpr size_t position{7};
  static constexpr char const * const name{"e_ehsize"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_ehsize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned long SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_ehsize>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_phextrasz> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned long;
  static constexpr size_t position{8};
  static constexpr char const * const name{"phextrasz"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_phextrasz};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned long SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_phextrasz>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_phnum> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned long;
  static constexpr size_t position{9};
  static constexpr char const * const name{"e_phnum"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_phnum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned long SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_phnum>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_shextrasz> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned long;
  static constexpr size_t position{10};
  static constexpr char const * const name{"shextrasz"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_shextrasz};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned long SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_shextrasz>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_shnum> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned long;
  static constexpr size_t position{11};
  static constexpr char const * const name{"e_shnum"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_shnum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned long SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_shnum>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_shstrndx> {
  using parent = SgAsmElfFileHeader;
  using field_type = unsigned long;
  static constexpr size_t position{12};
  static constexpr char const * const name{"e_shstrndx"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_e_shstrndx};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, unsigned long SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_e_shstrndx>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,SgAsmElfSectionTable*,&SgAsmElfFileHeader::p_sectionTable> {
  using parent = SgAsmElfFileHeader;
  using field_type = SgAsmElfSectionTable*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"sectionTable"};
  static constexpr char const * const typestr{"SgAsmElfSectionTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_sectionTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, SgAsmElfSectionTable* SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_sectionTable>;
};
template <> struct describe_field_t<SgAsmElfFileHeader,SgAsmElfSegmentTable*,&SgAsmElfFileHeader::p_segmentTable> {
  using parent = SgAsmElfFileHeader;
  using field_type = SgAsmElfSegmentTable*;
  static constexpr size_t position{14};
  static constexpr char const * const name{"segmentTable"};
  static constexpr char const * const typestr{"SgAsmElfSegmentTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfFileHeader::p_segmentTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfFileHeader, SgAsmElfSegmentTable* SgAsmElfFileHeader::*, &SgAsmElfFileHeader::p_segmentTable>;
};
template <> struct describe_node_t<SgAsmElfFileHeader> {
  using node = SgAsmElfFileHeader;
  using base = SgAsmGenericHeader;
  static constexpr char const * const name{"AsmElfFileHeader"};
  static constexpr unsigned long variant{156};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfFileHeader,unsigned char,&SgAsmElfFileHeader::p_e_ident_file_class>, describe_field_t<SgAsmElfFileHeader,unsigned char,&SgAsmElfFileHeader::p_e_ident_data_encoding>, describe_field_t<SgAsmElfFileHeader,unsigned char,&SgAsmElfFileHeader::p_e_ident_file_version>, describe_field_t<SgAsmElfFileHeader,SgUnsignedCharList,&SgAsmElfFileHeader::p_e_ident_padding>, describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_type>, describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_machine>, describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_flags>, describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_ehsize>, describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_phextrasz>, describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_phnum>, describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_shextrasz>, describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_shnum>, describe_field_t<SgAsmElfFileHeader,unsigned long,&SgAsmElfFileHeader::p_e_shstrndx>, describe_field_t<SgAsmElfFileHeader,SgAsmElfSectionTable*,&SgAsmElfFileHeader::p_sectionTable>, describe_field_t<SgAsmElfFileHeader,SgAsmElfSegmentTable*,&SgAsmElfFileHeader::p_segmentTable>>;
};
template <> struct node_from_variant_t<156> { using type = SgAsmElfFileHeader; };

// Class: AsmElfNoteEntry
template <> struct describe_field_t<SgAsmElfNoteEntry,unsigned,&SgAsmElfNoteEntry::p_type> {
  using parent = SgAsmElfNoteEntry;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfNoteEntry::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfNoteEntry, unsigned SgAsmElfNoteEntry::*, &SgAsmElfNoteEntry::p_type>;
};
template <> struct describe_field_t<SgAsmElfNoteEntry,SgAsmGenericString*,&SgAsmElfNoteEntry::p_name> {
  using parent = SgAsmElfNoteEntry;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfNoteEntry::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfNoteEntry, SgAsmGenericString* SgAsmElfNoteEntry::*, &SgAsmElfNoteEntry::p_name>;
};
template <> struct describe_field_t<SgAsmElfNoteEntry,SgUnsignedCharList,&SgAsmElfNoteEntry::p_payload> {
  using parent = SgAsmElfNoteEntry;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"payload"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfNoteEntry::p_payload};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfNoteEntry, SgUnsignedCharList SgAsmElfNoteEntry::*, &SgAsmElfNoteEntry::p_payload>;
};
template <> struct describe_node_t<SgAsmElfNoteEntry> {
  using node = SgAsmElfNoteEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfNoteEntry"};
  static constexpr unsigned long variant{157};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfNoteEntry,unsigned,&SgAsmElfNoteEntry::p_type>, describe_field_t<SgAsmElfNoteEntry,SgAsmGenericString*,&SgAsmElfNoteEntry::p_name>, describe_field_t<SgAsmElfNoteEntry,SgUnsignedCharList,&SgAsmElfNoteEntry::p_payload>>;
};
template <> struct node_from_variant_t<157> { using type = SgAsmElfNoteEntry; };

// Class: AsmElfNoteEntryList
template <> struct describe_field_t<SgAsmElfNoteEntryList,SgAsmElfNoteEntryPtrList,&SgAsmElfNoteEntryList::p_entries> {
  using parent = SgAsmElfNoteEntryList;
  using field_type = SgAsmElfNoteEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfNoteEntryPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfNoteEntryList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfNoteEntryList, SgAsmElfNoteEntryPtrList SgAsmElfNoteEntryList::*, &SgAsmElfNoteEntryList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfNoteEntryList> {
  using node = SgAsmElfNoteEntryList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfNoteEntryList"};
  static constexpr unsigned long variant{158};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfNoteEntryList,SgAsmElfNoteEntryPtrList,&SgAsmElfNoteEntryList::p_entries>>;
};
template <> struct node_from_variant_t<158> { using type = SgAsmElfNoteEntryList; };

// Class: AsmElfNoteSection
template <> struct describe_field_t<SgAsmElfNoteSection,SgAsmElfNoteEntryList*,&SgAsmElfNoteSection::p_entries> {
  using parent = SgAsmElfNoteSection;
  using field_type = SgAsmElfNoteEntryList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfNoteEntryList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfNoteSection::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfNoteSection, SgAsmElfNoteEntryList* SgAsmElfNoteSection::*, &SgAsmElfNoteSection::p_entries>;
};
template <> struct describe_node_t<SgAsmElfNoteSection> {
  using node = SgAsmElfNoteSection;
  using base = SgAsmElfSection;
  static constexpr char const * const name{"AsmElfNoteSection"};
  static constexpr unsigned long variant{159};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfNoteSection,SgAsmElfNoteEntryList*,&SgAsmElfNoteSection::p_entries>>;
};
template <> struct node_from_variant_t<159> { using type = SgAsmElfNoteSection; };

// Class: AsmElfRelocEntry
template <> struct describe_field_t<SgAsmElfRelocEntry,Rose::BinaryAnalysis::Address,&SgAsmElfRelocEntry::p_r_offset> {
  using parent = SgAsmElfRelocEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{0};
  static constexpr char const * const name{"r_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfRelocEntry::p_r_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfRelocEntry, Rose::BinaryAnalysis::Address SgAsmElfRelocEntry::*, &SgAsmElfRelocEntry::p_r_offset>;
};
template <> struct describe_field_t<SgAsmElfRelocEntry,Rose::BinaryAnalysis::Address,&SgAsmElfRelocEntry::p_r_addend> {
  using parent = SgAsmElfRelocEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{1};
  static constexpr char const * const name{"r_addend"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfRelocEntry::p_r_addend};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfRelocEntry, Rose::BinaryAnalysis::Address SgAsmElfRelocEntry::*, &SgAsmElfRelocEntry::p_r_addend>;
};
template <> struct describe_field_t<SgAsmElfRelocEntry,unsigned long,&SgAsmElfRelocEntry::p_sym> {
  using parent = SgAsmElfRelocEntry;
  using field_type = unsigned long;
  static constexpr size_t position{2};
  static constexpr char const * const name{"sym"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfRelocEntry::p_sym};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfRelocEntry, unsigned long SgAsmElfRelocEntry::*, &SgAsmElfRelocEntry::p_sym>;
};
template <> struct describe_field_t<SgAsmElfRelocEntry,SgAsmElfRelocEntry::RelocType,&SgAsmElfRelocEntry::p_type> {
  using parent = SgAsmElfRelocEntry;
  using field_type = SgAsmElfRelocEntry::RelocType;
  static constexpr size_t position{3};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAsmElfRelocEntry::RelocType"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfRelocEntry::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfRelocEntry, SgAsmElfRelocEntry::RelocType SgAsmElfRelocEntry::*, &SgAsmElfRelocEntry::p_type>;
};
template <> struct describe_field_t<SgAsmElfRelocEntry,SgUnsignedCharList,&SgAsmElfRelocEntry::p_extra> {
  using parent = SgAsmElfRelocEntry;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{4};
  static constexpr char const * const name{"extra"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfRelocEntry::p_extra};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfRelocEntry, SgUnsignedCharList SgAsmElfRelocEntry::*, &SgAsmElfRelocEntry::p_extra>;
};
template <> struct describe_node_t<SgAsmElfRelocEntry> {
  using node = SgAsmElfRelocEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfRelocEntry"};
  static constexpr unsigned long variant{160};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfRelocEntry,Rose::BinaryAnalysis::Address,&SgAsmElfRelocEntry::p_r_offset>, describe_field_t<SgAsmElfRelocEntry,Rose::BinaryAnalysis::Address,&SgAsmElfRelocEntry::p_r_addend>, describe_field_t<SgAsmElfRelocEntry,unsigned long,&SgAsmElfRelocEntry::p_sym>, describe_field_t<SgAsmElfRelocEntry,SgAsmElfRelocEntry::RelocType,&SgAsmElfRelocEntry::p_type>, describe_field_t<SgAsmElfRelocEntry,SgUnsignedCharList,&SgAsmElfRelocEntry::p_extra>>;
};
template <> struct node_from_variant_t<160> { using type = SgAsmElfRelocEntry; };

// Class: AsmElfRelocEntryList
template <> struct describe_field_t<SgAsmElfRelocEntryList,SgAsmElfRelocEntryPtrList,&SgAsmElfRelocEntryList::p_entries> {
  using parent = SgAsmElfRelocEntryList;
  using field_type = SgAsmElfRelocEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfRelocEntryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfRelocEntryList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfRelocEntryList, SgAsmElfRelocEntryPtrList SgAsmElfRelocEntryList::*, &SgAsmElfRelocEntryList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfRelocEntryList> {
  using node = SgAsmElfRelocEntryList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfRelocEntryList"};
  static constexpr unsigned long variant{161};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfRelocEntryList,SgAsmElfRelocEntryPtrList,&SgAsmElfRelocEntryList::p_entries>>;
};
template <> struct node_from_variant_t<161> { using type = SgAsmElfRelocEntryList; };

// Class: AsmElfRelocSection
template <> struct describe_field_t<SgAsmElfRelocSection,bool,&SgAsmElfRelocSection::p_usesAddend> {
  using parent = SgAsmElfRelocSection;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"usesAddend"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfRelocSection::p_usesAddend};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfRelocSection, bool SgAsmElfRelocSection::*, &SgAsmElfRelocSection::p_usesAddend>;
};
template <> struct describe_field_t<SgAsmElfRelocSection,SgAsmElfSection*,&SgAsmElfRelocSection::p_targetSection> {
  using parent = SgAsmElfRelocSection;
  using field_type = SgAsmElfSection*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"targetSection"};
  static constexpr char const * const typestr{"SgAsmElfSection*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfRelocSection::p_targetSection};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfRelocSection, SgAsmElfSection* SgAsmElfRelocSection::*, &SgAsmElfRelocSection::p_targetSection>;
};
template <> struct describe_field_t<SgAsmElfRelocSection,SgAsmElfRelocEntryList*,&SgAsmElfRelocSection::p_entries> {
  using parent = SgAsmElfRelocSection;
  using field_type = SgAsmElfRelocEntryList*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfRelocEntryList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfRelocSection::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfRelocSection, SgAsmElfRelocEntryList* SgAsmElfRelocSection::*, &SgAsmElfRelocSection::p_entries>;
};
template <> struct describe_node_t<SgAsmElfRelocSection> {
  using node = SgAsmElfRelocSection;
  using base = SgAsmElfSection;
  static constexpr char const * const name{"AsmElfRelocSection"};
  static constexpr unsigned long variant{162};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfRelocSection,bool,&SgAsmElfRelocSection::p_usesAddend>, describe_field_t<SgAsmElfRelocSection,SgAsmElfSection*,&SgAsmElfRelocSection::p_targetSection>, describe_field_t<SgAsmElfRelocSection,SgAsmElfRelocEntryList*,&SgAsmElfRelocSection::p_entries>>;
};
template <> struct node_from_variant_t<162> { using type = SgAsmElfRelocSection; };

// Class: AsmElfSection
template <> struct describe_field_t<SgAsmElfSection,SgAsmElfSection*,&SgAsmElfSection::p_linkedSection> {
  using parent = SgAsmElfSection;
  using field_type = SgAsmElfSection*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"linkedSection"};
  static constexpr char const * const typestr{"SgAsmElfSection*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSection::p_linkedSection};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSection, SgAsmElfSection* SgAsmElfSection::*, &SgAsmElfSection::p_linkedSection>;
};
template <> struct describe_field_t<SgAsmElfSection,SgAsmElfSectionTableEntry*,&SgAsmElfSection::p_sectionEntry> {
  using parent = SgAsmElfSection;
  using field_type = SgAsmElfSectionTableEntry*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"sectionEntry"};
  static constexpr char const * const typestr{"SgAsmElfSectionTableEntry*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSection::p_sectionEntry};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSection, SgAsmElfSectionTableEntry* SgAsmElfSection::*, &SgAsmElfSection::p_sectionEntry>;
};
template <> struct describe_field_t<SgAsmElfSection,SgAsmElfSegmentTableEntry*,&SgAsmElfSection::p_segmentEntry> {
  using parent = SgAsmElfSection;
  using field_type = SgAsmElfSegmentTableEntry*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"segmentEntry"};
  static constexpr char const * const typestr{"SgAsmElfSegmentTableEntry*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSection::p_segmentEntry};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSection, SgAsmElfSegmentTableEntry* SgAsmElfSection::*, &SgAsmElfSection::p_segmentEntry>;
};
template <> struct describe_node_t<SgAsmElfSection> {
  using node = SgAsmElfSection;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmElfSection"};
  static constexpr unsigned long variant{163};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgAsmElfDynamicSection, SgAsmElfEHFrameSection, SgAsmElfNoteSection, SgAsmElfRelocSection, SgAsmElfStringSection, SgAsmElfSymbolSection, SgAsmElfSymverDefinedSection, SgAsmElfSymverNeededSection, SgAsmElfSymverSection>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSection,SgAsmElfSection*,&SgAsmElfSection::p_linkedSection>, describe_field_t<SgAsmElfSection,SgAsmElfSectionTableEntry*,&SgAsmElfSection::p_sectionEntry>, describe_field_t<SgAsmElfSection,SgAsmElfSegmentTableEntry*,&SgAsmElfSection::p_segmentEntry>>;
};
template <> struct node_from_variant_t<163> { using type = SgAsmElfSection; };

// Class: AsmElfSectionTable
template <> struct describe_node_t<SgAsmElfSectionTable> {
  using node = SgAsmElfSectionTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmElfSectionTable"};
  static constexpr unsigned long variant{164};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<164> { using type = SgAsmElfSectionTable; };

// Class: AsmElfSectionTableEntry
template <> struct describe_field_t<SgAsmElfSectionTableEntry,unsigned,&SgAsmElfSectionTableEntry::p_sh_name> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"sh_name"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, unsigned SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_name>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,SgAsmElfSectionTableEntry::SectionType,&SgAsmElfSectionTableEntry::p_sh_type> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = SgAsmElfSectionTableEntry::SectionType;
  static constexpr size_t position{1};
  static constexpr char const * const name{"sh_type"};
  static constexpr char const * const typestr{"SgAsmElfSectionTableEntry::SectionType"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, SgAsmElfSectionTableEntry::SectionType SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_type>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,unsigned long,&SgAsmElfSectionTableEntry::p_sh_link> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = unsigned long;
  static constexpr size_t position{2};
  static constexpr char const * const name{"sh_link"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_link};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, unsigned long SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_link>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,unsigned long,&SgAsmElfSectionTableEntry::p_sh_info> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = unsigned long;
  static constexpr size_t position{3};
  static constexpr char const * const name{"sh_info"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_info};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, unsigned long SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_info>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,uint64_t,&SgAsmElfSectionTableEntry::p_sh_flags> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = uint64_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"sh_flags"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, uint64_t SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_flags>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_addr> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{5};
  static constexpr char const * const name{"sh_addr"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_addr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_addr>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_offset> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{6};
  static constexpr char const * const name{"sh_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_offset>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_size> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{7};
  static constexpr char const * const name{"sh_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_size>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_addralign> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{8};
  static constexpr char const * const name{"sh_addralign"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_addralign};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_addralign>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_entsize> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{9};
  static constexpr char const * const name{"sh_entsize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_sh_entsize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_sh_entsize>;
};
template <> struct describe_field_t<SgAsmElfSectionTableEntry,SgUnsignedCharList,&SgAsmElfSectionTableEntry::p_extra> {
  using parent = SgAsmElfSectionTableEntry;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{10};
  static constexpr char const * const name{"extra"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSectionTableEntry::p_extra};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSectionTableEntry, SgUnsignedCharList SgAsmElfSectionTableEntry::*, &SgAsmElfSectionTableEntry::p_extra>;
};
template <> struct describe_node_t<SgAsmElfSectionTableEntry> {
  using node = SgAsmElfSectionTableEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSectionTableEntry"};
  static constexpr unsigned long variant{165};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSectionTableEntry,unsigned,&SgAsmElfSectionTableEntry::p_sh_name>, describe_field_t<SgAsmElfSectionTableEntry,SgAsmElfSectionTableEntry::SectionType,&SgAsmElfSectionTableEntry::p_sh_type>, describe_field_t<SgAsmElfSectionTableEntry,unsigned long,&SgAsmElfSectionTableEntry::p_sh_link>, describe_field_t<SgAsmElfSectionTableEntry,unsigned long,&SgAsmElfSectionTableEntry::p_sh_info>, describe_field_t<SgAsmElfSectionTableEntry,uint64_t,&SgAsmElfSectionTableEntry::p_sh_flags>, describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_addr>, describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_offset>, describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_size>, describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_addralign>, describe_field_t<SgAsmElfSectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSectionTableEntry::p_sh_entsize>, describe_field_t<SgAsmElfSectionTableEntry,SgUnsignedCharList,&SgAsmElfSectionTableEntry::p_extra>>;
};
template <> struct node_from_variant_t<165> { using type = SgAsmElfSectionTableEntry; };

// Class: AsmElfSegmentTable
template <> struct describe_node_t<SgAsmElfSegmentTable> {
  using node = SgAsmElfSegmentTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmElfSegmentTable"};
  static constexpr unsigned long variant{166};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<166> { using type = SgAsmElfSegmentTable; };

// Class: AsmElfSegmentTableEntry
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,size_t,&SgAsmElfSegmentTableEntry::p_index> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = size_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, size_t SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_index>;
};
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,SgAsmElfSegmentTableEntry::SegmentType,&SgAsmElfSegmentTableEntry::p_type> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = SgAsmElfSegmentTableEntry::SegmentType;
  static constexpr size_t position{1};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAsmElfSegmentTableEntry::SegmentType"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, SgAsmElfSegmentTableEntry::SegmentType SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_type>;
};
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,SgAsmElfSegmentTableEntry::SegmentFlags,&SgAsmElfSegmentTableEntry::p_flags> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = SgAsmElfSegmentTableEntry::SegmentFlags;
  static constexpr size_t position{2};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"SgAsmElfSegmentTableEntry::SegmentFlags"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, SgAsmElfSegmentTableEntry::SegmentFlags SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_flags>;
};
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_offset> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{3};
  static constexpr char const * const name{"offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_offset>;
};
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_vaddr> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{4};
  static constexpr char const * const name{"vaddr"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_vaddr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_vaddr>;
};
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_paddr> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{5};
  static constexpr char const * const name{"paddr"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_paddr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_paddr>;
};
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_filesz> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{6};
  static constexpr char const * const name{"filesz"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_filesz};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_filesz>;
};
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_memsz> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{7};
  static constexpr char const * const name{"memsz"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_memsz};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_memsz>;
};
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_align> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{8};
  static constexpr char const * const name{"align"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_align};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, Rose::BinaryAnalysis::Address SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_align>;
};
template <> struct describe_field_t<SgAsmElfSegmentTableEntry,SgUnsignedCharList,&SgAsmElfSegmentTableEntry::p_extra> {
  using parent = SgAsmElfSegmentTableEntry;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{9};
  static constexpr char const * const name{"extra"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntry::p_extra};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntry, SgUnsignedCharList SgAsmElfSegmentTableEntry::*, &SgAsmElfSegmentTableEntry::p_extra>;
};
template <> struct describe_node_t<SgAsmElfSegmentTableEntry> {
  using node = SgAsmElfSegmentTableEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSegmentTableEntry"};
  static constexpr unsigned long variant{167};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSegmentTableEntry,size_t,&SgAsmElfSegmentTableEntry::p_index>, describe_field_t<SgAsmElfSegmentTableEntry,SgAsmElfSegmentTableEntry::SegmentType,&SgAsmElfSegmentTableEntry::p_type>, describe_field_t<SgAsmElfSegmentTableEntry,SgAsmElfSegmentTableEntry::SegmentFlags,&SgAsmElfSegmentTableEntry::p_flags>, describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_offset>, describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_vaddr>, describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_paddr>, describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_filesz>, describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_memsz>, describe_field_t<SgAsmElfSegmentTableEntry,Rose::BinaryAnalysis::Address,&SgAsmElfSegmentTableEntry::p_align>, describe_field_t<SgAsmElfSegmentTableEntry,SgUnsignedCharList,&SgAsmElfSegmentTableEntry::p_extra>>;
};
template <> struct node_from_variant_t<167> { using type = SgAsmElfSegmentTableEntry; };

// Class: AsmElfSegmentTableEntryList
template <> struct describe_field_t<SgAsmElfSegmentTableEntryList,SgAsmElfSegmentTableEntryPtrList,&SgAsmElfSegmentTableEntryList::p_entries> {
  using parent = SgAsmElfSegmentTableEntryList;
  using field_type = SgAsmElfSegmentTableEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSegmentTableEntryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSegmentTableEntryList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSegmentTableEntryList, SgAsmElfSegmentTableEntryPtrList SgAsmElfSegmentTableEntryList::*, &SgAsmElfSegmentTableEntryList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSegmentTableEntryList> {
  using node = SgAsmElfSegmentTableEntryList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSegmentTableEntryList"};
  static constexpr unsigned long variant{168};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSegmentTableEntryList,SgAsmElfSegmentTableEntryPtrList,&SgAsmElfSegmentTableEntryList::p_entries>>;
};
template <> struct node_from_variant_t<168> { using type = SgAsmElfSegmentTableEntryList; };

// Class: AsmElfStringSection
template <> struct describe_field_t<SgAsmElfStringSection,SgAsmElfStrtab*,&SgAsmElfStringSection::p_strtab> {
  using parent = SgAsmElfStringSection;
  using field_type = SgAsmElfStrtab*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"strtab"};
  static constexpr char const * const typestr{"SgAsmElfStrtab*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfStringSection::p_strtab};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfStringSection, SgAsmElfStrtab* SgAsmElfStringSection::*, &SgAsmElfStringSection::p_strtab>;
};
template <> struct describe_node_t<SgAsmElfStringSection> {
  using node = SgAsmElfStringSection;
  using base = SgAsmElfSection;
  static constexpr char const * const name{"AsmElfStringSection"};
  static constexpr unsigned long variant{169};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfStringSection,SgAsmElfStrtab*,&SgAsmElfStringSection::p_strtab>>;
};
template <> struct node_from_variant_t<169> { using type = SgAsmElfStringSection; };

// Class: AsmElfStrtab
template <> struct describe_node_t<SgAsmElfStrtab> {
  using node = SgAsmElfStrtab;
  using base = SgAsmGenericStrtab;
  static constexpr char const * const name{"AsmElfStrtab"};
  static constexpr unsigned long variant{170};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<170> { using type = SgAsmElfStrtab; };

// Class: AsmElfSymbol
template <> struct describe_field_t<SgAsmElfSymbol,unsigned char,&SgAsmElfSymbol::p_st_info> {
  using parent = SgAsmElfSymbol;
  using field_type = unsigned char;
  static constexpr size_t position{0};
  static constexpr char const * const name{"st_info"};
  static constexpr char const * const typestr{"unsigned char"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymbol::p_st_info};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymbol, unsigned char SgAsmElfSymbol::*, &SgAsmElfSymbol::p_st_info>;
};
template <> struct describe_field_t<SgAsmElfSymbol,unsigned char,&SgAsmElfSymbol::p_st_res1> {
  using parent = SgAsmElfSymbol;
  using field_type = unsigned char;
  static constexpr size_t position{1};
  static constexpr char const * const name{"st_res1"};
  static constexpr char const * const typestr{"unsigned char"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymbol::p_st_res1};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymbol, unsigned char SgAsmElfSymbol::*, &SgAsmElfSymbol::p_st_res1>;
};
template <> struct describe_field_t<SgAsmElfSymbol,unsigned,&SgAsmElfSymbol::p_st_shndx> {
  using parent = SgAsmElfSymbol;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"st_shndx"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymbol::p_st_shndx};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymbol, unsigned SgAsmElfSymbol::*, &SgAsmElfSymbol::p_st_shndx>;
};
template <> struct describe_field_t<SgAsmElfSymbol,Rose::BinaryAnalysis::Address,&SgAsmElfSymbol::p_st_size> {
  using parent = SgAsmElfSymbol;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{3};
  static constexpr char const * const name{"st_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymbol::p_st_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymbol, Rose::BinaryAnalysis::Address SgAsmElfSymbol::*, &SgAsmElfSymbol::p_st_size>;
};
template <> struct describe_field_t<SgAsmElfSymbol,SgUnsignedCharList,&SgAsmElfSymbol::p_extra> {
  using parent = SgAsmElfSymbol;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{4};
  static constexpr char const * const name{"extra"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymbol::p_extra};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymbol, SgUnsignedCharList SgAsmElfSymbol::*, &SgAsmElfSymbol::p_extra>;
};
template <> struct describe_node_t<SgAsmElfSymbol> {
  using node = SgAsmElfSymbol;
  using base = SgAsmGenericSymbol;
  static constexpr char const * const name{"AsmElfSymbol"};
  static constexpr unsigned long variant{171};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymbol,unsigned char,&SgAsmElfSymbol::p_st_info>, describe_field_t<SgAsmElfSymbol,unsigned char,&SgAsmElfSymbol::p_st_res1>, describe_field_t<SgAsmElfSymbol,unsigned,&SgAsmElfSymbol::p_st_shndx>, describe_field_t<SgAsmElfSymbol,Rose::BinaryAnalysis::Address,&SgAsmElfSymbol::p_st_size>, describe_field_t<SgAsmElfSymbol,SgUnsignedCharList,&SgAsmElfSymbol::p_extra>>;
};
template <> struct node_from_variant_t<171> { using type = SgAsmElfSymbol; };

// Class: AsmElfSymbolList
template <> struct describe_field_t<SgAsmElfSymbolList,SgAsmElfSymbolPtrList,&SgAsmElfSymbolList::p_symbols> {
  using parent = SgAsmElfSymbolList;
  using field_type = SgAsmElfSymbolPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbols"};
  static constexpr char const * const typestr{"SgAsmElfSymbolPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymbolList::p_symbols};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymbolList, SgAsmElfSymbolPtrList SgAsmElfSymbolList::*, &SgAsmElfSymbolList::p_symbols>;
};
template <> struct describe_node_t<SgAsmElfSymbolList> {
  using node = SgAsmElfSymbolList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymbolList"};
  static constexpr unsigned long variant{172};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymbolList,SgAsmElfSymbolPtrList,&SgAsmElfSymbolList::p_symbols>>;
};
template <> struct node_from_variant_t<172> { using type = SgAsmElfSymbolList; };

// Class: AsmElfSymbolSection
template <> struct describe_field_t<SgAsmElfSymbolSection,bool,&SgAsmElfSymbolSection::p_isDynamic> {
  using parent = SgAsmElfSymbolSection;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"isDynamic"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymbolSection::p_isDynamic};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymbolSection, bool SgAsmElfSymbolSection::*, &SgAsmElfSymbolSection::p_isDynamic>;
};
template <> struct describe_field_t<SgAsmElfSymbolSection,SgAsmElfSymbolList*,&SgAsmElfSymbolSection::p_symbols> {
  using parent = SgAsmElfSymbolSection;
  using field_type = SgAsmElfSymbolList*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"symbols"};
  static constexpr char const * const typestr{"SgAsmElfSymbolList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymbolSection::p_symbols};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymbolSection, SgAsmElfSymbolList* SgAsmElfSymbolSection::*, &SgAsmElfSymbolSection::p_symbols>;
};
template <> struct describe_node_t<SgAsmElfSymbolSection> {
  using node = SgAsmElfSymbolSection;
  using base = SgAsmElfSection;
  static constexpr char const * const name{"AsmElfSymbolSection"};
  static constexpr unsigned long variant{173};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymbolSection,bool,&SgAsmElfSymbolSection::p_isDynamic>, describe_field_t<SgAsmElfSymbolSection,SgAsmElfSymbolList*,&SgAsmElfSymbolSection::p_symbols>>;
};
template <> struct node_from_variant_t<173> { using type = SgAsmElfSymbolSection; };

// Class: AsmElfSymverDefinedAux
template <> struct describe_field_t<SgAsmElfSymverDefinedAux,SgAsmGenericString*,&SgAsmElfSymverDefinedAux::p_name> {
  using parent = SgAsmElfSymverDefinedAux;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverDefinedAux::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverDefinedAux, SgAsmGenericString* SgAsmElfSymverDefinedAux::*, &SgAsmElfSymverDefinedAux::p_name>;
};
template <> struct describe_node_t<SgAsmElfSymverDefinedAux> {
  using node = SgAsmElfSymverDefinedAux;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverDefinedAux"};
  static constexpr unsigned long variant{174};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverDefinedAux,SgAsmGenericString*,&SgAsmElfSymverDefinedAux::p_name>>;
};
template <> struct node_from_variant_t<174> { using type = SgAsmElfSymverDefinedAux; };

// Class: AsmElfSymverDefinedAuxList
template <> struct describe_field_t<SgAsmElfSymverDefinedAuxList,SgAsmElfSymverDefinedAuxPtrList,&SgAsmElfSymverDefinedAuxList::p_entries> {
  using parent = SgAsmElfSymverDefinedAuxList;
  using field_type = SgAsmElfSymverDefinedAuxPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverDefinedAuxPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverDefinedAuxList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverDefinedAuxList, SgAsmElfSymverDefinedAuxPtrList SgAsmElfSymverDefinedAuxList::*, &SgAsmElfSymverDefinedAuxList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverDefinedAuxList> {
  using node = SgAsmElfSymverDefinedAuxList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverDefinedAuxList"};
  static constexpr unsigned long variant{175};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverDefinedAuxList,SgAsmElfSymverDefinedAuxPtrList,&SgAsmElfSymverDefinedAuxList::p_entries>>;
};
template <> struct node_from_variant_t<175> { using type = SgAsmElfSymverDefinedAuxList; };

// Class: AsmElfSymverDefinedEntry
template <> struct describe_field_t<SgAsmElfSymverDefinedEntry,size_t,&SgAsmElfSymverDefinedEntry::p_version> {
  using parent = SgAsmElfSymverDefinedEntry;
  using field_type = size_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"version"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymverDefinedEntry::p_version};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverDefinedEntry, size_t SgAsmElfSymverDefinedEntry::*, &SgAsmElfSymverDefinedEntry::p_version>;
};
template <> struct describe_field_t<SgAsmElfSymverDefinedEntry,int,&SgAsmElfSymverDefinedEntry::p_flags> {
  using parent = SgAsmElfSymverDefinedEntry;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymverDefinedEntry::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverDefinedEntry, int SgAsmElfSymverDefinedEntry::*, &SgAsmElfSymverDefinedEntry::p_flags>;
};
template <> struct describe_field_t<SgAsmElfSymverDefinedEntry,size_t,&SgAsmElfSymverDefinedEntry::p_index> {
  using parent = SgAsmElfSymverDefinedEntry;
  using field_type = size_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymverDefinedEntry::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverDefinedEntry, size_t SgAsmElfSymverDefinedEntry::*, &SgAsmElfSymverDefinedEntry::p_index>;
};
template <> struct describe_field_t<SgAsmElfSymverDefinedEntry,uint32_t,&SgAsmElfSymverDefinedEntry::p_hash> {
  using parent = SgAsmElfSymverDefinedEntry;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"hash"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymverDefinedEntry::p_hash};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverDefinedEntry, uint32_t SgAsmElfSymverDefinedEntry::*, &SgAsmElfSymverDefinedEntry::p_hash>;
};
template <> struct describe_field_t<SgAsmElfSymverDefinedEntry,SgAsmElfSymverDefinedAuxList*,&SgAsmElfSymverDefinedEntry::p_entries> {
  using parent = SgAsmElfSymverDefinedEntry;
  using field_type = SgAsmElfSymverDefinedAuxList*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverDefinedAuxList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverDefinedEntry::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverDefinedEntry, SgAsmElfSymverDefinedAuxList* SgAsmElfSymverDefinedEntry::*, &SgAsmElfSymverDefinedEntry::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverDefinedEntry> {
  using node = SgAsmElfSymverDefinedEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverDefinedEntry"};
  static constexpr unsigned long variant{176};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverDefinedEntry,size_t,&SgAsmElfSymverDefinedEntry::p_version>, describe_field_t<SgAsmElfSymverDefinedEntry,int,&SgAsmElfSymverDefinedEntry::p_flags>, describe_field_t<SgAsmElfSymverDefinedEntry,size_t,&SgAsmElfSymverDefinedEntry::p_index>, describe_field_t<SgAsmElfSymverDefinedEntry,uint32_t,&SgAsmElfSymverDefinedEntry::p_hash>, describe_field_t<SgAsmElfSymverDefinedEntry,SgAsmElfSymverDefinedAuxList*,&SgAsmElfSymverDefinedEntry::p_entries>>;
};
template <> struct node_from_variant_t<176> { using type = SgAsmElfSymverDefinedEntry; };

// Class: AsmElfSymverDefinedEntryList
template <> struct describe_field_t<SgAsmElfSymverDefinedEntryList,SgAsmElfSymverDefinedEntryPtrList,&SgAsmElfSymverDefinedEntryList::p_entries> {
  using parent = SgAsmElfSymverDefinedEntryList;
  using field_type = SgAsmElfSymverDefinedEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverDefinedEntryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverDefinedEntryList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverDefinedEntryList, SgAsmElfSymverDefinedEntryPtrList SgAsmElfSymverDefinedEntryList::*, &SgAsmElfSymverDefinedEntryList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverDefinedEntryList> {
  using node = SgAsmElfSymverDefinedEntryList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverDefinedEntryList"};
  static constexpr unsigned long variant{177};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverDefinedEntryList,SgAsmElfSymverDefinedEntryPtrList,&SgAsmElfSymverDefinedEntryList::p_entries>>;
};
template <> struct node_from_variant_t<177> { using type = SgAsmElfSymverDefinedEntryList; };

// Class: AsmElfSymverDefinedSection
template <> struct describe_field_t<SgAsmElfSymverDefinedSection,SgAsmElfSymverDefinedEntryList*,&SgAsmElfSymverDefinedSection::p_entries> {
  using parent = SgAsmElfSymverDefinedSection;
  using field_type = SgAsmElfSymverDefinedEntryList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverDefinedEntryList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverDefinedSection::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverDefinedSection, SgAsmElfSymverDefinedEntryList* SgAsmElfSymverDefinedSection::*, &SgAsmElfSymverDefinedSection::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverDefinedSection> {
  using node = SgAsmElfSymverDefinedSection;
  using base = SgAsmElfSection;
  static constexpr char const * const name{"AsmElfSymverDefinedSection"};
  static constexpr unsigned long variant{178};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverDefinedSection,SgAsmElfSymverDefinedEntryList*,&SgAsmElfSymverDefinedSection::p_entries>>;
};
template <> struct node_from_variant_t<178> { using type = SgAsmElfSymverDefinedSection; };

// Class: AsmElfSymverEntry
template <> struct describe_field_t<SgAsmElfSymverEntry,size_t,&SgAsmElfSymverEntry::p_value> {
  using parent = SgAsmElfSymverEntry;
  using field_type = size_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymverEntry::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverEntry, size_t SgAsmElfSymverEntry::*, &SgAsmElfSymverEntry::p_value>;
};
template <> struct describe_node_t<SgAsmElfSymverEntry> {
  using node = SgAsmElfSymverEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverEntry"};
  static constexpr unsigned long variant{179};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverEntry,size_t,&SgAsmElfSymverEntry::p_value>>;
};
template <> struct node_from_variant_t<179> { using type = SgAsmElfSymverEntry; };

// Class: AsmElfSymverEntryList
template <> struct describe_field_t<SgAsmElfSymverEntryList,SgAsmElfSymverEntryPtrList,&SgAsmElfSymverEntryList::p_entries> {
  using parent = SgAsmElfSymverEntryList;
  using field_type = SgAsmElfSymverEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverEntryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverEntryList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverEntryList, SgAsmElfSymverEntryPtrList SgAsmElfSymverEntryList::*, &SgAsmElfSymverEntryList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverEntryList> {
  using node = SgAsmElfSymverEntryList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverEntryList"};
  static constexpr unsigned long variant{180};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverEntryList,SgAsmElfSymverEntryPtrList,&SgAsmElfSymverEntryList::p_entries>>;
};
template <> struct node_from_variant_t<180> { using type = SgAsmElfSymverEntryList; };

// Class: AsmElfSymverNeededAux
template <> struct describe_field_t<SgAsmElfSymverNeededAux,uint32_t,&SgAsmElfSymverNeededAux::p_hash> {
  using parent = SgAsmElfSymverNeededAux;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"hash"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededAux::p_hash};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededAux, uint32_t SgAsmElfSymverNeededAux::*, &SgAsmElfSymverNeededAux::p_hash>;
};
template <> struct describe_field_t<SgAsmElfSymverNeededAux,int,&SgAsmElfSymverNeededAux::p_flags> {
  using parent = SgAsmElfSymverNeededAux;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededAux::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededAux, int SgAsmElfSymverNeededAux::*, &SgAsmElfSymverNeededAux::p_flags>;
};
template <> struct describe_field_t<SgAsmElfSymverNeededAux,size_t,&SgAsmElfSymverNeededAux::p_other> {
  using parent = SgAsmElfSymverNeededAux;
  using field_type = size_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"other"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededAux::p_other};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededAux, size_t SgAsmElfSymverNeededAux::*, &SgAsmElfSymverNeededAux::p_other>;
};
template <> struct describe_field_t<SgAsmElfSymverNeededAux,SgAsmGenericString*,&SgAsmElfSymverNeededAux::p_name> {
  using parent = SgAsmElfSymverNeededAux;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededAux::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededAux, SgAsmGenericString* SgAsmElfSymverNeededAux::*, &SgAsmElfSymverNeededAux::p_name>;
};
template <> struct describe_node_t<SgAsmElfSymverNeededAux> {
  using node = SgAsmElfSymverNeededAux;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverNeededAux"};
  static constexpr unsigned long variant{181};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverNeededAux,uint32_t,&SgAsmElfSymverNeededAux::p_hash>, describe_field_t<SgAsmElfSymverNeededAux,int,&SgAsmElfSymverNeededAux::p_flags>, describe_field_t<SgAsmElfSymverNeededAux,size_t,&SgAsmElfSymverNeededAux::p_other>, describe_field_t<SgAsmElfSymverNeededAux,SgAsmGenericString*,&SgAsmElfSymverNeededAux::p_name>>;
};
template <> struct node_from_variant_t<181> { using type = SgAsmElfSymverNeededAux; };

// Class: AsmElfSymverNeededAuxList
template <> struct describe_field_t<SgAsmElfSymverNeededAuxList,SgAsmElfSymverNeededAuxPtrList,&SgAsmElfSymverNeededAuxList::p_entries> {
  using parent = SgAsmElfSymverNeededAuxList;
  using field_type = SgAsmElfSymverNeededAuxPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverNeededAuxPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededAuxList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededAuxList, SgAsmElfSymverNeededAuxPtrList SgAsmElfSymverNeededAuxList::*, &SgAsmElfSymverNeededAuxList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverNeededAuxList> {
  using node = SgAsmElfSymverNeededAuxList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverNeededAuxList"};
  static constexpr unsigned long variant{182};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverNeededAuxList,SgAsmElfSymverNeededAuxPtrList,&SgAsmElfSymverNeededAuxList::p_entries>>;
};
template <> struct node_from_variant_t<182> { using type = SgAsmElfSymverNeededAuxList; };

// Class: AsmElfSymverNeededEntry
template <> struct describe_field_t<SgAsmElfSymverNeededEntry,size_t,&SgAsmElfSymverNeededEntry::p_version> {
  using parent = SgAsmElfSymverNeededEntry;
  using field_type = size_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"version"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededEntry::p_version};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededEntry, size_t SgAsmElfSymverNeededEntry::*, &SgAsmElfSymverNeededEntry::p_version>;
};
template <> struct describe_field_t<SgAsmElfSymverNeededEntry,SgAsmGenericString*,&SgAsmElfSymverNeededEntry::p_fileName> {
  using parent = SgAsmElfSymverNeededEntry;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"fileName"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededEntry::p_fileName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededEntry, SgAsmGenericString* SgAsmElfSymverNeededEntry::*, &SgAsmElfSymverNeededEntry::p_fileName>;
};
template <> struct describe_field_t<SgAsmElfSymverNeededEntry,SgAsmElfSymverNeededAuxList*,&SgAsmElfSymverNeededEntry::p_entries> {
  using parent = SgAsmElfSymverNeededEntry;
  using field_type = SgAsmElfSymverNeededAuxList*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverNeededAuxList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededEntry::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededEntry, SgAsmElfSymverNeededAuxList* SgAsmElfSymverNeededEntry::*, &SgAsmElfSymverNeededEntry::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverNeededEntry> {
  using node = SgAsmElfSymverNeededEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverNeededEntry"};
  static constexpr unsigned long variant{183};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverNeededEntry,size_t,&SgAsmElfSymverNeededEntry::p_version>, describe_field_t<SgAsmElfSymverNeededEntry,SgAsmGenericString*,&SgAsmElfSymverNeededEntry::p_fileName>, describe_field_t<SgAsmElfSymverNeededEntry,SgAsmElfSymverNeededAuxList*,&SgAsmElfSymverNeededEntry::p_entries>>;
};
template <> struct node_from_variant_t<183> { using type = SgAsmElfSymverNeededEntry; };

// Class: AsmElfSymverNeededEntryList
template <> struct describe_field_t<SgAsmElfSymverNeededEntryList,SgAsmElfSymverNeededEntryPtrList,&SgAsmElfSymverNeededEntryList::p_entries> {
  using parent = SgAsmElfSymverNeededEntryList;
  using field_type = SgAsmElfSymverNeededEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverNeededEntryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededEntryList::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededEntryList, SgAsmElfSymverNeededEntryPtrList SgAsmElfSymverNeededEntryList::*, &SgAsmElfSymverNeededEntryList::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverNeededEntryList> {
  using node = SgAsmElfSymverNeededEntryList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmElfSymverNeededEntryList"};
  static constexpr unsigned long variant{184};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverNeededEntryList,SgAsmElfSymverNeededEntryPtrList,&SgAsmElfSymverNeededEntryList::p_entries>>;
};
template <> struct node_from_variant_t<184> { using type = SgAsmElfSymverNeededEntryList; };

// Class: AsmElfSymverNeededSection
template <> struct describe_field_t<SgAsmElfSymverNeededSection,SgAsmElfSymverNeededEntryList*,&SgAsmElfSymverNeededSection::p_entries> {
  using parent = SgAsmElfSymverNeededSection;
  using field_type = SgAsmElfSymverNeededEntryList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverNeededEntryList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverNeededSection::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverNeededSection, SgAsmElfSymverNeededEntryList* SgAsmElfSymverNeededSection::*, &SgAsmElfSymverNeededSection::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverNeededSection> {
  using node = SgAsmElfSymverNeededSection;
  using base = SgAsmElfSection;
  static constexpr char const * const name{"AsmElfSymverNeededSection"};
  static constexpr unsigned long variant{185};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverNeededSection,SgAsmElfSymverNeededEntryList*,&SgAsmElfSymverNeededSection::p_entries>>;
};
template <> struct node_from_variant_t<185> { using type = SgAsmElfSymverNeededSection; };

// Class: AsmElfSymverSection
template <> struct describe_field_t<SgAsmElfSymverSection,SgAsmElfSymverEntryList*,&SgAsmElfSymverSection::p_entries> {
  using parent = SgAsmElfSymverSection;
  using field_type = SgAsmElfSymverEntryList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmElfSymverEntryList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmElfSymverSection::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmElfSymverSection, SgAsmElfSymverEntryList* SgAsmElfSymverSection::*, &SgAsmElfSymverSection::p_entries>;
};
template <> struct describe_node_t<SgAsmElfSymverSection> {
  using node = SgAsmElfSymverSection;
  using base = SgAsmElfSection;
  static constexpr char const * const name{"AsmElfSymverSection"};
  static constexpr unsigned long variant{186};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmElfSymverSection,SgAsmElfSymverEntryList*,&SgAsmElfSymverSection::p_entries>>;
};
template <> struct node_from_variant_t<186> { using type = SgAsmElfSymverSection; };

// Class: AsmExecutableFileFormat
template <> struct describe_node_t<SgAsmExecutableFileFormat> {
  using node = SgAsmExecutableFileFormat;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmExecutableFileFormat"};
  static constexpr unsigned long variant{187};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmCoffSymbolList, SgAsmDwarfInformation, SgAsmElfDynamicEntry, SgAsmElfDynamicEntryList, SgAsmElfEHFrameEntryCI, SgAsmElfEHFrameEntryCIList, SgAsmElfEHFrameEntryFD, SgAsmElfEHFrameEntryFDList, SgAsmElfNoteEntry, SgAsmElfNoteEntryList, SgAsmElfRelocEntry, SgAsmElfRelocEntryList, SgAsmElfSectionTableEntry, SgAsmElfSegmentTableEntry, SgAsmElfSegmentTableEntryList, SgAsmElfSymbolList, SgAsmElfSymverDefinedAux, SgAsmElfSymverDefinedAuxList, SgAsmElfSymverDefinedEntry, SgAsmElfSymverDefinedEntryList, SgAsmElfSymverEntry, SgAsmElfSymverEntryList, SgAsmElfSymverNeededAux, SgAsmElfSymverNeededAuxList, SgAsmElfSymverNeededEntry, SgAsmElfSymverNeededEntryList, SgAsmGenericDLL, SgAsmGenericDLLList, SgAsmGenericFile, SgAsmGenericFormat, SgAsmGenericHeaderList, SgAsmGenericSection, SgAsmGenericSectionList, SgAsmGenericString, SgAsmGenericStrtab, SgAsmGenericSymbol, SgAsmGenericSymbolList, SgAsmLEEntryPoint, SgAsmLEPageTableEntry, SgAsmLESectionTableEntry, SgAsmNEEntryPoint, SgAsmNERelocEntry, SgAsmNESectionTableEntry, SgAsmPEExportDirectory, SgAsmPEExportEntry, SgAsmPEExportEntryList, SgAsmPEImportDirectory, SgAsmPEImportDirectoryList, SgAsmPEImportItem, SgAsmPEImportItemList, SgAsmPERVASizePair, SgAsmPERVASizePairList, SgAsmPESectionTableEntry, SgAsmStringStorage>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<187> { using type = SgAsmExecutableFileFormat; };

// Class: AsmExprListExp
template <> struct describe_field_t<SgAsmExprListExp,SgAsmExpressionPtrList,&SgAsmExprListExp::p_expressions> {
  using parent = SgAsmExprListExp;
  using field_type = SgAsmExpressionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expressions"};
  static constexpr char const * const typestr{"SgAsmExpressionPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmExprListExp::p_expressions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmExprListExp, SgAsmExpressionPtrList SgAsmExprListExp::*, &SgAsmExprListExp::p_expressions>;
};
template <> struct describe_node_t<SgAsmExprListExp> {
  using node = SgAsmExprListExp;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmExprListExp"};
  static constexpr unsigned long variant{188};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmExprListExp,SgAsmExpressionPtrList,&SgAsmExprListExp::p_expressions>>;
};
template <> struct node_from_variant_t<188> { using type = SgAsmExprListExp; };

// Class: AsmExpression
template <> struct describe_field_t<SgAsmExpression,SgAsmType*,&SgAsmExpression::p_type> {
  using parent = SgAsmExpression;
  using field_type = SgAsmType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAsmType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmExpression::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmExpression, SgAsmType* SgAsmExpression::*, &SgAsmExpression::p_type>;
};
template <> struct describe_field_t<SgAsmExpression,std::string,&SgAsmExpression::p_comment> {
  using parent = SgAsmExpression;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"comment"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmExpression::p_comment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmExpression, std::string SgAsmExpression::*, &SgAsmExpression::p_comment>;
};
template <> struct describe_node_t<SgAsmExpression> {
  using node = SgAsmExpression;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmExpression"};
  static constexpr unsigned long variant{189};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmAarch32Coprocessor, SgAsmBinaryExpression, SgAsmByteOrder, SgAsmCommonSubExpression, SgAsmControlFlagsExpression, SgAsmExprListExp, SgAsmMemoryReferenceExpression, SgAsmRegisterNames, SgAsmRegisterReferenceExpression, SgAsmRiscOperation, SgAsmStackExpression, SgAsmUnaryExpression, SgAsmValueExpression>;
  using fields_t = mp::List<describe_field_t<SgAsmExpression,SgAsmType*,&SgAsmExpression::p_type>, describe_field_t<SgAsmExpression,std::string,&SgAsmExpression::p_comment>>;
};
template <> struct node_from_variant_t<189> { using type = SgAsmExpression; };

// Class: AsmSynthesizedFieldDeclaration
template <> struct describe_field_t<SgAsmSynthesizedFieldDeclaration,std::string,&SgAsmSynthesizedFieldDeclaration::p_name> {
  using parent = SgAsmSynthesizedFieldDeclaration;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmSynthesizedFieldDeclaration::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmSynthesizedFieldDeclaration, std::string SgAsmSynthesizedFieldDeclaration::*, &SgAsmSynthesizedFieldDeclaration::p_name>;
};
template <> struct describe_field_t<SgAsmSynthesizedFieldDeclaration,uint64_t,&SgAsmSynthesizedFieldDeclaration::p_offset> {
  using parent = SgAsmSynthesizedFieldDeclaration;
  using field_type = uint64_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"offset"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmSynthesizedFieldDeclaration::p_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmSynthesizedFieldDeclaration, uint64_t SgAsmSynthesizedFieldDeclaration::*, &SgAsmSynthesizedFieldDeclaration::p_offset>;
};
template <> struct describe_node_t<SgAsmSynthesizedFieldDeclaration> {
  using node = SgAsmSynthesizedFieldDeclaration;
  using base = SgAsmSynthesizedDeclaration;
  static constexpr char const * const name{"AsmSynthesizedFieldDeclaration"};
  static constexpr unsigned long variant{190};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmSynthesizedFieldDeclaration,std::string,&SgAsmSynthesizedFieldDeclaration::p_name>, describe_field_t<SgAsmSynthesizedFieldDeclaration,uint64_t,&SgAsmSynthesizedFieldDeclaration::p_offset>>;
};
template <> struct node_from_variant_t<190> { using type = SgAsmSynthesizedFieldDeclaration; };

// Class: AsmFloatType
template <> struct describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_significandOffset> {
  using parent = SgAsmFloatType;
  using field_type = size_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"significandOffset"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFloatType::p_significandOffset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFloatType, size_t SgAsmFloatType::*, &SgAsmFloatType::p_significandOffset>;
};
template <> struct describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_significandNBits> {
  using parent = SgAsmFloatType;
  using field_type = size_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"significandNBits"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFloatType::p_significandNBits};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFloatType, size_t SgAsmFloatType::*, &SgAsmFloatType::p_significandNBits>;
};
template <> struct describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_signBitOffset> {
  using parent = SgAsmFloatType;
  using field_type = size_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"signBitOffset"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFloatType::p_signBitOffset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFloatType, size_t SgAsmFloatType::*, &SgAsmFloatType::p_signBitOffset>;
};
template <> struct describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_exponentOffset> {
  using parent = SgAsmFloatType;
  using field_type = size_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"exponentOffset"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFloatType::p_exponentOffset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFloatType, size_t SgAsmFloatType::*, &SgAsmFloatType::p_exponentOffset>;
};
template <> struct describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_exponentNBits> {
  using parent = SgAsmFloatType;
  using field_type = size_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"exponentNBits"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFloatType::p_exponentNBits};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFloatType, size_t SgAsmFloatType::*, &SgAsmFloatType::p_exponentNBits>;
};
template <> struct describe_field_t<SgAsmFloatType,uint64_t,&SgAsmFloatType::p_exponentBias> {
  using parent = SgAsmFloatType;
  using field_type = uint64_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"exponentBias"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFloatType::p_exponentBias};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFloatType, uint64_t SgAsmFloatType::*, &SgAsmFloatType::p_exponentBias>;
};
template <> struct describe_field_t<SgAsmFloatType,unsigned,&SgAsmFloatType::p_flags> {
  using parent = SgAsmFloatType;
  using field_type = unsigned;
  static constexpr size_t position{6};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFloatType::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFloatType, unsigned SgAsmFloatType::*, &SgAsmFloatType::p_flags>;
};
template <> struct describe_node_t<SgAsmFloatType> {
  using node = SgAsmFloatType;
  using base = SgAsmScalarType;
  static constexpr char const * const name{"AsmFloatType"};
  static constexpr unsigned long variant{191};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_significandOffset>, describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_significandNBits>, describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_signBitOffset>, describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_exponentOffset>, describe_field_t<SgAsmFloatType,size_t,&SgAsmFloatType::p_exponentNBits>, describe_field_t<SgAsmFloatType,uint64_t,&SgAsmFloatType::p_exponentBias>, describe_field_t<SgAsmFloatType,unsigned,&SgAsmFloatType::p_flags>>;
};
template <> struct node_from_variant_t<191> { using type = SgAsmFloatType; };

// Class: AsmFloatValueExpression
template <> struct describe_node_t<SgAsmFloatValueExpression> {
  using node = SgAsmFloatValueExpression;
  using base = SgAsmConstantExpression;
  static constexpr char const * const name{"AsmFloatValueExpression"};
  static constexpr unsigned long variant{192};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<192> { using type = SgAsmFloatValueExpression; };

// Class: AsmFunction
template <> struct describe_field_t<SgAsmFunction,std::string,&SgAsmFunction::p_name> {
  using parent = SgAsmFunction;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, std::string SgAsmFunction::*, &SgAsmFunction::p_name>;
};
template <> struct describe_field_t<SgAsmFunction,unsigned,&SgAsmFunction::p_reason> {
  using parent = SgAsmFunction;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"reason"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_reason};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, unsigned SgAsmFunction::*, &SgAsmFunction::p_reason>;
};
template <> struct describe_field_t<SgAsmFunction,std::string,&SgAsmFunction::p_reasonComment> {
  using parent = SgAsmFunction;
  using field_type = std::string;
  static constexpr size_t position{2};
  static constexpr char const * const name{"reasonComment"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_reasonComment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, std::string SgAsmFunction::*, &SgAsmFunction::p_reasonComment>;
};
template <> struct describe_field_t<SgAsmFunction,SgAsmFunction::function_kind_enum,&SgAsmFunction::p_functionKind> {
  using parent = SgAsmFunction;
  using field_type = SgAsmFunction::function_kind_enum;
  static constexpr size_t position{3};
  static constexpr char const * const name{"functionKind"};
  static constexpr char const * const typestr{"SgAsmFunction::function_kind_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_functionKind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, SgAsmFunction::function_kind_enum SgAsmFunction::*, &SgAsmFunction::p_functionKind>;
};
template <> struct describe_field_t<SgAsmFunction,SgAsmFunction::MayReturn,&SgAsmFunction::p_mayReturn> {
  using parent = SgAsmFunction;
  using field_type = SgAsmFunction::MayReturn;
  static constexpr size_t position{4};
  static constexpr char const * const name{"mayReturn"};
  static constexpr char const * const typestr{"SgAsmFunction::MayReturn"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_mayReturn};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, SgAsmFunction::MayReturn SgAsmFunction::*, &SgAsmFunction::p_mayReturn>;
};
template <> struct describe_field_t<SgAsmFunction,std::string,&SgAsmFunction::p_nameMd5> {
  using parent = SgAsmFunction;
  using field_type = std::string;
  static constexpr size_t position{5};
  static constexpr char const * const name{"nameMd5"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_nameMd5};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, std::string SgAsmFunction::*, &SgAsmFunction::p_nameMd5>;
};
template <> struct describe_field_t<SgAsmFunction,SgAsmStatementPtrList,&SgAsmFunction::p_statementList> {
  using parent = SgAsmFunction;
  using field_type = SgAsmStatementPtrList;
  static constexpr size_t position{6};
  static constexpr char const * const name{"statementList"};
  static constexpr char const * const typestr{"SgAsmStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_statementList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, SgAsmStatementPtrList SgAsmFunction::*, &SgAsmFunction::p_statementList>;
};
template <> struct describe_field_t<SgAsmFunction,SgAsmStatementPtrList,&SgAsmFunction::p_dest> {
  using parent = SgAsmFunction;
  using field_type = SgAsmStatementPtrList;
  static constexpr size_t position{7};
  static constexpr char const * const name{"dest"};
  static constexpr char const * const typestr{"SgAsmStatementPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_dest};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, SgAsmStatementPtrList SgAsmFunction::*, &SgAsmFunction::p_dest>;
};
template <> struct describe_field_t<SgAsmFunction,Rose::BinaryAnalysis::Address,&SgAsmFunction::p_entryVa> {
  using parent = SgAsmFunction;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{8};
  static constexpr char const * const name{"entryVa"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_entryVa};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, Rose::BinaryAnalysis::Address SgAsmFunction::*, &SgAsmFunction::p_entryVa>;
};
template <> struct describe_field_t<SgAsmFunction,SgSymbolTable*,&SgAsmFunction::p_symbolTable> {
  using parent = SgAsmFunction;
  using field_type = SgSymbolTable*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"symbolTable"};
  static constexpr char const * const typestr{"SgSymbolTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_symbolTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, SgSymbolTable* SgAsmFunction::*, &SgAsmFunction::p_symbolTable>;
};
template <> struct describe_field_t<SgAsmFunction,size_t,&SgAsmFunction::p_cachedVertex> {
  using parent = SgAsmFunction;
  using field_type = size_t;
  static constexpr size_t position{10};
  static constexpr char const * const name{"cachedVertex"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_cachedVertex};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, size_t SgAsmFunction::*, &SgAsmFunction::p_cachedVertex>;
};
template <> struct describe_field_t<SgAsmFunction,int64_t,&SgAsmFunction::p_stackDelta> {
  using parent = SgAsmFunction;
  using field_type = int64_t;
  static constexpr size_t position{11};
  static constexpr char const * const name{"stackDelta"};
  static constexpr char const * const typestr{"int64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_stackDelta};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, int64_t SgAsmFunction::*, &SgAsmFunction::p_stackDelta>;
};
template <> struct describe_field_t<SgAsmFunction,std::string,&SgAsmFunction::p_callingConvention> {
  using parent = SgAsmFunction;
  using field_type = std::string;
  static constexpr size_t position{12};
  static constexpr char const * const name{"callingConvention"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmFunction::p_callingConvention};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmFunction, std::string SgAsmFunction::*, &SgAsmFunction::p_callingConvention>;
};
template <> struct describe_node_t<SgAsmFunction> {
  using node = SgAsmFunction;
  using base = SgAsmSynthesizedDeclaration;
  static constexpr char const * const name{"AsmFunction"};
  static constexpr unsigned long variant{193};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmFunction,std::string,&SgAsmFunction::p_name>, describe_field_t<SgAsmFunction,unsigned,&SgAsmFunction::p_reason>, describe_field_t<SgAsmFunction,std::string,&SgAsmFunction::p_reasonComment>, describe_field_t<SgAsmFunction,SgAsmFunction::function_kind_enum,&SgAsmFunction::p_functionKind>, describe_field_t<SgAsmFunction,SgAsmFunction::MayReturn,&SgAsmFunction::p_mayReturn>, describe_field_t<SgAsmFunction,std::string,&SgAsmFunction::p_nameMd5>, describe_field_t<SgAsmFunction,SgAsmStatementPtrList,&SgAsmFunction::p_statementList>, describe_field_t<SgAsmFunction,SgAsmStatementPtrList,&SgAsmFunction::p_dest>, describe_field_t<SgAsmFunction,Rose::BinaryAnalysis::Address,&SgAsmFunction::p_entryVa>, describe_field_t<SgAsmFunction,SgSymbolTable*,&SgAsmFunction::p_symbolTable>, describe_field_t<SgAsmFunction,size_t,&SgAsmFunction::p_cachedVertex>, describe_field_t<SgAsmFunction,int64_t,&SgAsmFunction::p_stackDelta>, describe_field_t<SgAsmFunction,std::string,&SgAsmFunction::p_callingConvention>>;
};
template <> struct node_from_variant_t<193> { using type = SgAsmFunction; };

// Class: AsmGenericDLL
template <> struct describe_field_t<SgAsmGenericDLL,SgAsmGenericString*,&SgAsmGenericDLL::p_name> {
  using parent = SgAsmGenericDLL;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericDLL::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericDLL, SgAsmGenericString* SgAsmGenericDLL::*, &SgAsmGenericDLL::p_name>;
};
template <> struct describe_field_t<SgAsmGenericDLL,SgStringList,&SgAsmGenericDLL::p_symbols> {
  using parent = SgAsmGenericDLL;
  using field_type = SgStringList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"symbols"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericDLL::p_symbols};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericDLL, SgStringList SgAsmGenericDLL::*, &SgAsmGenericDLL::p_symbols>;
};
template <> struct describe_node_t<SgAsmGenericDLL> {
  using node = SgAsmGenericDLL;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericDLL"};
  static constexpr unsigned long variant{194};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericDLL,SgAsmGenericString*,&SgAsmGenericDLL::p_name>, describe_field_t<SgAsmGenericDLL,SgStringList,&SgAsmGenericDLL::p_symbols>>;
};
template <> struct node_from_variant_t<194> { using type = SgAsmGenericDLL; };

// Class: AsmGenericDLLList
template <> struct describe_field_t<SgAsmGenericDLLList,SgAsmGenericDLLPtrList,&SgAsmGenericDLLList::p_dlls> {
  using parent = SgAsmGenericDLLList;
  using field_type = SgAsmGenericDLLPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"dlls"};
  static constexpr char const * const typestr{"SgAsmGenericDLLPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericDLLList::p_dlls};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericDLLList, SgAsmGenericDLLPtrList SgAsmGenericDLLList::*, &SgAsmGenericDLLList::p_dlls>;
};
template <> struct describe_node_t<SgAsmGenericDLLList> {
  using node = SgAsmGenericDLLList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericDLLList"};
  static constexpr unsigned long variant{195};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericDLLList,SgAsmGenericDLLPtrList,&SgAsmGenericDLLList::p_dlls>>;
};
template <> struct node_from_variant_t<195> { using type = SgAsmGenericDLLList; };

// Class: AsmGenericFile
template <> struct describe_field_t<SgAsmGenericFile,SgAsmDwarfCompilationUnitList*,&SgAsmGenericFile::p_dwarfInfo> {
  using parent = SgAsmGenericFile;
  using field_type = SgAsmDwarfCompilationUnitList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"dwarfInfo"};
  static constexpr char const * const typestr{"SgAsmDwarfCompilationUnitList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_dwarfInfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, SgAsmDwarfCompilationUnitList* SgAsmGenericFile::*, &SgAsmGenericFile::p_dwarfInfo>;
};
template <> struct describe_field_t<SgAsmGenericFile,std::string,&SgAsmGenericFile::p_name> {
  using parent = SgAsmGenericFile;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, std::string SgAsmGenericFile::*, &SgAsmGenericFile::p_name>;
};
template <> struct describe_field_t<SgAsmGenericFile,int,&SgAsmGenericFile::p_fd> {
  using parent = SgAsmGenericFile;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"fd"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_fd};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, int SgAsmGenericFile::*, &SgAsmGenericFile::p_fd>;
};
template <> struct describe_field_t<SgAsmGenericFile,struct stat,&SgAsmGenericFile::p_sb> {
  using parent = SgAsmGenericFile;
  using field_type = struct stat;
  static constexpr size_t position{3};
  static constexpr char const * const name{"sb"};
  static constexpr char const * const typestr{"struct stat"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_sb};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, struct stat SgAsmGenericFile::*, &SgAsmGenericFile::p_sb>;
};
template <> struct describe_field_t<SgAsmGenericFile,SgFileContentList,&SgAsmGenericFile::p_data> {
  using parent = SgAsmGenericFile;
  using field_type = SgFileContentList;
  static constexpr size_t position{4};
  static constexpr char const * const name{"data"};
  static constexpr char const * const typestr{"SgFileContentList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_data};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, SgFileContentList SgAsmGenericFile::*, &SgAsmGenericFile::p_data>;
};
template <> struct describe_field_t<SgAsmGenericFile,SgAsmGenericHeaderList*,&SgAsmGenericFile::p_headers> {
  using parent = SgAsmGenericFile;
  using field_type = SgAsmGenericHeaderList*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"headers"};
  static constexpr char const * const typestr{"SgAsmGenericHeaderList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_headers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, SgAsmGenericHeaderList* SgAsmGenericFile::*, &SgAsmGenericFile::p_headers>;
};
template <> struct describe_field_t<SgAsmGenericFile,SgAsmGenericSectionList*,&SgAsmGenericFile::p_holes> {
  using parent = SgAsmGenericFile;
  using field_type = SgAsmGenericSectionList*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"holes"};
  static constexpr char const * const typestr{"SgAsmGenericSectionList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_holes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, SgAsmGenericSectionList* SgAsmGenericFile::*, &SgAsmGenericFile::p_holes>;
};
template <> struct describe_field_t<SgAsmGenericFile,bool,&SgAsmGenericFile::p_truncateZeros> {
  using parent = SgAsmGenericFile;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"truncateZeros"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_truncateZeros};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, bool SgAsmGenericFile::*, &SgAsmGenericFile::p_truncateZeros>;
};
template <> struct describe_field_t<SgAsmGenericFile,bool,&SgAsmGenericFile::p_trackingReferences> {
  using parent = SgAsmGenericFile;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"trackingReferences"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_trackingReferences};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, bool SgAsmGenericFile::*, &SgAsmGenericFile::p_trackingReferences>;
};
template <> struct describe_field_t<SgAsmGenericFile,Rose::BinaryAnalysis::AddressIntervalSet,&SgAsmGenericFile::p_referencedExtents> {
  using parent = SgAsmGenericFile;
  using field_type = Rose::BinaryAnalysis::AddressIntervalSet;
  static constexpr size_t position{9};
  static constexpr char const * const name{"referencedExtents"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::AddressIntervalSet"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_referencedExtents};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, Rose::BinaryAnalysis::AddressIntervalSet SgAsmGenericFile::*, &SgAsmGenericFile::p_referencedExtents>;
};
template <> struct describe_field_t<SgAsmGenericFile,bool,&SgAsmGenericFile::p_neuter> {
  using parent = SgAsmGenericFile;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"neuter"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFile::p_neuter};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFile, bool SgAsmGenericFile::*, &SgAsmGenericFile::p_neuter>;
};
template <> struct describe_node_t<SgAsmGenericFile> {
  using node = SgAsmGenericFile;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericFile"};
  static constexpr unsigned long variant{196};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericFile,SgAsmDwarfCompilationUnitList*,&SgAsmGenericFile::p_dwarfInfo>, describe_field_t<SgAsmGenericFile,std::string,&SgAsmGenericFile::p_name>, describe_field_t<SgAsmGenericFile,int,&SgAsmGenericFile::p_fd>, describe_field_t<SgAsmGenericFile,struct stat,&SgAsmGenericFile::p_sb>, describe_field_t<SgAsmGenericFile,SgFileContentList,&SgAsmGenericFile::p_data>, describe_field_t<SgAsmGenericFile,SgAsmGenericHeaderList*,&SgAsmGenericFile::p_headers>, describe_field_t<SgAsmGenericFile,SgAsmGenericSectionList*,&SgAsmGenericFile::p_holes>, describe_field_t<SgAsmGenericFile,bool,&SgAsmGenericFile::p_truncateZeros>, describe_field_t<SgAsmGenericFile,bool,&SgAsmGenericFile::p_trackingReferences>, describe_field_t<SgAsmGenericFile,Rose::BinaryAnalysis::AddressIntervalSet,&SgAsmGenericFile::p_referencedExtents>, describe_field_t<SgAsmGenericFile,bool,&SgAsmGenericFile::p_neuter>>;
};
template <> struct node_from_variant_t<196> { using type = SgAsmGenericFile; };

// Class: AsmGenericFileList
template <> struct describe_field_t<SgAsmGenericFileList,SgAsmGenericFilePtrList,&SgAsmGenericFileList::p_files> {
  using parent = SgAsmGenericFileList;
  using field_type = SgAsmGenericFilePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"files"};
  static constexpr char const * const typestr{"SgAsmGenericFilePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericFileList::p_files};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFileList, SgAsmGenericFilePtrList SgAsmGenericFileList::*, &SgAsmGenericFileList::p_files>;
};
template <> struct describe_node_t<SgAsmGenericFileList> {
  using node = SgAsmGenericFileList;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmGenericFileList"};
  static constexpr unsigned long variant{197};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericFileList,SgAsmGenericFilePtrList,&SgAsmGenericFileList::p_files>>;
};
template <> struct node_from_variant_t<197> { using type = SgAsmGenericFileList; };

// Class: AsmGenericFormat
template <> struct describe_field_t<SgAsmGenericFormat,SgAsmGenericFormat::ExecFamily,&SgAsmGenericFormat::p_family> {
  using parent = SgAsmGenericFormat;
  using field_type = SgAsmGenericFormat::ExecFamily;
  static constexpr size_t position{0};
  static constexpr char const * const name{"family"};
  static constexpr char const * const typestr{"SgAsmGenericFormat::ExecFamily"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFormat::p_family};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFormat, SgAsmGenericFormat::ExecFamily SgAsmGenericFormat::*, &SgAsmGenericFormat::p_family>;
};
template <> struct describe_field_t<SgAsmGenericFormat,SgAsmGenericFormat::ExecPurpose,&SgAsmGenericFormat::p_purpose> {
  using parent = SgAsmGenericFormat;
  using field_type = SgAsmGenericFormat::ExecPurpose;
  static constexpr size_t position{1};
  static constexpr char const * const name{"purpose"};
  static constexpr char const * const typestr{"SgAsmGenericFormat::ExecPurpose"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFormat::p_purpose};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFormat, SgAsmGenericFormat::ExecPurpose SgAsmGenericFormat::*, &SgAsmGenericFormat::p_purpose>;
};
template <> struct describe_field_t<SgAsmGenericFormat,Rose::BinaryAnalysis::ByteOrder::Endianness,&SgAsmGenericFormat::p_sex> {
  using parent = SgAsmGenericFormat;
  using field_type = Rose::BinaryAnalysis::ByteOrder::Endianness;
  static constexpr size_t position{2};
  static constexpr char const * const name{"sex"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::ByteOrder::Endianness"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFormat::p_sex};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFormat, Rose::BinaryAnalysis::ByteOrder::Endianness SgAsmGenericFormat::*, &SgAsmGenericFormat::p_sex>;
};
template <> struct describe_field_t<SgAsmGenericFormat,unsigned,&SgAsmGenericFormat::p_version> {
  using parent = SgAsmGenericFormat;
  using field_type = unsigned;
  static constexpr size_t position{3};
  static constexpr char const * const name{"version"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFormat::p_version};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFormat, unsigned SgAsmGenericFormat::*, &SgAsmGenericFormat::p_version>;
};
template <> struct describe_field_t<SgAsmGenericFormat,bool,&SgAsmGenericFormat::p_isCurrentVersion> {
  using parent = SgAsmGenericFormat;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"isCurrentVersion"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFormat::p_isCurrentVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFormat, bool SgAsmGenericFormat::*, &SgAsmGenericFormat::p_isCurrentVersion>;
};
template <> struct describe_field_t<SgAsmGenericFormat,SgAsmGenericFormat::ExecABI,&SgAsmGenericFormat::p_abi> {
  using parent = SgAsmGenericFormat;
  using field_type = SgAsmGenericFormat::ExecABI;
  static constexpr size_t position{5};
  static constexpr char const * const name{"abi"};
  static constexpr char const * const typestr{"SgAsmGenericFormat::ExecABI"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFormat::p_abi};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFormat, SgAsmGenericFormat::ExecABI SgAsmGenericFormat::*, &SgAsmGenericFormat::p_abi>;
};
template <> struct describe_field_t<SgAsmGenericFormat,unsigned,&SgAsmGenericFormat::p_abiVersion> {
  using parent = SgAsmGenericFormat;
  using field_type = unsigned;
  static constexpr size_t position{6};
  static constexpr char const * const name{"abiVersion"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFormat::p_abiVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFormat, unsigned SgAsmGenericFormat::*, &SgAsmGenericFormat::p_abiVersion>;
};
template <> struct describe_field_t<SgAsmGenericFormat,size_t,&SgAsmGenericFormat::p_wordSize> {
  using parent = SgAsmGenericFormat;
  using field_type = size_t;
  static constexpr size_t position{7};
  static constexpr char const * const name{"wordSize"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericFormat::p_wordSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericFormat, size_t SgAsmGenericFormat::*, &SgAsmGenericFormat::p_wordSize>;
};
template <> struct describe_node_t<SgAsmGenericFormat> {
  using node = SgAsmGenericFormat;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericFormat"};
  static constexpr unsigned long variant{198};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericFormat,SgAsmGenericFormat::ExecFamily,&SgAsmGenericFormat::p_family>, describe_field_t<SgAsmGenericFormat,SgAsmGenericFormat::ExecPurpose,&SgAsmGenericFormat::p_purpose>, describe_field_t<SgAsmGenericFormat,Rose::BinaryAnalysis::ByteOrder::Endianness,&SgAsmGenericFormat::p_sex>, describe_field_t<SgAsmGenericFormat,unsigned,&SgAsmGenericFormat::p_version>, describe_field_t<SgAsmGenericFormat,bool,&SgAsmGenericFormat::p_isCurrentVersion>, describe_field_t<SgAsmGenericFormat,SgAsmGenericFormat::ExecABI,&SgAsmGenericFormat::p_abi>, describe_field_t<SgAsmGenericFormat,unsigned,&SgAsmGenericFormat::p_abiVersion>, describe_field_t<SgAsmGenericFormat,size_t,&SgAsmGenericFormat::p_wordSize>>;
};
template <> struct node_from_variant_t<198> { using type = SgAsmGenericFormat; };

// Class: AsmGenericHeader
template <> struct describe_field_t<SgAsmGenericHeader,SgAsmGenericFormat*,&SgAsmGenericHeader::p_executableFormat> {
  using parent = SgAsmGenericHeader;
  using field_type = SgAsmGenericFormat*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"executableFormat"};
  static constexpr char const * const typestr{"SgAsmGenericFormat*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericHeader::p_executableFormat};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericHeader, SgAsmGenericFormat* SgAsmGenericHeader::*, &SgAsmGenericHeader::p_executableFormat>;
};
template <> struct describe_field_t<SgAsmGenericHeader,SgCharList,&SgAsmGenericHeader::p_magic> {
  using parent = SgAsmGenericHeader;
  using field_type = SgCharList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"magic"};
  static constexpr char const * const typestr{"SgCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericHeader::p_magic};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericHeader, SgCharList SgAsmGenericHeader::*, &SgAsmGenericHeader::p_magic>;
};
template <> struct describe_field_t<SgAsmGenericHeader,SgAsmGenericFormat::InsSetArchitecture,&SgAsmGenericHeader::p_isa> {
  using parent = SgAsmGenericHeader;
  using field_type = SgAsmGenericFormat::InsSetArchitecture;
  static constexpr size_t position{2};
  static constexpr char const * const name{"isa"};
  static constexpr char const * const typestr{"SgAsmGenericFormat::InsSetArchitecture"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericHeader::p_isa};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericHeader, SgAsmGenericFormat::InsSetArchitecture SgAsmGenericHeader::*, &SgAsmGenericHeader::p_isa>;
};
template <> struct describe_field_t<SgAsmGenericHeader,Rose::BinaryAnalysis::Address,&SgAsmGenericHeader::p_baseVa> {
  using parent = SgAsmGenericHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{3};
  static constexpr char const * const name{"baseVa"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericHeader::p_baseVa};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericHeader, Rose::BinaryAnalysis::Address SgAsmGenericHeader::*, &SgAsmGenericHeader::p_baseVa>;
};
template <> struct describe_field_t<SgAsmGenericHeader,SgRVAList,&SgAsmGenericHeader::p_entryRvas> {
  using parent = SgAsmGenericHeader;
  using field_type = SgRVAList;
  static constexpr size_t position{4};
  static constexpr char const * const name{"entryRvas"};
  static constexpr char const * const typestr{"SgRVAList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericHeader::p_entryRvas};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericHeader, SgRVAList SgAsmGenericHeader::*, &SgAsmGenericHeader::p_entryRvas>;
};
template <> struct describe_field_t<SgAsmGenericHeader,SgAsmGenericDLLList*,&SgAsmGenericHeader::p_dlls> {
  using parent = SgAsmGenericHeader;
  using field_type = SgAsmGenericDLLList*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"dlls"};
  static constexpr char const * const typestr{"SgAsmGenericDLLList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericHeader::p_dlls};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericHeader, SgAsmGenericDLLList* SgAsmGenericHeader::*, &SgAsmGenericHeader::p_dlls>;
};
template <> struct describe_field_t<SgAsmGenericHeader,SgAsmGenericSectionList*,&SgAsmGenericHeader::p_sections> {
  using parent = SgAsmGenericHeader;
  using field_type = SgAsmGenericSectionList*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"sections"};
  static constexpr char const * const typestr{"SgAsmGenericSectionList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericHeader::p_sections};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericHeader, SgAsmGenericSectionList* SgAsmGenericHeader::*, &SgAsmGenericHeader::p_sections>;
};
template <> struct describe_node_t<SgAsmGenericHeader> {
  using node = SgAsmGenericHeader;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmGenericHeader"};
  static constexpr unsigned long variant{199};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgAsmDOSFileHeader, SgAsmElfFileHeader, SgAsmJvmFileHeader, SgAsmLEFileHeader, SgAsmNEFileHeader, SgAsmPEFileHeader>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericHeader,SgAsmGenericFormat*,&SgAsmGenericHeader::p_executableFormat>, describe_field_t<SgAsmGenericHeader,SgCharList,&SgAsmGenericHeader::p_magic>, describe_field_t<SgAsmGenericHeader,SgAsmGenericFormat::InsSetArchitecture,&SgAsmGenericHeader::p_isa>, describe_field_t<SgAsmGenericHeader,Rose::BinaryAnalysis::Address,&SgAsmGenericHeader::p_baseVa>, describe_field_t<SgAsmGenericHeader,SgRVAList,&SgAsmGenericHeader::p_entryRvas>, describe_field_t<SgAsmGenericHeader,SgAsmGenericDLLList*,&SgAsmGenericHeader::p_dlls>, describe_field_t<SgAsmGenericHeader,SgAsmGenericSectionList*,&SgAsmGenericHeader::p_sections>>;
};
template <> struct node_from_variant_t<199> { using type = SgAsmGenericHeader; };

// Class: AsmGenericHeaderList
template <> struct describe_field_t<SgAsmGenericHeaderList,SgAsmGenericHeaderPtrList,&SgAsmGenericHeaderList::p_headers> {
  using parent = SgAsmGenericHeaderList;
  using field_type = SgAsmGenericHeaderPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"headers"};
  static constexpr char const * const typestr{"SgAsmGenericHeaderPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericHeaderList::p_headers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericHeaderList, SgAsmGenericHeaderPtrList SgAsmGenericHeaderList::*, &SgAsmGenericHeaderList::p_headers>;
};
template <> struct describe_node_t<SgAsmGenericHeaderList> {
  using node = SgAsmGenericHeaderList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericHeaderList"};
  static constexpr unsigned long variant{200};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericHeaderList,SgAsmGenericHeaderPtrList,&SgAsmGenericHeaderList::p_headers>>;
};
template <> struct node_from_variant_t<200> { using type = SgAsmGenericHeaderList; };

// Class: AsmGenericSection
template <> struct describe_field_t<SgAsmGenericSection,SgAsmGenericFile*,&SgAsmGenericSection::p_file> {
  using parent = SgAsmGenericSection;
  using field_type = SgAsmGenericFile*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"file"};
  static constexpr char const * const typestr{"SgAsmGenericFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, SgAsmGenericFile* SgAsmGenericSection::*, &SgAsmGenericSection::p_file>;
};
template <> struct describe_field_t<SgAsmGenericSection,SgAsmGenericHeader*,&SgAsmGenericSection::p_header> {
  using parent = SgAsmGenericSection;
  using field_type = SgAsmGenericHeader*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"header"};
  static constexpr char const * const typestr{"SgAsmGenericHeader*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_header};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, SgAsmGenericHeader* SgAsmGenericSection::*, &SgAsmGenericSection::p_header>;
};
template <> struct describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_size> {
  using parent = SgAsmGenericSection;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{2};
  static constexpr char const * const name{"size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, Rose::BinaryAnalysis::Address SgAsmGenericSection::*, &SgAsmGenericSection::p_size>;
};
template <> struct describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_offset> {
  using parent = SgAsmGenericSection;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{3};
  static constexpr char const * const name{"offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, Rose::BinaryAnalysis::Address SgAsmGenericSection::*, &SgAsmGenericSection::p_offset>;
};
template <> struct describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_fileAlignment> {
  using parent = SgAsmGenericSection;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{4};
  static constexpr char const * const name{"fileAlignment"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_fileAlignment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, Rose::BinaryAnalysis::Address SgAsmGenericSection::*, &SgAsmGenericSection::p_fileAlignment>;
};
template <> struct describe_field_t<SgAsmGenericSection,SgFileContentList,&SgAsmGenericSection::p_data> {
  using parent = SgAsmGenericSection;
  using field_type = SgFileContentList;
  static constexpr size_t position{5};
  static constexpr char const * const name{"data"};
  static constexpr char const * const typestr{"SgFileContentList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_data};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, SgFileContentList SgAsmGenericSection::*, &SgAsmGenericSection::p_data>;
};
template <> struct describe_field_t<SgAsmGenericSection,SgAsmGenericSection::SectionPurpose,&SgAsmGenericSection::p_purpose> {
  using parent = SgAsmGenericSection;
  using field_type = SgAsmGenericSection::SectionPurpose;
  static constexpr size_t position{6};
  static constexpr char const * const name{"purpose"};
  static constexpr char const * const typestr{"SgAsmGenericSection::SectionPurpose"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_purpose};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, SgAsmGenericSection::SectionPurpose SgAsmGenericSection::*, &SgAsmGenericSection::p_purpose>;
};
template <> struct describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_synthesized> {
  using parent = SgAsmGenericSection;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"synthesized"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_synthesized};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, bool SgAsmGenericSection::*, &SgAsmGenericSection::p_synthesized>;
};
template <> struct describe_field_t<SgAsmGenericSection,int,&SgAsmGenericSection::p_id> {
  using parent = SgAsmGenericSection;
  using field_type = int;
  static constexpr size_t position{8};
  static constexpr char const * const name{"id"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_id};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, int SgAsmGenericSection::*, &SgAsmGenericSection::p_id>;
};
template <> struct describe_field_t<SgAsmGenericSection,SgAsmGenericString*,&SgAsmGenericSection::p_name> {
  using parent = SgAsmGenericSection;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, SgAsmGenericString* SgAsmGenericSection::*, &SgAsmGenericSection::p_name>;
};
template <> struct describe_field_t<SgAsmGenericSection,std::string,&SgAsmGenericSection::p_shortName> {
  using parent = SgAsmGenericSection;
  using field_type = std::string;
  static constexpr size_t position{10};
  static constexpr char const * const name{"shortName"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_shortName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, std::string SgAsmGenericSection::*, &SgAsmGenericSection::p_shortName>;
};
template <> struct describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_mappedPreferredRva> {
  using parent = SgAsmGenericSection;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{11};
  static constexpr char const * const name{"mappedPreferredRva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_mappedPreferredRva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, Rose::BinaryAnalysis::Address SgAsmGenericSection::*, &SgAsmGenericSection::p_mappedPreferredRva>;
};
template <> struct describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_mappedSize> {
  using parent = SgAsmGenericSection;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{12};
  static constexpr char const * const name{"mappedSize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_mappedSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, Rose::BinaryAnalysis::Address SgAsmGenericSection::*, &SgAsmGenericSection::p_mappedSize>;
};
template <> struct describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_mappedAlignment> {
  using parent = SgAsmGenericSection;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{13};
  static constexpr char const * const name{"mappedAlignment"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_mappedAlignment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, Rose::BinaryAnalysis::Address SgAsmGenericSection::*, &SgAsmGenericSection::p_mappedAlignment>;
};
template <> struct describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_mappedReadPermission> {
  using parent = SgAsmGenericSection;
  using field_type = bool;
  static constexpr size_t position{14};
  static constexpr char const * const name{"mappedReadPermission"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_mappedReadPermission};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, bool SgAsmGenericSection::*, &SgAsmGenericSection::p_mappedReadPermission>;
};
template <> struct describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_mappedWritePermission> {
  using parent = SgAsmGenericSection;
  using field_type = bool;
  static constexpr size_t position{15};
  static constexpr char const * const name{"mappedWritePermission"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_mappedWritePermission};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, bool SgAsmGenericSection::*, &SgAsmGenericSection::p_mappedWritePermission>;
};
template <> struct describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_mappedExecutePermission> {
  using parent = SgAsmGenericSection;
  using field_type = bool;
  static constexpr size_t position{16};
  static constexpr char const * const name{"mappedExecutePermission"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_mappedExecutePermission};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, bool SgAsmGenericSection::*, &SgAsmGenericSection::p_mappedExecutePermission>;
};
template <> struct describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_containsCode> {
  using parent = SgAsmGenericSection;
  using field_type = bool;
  static constexpr size_t position{17};
  static constexpr char const * const name{"containsCode"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_containsCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, bool SgAsmGenericSection::*, &SgAsmGenericSection::p_containsCode>;
};
template <> struct describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_mappedActualVa> {
  using parent = SgAsmGenericSection;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{18};
  static constexpr char const * const name{"mappedActualVa"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSection::p_mappedActualVa};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSection, Rose::BinaryAnalysis::Address SgAsmGenericSection::*, &SgAsmGenericSection::p_mappedActualVa>;
};
template <> struct describe_node_t<SgAsmGenericSection> {
  using node = SgAsmGenericSection;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericSection"};
  static constexpr unsigned long variant{201};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgAsmCliHeader, SgAsmCoffSymbolTable, SgAsmDOSExtendedHeader, SgAsmElfSection, SgAsmElfSectionTable, SgAsmElfSegmentTable, SgAsmGenericHeader, SgAsmJvmAttributeTable, SgAsmJvmConstantPool, SgAsmJvmFieldTable, SgAsmJvmMethodTable, SgAsmLEEntryTable, SgAsmLENameTable, SgAsmLEPageTable, SgAsmLERelocTable, SgAsmLESection, SgAsmLESectionTable, SgAsmNEEntryTable, SgAsmNEModuleTable, SgAsmNENameTable, SgAsmNERelocTable, SgAsmNESection, SgAsmNESectionTable, SgAsmNEStringTable, SgAsmPESection, SgAsmPESectionTable>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericSection,SgAsmGenericFile*,&SgAsmGenericSection::p_file>, describe_field_t<SgAsmGenericSection,SgAsmGenericHeader*,&SgAsmGenericSection::p_header>, describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_size>, describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_offset>, describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_fileAlignment>, describe_field_t<SgAsmGenericSection,SgFileContentList,&SgAsmGenericSection::p_data>, describe_field_t<SgAsmGenericSection,SgAsmGenericSection::SectionPurpose,&SgAsmGenericSection::p_purpose>, describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_synthesized>, describe_field_t<SgAsmGenericSection,int,&SgAsmGenericSection::p_id>, describe_field_t<SgAsmGenericSection,SgAsmGenericString*,&SgAsmGenericSection::p_name>, describe_field_t<SgAsmGenericSection,std::string,&SgAsmGenericSection::p_shortName>, describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_mappedPreferredRva>, describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_mappedSize>, describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_mappedAlignment>, describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_mappedReadPermission>, describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_mappedWritePermission>, describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_mappedExecutePermission>, describe_field_t<SgAsmGenericSection,bool,&SgAsmGenericSection::p_containsCode>, describe_field_t<SgAsmGenericSection,Rose::BinaryAnalysis::Address,&SgAsmGenericSection::p_mappedActualVa>>;
};
template <> struct node_from_variant_t<201> { using type = SgAsmGenericSection; };

// Class: AsmGenericSectionList
template <> struct describe_field_t<SgAsmGenericSectionList,SgAsmGenericSectionPtrList,&SgAsmGenericSectionList::p_sections> {
  using parent = SgAsmGenericSectionList;
  using field_type = SgAsmGenericSectionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"sections"};
  static constexpr char const * const typestr{"SgAsmGenericSectionPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericSectionList::p_sections};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSectionList, SgAsmGenericSectionPtrList SgAsmGenericSectionList::*, &SgAsmGenericSectionList::p_sections>;
};
template <> struct describe_node_t<SgAsmGenericSectionList> {
  using node = SgAsmGenericSectionList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericSectionList"};
  static constexpr unsigned long variant{202};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericSectionList,SgAsmGenericSectionPtrList,&SgAsmGenericSectionList::p_sections>>;
};
template <> struct node_from_variant_t<202> { using type = SgAsmGenericSectionList; };

// Class: AsmGenericString
template <> struct describe_node_t<SgAsmGenericString> {
  using node = SgAsmGenericString;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericString"};
  static constexpr unsigned long variant{203};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmBasicString, SgAsmStoredString>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<203> { using type = SgAsmGenericString; };

// Class: AsmGenericStrtab
template <> struct describe_field_t<SgAsmGenericStrtab,SgAsmGenericSection*,&SgAsmGenericStrtab::p_container> {
  using parent = SgAsmGenericStrtab;
  using field_type = SgAsmGenericSection*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"container"};
  static constexpr char const * const typestr{"SgAsmGenericSection*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericStrtab::p_container};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericStrtab, SgAsmGenericSection* SgAsmGenericStrtab::*, &SgAsmGenericStrtab::p_container>;
};
template <> struct describe_field_t<SgAsmGenericStrtab,SgAsmGenericStrtab::referenced_t,&SgAsmGenericStrtab::p_storageList> {
  using parent = SgAsmGenericStrtab;
  using field_type = SgAsmGenericStrtab::referenced_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"storageList"};
  static constexpr char const * const typestr{"SgAsmGenericStrtab::referenced_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericStrtab::p_storageList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericStrtab, SgAsmGenericStrtab::referenced_t SgAsmGenericStrtab::*, &SgAsmGenericStrtab::p_storageList>;
};
template <> struct describe_field_t<SgAsmGenericStrtab,Rose::BinaryAnalysis::AddressIntervalSet,&SgAsmGenericStrtab::p_freeList> {
  using parent = SgAsmGenericStrtab;
  using field_type = Rose::BinaryAnalysis::AddressIntervalSet;
  static constexpr size_t position{2};
  static constexpr char const * const name{"freeList"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::AddressIntervalSet"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericStrtab::p_freeList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericStrtab, Rose::BinaryAnalysis::AddressIntervalSet SgAsmGenericStrtab::*, &SgAsmGenericStrtab::p_freeList>;
};
template <> struct describe_field_t<SgAsmGenericStrtab,SgAsmStringStorage*,&SgAsmGenericStrtab::p_dontFree> {
  using parent = SgAsmGenericStrtab;
  using field_type = SgAsmStringStorage*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"dontFree"};
  static constexpr char const * const typestr{"SgAsmStringStorage*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericStrtab::p_dontFree};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericStrtab, SgAsmStringStorage* SgAsmGenericStrtab::*, &SgAsmGenericStrtab::p_dontFree>;
};
template <> struct describe_field_t<SgAsmGenericStrtab,size_t,&SgAsmGenericStrtab::p_numberFreed> {
  using parent = SgAsmGenericStrtab;
  using field_type = size_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"numberFreed"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericStrtab::p_numberFreed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericStrtab, size_t SgAsmGenericStrtab::*, &SgAsmGenericStrtab::p_numberFreed>;
};
template <> struct describe_node_t<SgAsmGenericStrtab> {
  using node = SgAsmGenericStrtab;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericStrtab"};
  static constexpr unsigned long variant{204};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmCoffStrtab, SgAsmElfStrtab>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericStrtab,SgAsmGenericSection*,&SgAsmGenericStrtab::p_container>, describe_field_t<SgAsmGenericStrtab,SgAsmGenericStrtab::referenced_t,&SgAsmGenericStrtab::p_storageList>, describe_field_t<SgAsmGenericStrtab,Rose::BinaryAnalysis::AddressIntervalSet,&SgAsmGenericStrtab::p_freeList>, describe_field_t<SgAsmGenericStrtab,SgAsmStringStorage*,&SgAsmGenericStrtab::p_dontFree>, describe_field_t<SgAsmGenericStrtab,size_t,&SgAsmGenericStrtab::p_numberFreed>>;
};
template <> struct node_from_variant_t<204> { using type = SgAsmGenericStrtab; };

// Class: AsmGenericSymbol
template <> struct describe_field_t<SgAsmGenericSymbol,SgAsmGenericSymbol::SymbolDefState,&SgAsmGenericSymbol::p_definitionState> {
  using parent = SgAsmGenericSymbol;
  using field_type = SgAsmGenericSymbol::SymbolDefState;
  static constexpr size_t position{0};
  static constexpr char const * const name{"definitionState"};
  static constexpr char const * const typestr{"SgAsmGenericSymbol::SymbolDefState"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSymbol::p_definitionState};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSymbol, SgAsmGenericSymbol::SymbolDefState SgAsmGenericSymbol::*, &SgAsmGenericSymbol::p_definitionState>;
};
template <> struct describe_field_t<SgAsmGenericSymbol,SgAsmGenericSymbol::SymbolBinding,&SgAsmGenericSymbol::p_binding> {
  using parent = SgAsmGenericSymbol;
  using field_type = SgAsmGenericSymbol::SymbolBinding;
  static constexpr size_t position{1};
  static constexpr char const * const name{"binding"};
  static constexpr char const * const typestr{"SgAsmGenericSymbol::SymbolBinding"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSymbol::p_binding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSymbol, SgAsmGenericSymbol::SymbolBinding SgAsmGenericSymbol::*, &SgAsmGenericSymbol::p_binding>;
};
template <> struct describe_field_t<SgAsmGenericSymbol,SgAsmGenericSymbol::SymbolType,&SgAsmGenericSymbol::p_type> {
  using parent = SgAsmGenericSymbol;
  using field_type = SgAsmGenericSymbol::SymbolType;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAsmGenericSymbol::SymbolType"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSymbol::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSymbol, SgAsmGenericSymbol::SymbolType SgAsmGenericSymbol::*, &SgAsmGenericSymbol::p_type>;
};
template <> struct describe_field_t<SgAsmGenericSymbol,Rose::BinaryAnalysis::Address,&SgAsmGenericSymbol::p_value> {
  using parent = SgAsmGenericSymbol;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{3};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSymbol::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSymbol, Rose::BinaryAnalysis::Address SgAsmGenericSymbol::*, &SgAsmGenericSymbol::p_value>;
};
template <> struct describe_field_t<SgAsmGenericSymbol,Rose::BinaryAnalysis::Address,&SgAsmGenericSymbol::p_size> {
  using parent = SgAsmGenericSymbol;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{4};
  static constexpr char const * const name{"size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSymbol::p_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSymbol, Rose::BinaryAnalysis::Address SgAsmGenericSymbol::*, &SgAsmGenericSymbol::p_size>;
};
template <> struct describe_field_t<SgAsmGenericSymbol,SgAsmGenericSection*,&SgAsmGenericSymbol::p_bound> {
  using parent = SgAsmGenericSymbol;
  using field_type = SgAsmGenericSection*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"bound"};
  static constexpr char const * const typestr{"SgAsmGenericSection*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSymbol::p_bound};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSymbol, SgAsmGenericSection* SgAsmGenericSymbol::*, &SgAsmGenericSymbol::p_bound>;
};
template <> struct describe_field_t<SgAsmGenericSymbol,SgAsmGenericString*,&SgAsmGenericSymbol::p_name> {
  using parent = SgAsmGenericSymbol;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmGenericSymbol::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSymbol, SgAsmGenericString* SgAsmGenericSymbol::*, &SgAsmGenericSymbol::p_name>;
};
template <> struct describe_node_t<SgAsmGenericSymbol> {
  using node = SgAsmGenericSymbol;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericSymbol"};
  static constexpr unsigned long variant{205};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmCoffSymbol, SgAsmElfSymbol>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericSymbol,SgAsmGenericSymbol::SymbolDefState,&SgAsmGenericSymbol::p_definitionState>, describe_field_t<SgAsmGenericSymbol,SgAsmGenericSymbol::SymbolBinding,&SgAsmGenericSymbol::p_binding>, describe_field_t<SgAsmGenericSymbol,SgAsmGenericSymbol::SymbolType,&SgAsmGenericSymbol::p_type>, describe_field_t<SgAsmGenericSymbol,Rose::BinaryAnalysis::Address,&SgAsmGenericSymbol::p_value>, describe_field_t<SgAsmGenericSymbol,Rose::BinaryAnalysis::Address,&SgAsmGenericSymbol::p_size>, describe_field_t<SgAsmGenericSymbol,SgAsmGenericSection*,&SgAsmGenericSymbol::p_bound>, describe_field_t<SgAsmGenericSymbol,SgAsmGenericString*,&SgAsmGenericSymbol::p_name>>;
};
template <> struct node_from_variant_t<205> { using type = SgAsmGenericSymbol; };

// Class: AsmGenericSymbolList
template <> struct describe_field_t<SgAsmGenericSymbolList,SgAsmGenericSymbolPtrList,&SgAsmGenericSymbolList::p_symbols> {
  using parent = SgAsmGenericSymbolList;
  using field_type = SgAsmGenericSymbolPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbols"};
  static constexpr char const * const typestr{"SgAsmGenericSymbolPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmGenericSymbolList::p_symbols};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmGenericSymbolList, SgAsmGenericSymbolPtrList SgAsmGenericSymbolList::*, &SgAsmGenericSymbolList::p_symbols>;
};
template <> struct describe_node_t<SgAsmGenericSymbolList> {
  using node = SgAsmGenericSymbolList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmGenericSymbolList"};
  static constexpr unsigned long variant{206};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmGenericSymbolList,SgAsmGenericSymbolPtrList,&SgAsmGenericSymbolList::p_symbols>>;
};
template <> struct node_from_variant_t<206> { using type = SgAsmGenericSymbolList; };

// Class: AsmIndirectRegisterExpression
template <> struct describe_field_t<SgAsmIndirectRegisterExpression,Rose::BinaryAnalysis::RegisterDescriptor,&SgAsmIndirectRegisterExpression::p_stride> {
  using parent = SgAsmIndirectRegisterExpression;
  using field_type = Rose::BinaryAnalysis::RegisterDescriptor;
  static constexpr size_t position{0};
  static constexpr char const * const name{"stride"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RegisterDescriptor"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmIndirectRegisterExpression::p_stride};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmIndirectRegisterExpression, Rose::BinaryAnalysis::RegisterDescriptor SgAsmIndirectRegisterExpression::*, &SgAsmIndirectRegisterExpression::p_stride>;
};
template <> struct describe_field_t<SgAsmIndirectRegisterExpression,Rose::BinaryAnalysis::RegisterDescriptor,&SgAsmIndirectRegisterExpression::p_offset> {
  using parent = SgAsmIndirectRegisterExpression;
  using field_type = Rose::BinaryAnalysis::RegisterDescriptor;
  static constexpr size_t position{1};
  static constexpr char const * const name{"offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RegisterDescriptor"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmIndirectRegisterExpression::p_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmIndirectRegisterExpression, Rose::BinaryAnalysis::RegisterDescriptor SgAsmIndirectRegisterExpression::*, &SgAsmIndirectRegisterExpression::p_offset>;
};
template <> struct describe_field_t<SgAsmIndirectRegisterExpression,size_t,&SgAsmIndirectRegisterExpression::p_index> {
  using parent = SgAsmIndirectRegisterExpression;
  using field_type = size_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmIndirectRegisterExpression::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmIndirectRegisterExpression, size_t SgAsmIndirectRegisterExpression::*, &SgAsmIndirectRegisterExpression::p_index>;
};
template <> struct describe_field_t<SgAsmIndirectRegisterExpression,size_t,&SgAsmIndirectRegisterExpression::p_modulus> {
  using parent = SgAsmIndirectRegisterExpression;
  using field_type = size_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"modulus"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmIndirectRegisterExpression::p_modulus};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmIndirectRegisterExpression, size_t SgAsmIndirectRegisterExpression::*, &SgAsmIndirectRegisterExpression::p_modulus>;
};
template <> struct describe_node_t<SgAsmIndirectRegisterExpression> {
  using node = SgAsmIndirectRegisterExpression;
  using base = SgAsmRegisterReferenceExpression;
  static constexpr char const * const name{"AsmIndirectRegisterExpression"};
  static constexpr unsigned long variant{207};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmIndirectRegisterExpression,Rose::BinaryAnalysis::RegisterDescriptor,&SgAsmIndirectRegisterExpression::p_stride>, describe_field_t<SgAsmIndirectRegisterExpression,Rose::BinaryAnalysis::RegisterDescriptor,&SgAsmIndirectRegisterExpression::p_offset>, describe_field_t<SgAsmIndirectRegisterExpression,size_t,&SgAsmIndirectRegisterExpression::p_index>, describe_field_t<SgAsmIndirectRegisterExpression,size_t,&SgAsmIndirectRegisterExpression::p_modulus>>;
};
template <> struct node_from_variant_t<207> { using type = SgAsmIndirectRegisterExpression; };

// Class: AsmInstruction
template <> struct describe_field_t<SgAsmInstruction,uint8_t,&SgAsmInstruction::p_architectureId> {
  using parent = SgAsmInstruction;
  using field_type = uint8_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"architectureId"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmInstruction::p_architectureId};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInstruction, uint8_t SgAsmInstruction::*, &SgAsmInstruction::p_architectureId>;
};
template <> struct describe_field_t<SgAsmInstruction,SgUnsignedCharList,&SgAsmInstruction::p_rawBytes> {
  using parent = SgAsmInstruction;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"rawBytes"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmInstruction::p_rawBytes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInstruction, SgUnsignedCharList SgAsmInstruction::*, &SgAsmInstruction::p_rawBytes>;
};
template <> struct describe_field_t<SgAsmInstruction,SgAsmOperandList*,&SgAsmInstruction::p_operandList> {
  using parent = SgAsmInstruction;
  using field_type = SgAsmOperandList*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"operandList"};
  static constexpr char const * const typestr{"SgAsmOperandList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmInstruction::p_operandList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInstruction, SgAsmOperandList* SgAsmInstruction::*, &SgAsmInstruction::p_operandList>;
};
template <> struct describe_field_t<SgAsmInstruction,SgAsmInstruction*,&SgAsmInstruction::p_delaySlot> {
  using parent = SgAsmInstruction;
  using field_type = SgAsmInstruction*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"delaySlot"};
  static constexpr char const * const typestr{"SgAsmInstruction*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmInstruction::p_delaySlot};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInstruction, SgAsmInstruction* SgAsmInstruction::*, &SgAsmInstruction::p_delaySlot>;
};
template <> struct describe_field_t<SgAsmInstruction,SgAsmExprListExp*,&SgAsmInstruction::p_semantics> {
  using parent = SgAsmInstruction;
  using field_type = SgAsmExprListExp*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"semantics"};
  static constexpr char const * const typestr{"SgAsmExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmInstruction::p_semantics};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInstruction, SgAsmExprListExp* SgAsmInstruction::*, &SgAsmInstruction::p_semantics>;
};
template <> struct describe_node_t<SgAsmInstruction> {
  using node = SgAsmInstruction;
  using base = SgAsmStatement;
  static constexpr char const * const name{"AsmInstruction"};
  static constexpr unsigned long variant{208};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgAsmCilInstruction, SgAsmJvmInstruction, SgAsmM68kInstruction, SgAsmMipsInstruction, SgAsmNullInstruction, SgAsmPowerpcInstruction, SgAsmUserInstruction, SgAsmX86Instruction>;
  using fields_t = mp::List<describe_field_t<SgAsmInstruction,uint8_t,&SgAsmInstruction::p_architectureId>, describe_field_t<SgAsmInstruction,SgUnsignedCharList,&SgAsmInstruction::p_rawBytes>, describe_field_t<SgAsmInstruction,SgAsmOperandList*,&SgAsmInstruction::p_operandList>, describe_field_t<SgAsmInstruction,SgAsmInstruction*,&SgAsmInstruction::p_delaySlot>, describe_field_t<SgAsmInstruction,SgAsmExprListExp*,&SgAsmInstruction::p_semantics>>;
};
template <> struct node_from_variant_t<208> { using type = SgAsmInstruction; };

// Class: AsmIntegerValueExpression
template <> struct describe_field_t<SgAsmIntegerValueExpression,SgNode*,&SgAsmIntegerValueExpression::p_baseNode> {
  using parent = SgAsmIntegerValueExpression;
  using field_type = SgNode*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"baseNode"};
  static constexpr char const * const typestr{"SgNode*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmIntegerValueExpression::p_baseNode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmIntegerValueExpression, SgNode* SgAsmIntegerValueExpression::*, &SgAsmIntegerValueExpression::p_baseNode>;
};
template <> struct describe_node_t<SgAsmIntegerValueExpression> {
  using node = SgAsmIntegerValueExpression;
  using base = SgAsmConstantExpression;
  static constexpr char const * const name{"AsmIntegerValueExpression"};
  static constexpr unsigned long variant{209};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmIntegerValueExpression,SgNode*,&SgAsmIntegerValueExpression::p_baseNode>>;
};
template <> struct node_from_variant_t<209> { using type = SgAsmIntegerValueExpression; };

// Class: AsmIntegerType
template <> struct describe_field_t<SgAsmIntegerType,bool,&SgAsmIntegerType::p_isSigned> {
  using parent = SgAsmIntegerType;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"isSigned"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmIntegerType::p_isSigned};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmIntegerType, bool SgAsmIntegerType::*, &SgAsmIntegerType::p_isSigned>;
};
template <> struct describe_node_t<SgAsmIntegerType> {
  using node = SgAsmIntegerType;
  using base = SgAsmScalarType;
  static constexpr char const * const name{"AsmIntegerType"};
  static constexpr unsigned long variant{210};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmIntegerType,bool,&SgAsmIntegerType::p_isSigned>>;
};
template <> struct node_from_variant_t<210> { using type = SgAsmIntegerType; };

// Class: AsmInterpretation
template <> struct describe_field_t<SgAsmInterpretation,SgAsmGenericHeaderList*,&SgAsmInterpretation::p_headers> {
  using parent = SgAsmInterpretation;
  using field_type = SgAsmGenericHeaderList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"headers"};
  static constexpr char const * const typestr{"SgAsmGenericHeaderList*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmInterpretation::p_headers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInterpretation, SgAsmGenericHeaderList* SgAsmInterpretation::*, &SgAsmInterpretation::p_headers>;
};
template <> struct describe_field_t<SgAsmInterpretation,SgAsmBlock*,&SgAsmInterpretation::p_globalBlock> {
  using parent = SgAsmInterpretation;
  using field_type = SgAsmBlock*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"globalBlock"};
  static constexpr char const * const typestr{"SgAsmBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmInterpretation::p_globalBlock};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInterpretation, SgAsmBlock* SgAsmInterpretation::*, &SgAsmInterpretation::p_globalBlock>;
};
template <> struct describe_field_t<SgAsmInterpretation,bool,&SgAsmInterpretation::p_coverageComputed> {
  using parent = SgAsmInterpretation;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"coverageComputed"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmInterpretation::p_coverageComputed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInterpretation, bool SgAsmInterpretation::*, &SgAsmInterpretation::p_coverageComputed>;
};
template <> struct describe_field_t<SgAsmInterpretation,double,&SgAsmInterpretation::p_percentageCoverage> {
  using parent = SgAsmInterpretation;
  using field_type = double;
  static constexpr size_t position{3};
  static constexpr char const * const name{"percentageCoverage"};
  static constexpr char const * const typestr{"double"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmInterpretation::p_percentageCoverage};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInterpretation, double SgAsmInterpretation::*, &SgAsmInterpretation::p_percentageCoverage>;
};
template <> struct describe_node_t<SgAsmInterpretation> {
  using node = SgAsmInterpretation;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmInterpretation"};
  static constexpr unsigned long variant{211};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmInterpretation,SgAsmGenericHeaderList*,&SgAsmInterpretation::p_headers>, describe_field_t<SgAsmInterpretation,SgAsmBlock*,&SgAsmInterpretation::p_globalBlock>, describe_field_t<SgAsmInterpretation,bool,&SgAsmInterpretation::p_coverageComputed>, describe_field_t<SgAsmInterpretation,double,&SgAsmInterpretation::p_percentageCoverage>>;
};
template <> struct node_from_variant_t<211> { using type = SgAsmInterpretation; };

// Class: AsmInterpretationList
template <> struct describe_field_t<SgAsmInterpretationList,SgAsmInterpretationPtrList,&SgAsmInterpretationList::p_interpretations> {
  using parent = SgAsmInterpretationList;
  using field_type = SgAsmInterpretationPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"interpretations"};
  static constexpr char const * const typestr{"SgAsmInterpretationPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmInterpretationList::p_interpretations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInterpretationList, SgAsmInterpretationPtrList SgAsmInterpretationList::*, &SgAsmInterpretationList::p_interpretations>;
};
template <> struct describe_node_t<SgAsmInterpretationList> {
  using node = SgAsmInterpretationList;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmInterpretationList"};
  static constexpr unsigned long variant{212};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmInterpretationList,SgAsmInterpretationPtrList,&SgAsmInterpretationList::p_interpretations>>;
};
template <> struct node_from_variant_t<212> { using type = SgAsmInterpretationList; };

// Class: AsmJvmAttribute
template <> struct describe_field_t<SgAsmJvmAttribute,uint16_t,&SgAsmJvmAttribute::p_attribute_name_index> {
  using parent = SgAsmJvmAttribute;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"attribute_name_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmAttribute::p_attribute_name_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmAttribute, uint16_t SgAsmJvmAttribute::*, &SgAsmJvmAttribute::p_attribute_name_index>;
};
template <> struct describe_field_t<SgAsmJvmAttribute,uint32_t,&SgAsmJvmAttribute::p_attribute_length> {
  using parent = SgAsmJvmAttribute;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"attribute_length"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmAttribute::p_attribute_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmAttribute, uint32_t SgAsmJvmAttribute::*, &SgAsmJvmAttribute::p_attribute_length>;
};
template <> struct describe_node_t<SgAsmJvmAttribute> {
  using node = SgAsmJvmAttribute;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmAttribute"};
  static constexpr unsigned long variant{213};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmJvmBootstrapMethods, SgAsmJvmCodeAttribute, SgAsmJvmConstantValue, SgAsmJvmDeprecated, SgAsmJvmEnclosingMethod, SgAsmJvmExceptions, SgAsmJvmInnerClasses, SgAsmJvmLineNumberTable, SgAsmJvmLocalVariableTable, SgAsmJvmLocalVariableTypeTable, SgAsmJvmMethodParameters, SgAsmJvmModuleMainClass, SgAsmJvmNestHost, SgAsmJvmNestMembers, SgAsmJvmSignature, SgAsmJvmSourceFile, SgAsmJvmStackMapTable, SgAsmJvmSynthetic>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmAttribute,uint16_t,&SgAsmJvmAttribute::p_attribute_name_index>, describe_field_t<SgAsmJvmAttribute,uint32_t,&SgAsmJvmAttribute::p_attribute_length>>;
};
template <> struct node_from_variant_t<213> { using type = SgAsmJvmAttribute; };

// Class: AsmJvmCodeAttribute
template <> struct describe_field_t<SgAsmJvmCodeAttribute,uint16_t,&SgAsmJvmCodeAttribute::p_max_stack> {
  using parent = SgAsmJvmCodeAttribute;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"max_stack"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmCodeAttribute::p_max_stack};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmCodeAttribute, uint16_t SgAsmJvmCodeAttribute::*, &SgAsmJvmCodeAttribute::p_max_stack>;
};
template <> struct describe_field_t<SgAsmJvmCodeAttribute,uint16_t,&SgAsmJvmCodeAttribute::p_max_locals> {
  using parent = SgAsmJvmCodeAttribute;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"max_locals"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmCodeAttribute::p_max_locals};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmCodeAttribute, uint16_t SgAsmJvmCodeAttribute::*, &SgAsmJvmCodeAttribute::p_max_locals>;
};
template <> struct describe_field_t<SgAsmJvmCodeAttribute,uint32_t,&SgAsmJvmCodeAttribute::p_code_length> {
  using parent = SgAsmJvmCodeAttribute;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"code_length"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmCodeAttribute::p_code_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmCodeAttribute, uint32_t SgAsmJvmCodeAttribute::*, &SgAsmJvmCodeAttribute::p_code_length>;
};
template <> struct describe_field_t<SgAsmJvmCodeAttribute,const char*,&SgAsmJvmCodeAttribute::p_code> {
  using parent = SgAsmJvmCodeAttribute;
  using field_type = const char*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"code"};
  static constexpr char const * const typestr{"const char*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmCodeAttribute::p_code};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmCodeAttribute, const char* SgAsmJvmCodeAttribute::*, &SgAsmJvmCodeAttribute::p_code>;
};
template <> struct describe_field_t<SgAsmJvmCodeAttribute,SgAsmJvmExceptionTable*,&SgAsmJvmCodeAttribute::p_exception_table> {
  using parent = SgAsmJvmCodeAttribute;
  using field_type = SgAsmJvmExceptionTable*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"exception_table"};
  static constexpr char const * const typestr{"SgAsmJvmExceptionTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmCodeAttribute::p_exception_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmCodeAttribute, SgAsmJvmExceptionTable* SgAsmJvmCodeAttribute::*, &SgAsmJvmCodeAttribute::p_exception_table>;
};
template <> struct describe_field_t<SgAsmJvmCodeAttribute,SgAsmJvmAttributeTable*,&SgAsmJvmCodeAttribute::p_attribute_table> {
  using parent = SgAsmJvmCodeAttribute;
  using field_type = SgAsmJvmAttributeTable*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"attribute_table"};
  static constexpr char const * const typestr{"SgAsmJvmAttributeTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmCodeAttribute::p_attribute_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmCodeAttribute, SgAsmJvmAttributeTable* SgAsmJvmCodeAttribute::*, &SgAsmJvmCodeAttribute::p_attribute_table>;
};
template <> struct describe_field_t<SgAsmJvmCodeAttribute,Rose::BinaryAnalysis::Address,&SgAsmJvmCodeAttribute::p_code_offset> {
  using parent = SgAsmJvmCodeAttribute;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{6};
  static constexpr char const * const name{"code_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmCodeAttribute::p_code_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmCodeAttribute, Rose::BinaryAnalysis::Address SgAsmJvmCodeAttribute::*, &SgAsmJvmCodeAttribute::p_code_offset>;
};
template <> struct describe_node_t<SgAsmJvmCodeAttribute> {
  using node = SgAsmJvmCodeAttribute;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmCodeAttribute"};
  static constexpr unsigned long variant{214};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmCodeAttribute,uint16_t,&SgAsmJvmCodeAttribute::p_max_stack>, describe_field_t<SgAsmJvmCodeAttribute,uint16_t,&SgAsmJvmCodeAttribute::p_max_locals>, describe_field_t<SgAsmJvmCodeAttribute,uint32_t,&SgAsmJvmCodeAttribute::p_code_length>, describe_field_t<SgAsmJvmCodeAttribute,const char*,&SgAsmJvmCodeAttribute::p_code>, describe_field_t<SgAsmJvmCodeAttribute,SgAsmJvmExceptionTable*,&SgAsmJvmCodeAttribute::p_exception_table>, describe_field_t<SgAsmJvmCodeAttribute,SgAsmJvmAttributeTable*,&SgAsmJvmCodeAttribute::p_attribute_table>, describe_field_t<SgAsmJvmCodeAttribute,Rose::BinaryAnalysis::Address,&SgAsmJvmCodeAttribute::p_code_offset>>;
};
template <> struct node_from_variant_t<214> { using type = SgAsmJvmCodeAttribute; };

// Class: AsmJvmMethod
template <> struct describe_field_t<SgAsmJvmMethod,uint16_t,&SgAsmJvmMethod::p_access_flags> {
  using parent = SgAsmJvmMethod;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"access_flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmMethod::p_access_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmMethod, uint16_t SgAsmJvmMethod::*, &SgAsmJvmMethod::p_access_flags>;
};
template <> struct describe_field_t<SgAsmJvmMethod,uint16_t,&SgAsmJvmMethod::p_name_index> {
  using parent = SgAsmJvmMethod;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"name_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmMethod::p_name_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmMethod, uint16_t SgAsmJvmMethod::*, &SgAsmJvmMethod::p_name_index>;
};
template <> struct describe_field_t<SgAsmJvmMethod,uint16_t,&SgAsmJvmMethod::p_descriptor_index> {
  using parent = SgAsmJvmMethod;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"descriptor_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmMethod::p_descriptor_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmMethod, uint16_t SgAsmJvmMethod::*, &SgAsmJvmMethod::p_descriptor_index>;
};
template <> struct describe_field_t<SgAsmJvmMethod,SgAsmJvmAttributeTable*,&SgAsmJvmMethod::p_attribute_table> {
  using parent = SgAsmJvmMethod;
  using field_type = SgAsmJvmAttributeTable*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"attribute_table"};
  static constexpr char const * const typestr{"SgAsmJvmAttributeTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmJvmMethod::p_attribute_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmMethod, SgAsmJvmAttributeTable* SgAsmJvmMethod::*, &SgAsmJvmMethod::p_attribute_table>;
};
template <> struct describe_field_t<SgAsmJvmMethod,SgAsmInstructionList*,&SgAsmJvmMethod::p_instruction_list> {
  using parent = SgAsmJvmMethod;
  using field_type = SgAsmInstructionList*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"instruction_list"};
  static constexpr char const * const typestr{"SgAsmInstructionList*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmMethod::p_instruction_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmMethod, SgAsmInstructionList* SgAsmJvmMethod::*, &SgAsmJvmMethod::p_instruction_list>;
};
template <> struct describe_node_t<SgAsmJvmMethod> {
  using node = SgAsmJvmMethod;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmMethod"};
  static constexpr unsigned long variant{215};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmMethod,uint16_t,&SgAsmJvmMethod::p_access_flags>, describe_field_t<SgAsmJvmMethod,uint16_t,&SgAsmJvmMethod::p_name_index>, describe_field_t<SgAsmJvmMethod,uint16_t,&SgAsmJvmMethod::p_descriptor_index>, describe_field_t<SgAsmJvmMethod,SgAsmJvmAttributeTable*,&SgAsmJvmMethod::p_attribute_table>, describe_field_t<SgAsmJvmMethod,SgAsmInstructionList*,&SgAsmJvmMethod::p_instruction_list>>;
};
template <> struct node_from_variant_t<215> { using type = SgAsmJvmMethod; };

// Class: AsmJvmConstantPool
template <> struct describe_field_t<SgAsmJvmConstantPool,SgAsmJvmConstantPoolEntryPtrList,&SgAsmJvmConstantPool::p_entries> {
  using parent = SgAsmJvmConstantPool;
  using field_type = SgAsmJvmConstantPoolEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmJvmConstantPoolEntryPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPool::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPool, SgAsmJvmConstantPoolEntryPtrList SgAsmJvmConstantPool::*, &SgAsmJvmConstantPool::p_entries>;
};
template <> struct describe_node_t<SgAsmJvmConstantPool> {
  using node = SgAsmJvmConstantPool;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmJvmConstantPool"};
  static constexpr unsigned long variant{216};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmConstantPool,SgAsmJvmConstantPoolEntryPtrList,&SgAsmJvmConstantPool::p_entries>>;
};
template <> struct node_from_variant_t<216> { using type = SgAsmJvmConstantPool; };

// Class: AsmJvmConstantPoolEntry
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,SgAsmJvmConstantPoolEntry::Kind,&SgAsmJvmConstantPoolEntry::p_tag> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = SgAsmJvmConstantPoolEntry::Kind;
  static constexpr size_t position{0};
  static constexpr char const * const name{"tag"};
  static constexpr char const * const typestr{"SgAsmJvmConstantPoolEntry::Kind"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_tag};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, SgAsmJvmConstantPoolEntry::Kind SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_tag>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint32_t,&SgAsmJvmConstantPoolEntry::p_bytes> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"bytes"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_bytes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint32_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_bytes>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint32_t,&SgAsmJvmConstantPoolEntry::p_hi_bytes> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"hi_bytes"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_hi_bytes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint32_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_hi_bytes>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint32_t,&SgAsmJvmConstantPoolEntry::p_low_bytes> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"low_bytes"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_low_bytes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint32_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_low_bytes>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_bootstrap_method_attr_index> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint16_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"bootstrap_method_attr_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_bootstrap_method_attr_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint16_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_bootstrap_method_attr_index>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_class_index> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint16_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"class_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_class_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint16_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_class_index>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_descriptor_index> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint16_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"descriptor_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_descriptor_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint16_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_descriptor_index>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_name_index> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint16_t;
  static constexpr size_t position{7};
  static constexpr char const * const name{"name_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_name_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint16_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_name_index>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_name_and_type_index> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint16_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"name_and_type_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_name_and_type_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint16_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_name_and_type_index>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_reference_index> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint16_t;
  static constexpr size_t position{9};
  static constexpr char const * const name{"reference_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_reference_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint16_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_reference_index>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint8_t,&SgAsmJvmConstantPoolEntry::p_reference_kind> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint8_t;
  static constexpr size_t position{10};
  static constexpr char const * const name{"reference_kind"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_reference_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint8_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_reference_kind>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_string_index> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint16_t;
  static constexpr size_t position{11};
  static constexpr char const * const name{"string_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_string_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint16_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_string_index>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_length> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = uint16_t;
  static constexpr size_t position{12};
  static constexpr char const * const name{"length"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, uint16_t SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_length>;
};
template <> struct describe_field_t<SgAsmJvmConstantPoolEntry,char*,&SgAsmJvmConstantPoolEntry::p_utf8_bytes> {
  using parent = SgAsmJvmConstantPoolEntry;
  using field_type = char*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"utf8_bytes"};
  static constexpr char const * const typestr{"char*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantPoolEntry::p_utf8_bytes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantPoolEntry, char* SgAsmJvmConstantPoolEntry::*, &SgAsmJvmConstantPoolEntry::p_utf8_bytes>;
};
template <> struct describe_node_t<SgAsmJvmConstantPoolEntry> {
  using node = SgAsmJvmConstantPoolEntry;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmConstantPoolEntry"};
  static constexpr unsigned long variant{217};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmConstantPoolEntry,SgAsmJvmConstantPoolEntry::Kind,&SgAsmJvmConstantPoolEntry::p_tag>, describe_field_t<SgAsmJvmConstantPoolEntry,uint32_t,&SgAsmJvmConstantPoolEntry::p_bytes>, describe_field_t<SgAsmJvmConstantPoolEntry,uint32_t,&SgAsmJvmConstantPoolEntry::p_hi_bytes>, describe_field_t<SgAsmJvmConstantPoolEntry,uint32_t,&SgAsmJvmConstantPoolEntry::p_low_bytes>, describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_bootstrap_method_attr_index>, describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_class_index>, describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_descriptor_index>, describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_name_index>, describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_name_and_type_index>, describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_reference_index>, describe_field_t<SgAsmJvmConstantPoolEntry,uint8_t,&SgAsmJvmConstantPoolEntry::p_reference_kind>, describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_string_index>, describe_field_t<SgAsmJvmConstantPoolEntry,uint16_t,&SgAsmJvmConstantPoolEntry::p_length>, describe_field_t<SgAsmJvmConstantPoolEntry,char*,&SgAsmJvmConstantPoolEntry::p_utf8_bytes>>;
};
template <> struct node_from_variant_t<217> { using type = SgAsmJvmConstantPoolEntry; };

// Class: AsmJvmConstantValue
template <> struct describe_field_t<SgAsmJvmConstantValue,uint16_t,&SgAsmJvmConstantValue::p_constantvalue_index> {
  using parent = SgAsmJvmConstantValue;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"constantvalue_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmConstantValue::p_constantvalue_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmConstantValue, uint16_t SgAsmJvmConstantValue::*, &SgAsmJvmConstantValue::p_constantvalue_index>;
};
template <> struct describe_node_t<SgAsmJvmConstantValue> {
  using node = SgAsmJvmConstantValue;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmConstantValue"};
  static constexpr unsigned long variant{218};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmConstantValue,uint16_t,&SgAsmJvmConstantValue::p_constantvalue_index>>;
};
template <> struct node_from_variant_t<218> { using type = SgAsmJvmConstantValue; };

// Class: AsmJvmInstruction
template <> struct describe_field_t<SgAsmJvmInstruction,Rose::BinaryAnalysis::JvmInstructionKind,&SgAsmJvmInstruction::p_kind> {
  using parent = SgAsmJvmInstruction;
  using field_type = Rose::BinaryAnalysis::JvmInstructionKind;
  static constexpr size_t position{0};
  static constexpr char const * const name{"kind"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::JvmInstructionKind"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmInstruction::p_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmInstruction, Rose::BinaryAnalysis::JvmInstructionKind SgAsmJvmInstruction::*, &SgAsmJvmInstruction::p_kind>;
};
template <> struct describe_node_t<SgAsmJvmInstruction> {
  using node = SgAsmJvmInstruction;
  using base = SgAsmInstruction;
  static constexpr char const * const name{"AsmJvmInstruction"};
  static constexpr unsigned long variant{219};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmInstruction,Rose::BinaryAnalysis::JvmInstructionKind,&SgAsmJvmInstruction::p_kind>>;
};
template <> struct node_from_variant_t<219> { using type = SgAsmJvmInstruction; };

// Class: AsmJvmFileHeader
template <> struct describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_minor_version> {
  using parent = SgAsmJvmFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"minor_version"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_minor_version};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, uint16_t SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_minor_version>;
};
template <> struct describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_major_version> {
  using parent = SgAsmJvmFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"major_version"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_major_version};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, uint16_t SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_major_version>;
};
template <> struct describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_access_flags> {
  using parent = SgAsmJvmFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"access_flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_access_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, uint16_t SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_access_flags>;
};
template <> struct describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_this_class> {
  using parent = SgAsmJvmFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"this_class"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_this_class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, uint16_t SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_this_class>;
};
template <> struct describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_super_class> {
  using parent = SgAsmJvmFileHeader;
  using field_type = uint16_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"super_class"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_super_class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, uint16_t SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_super_class>;
};
template <> struct describe_field_t<SgAsmJvmFileHeader,SgAsmJvmConstantPool*,&SgAsmJvmFileHeader::p_constant_pool> {
  using parent = SgAsmJvmFileHeader;
  using field_type = SgAsmJvmConstantPool*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"constant_pool"};
  static constexpr char const * const typestr{"SgAsmJvmConstantPool*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_constant_pool};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, SgAsmJvmConstantPool* SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_constant_pool>;
};
template <> struct describe_field_t<SgAsmJvmFileHeader,std::list<uint16_t>,&SgAsmJvmFileHeader::p_interfaces> {
  using parent = SgAsmJvmFileHeader;
  using field_type = std::list<uint16_t>;
  static constexpr size_t position{6};
  static constexpr char const * const name{"interfaces"};
  static constexpr char const * const typestr{"std::list<uint16_t>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_interfaces};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, std::list<uint16_t> SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_interfaces>;
};
template <> struct describe_field_t<SgAsmJvmFileHeader,SgAsmJvmFieldTable*,&SgAsmJvmFileHeader::p_field_table> {
  using parent = SgAsmJvmFileHeader;
  using field_type = SgAsmJvmFieldTable*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"field_table"};
  static constexpr char const * const typestr{"SgAsmJvmFieldTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_field_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, SgAsmJvmFieldTable* SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_field_table>;
};
template <> struct describe_field_t<SgAsmJvmFileHeader,SgAsmJvmMethodTable*,&SgAsmJvmFileHeader::p_method_table> {
  using parent = SgAsmJvmFileHeader;
  using field_type = SgAsmJvmMethodTable*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"method_table"};
  static constexpr char const * const typestr{"SgAsmJvmMethodTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_method_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, SgAsmJvmMethodTable* SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_method_table>;
};
template <> struct describe_field_t<SgAsmJvmFileHeader,SgAsmJvmAttributeTable*,&SgAsmJvmFileHeader::p_attribute_table> {
  using parent = SgAsmJvmFileHeader;
  using field_type = SgAsmJvmAttributeTable*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"attribute_table"};
  static constexpr char const * const typestr{"SgAsmJvmAttributeTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmFileHeader::p_attribute_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFileHeader, SgAsmJvmAttributeTable* SgAsmJvmFileHeader::*, &SgAsmJvmFileHeader::p_attribute_table>;
};
template <> struct describe_node_t<SgAsmJvmFileHeader> {
  using node = SgAsmJvmFileHeader;
  using base = SgAsmGenericHeader;
  static constexpr char const * const name{"AsmJvmFileHeader"};
  static constexpr unsigned long variant{220};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_minor_version>, describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_major_version>, describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_access_flags>, describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_this_class>, describe_field_t<SgAsmJvmFileHeader,uint16_t,&SgAsmJvmFileHeader::p_super_class>, describe_field_t<SgAsmJvmFileHeader,SgAsmJvmConstantPool*,&SgAsmJvmFileHeader::p_constant_pool>, describe_field_t<SgAsmJvmFileHeader,std::list<uint16_t>,&SgAsmJvmFileHeader::p_interfaces>, describe_field_t<SgAsmJvmFileHeader,SgAsmJvmFieldTable*,&SgAsmJvmFileHeader::p_field_table>, describe_field_t<SgAsmJvmFileHeader,SgAsmJvmMethodTable*,&SgAsmJvmFileHeader::p_method_table>, describe_field_t<SgAsmJvmFileHeader,SgAsmJvmAttributeTable*,&SgAsmJvmFileHeader::p_attribute_table>>;
};
template <> struct node_from_variant_t<220> { using type = SgAsmJvmFileHeader; };

// Class: AsmJvmNode
template <> struct describe_node_t<SgAsmJvmNode> {
  using node = SgAsmJvmNode;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmJvmNode"};
  static constexpr unsigned long variant{221};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmJvmAttribute, SgAsmJvmBootstrapMethod, SgAsmJvmClass, SgAsmJvmConstantPoolEntry, SgAsmJvmExceptionHandler, SgAsmJvmExceptionTable, SgAsmJvmField, SgAsmJvmInnerClassesEntry, SgAsmJvmLineNumberEntry, SgAsmJvmLocalVariableEntry, SgAsmJvmLocalVariableTypeEntry, SgAsmJvmMethod, SgAsmJvmMethodParametersEntry, SgAsmJvmStackMapFrame, SgAsmJvmStackMapVerificationType>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<221> { using type = SgAsmJvmNode; };

// Class: AsmJvmSignature
template <> struct describe_field_t<SgAsmJvmSignature,uint16_t,&SgAsmJvmSignature::p_signature_index> {
  using parent = SgAsmJvmSignature;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"signature_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmSignature::p_signature_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmSignature, uint16_t SgAsmJvmSignature::*, &SgAsmJvmSignature::p_signature_index>;
};
template <> struct describe_node_t<SgAsmJvmSignature> {
  using node = SgAsmJvmSignature;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmSignature"};
  static constexpr unsigned long variant{222};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmSignature,uint16_t,&SgAsmJvmSignature::p_signature_index>>;
};
template <> struct node_from_variant_t<222> { using type = SgAsmJvmSignature; };

// Class: AsmJvmSourceFile
template <> struct describe_field_t<SgAsmJvmSourceFile,uint16_t,&SgAsmJvmSourceFile::p_sourcefile_index> {
  using parent = SgAsmJvmSourceFile;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"sourcefile_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmSourceFile::p_sourcefile_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmSourceFile, uint16_t SgAsmJvmSourceFile::*, &SgAsmJvmSourceFile::p_sourcefile_index>;
};
template <> struct describe_node_t<SgAsmJvmSourceFile> {
  using node = SgAsmJvmSourceFile;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmSourceFile"};
  static constexpr unsigned long variant{223};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmSourceFile,uint16_t,&SgAsmJvmSourceFile::p_sourcefile_index>>;
};
template <> struct node_from_variant_t<223> { using type = SgAsmJvmSourceFile; };

// Class: AsmLEEntryPoint
template <> struct describe_field_t<SgAsmLEEntryPoint,SgAsmLEEntryPointPtrList,&SgAsmLEEntryPoint::p_entries> {
  using parent = SgAsmLEEntryPoint;
  using field_type = SgAsmLEEntryPointPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmLEEntryPointPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLEEntryPoint::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEEntryPoint, SgAsmLEEntryPointPtrList SgAsmLEEntryPoint::*, &SgAsmLEEntryPoint::p_entries>;
};
template <> struct describe_field_t<SgAsmLEEntryPoint,unsigned,&SgAsmLEEntryPoint::p_flags> {
  using parent = SgAsmLEEntryPoint;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEEntryPoint::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEEntryPoint, unsigned SgAsmLEEntryPoint::*, &SgAsmLEEntryPoint::p_flags>;
};
template <> struct describe_field_t<SgAsmLEEntryPoint,unsigned,&SgAsmLEEntryPoint::p_objnum> {
  using parent = SgAsmLEEntryPoint;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"objnum"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEEntryPoint::p_objnum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEEntryPoint, unsigned SgAsmLEEntryPoint::*, &SgAsmLEEntryPoint::p_objnum>;
};
template <> struct describe_field_t<SgAsmLEEntryPoint,unsigned,&SgAsmLEEntryPoint::p_entry_type> {
  using parent = SgAsmLEEntryPoint;
  using field_type = unsigned;
  static constexpr size_t position{3};
  static constexpr char const * const name{"entry_type"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEEntryPoint::p_entry_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEEntryPoint, unsigned SgAsmLEEntryPoint::*, &SgAsmLEEntryPoint::p_entry_type>;
};
template <> struct describe_field_t<SgAsmLEEntryPoint,unsigned,&SgAsmLEEntryPoint::p_res1> {
  using parent = SgAsmLEEntryPoint;
  using field_type = unsigned;
  static constexpr size_t position{4};
  static constexpr char const * const name{"res1"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEEntryPoint::p_res1};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEEntryPoint, unsigned SgAsmLEEntryPoint::*, &SgAsmLEEntryPoint::p_res1>;
};
template <> struct describe_field_t<SgAsmLEEntryPoint,Rose::BinaryAnalysis::Address,&SgAsmLEEntryPoint::p_entry_offset> {
  using parent = SgAsmLEEntryPoint;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{5};
  static constexpr char const * const name{"entry_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEEntryPoint::p_entry_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEEntryPoint, Rose::BinaryAnalysis::Address SgAsmLEEntryPoint::*, &SgAsmLEEntryPoint::p_entry_offset>;
};
template <> struct describe_node_t<SgAsmLEEntryPoint> {
  using node = SgAsmLEEntryPoint;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmLEEntryPoint"};
  static constexpr unsigned long variant{224};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmLEEntryPoint,SgAsmLEEntryPointPtrList,&SgAsmLEEntryPoint::p_entries>, describe_field_t<SgAsmLEEntryPoint,unsigned,&SgAsmLEEntryPoint::p_flags>, describe_field_t<SgAsmLEEntryPoint,unsigned,&SgAsmLEEntryPoint::p_objnum>, describe_field_t<SgAsmLEEntryPoint,unsigned,&SgAsmLEEntryPoint::p_entry_type>, describe_field_t<SgAsmLEEntryPoint,unsigned,&SgAsmLEEntryPoint::p_res1>, describe_field_t<SgAsmLEEntryPoint,Rose::BinaryAnalysis::Address,&SgAsmLEEntryPoint::p_entry_offset>>;
};
template <> struct node_from_variant_t<224> { using type = SgAsmLEEntryPoint; };

// Class: AsmLEEntryTable
template <> struct describe_field_t<SgAsmLEEntryTable,SgSizeTList,&SgAsmLEEntryTable::p_bundle_sizes> {
  using parent = SgAsmLEEntryTable;
  using field_type = SgSizeTList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"bundle_sizes"};
  static constexpr char const * const typestr{"SgSizeTList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEEntryTable::p_bundle_sizes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEEntryTable, SgSizeTList SgAsmLEEntryTable::*, &SgAsmLEEntryTable::p_bundle_sizes>;
};
template <> struct describe_field_t<SgAsmLEEntryTable,SgAsmLEEntryPointPtrList,&SgAsmLEEntryTable::p_entries> {
  using parent = SgAsmLEEntryTable;
  using field_type = SgAsmLEEntryPointPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmLEEntryPointPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLEEntryTable::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEEntryTable, SgAsmLEEntryPointPtrList SgAsmLEEntryTable::*, &SgAsmLEEntryTable::p_entries>;
};
template <> struct describe_node_t<SgAsmLEEntryTable> {
  using node = SgAsmLEEntryTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmLEEntryTable"};
  static constexpr unsigned long variant{225};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmLEEntryTable,SgSizeTList,&SgAsmLEEntryTable::p_bundle_sizes>, describe_field_t<SgAsmLEEntryTable,SgAsmLEEntryPointPtrList,&SgAsmLEEntryTable::p_entries>>;
};
template <> struct node_from_variant_t<225> { using type = SgAsmLEEntryTable; };

// Class: AsmLEFileHeader
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_byte_order> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"e_byte_order"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_byte_order};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_byte_order>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_word_order> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"e_word_order"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_word_order};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_word_order>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_format_level> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"e_format_level"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_format_level};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_format_level>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_cpu_type> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{3};
  static constexpr char const * const name{"e_cpu_type"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_cpu_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_cpu_type>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_os_type> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{4};
  static constexpr char const * const name{"e_os_type"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_os_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_os_type>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_module_version> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{5};
  static constexpr char const * const name{"e_module_version"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_module_version};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_module_version>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_flags> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{6};
  static constexpr char const * const name{"e_flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_flags>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_eip_section> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{7};
  static constexpr char const * const name{"e_eip_section"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_eip_section};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_eip_section>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_esp_section> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{8};
  static constexpr char const * const name{"e_esp_section"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_esp_section};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_esp_section>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_last_page_size> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{9};
  static constexpr char const * const name{"e_last_page_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_last_page_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_last_page_size>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_page_offset_shift> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{10};
  static constexpr char const * const name{"e_page_offset_shift"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_page_offset_shift};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_page_offset_shift>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_fixup_sect_cksum> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{11};
  static constexpr char const * const name{"e_fixup_sect_cksum"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_fixup_sect_cksum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_fixup_sect_cksum>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_loader_sect_cksum> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{12};
  static constexpr char const * const name{"e_loader_sect_cksum"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_loader_sect_cksum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_loader_sect_cksum>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_secttab_nentries> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{13};
  static constexpr char const * const name{"e_secttab_nentries"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_secttab_nentries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_secttab_nentries>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_rsrctab_nentries> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{14};
  static constexpr char const * const name{"e_rsrctab_nentries"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_rsrctab_nentries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_rsrctab_nentries>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_fmtdirtab_nentries> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{15};
  static constexpr char const * const name{"e_fmtdirtab_nentries"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_fmtdirtab_nentries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_fmtdirtab_nentries>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_import_modtab_nentries> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{16};
  static constexpr char const * const name{"e_import_modtab_nentries"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_import_modtab_nentries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_import_modtab_nentries>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_preload_npages> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{17};
  static constexpr char const * const name{"e_preload_npages"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_preload_npages};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_preload_npages>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_nonresnametab_size> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{18};
  static constexpr char const * const name{"e_nonresnametab_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_nonresnametab_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_nonresnametab_size>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_nonresnametab_cksum> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{19};
  static constexpr char const * const name{"e_nonresnametab_cksum"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_nonresnametab_cksum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_nonresnametab_cksum>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_auto_ds_section> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{20};
  static constexpr char const * const name{"e_auto_ds_section"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_auto_ds_section};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_auto_ds_section>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_debug_info_size> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{21};
  static constexpr char const * const name{"e_debug_info_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_debug_info_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_debug_info_size>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_num_instance_preload> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{22};
  static constexpr char const * const name{"e_num_instance_preload"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_num_instance_preload};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_num_instance_preload>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_num_instance_demand> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{23};
  static constexpr char const * const name{"e_num_instance_demand"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_num_instance_demand};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_num_instance_demand>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_heap_size> {
  using parent = SgAsmLEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{24};
  static constexpr char const * const name{"e_heap_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_heap_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, unsigned SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_heap_size>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_npages> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{25};
  static constexpr char const * const name{"e_npages"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_npages};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_npages>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_eip> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{26};
  static constexpr char const * const name{"e_eip"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_eip};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_eip>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_esp> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{27};
  static constexpr char const * const name{"e_esp"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_esp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_esp>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_page_size> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{28};
  static constexpr char const * const name{"e_page_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_page_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_page_size>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_fixup_sect_size> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{29};
  static constexpr char const * const name{"e_fixup_sect_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_fixup_sect_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_fixup_sect_size>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_loader_sect_size> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{30};
  static constexpr char const * const name{"e_loader_sect_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_loader_sect_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_loader_sect_size>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_secttab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{31};
  static constexpr char const * const name{"e_secttab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_secttab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_secttab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_pagetab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{32};
  static constexpr char const * const name{"e_pagetab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_pagetab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_pagetab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_iterpages_offset> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{33};
  static constexpr char const * const name{"e_iterpages_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_iterpages_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_iterpages_offset>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_rsrctab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{34};
  static constexpr char const * const name{"e_rsrctab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_rsrctab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_rsrctab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_resnametab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{35};
  static constexpr char const * const name{"e_resnametab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_resnametab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_resnametab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_entrytab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{36};
  static constexpr char const * const name{"e_entrytab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_entrytab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_entrytab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_fmtdirtab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{37};
  static constexpr char const * const name{"e_fmtdirtab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_fmtdirtab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_fmtdirtab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_fixup_pagetab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{38};
  static constexpr char const * const name{"e_fixup_pagetab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_fixup_pagetab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_fixup_pagetab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_fixup_rectab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{39};
  static constexpr char const * const name{"e_fixup_rectab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_fixup_rectab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_fixup_rectab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_import_modtab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{40};
  static constexpr char const * const name{"e_import_modtab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_import_modtab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_import_modtab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_import_proctab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{41};
  static constexpr char const * const name{"e_import_proctab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_import_proctab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_import_proctab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_ppcksumtab_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{42};
  static constexpr char const * const name{"e_ppcksumtab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_ppcksumtab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_ppcksumtab_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_data_pages_offset> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{43};
  static constexpr char const * const name{"e_data_pages_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_data_pages_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_data_pages_offset>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_nonresnametab_offset> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{44};
  static constexpr char const * const name{"e_nonresnametab_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_nonresnametab_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_nonresnametab_offset>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_debug_info_rfo> {
  using parent = SgAsmLEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{45};
  static constexpr char const * const name{"e_debug_info_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_e_debug_info_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, Rose::BinaryAnalysis::Address SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_e_debug_info_rfo>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,SgAsmDOSExtendedHeader*,&SgAsmLEFileHeader::p_dos2Header> {
  using parent = SgAsmLEFileHeader;
  using field_type = SgAsmDOSExtendedHeader*;
  static constexpr size_t position{46};
  static constexpr char const * const name{"dos2Header"};
  static constexpr char const * const typestr{"SgAsmDOSExtendedHeader*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_dos2Header};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, SgAsmDOSExtendedHeader* SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_dos2Header>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,SgAsmLESectionTable*,&SgAsmLEFileHeader::p_sectionTable> {
  using parent = SgAsmLEFileHeader;
  using field_type = SgAsmLESectionTable*;
  static constexpr size_t position{47};
  static constexpr char const * const name{"sectionTable"};
  static constexpr char const * const typestr{"SgAsmLESectionTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_sectionTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, SgAsmLESectionTable* SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_sectionTable>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,SgAsmLEPageTable*,&SgAsmLEFileHeader::p_pageTable> {
  using parent = SgAsmLEFileHeader;
  using field_type = SgAsmLEPageTable*;
  static constexpr size_t position{48};
  static constexpr char const * const name{"pageTable"};
  static constexpr char const * const typestr{"SgAsmLEPageTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_pageTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, SgAsmLEPageTable* SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_pageTable>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,SgAsmLENameTable*,&SgAsmLEFileHeader::p_residentNameTable> {
  using parent = SgAsmLEFileHeader;
  using field_type = SgAsmLENameTable*;
  static constexpr size_t position{49};
  static constexpr char const * const name{"residentNameTable"};
  static constexpr char const * const typestr{"SgAsmLENameTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_residentNameTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, SgAsmLENameTable* SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_residentNameTable>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,SgAsmLENameTable*,&SgAsmLEFileHeader::p_nonresidentNameTable> {
  using parent = SgAsmLEFileHeader;
  using field_type = SgAsmLENameTable*;
  static constexpr size_t position{50};
  static constexpr char const * const name{"nonresidentNameTable"};
  static constexpr char const * const typestr{"SgAsmLENameTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_nonresidentNameTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, SgAsmLENameTable* SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_nonresidentNameTable>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,SgAsmLEEntryTable*,&SgAsmLEFileHeader::p_entryTable> {
  using parent = SgAsmLEFileHeader;
  using field_type = SgAsmLEEntryTable*;
  static constexpr size_t position{51};
  static constexpr char const * const name{"entryTable"};
  static constexpr char const * const typestr{"SgAsmLEEntryTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_entryTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, SgAsmLEEntryTable* SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_entryTable>;
};
template <> struct describe_field_t<SgAsmLEFileHeader,SgAsmLERelocTable*,&SgAsmLEFileHeader::p_relocationTable> {
  using parent = SgAsmLEFileHeader;
  using field_type = SgAsmLERelocTable*;
  static constexpr size_t position{52};
  static constexpr char const * const name{"relocationTable"};
  static constexpr char const * const typestr{"SgAsmLERelocTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLEFileHeader::p_relocationTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEFileHeader, SgAsmLERelocTable* SgAsmLEFileHeader::*, &SgAsmLEFileHeader::p_relocationTable>;
};
template <> struct describe_node_t<SgAsmLEFileHeader> {
  using node = SgAsmLEFileHeader;
  using base = SgAsmGenericHeader;
  static constexpr char const * const name{"AsmLEFileHeader"};
  static constexpr unsigned long variant{226};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_byte_order>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_word_order>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_format_level>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_cpu_type>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_os_type>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_module_version>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_flags>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_eip_section>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_esp_section>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_last_page_size>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_page_offset_shift>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_fixup_sect_cksum>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_loader_sect_cksum>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_secttab_nentries>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_rsrctab_nentries>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_fmtdirtab_nentries>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_import_modtab_nentries>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_preload_npages>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_nonresnametab_size>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_nonresnametab_cksum>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_auto_ds_section>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_debug_info_size>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_num_instance_preload>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_num_instance_demand>, describe_field_t<SgAsmLEFileHeader,unsigned,&SgAsmLEFileHeader::p_e_heap_size>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_npages>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_eip>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_esp>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_page_size>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_fixup_sect_size>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_loader_sect_size>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_secttab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_pagetab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_iterpages_offset>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_rsrctab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_resnametab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_entrytab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_fmtdirtab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_fixup_pagetab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_fixup_rectab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_import_modtab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_import_proctab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_ppcksumtab_rfo>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_data_pages_offset>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_nonresnametab_offset>, describe_field_t<SgAsmLEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmLEFileHeader::p_e_debug_info_rfo>, describe_field_t<SgAsmLEFileHeader,SgAsmDOSExtendedHeader*,&SgAsmLEFileHeader::p_dos2Header>, describe_field_t<SgAsmLEFileHeader,SgAsmLESectionTable*,&SgAsmLEFileHeader::p_sectionTable>, describe_field_t<SgAsmLEFileHeader,SgAsmLEPageTable*,&SgAsmLEFileHeader::p_pageTable>, describe_field_t<SgAsmLEFileHeader,SgAsmLENameTable*,&SgAsmLEFileHeader::p_residentNameTable>, describe_field_t<SgAsmLEFileHeader,SgAsmLENameTable*,&SgAsmLEFileHeader::p_nonresidentNameTable>, describe_field_t<SgAsmLEFileHeader,SgAsmLEEntryTable*,&SgAsmLEFileHeader::p_entryTable>, describe_field_t<SgAsmLEFileHeader,SgAsmLERelocTable*,&SgAsmLEFileHeader::p_relocationTable>>;
};
template <> struct node_from_variant_t<226> { using type = SgAsmLEFileHeader; };

// Class: AsmLENameTable
template <> struct describe_field_t<SgAsmLENameTable,SgStringList,&SgAsmLENameTable::p_names> {
  using parent = SgAsmLENameTable;
  using field_type = SgStringList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"names"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLENameTable::p_names};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLENameTable, SgStringList SgAsmLENameTable::*, &SgAsmLENameTable::p_names>;
};
template <> struct describe_field_t<SgAsmLENameTable,SgUnsignedList,&SgAsmLENameTable::p_ordinals> {
  using parent = SgAsmLENameTable;
  using field_type = SgUnsignedList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"ordinals"};
  static constexpr char const * const typestr{"SgUnsignedList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLENameTable::p_ordinals};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLENameTable, SgUnsignedList SgAsmLENameTable::*, &SgAsmLENameTable::p_ordinals>;
};
template <> struct describe_node_t<SgAsmLENameTable> {
  using node = SgAsmLENameTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmLENameTable"};
  static constexpr unsigned long variant{227};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmLENameTable,SgStringList,&SgAsmLENameTable::p_names>, describe_field_t<SgAsmLENameTable,SgUnsignedList,&SgAsmLENameTable::p_ordinals>>;
};
template <> struct node_from_variant_t<227> { using type = SgAsmLENameTable; };

// Class: AsmLEPageTable
template <> struct describe_field_t<SgAsmLEPageTable,SgAsmLEPageTableEntryPtrList,&SgAsmLEPageTable::p_entries> {
  using parent = SgAsmLEPageTable;
  using field_type = SgAsmLEPageTableEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmLEPageTableEntryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLEPageTable::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEPageTable, SgAsmLEPageTableEntryPtrList SgAsmLEPageTable::*, &SgAsmLEPageTable::p_entries>;
};
template <> struct describe_node_t<SgAsmLEPageTable> {
  using node = SgAsmLEPageTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmLEPageTable"};
  static constexpr unsigned long variant{228};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmLEPageTable,SgAsmLEPageTableEntryPtrList,&SgAsmLEPageTable::p_entries>>;
};
template <> struct node_from_variant_t<228> { using type = SgAsmLEPageTable; };

// Class: AsmLEPageTableEntry
template <> struct describe_field_t<SgAsmLEPageTableEntry,unsigned,&SgAsmLEPageTableEntry::p_pageno> {
  using parent = SgAsmLEPageTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"pageno"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEPageTableEntry::p_pageno};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEPageTableEntry, unsigned SgAsmLEPageTableEntry::*, &SgAsmLEPageTableEntry::p_pageno>;
};
template <> struct describe_field_t<SgAsmLEPageTableEntry,unsigned,&SgAsmLEPageTableEntry::p_flags> {
  using parent = SgAsmLEPageTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLEPageTableEntry::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLEPageTableEntry, unsigned SgAsmLEPageTableEntry::*, &SgAsmLEPageTableEntry::p_flags>;
};
template <> struct describe_node_t<SgAsmLEPageTableEntry> {
  using node = SgAsmLEPageTableEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmLEPageTableEntry"};
  static constexpr unsigned long variant{229};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmLEPageTableEntry,unsigned,&SgAsmLEPageTableEntry::p_pageno>, describe_field_t<SgAsmLEPageTableEntry,unsigned,&SgAsmLEPageTableEntry::p_flags>>;
};
template <> struct node_from_variant_t<229> { using type = SgAsmLEPageTableEntry; };

// Class: AsmLERelocTable
template <> struct describe_field_t<SgAsmLERelocTable,SgAsmLERelocEntryPtrList,&SgAsmLERelocTable::p_entries> {
  using parent = SgAsmLERelocTable;
  using field_type = SgAsmLERelocEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmLERelocEntryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLERelocTable::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLERelocTable, SgAsmLERelocEntryPtrList SgAsmLERelocTable::*, &SgAsmLERelocTable::p_entries>;
};
template <> struct describe_node_t<SgAsmLERelocTable> {
  using node = SgAsmLERelocTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmLERelocTable"};
  static constexpr unsigned long variant{230};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmLERelocTable,SgAsmLERelocEntryPtrList,&SgAsmLERelocTable::p_entries>>;
};
template <> struct node_from_variant_t<230> { using type = SgAsmLERelocTable; };

// Class: AsmLESection
template <> struct describe_field_t<SgAsmLESection,SgAsmLESectionTableEntry*,&SgAsmLESection::p_sectionTableEntry> {
  using parent = SgAsmLESection;
  using field_type = SgAsmLESectionTableEntry*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"sectionTableEntry"};
  static constexpr char const * const typestr{"SgAsmLESectionTableEntry*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmLESection::p_sectionTableEntry};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLESection, SgAsmLESectionTableEntry* SgAsmLESection::*, &SgAsmLESection::p_sectionTableEntry>;
};
template <> struct describe_node_t<SgAsmLESection> {
  using node = SgAsmLESection;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmLESection"};
  static constexpr unsigned long variant{231};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmLESection,SgAsmLESectionTableEntry*,&SgAsmLESection::p_sectionTableEntry>>;
};
template <> struct node_from_variant_t<231> { using type = SgAsmLESection; };

// Class: AsmLESectionTable
template <> struct describe_node_t<SgAsmLESectionTable> {
  using node = SgAsmLESectionTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmLESectionTable"};
  static constexpr unsigned long variant{232};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<232> { using type = SgAsmLESectionTable; };

// Class: AsmLESectionTableEntry
template <> struct describe_field_t<SgAsmLESectionTableEntry,unsigned,&SgAsmLESectionTableEntry::p_flags> {
  using parent = SgAsmLESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLESectionTableEntry::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLESectionTableEntry, unsigned SgAsmLESectionTableEntry::*, &SgAsmLESectionTableEntry::p_flags>;
};
template <> struct describe_field_t<SgAsmLESectionTableEntry,unsigned,&SgAsmLESectionTableEntry::p_pageMapIndex> {
  using parent = SgAsmLESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"pageMapIndex"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLESectionTableEntry::p_pageMapIndex};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLESectionTableEntry, unsigned SgAsmLESectionTableEntry::*, &SgAsmLESectionTableEntry::p_pageMapIndex>;
};
template <> struct describe_field_t<SgAsmLESectionTableEntry,unsigned,&SgAsmLESectionTableEntry::p_pageMapNEntries> {
  using parent = SgAsmLESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"pageMapNEntries"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLESectionTableEntry::p_pageMapNEntries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLESectionTableEntry, unsigned SgAsmLESectionTableEntry::*, &SgAsmLESectionTableEntry::p_pageMapNEntries>;
};
template <> struct describe_field_t<SgAsmLESectionTableEntry,unsigned,&SgAsmLESectionTableEntry::p_res1> {
  using parent = SgAsmLESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{3};
  static constexpr char const * const name{"res1"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLESectionTableEntry::p_res1};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLESectionTableEntry, unsigned SgAsmLESectionTableEntry::*, &SgAsmLESectionTableEntry::p_res1>;
};
template <> struct describe_field_t<SgAsmLESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmLESectionTableEntry::p_mappedSize> {
  using parent = SgAsmLESectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{4};
  static constexpr char const * const name{"mappedSize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLESectionTableEntry::p_mappedSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLESectionTableEntry, Rose::BinaryAnalysis::Address SgAsmLESectionTableEntry::*, &SgAsmLESectionTableEntry::p_mappedSize>;
};
template <> struct describe_field_t<SgAsmLESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmLESectionTableEntry::p_baseAddr> {
  using parent = SgAsmLESectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{5};
  static constexpr char const * const name{"baseAddr"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmLESectionTableEntry::p_baseAddr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmLESectionTableEntry, Rose::BinaryAnalysis::Address SgAsmLESectionTableEntry::*, &SgAsmLESectionTableEntry::p_baseAddr>;
};
template <> struct describe_node_t<SgAsmLESectionTableEntry> {
  using node = SgAsmLESectionTableEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmLESectionTableEntry"};
  static constexpr unsigned long variant{233};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmLESectionTableEntry,unsigned,&SgAsmLESectionTableEntry::p_flags>, describe_field_t<SgAsmLESectionTableEntry,unsigned,&SgAsmLESectionTableEntry::p_pageMapIndex>, describe_field_t<SgAsmLESectionTableEntry,unsigned,&SgAsmLESectionTableEntry::p_pageMapNEntries>, describe_field_t<SgAsmLESectionTableEntry,unsigned,&SgAsmLESectionTableEntry::p_res1>, describe_field_t<SgAsmLESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmLESectionTableEntry::p_mappedSize>, describe_field_t<SgAsmLESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmLESectionTableEntry::p_baseAddr>>;
};
template <> struct node_from_variant_t<233> { using type = SgAsmLESectionTableEntry; };

// Class: AsmM68kInstruction
template <> struct describe_field_t<SgAsmM68kInstruction,Rose::BinaryAnalysis::M68kInstructionKind,&SgAsmM68kInstruction::p_kind> {
  using parent = SgAsmM68kInstruction;
  using field_type = Rose::BinaryAnalysis::M68kInstructionKind;
  static constexpr size_t position{0};
  static constexpr char const * const name{"kind"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::M68kInstructionKind"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmM68kInstruction::p_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmM68kInstruction, Rose::BinaryAnalysis::M68kInstructionKind SgAsmM68kInstruction::*, &SgAsmM68kInstruction::p_kind>;
};
template <> struct describe_field_t<SgAsmM68kInstruction,Rose::BinaryAnalysis::M68kDataFormat,&SgAsmM68kInstruction::p_dataFormat> {
  using parent = SgAsmM68kInstruction;
  using field_type = Rose::BinaryAnalysis::M68kDataFormat;
  static constexpr size_t position{1};
  static constexpr char const * const name{"dataFormat"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::M68kDataFormat"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmM68kInstruction::p_dataFormat};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmM68kInstruction, Rose::BinaryAnalysis::M68kDataFormat SgAsmM68kInstruction::*, &SgAsmM68kInstruction::p_dataFormat>;
};
template <> struct describe_node_t<SgAsmM68kInstruction> {
  using node = SgAsmM68kInstruction;
  using base = SgAsmInstruction;
  static constexpr char const * const name{"AsmM68kInstruction"};
  static constexpr unsigned long variant{234};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmM68kInstruction,Rose::BinaryAnalysis::M68kInstructionKind,&SgAsmM68kInstruction::p_kind>, describe_field_t<SgAsmM68kInstruction,Rose::BinaryAnalysis::M68kDataFormat,&SgAsmM68kInstruction::p_dataFormat>>;
};
template <> struct node_from_variant_t<234> { using type = SgAsmM68kInstruction; };

// Class: AsmMemoryReferenceExpression
template <> struct describe_field_t<SgAsmMemoryReferenceExpression,SgAsmExpression*,&SgAsmMemoryReferenceExpression::p_address> {
  using parent = SgAsmMemoryReferenceExpression;
  using field_type = SgAsmExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"address"};
  static constexpr char const * const typestr{"SgAsmExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmMemoryReferenceExpression::p_address};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmMemoryReferenceExpression, SgAsmExpression* SgAsmMemoryReferenceExpression::*, &SgAsmMemoryReferenceExpression::p_address>;
};
template <> struct describe_field_t<SgAsmMemoryReferenceExpression,SgAsmExpression*,&SgAsmMemoryReferenceExpression::p_segment> {
  using parent = SgAsmMemoryReferenceExpression;
  using field_type = SgAsmExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"segment"};
  static constexpr char const * const typestr{"SgAsmExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmMemoryReferenceExpression::p_segment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmMemoryReferenceExpression, SgAsmExpression* SgAsmMemoryReferenceExpression::*, &SgAsmMemoryReferenceExpression::p_segment>;
};
template <> struct describe_node_t<SgAsmMemoryReferenceExpression> {
  using node = SgAsmMemoryReferenceExpression;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmMemoryReferenceExpression"};
  static constexpr unsigned long variant{235};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmMemoryReferenceExpression,SgAsmExpression*,&SgAsmMemoryReferenceExpression::p_address>, describe_field_t<SgAsmMemoryReferenceExpression,SgAsmExpression*,&SgAsmMemoryReferenceExpression::p_segment>>;
};
template <> struct node_from_variant_t<235> { using type = SgAsmMemoryReferenceExpression; };

// Class: AsmMipsInstruction
template <> struct describe_field_t<SgAsmMipsInstruction,Rose::BinaryAnalysis::MipsInstructionKind,&SgAsmMipsInstruction::p_kind> {
  using parent = SgAsmMipsInstruction;
  using field_type = Rose::BinaryAnalysis::MipsInstructionKind;
  static constexpr size_t position{0};
  static constexpr char const * const name{"kind"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::MipsInstructionKind"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmMipsInstruction::p_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmMipsInstruction, Rose::BinaryAnalysis::MipsInstructionKind SgAsmMipsInstruction::*, &SgAsmMipsInstruction::p_kind>;
};
template <> struct describe_node_t<SgAsmMipsInstruction> {
  using node = SgAsmMipsInstruction;
  using base = SgAsmInstruction;
  static constexpr char const * const name{"AsmMipsInstruction"};
  static constexpr unsigned long variant{236};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmMipsInstruction,Rose::BinaryAnalysis::MipsInstructionKind,&SgAsmMipsInstruction::p_kind>>;
};
template <> struct node_from_variant_t<236> { using type = SgAsmMipsInstruction; };

// Class: AsmNEEntryPoint
template <> struct describe_field_t<SgAsmNEEntryPoint,SgAsmNEEntryPoint::NEEntryFlags,&SgAsmNEEntryPoint::p_flags> {
  using parent = SgAsmNEEntryPoint;
  using field_type = SgAsmNEEntryPoint::NEEntryFlags;
  static constexpr size_t position{0};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"SgAsmNEEntryPoint::NEEntryFlags"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEEntryPoint::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEEntryPoint, SgAsmNEEntryPoint::NEEntryFlags SgAsmNEEntryPoint::*, &SgAsmNEEntryPoint::p_flags>;
};
template <> struct describe_field_t<SgAsmNEEntryPoint,unsigned,&SgAsmNEEntryPoint::p_int3f> {
  using parent = SgAsmNEEntryPoint;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"int3f"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEEntryPoint::p_int3f};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEEntryPoint, unsigned SgAsmNEEntryPoint::*, &SgAsmNEEntryPoint::p_int3f>;
};
template <> struct describe_field_t<SgAsmNEEntryPoint,unsigned,&SgAsmNEEntryPoint::p_sectionIndex> {
  using parent = SgAsmNEEntryPoint;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"sectionIndex"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEEntryPoint::p_sectionIndex};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEEntryPoint, unsigned SgAsmNEEntryPoint::*, &SgAsmNEEntryPoint::p_sectionIndex>;
};
template <> struct describe_field_t<SgAsmNEEntryPoint,unsigned,&SgAsmNEEntryPoint::p_sectionOffset> {
  using parent = SgAsmNEEntryPoint;
  using field_type = unsigned;
  static constexpr size_t position{3};
  static constexpr char const * const name{"sectionOffset"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEEntryPoint::p_sectionOffset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEEntryPoint, unsigned SgAsmNEEntryPoint::*, &SgAsmNEEntryPoint::p_sectionOffset>;
};
template <> struct describe_node_t<SgAsmNEEntryPoint> {
  using node = SgAsmNEEntryPoint;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmNEEntryPoint"};
  static constexpr unsigned long variant{237};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNEEntryPoint,SgAsmNEEntryPoint::NEEntryFlags,&SgAsmNEEntryPoint::p_flags>, describe_field_t<SgAsmNEEntryPoint,unsigned,&SgAsmNEEntryPoint::p_int3f>, describe_field_t<SgAsmNEEntryPoint,unsigned,&SgAsmNEEntryPoint::p_sectionIndex>, describe_field_t<SgAsmNEEntryPoint,unsigned,&SgAsmNEEntryPoint::p_sectionOffset>>;
};
template <> struct node_from_variant_t<237> { using type = SgAsmNEEntryPoint; };

// Class: AsmNEEntryTable
template <> struct describe_field_t<SgAsmNEEntryTable,SgSizeTList,&SgAsmNEEntryTable::p_bundle_sizes> {
  using parent = SgAsmNEEntryTable;
  using field_type = SgSizeTList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"bundle_sizes"};
  static constexpr char const * const typestr{"SgSizeTList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEEntryTable::p_bundle_sizes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEEntryTable, SgSizeTList SgAsmNEEntryTable::*, &SgAsmNEEntryTable::p_bundle_sizes>;
};
template <> struct describe_field_t<SgAsmNEEntryTable,SgAsmNEEntryPointPtrList,&SgAsmNEEntryTable::p_entries> {
  using parent = SgAsmNEEntryTable;
  using field_type = SgAsmNEEntryPointPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmNEEntryPointPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNEEntryTable::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEEntryTable, SgAsmNEEntryPointPtrList SgAsmNEEntryTable::*, &SgAsmNEEntryTable::p_entries>;
};
template <> struct describe_node_t<SgAsmNEEntryTable> {
  using node = SgAsmNEEntryTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmNEEntryTable"};
  static constexpr unsigned long variant{238};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNEEntryTable,SgSizeTList,&SgAsmNEEntryTable::p_bundle_sizes>, describe_field_t<SgAsmNEEntryTable,SgAsmNEEntryPointPtrList,&SgAsmNEEntryTable::p_entries>>;
};
template <> struct node_from_variant_t<238> { using type = SgAsmNEEntryTable; };

// Class: AsmNEFileHeader
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_linker_major> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"e_linker_major"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_linker_major};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_linker_major>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_linker_minor> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"e_linker_minor"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_linker_minor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_linker_minor>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_checksum> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"e_checksum"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_checksum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_checksum>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_flags1> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{3};
  static constexpr char const * const name{"e_flags1"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_flags1};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_flags1>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_autodata_sn> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{4};
  static constexpr char const * const name{"e_autodata_sn"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_autodata_sn};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_autodata_sn>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_bss_size> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{5};
  static constexpr char const * const name{"e_bss_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_bss_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_bss_size>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_stack_size> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{6};
  static constexpr char const * const name{"e_stack_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_stack_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_stack_size>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_csip> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{7};
  static constexpr char const * const name{"e_csip"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_csip};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_csip>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_sssp> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{8};
  static constexpr char const * const name{"e_sssp"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_sssp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_sssp>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nsections> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{9};
  static constexpr char const * const name{"e_nsections"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_nsections};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_nsections>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nmodrefs> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{10};
  static constexpr char const * const name{"e_nmodrefs"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_nmodrefs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_nmodrefs>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nnonresnames> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{11};
  static constexpr char const * const name{"e_nnonresnames"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_nnonresnames};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_nnonresnames>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nmovable_entries> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{12};
  static constexpr char const * const name{"e_nmovable_entries"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_nmovable_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_nmovable_entries>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_sector_align> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{13};
  static constexpr char const * const name{"e_sector_align"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_sector_align};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_sector_align>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nresources> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{14};
  static constexpr char const * const name{"e_nresources"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_nresources};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_nresources>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_exetype> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{15};
  static constexpr char const * const name{"e_exetype"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_exetype};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_exetype>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_flags2> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{16};
  static constexpr char const * const name{"e_flags2"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_flags2};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_flags2>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_res1> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{17};
  static constexpr char const * const name{"e_res1"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_res1};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_res1>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_winvers> {
  using parent = SgAsmNEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{18};
  static constexpr char const * const name{"e_winvers"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_winvers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, unsigned SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_winvers>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_entrytab_rfo> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{19};
  static constexpr char const * const name{"e_entrytab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_entrytab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_entrytab_rfo>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_entrytab_size> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{20};
  static constexpr char const * const name{"e_entrytab_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_entrytab_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_entrytab_size>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_sectab_rfo> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{21};
  static constexpr char const * const name{"e_sectab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_sectab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_sectab_rfo>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_rsrctab_rfo> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{22};
  static constexpr char const * const name{"e_rsrctab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_rsrctab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_rsrctab_rfo>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_resnametab_rfo> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{23};
  static constexpr char const * const name{"e_resnametab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_resnametab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_resnametab_rfo>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_modreftab_rfo> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{24};
  static constexpr char const * const name{"e_modreftab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_modreftab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_modreftab_rfo>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_importnametab_rfo> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{25};
  static constexpr char const * const name{"e_importnametab_rfo"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_importnametab_rfo};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_importnametab_rfo>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_nonresnametab_offset> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{26};
  static constexpr char const * const name{"e_nonresnametab_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_nonresnametab_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_nonresnametab_offset>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_fastload_sector> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{27};
  static constexpr char const * const name{"e_fastload_sector"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_fastload_sector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_fastload_sector>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_fastload_nsectors> {
  using parent = SgAsmNEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{28};
  static constexpr char const * const name{"e_fastload_nsectors"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_e_fastload_nsectors};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, Rose::BinaryAnalysis::Address SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_e_fastload_nsectors>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,SgAsmDOSExtendedHeader*,&SgAsmNEFileHeader::p_dos2Header> {
  using parent = SgAsmNEFileHeader;
  using field_type = SgAsmDOSExtendedHeader*;
  static constexpr size_t position{29};
  static constexpr char const * const name{"dos2Header"};
  static constexpr char const * const typestr{"SgAsmDOSExtendedHeader*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_dos2Header};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, SgAsmDOSExtendedHeader* SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_dos2Header>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,SgAsmNESectionTable*,&SgAsmNEFileHeader::p_sectionTable> {
  using parent = SgAsmNEFileHeader;
  using field_type = SgAsmNESectionTable*;
  static constexpr size_t position{30};
  static constexpr char const * const name{"sectionTable"};
  static constexpr char const * const typestr{"SgAsmNESectionTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_sectionTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, SgAsmNESectionTable* SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_sectionTable>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,SgAsmNENameTable*,&SgAsmNEFileHeader::p_residentNameTable> {
  using parent = SgAsmNEFileHeader;
  using field_type = SgAsmNENameTable*;
  static constexpr size_t position{31};
  static constexpr char const * const name{"residentNameTable"};
  static constexpr char const * const typestr{"SgAsmNENameTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_residentNameTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, SgAsmNENameTable* SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_residentNameTable>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,SgAsmNENameTable*,&SgAsmNEFileHeader::p_nonresidentNameTable> {
  using parent = SgAsmNEFileHeader;
  using field_type = SgAsmNENameTable*;
  static constexpr size_t position{32};
  static constexpr char const * const name{"nonresidentNameTable"};
  static constexpr char const * const typestr{"SgAsmNENameTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_nonresidentNameTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, SgAsmNENameTable* SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_nonresidentNameTable>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,SgAsmNEModuleTable*,&SgAsmNEFileHeader::p_moduleTable> {
  using parent = SgAsmNEFileHeader;
  using field_type = SgAsmNEModuleTable*;
  static constexpr size_t position{33};
  static constexpr char const * const name{"moduleTable"};
  static constexpr char const * const typestr{"SgAsmNEModuleTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_moduleTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, SgAsmNEModuleTable* SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_moduleTable>;
};
template <> struct describe_field_t<SgAsmNEFileHeader,SgAsmNEEntryTable*,&SgAsmNEFileHeader::p_entryTable> {
  using parent = SgAsmNEFileHeader;
  using field_type = SgAsmNEEntryTable*;
  static constexpr size_t position{34};
  static constexpr char const * const name{"entryTable"};
  static constexpr char const * const typestr{"SgAsmNEEntryTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNEFileHeader::p_entryTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEFileHeader, SgAsmNEEntryTable* SgAsmNEFileHeader::*, &SgAsmNEFileHeader::p_entryTable>;
};
template <> struct describe_node_t<SgAsmNEFileHeader> {
  using node = SgAsmNEFileHeader;
  using base = SgAsmGenericHeader;
  static constexpr char const * const name{"AsmNEFileHeader"};
  static constexpr unsigned long variant{239};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_linker_major>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_linker_minor>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_checksum>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_flags1>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_autodata_sn>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_bss_size>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_stack_size>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_csip>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_sssp>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nsections>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nmodrefs>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nnonresnames>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nmovable_entries>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_sector_align>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_nresources>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_exetype>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_flags2>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_res1>, describe_field_t<SgAsmNEFileHeader,unsigned,&SgAsmNEFileHeader::p_e_winvers>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_entrytab_rfo>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_entrytab_size>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_sectab_rfo>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_rsrctab_rfo>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_resnametab_rfo>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_modreftab_rfo>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_importnametab_rfo>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_nonresnametab_offset>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_fastload_sector>, describe_field_t<SgAsmNEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmNEFileHeader::p_e_fastload_nsectors>, describe_field_t<SgAsmNEFileHeader,SgAsmDOSExtendedHeader*,&SgAsmNEFileHeader::p_dos2Header>, describe_field_t<SgAsmNEFileHeader,SgAsmNESectionTable*,&SgAsmNEFileHeader::p_sectionTable>, describe_field_t<SgAsmNEFileHeader,SgAsmNENameTable*,&SgAsmNEFileHeader::p_residentNameTable>, describe_field_t<SgAsmNEFileHeader,SgAsmNENameTable*,&SgAsmNEFileHeader::p_nonresidentNameTable>, describe_field_t<SgAsmNEFileHeader,SgAsmNEModuleTable*,&SgAsmNEFileHeader::p_moduleTable>, describe_field_t<SgAsmNEFileHeader,SgAsmNEEntryTable*,&SgAsmNEFileHeader::p_entryTable>>;
};
template <> struct node_from_variant_t<239> { using type = SgAsmNEFileHeader; };

// Class: AsmNEModuleTable
template <> struct describe_field_t<SgAsmNEModuleTable,SgAsmNEStringTable*,&SgAsmNEModuleTable::p_strtab> {
  using parent = SgAsmNEModuleTable;
  using field_type = SgAsmNEStringTable*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"strtab"};
  static constexpr char const * const typestr{"SgAsmNEStringTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNEModuleTable::p_strtab};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEModuleTable, SgAsmNEStringTable* SgAsmNEModuleTable::*, &SgAsmNEModuleTable::p_strtab>;
};
template <> struct describe_field_t<SgAsmNEModuleTable,SgAddressList,&SgAsmNEModuleTable::p_nameOffsets> {
  using parent = SgAsmNEModuleTable;
  using field_type = SgAddressList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"nameOffsets"};
  static constexpr char const * const typestr{"SgAddressList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEModuleTable::p_nameOffsets};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEModuleTable, SgAddressList SgAsmNEModuleTable::*, &SgAsmNEModuleTable::p_nameOffsets>;
};
template <> struct describe_field_t<SgAsmNEModuleTable,SgStringList,&SgAsmNEModuleTable::p_names> {
  using parent = SgAsmNEModuleTable;
  using field_type = SgStringList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"names"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNEModuleTable::p_names};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNEModuleTable, SgStringList SgAsmNEModuleTable::*, &SgAsmNEModuleTable::p_names>;
};
template <> struct describe_node_t<SgAsmNEModuleTable> {
  using node = SgAsmNEModuleTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmNEModuleTable"};
  static constexpr unsigned long variant{240};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNEModuleTable,SgAsmNEStringTable*,&SgAsmNEModuleTable::p_strtab>, describe_field_t<SgAsmNEModuleTable,SgAddressList,&SgAsmNEModuleTable::p_nameOffsets>, describe_field_t<SgAsmNEModuleTable,SgStringList,&SgAsmNEModuleTable::p_names>>;
};
template <> struct node_from_variant_t<240> { using type = SgAsmNEModuleTable; };

// Class: AsmNENameTable
template <> struct describe_field_t<SgAsmNENameTable,SgStringList,&SgAsmNENameTable::p_names> {
  using parent = SgAsmNENameTable;
  using field_type = SgStringList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"names"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNENameTable::p_names};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNENameTable, SgStringList SgAsmNENameTable::*, &SgAsmNENameTable::p_names>;
};
template <> struct describe_field_t<SgAsmNENameTable,SgUnsignedList,&SgAsmNENameTable::p_ordinals> {
  using parent = SgAsmNENameTable;
  using field_type = SgUnsignedList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"ordinals"};
  static constexpr char const * const typestr{"SgUnsignedList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNENameTable::p_ordinals};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNENameTable, SgUnsignedList SgAsmNENameTable::*, &SgAsmNENameTable::p_ordinals>;
};
template <> struct describe_node_t<SgAsmNENameTable> {
  using node = SgAsmNENameTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmNENameTable"};
  static constexpr unsigned long variant{241};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNENameTable,SgStringList,&SgAsmNENameTable::p_names>, describe_field_t<SgAsmNENameTable,SgUnsignedList,&SgAsmNENameTable::p_ordinals>>;
};
template <> struct node_from_variant_t<241> { using type = SgAsmNENameTable; };

// Class: AsmNERelocEntry
template <> struct describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::NERelocSrcType,&SgAsmNERelocEntry::p_src_type> {
  using parent = SgAsmNERelocEntry;
  using field_type = SgAsmNERelocEntry::NERelocSrcType;
  static constexpr size_t position{0};
  static constexpr char const * const name{"src_type"};
  static constexpr char const * const typestr{"SgAsmNERelocEntry::NERelocSrcType"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNERelocEntry::p_src_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocEntry, SgAsmNERelocEntry::NERelocSrcType SgAsmNERelocEntry::*, &SgAsmNERelocEntry::p_src_type>;
};
template <> struct describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::NERelocModifiers,&SgAsmNERelocEntry::p_modifier> {
  using parent = SgAsmNERelocEntry;
  using field_type = SgAsmNERelocEntry::NERelocModifiers;
  static constexpr size_t position{1};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgAsmNERelocEntry::NERelocModifiers"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNERelocEntry::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocEntry, SgAsmNERelocEntry::NERelocModifiers SgAsmNERelocEntry::*, &SgAsmNERelocEntry::p_modifier>;
};
template <> struct describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::NERelocTgtType,&SgAsmNERelocEntry::p_tgt_type> {
  using parent = SgAsmNERelocEntry;
  using field_type = SgAsmNERelocEntry::NERelocTgtType;
  static constexpr size_t position{2};
  static constexpr char const * const name{"tgt_type"};
  static constexpr char const * const typestr{"SgAsmNERelocEntry::NERelocTgtType"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNERelocEntry::p_tgt_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocEntry, SgAsmNERelocEntry::NERelocTgtType SgAsmNERelocEntry::*, &SgAsmNERelocEntry::p_tgt_type>;
};
template <> struct describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::NERelocFlags,&SgAsmNERelocEntry::p_flags> {
  using parent = SgAsmNERelocEntry;
  using field_type = SgAsmNERelocEntry::NERelocFlags;
  static constexpr size_t position{3};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"SgAsmNERelocEntry::NERelocFlags"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNERelocEntry::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocEntry, SgAsmNERelocEntry::NERelocFlags SgAsmNERelocEntry::*, &SgAsmNERelocEntry::p_flags>;
};
template <> struct describe_field_t<SgAsmNERelocEntry,Rose::BinaryAnalysis::Address,&SgAsmNERelocEntry::p_src_offset> {
  using parent = SgAsmNERelocEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{4};
  static constexpr char const * const name{"src_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNERelocEntry::p_src_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocEntry, Rose::BinaryAnalysis::Address SgAsmNERelocEntry::*, &SgAsmNERelocEntry::p_src_offset>;
};
template <> struct describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::iref_type,&SgAsmNERelocEntry::p_iref> {
  using parent = SgAsmNERelocEntry;
  using field_type = SgAsmNERelocEntry::iref_type;
  static constexpr size_t position{5};
  static constexpr char const * const name{"iref"};
  static constexpr char const * const typestr{"SgAsmNERelocEntry::iref_type"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNERelocEntry::p_iref};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocEntry, SgAsmNERelocEntry::iref_type SgAsmNERelocEntry::*, &SgAsmNERelocEntry::p_iref>;
};
template <> struct describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::iord_type,&SgAsmNERelocEntry::p_iord> {
  using parent = SgAsmNERelocEntry;
  using field_type = SgAsmNERelocEntry::iord_type;
  static constexpr size_t position{6};
  static constexpr char const * const name{"iord"};
  static constexpr char const * const typestr{"SgAsmNERelocEntry::iord_type"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNERelocEntry::p_iord};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocEntry, SgAsmNERelocEntry::iord_type SgAsmNERelocEntry::*, &SgAsmNERelocEntry::p_iord>;
};
template <> struct describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::iname_type,&SgAsmNERelocEntry::p_iname> {
  using parent = SgAsmNERelocEntry;
  using field_type = SgAsmNERelocEntry::iname_type;
  static constexpr size_t position{7};
  static constexpr char const * const name{"iname"};
  static constexpr char const * const typestr{"SgAsmNERelocEntry::iname_type"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNERelocEntry::p_iname};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocEntry, SgAsmNERelocEntry::iname_type SgAsmNERelocEntry::*, &SgAsmNERelocEntry::p_iname>;
};
template <> struct describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::osfixup_type,&SgAsmNERelocEntry::p_osfixup> {
  using parent = SgAsmNERelocEntry;
  using field_type = SgAsmNERelocEntry::osfixup_type;
  static constexpr size_t position{8};
  static constexpr char const * const name{"osfixup"};
  static constexpr char const * const typestr{"SgAsmNERelocEntry::osfixup_type"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNERelocEntry::p_osfixup};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocEntry, SgAsmNERelocEntry::osfixup_type SgAsmNERelocEntry::*, &SgAsmNERelocEntry::p_osfixup>;
};
template <> struct describe_node_t<SgAsmNERelocEntry> {
  using node = SgAsmNERelocEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmNERelocEntry"};
  static constexpr unsigned long variant{242};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::NERelocSrcType,&SgAsmNERelocEntry::p_src_type>, describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::NERelocModifiers,&SgAsmNERelocEntry::p_modifier>, describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::NERelocTgtType,&SgAsmNERelocEntry::p_tgt_type>, describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::NERelocFlags,&SgAsmNERelocEntry::p_flags>, describe_field_t<SgAsmNERelocEntry,Rose::BinaryAnalysis::Address,&SgAsmNERelocEntry::p_src_offset>, describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::iref_type,&SgAsmNERelocEntry::p_iref>, describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::iord_type,&SgAsmNERelocEntry::p_iord>, describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::iname_type,&SgAsmNERelocEntry::p_iname>, describe_field_t<SgAsmNERelocEntry,SgAsmNERelocEntry::osfixup_type,&SgAsmNERelocEntry::p_osfixup>>;
};
template <> struct node_from_variant_t<242> { using type = SgAsmNERelocEntry; };

// Class: AsmNERelocTable
template <> struct describe_field_t<SgAsmNERelocTable,SgAsmNERelocEntryPtrList,&SgAsmNERelocTable::p_entries> {
  using parent = SgAsmNERelocTable;
  using field_type = SgAsmNERelocEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmNERelocEntryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNERelocTable::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNERelocTable, SgAsmNERelocEntryPtrList SgAsmNERelocTable::*, &SgAsmNERelocTable::p_entries>;
};
template <> struct describe_node_t<SgAsmNERelocTable> {
  using node = SgAsmNERelocTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmNERelocTable"};
  static constexpr unsigned long variant{243};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNERelocTable,SgAsmNERelocEntryPtrList,&SgAsmNERelocTable::p_entries>>;
};
template <> struct node_from_variant_t<243> { using type = SgAsmNERelocTable; };

// Class: AsmNESection
template <> struct describe_field_t<SgAsmNESection,SgAsmNESectionTableEntry*,&SgAsmNESection::p_sectionTableEntry> {
  using parent = SgAsmNESection;
  using field_type = SgAsmNESectionTableEntry*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"sectionTableEntry"};
  static constexpr char const * const typestr{"SgAsmNESectionTableEntry*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNESection::p_sectionTableEntry};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESection, SgAsmNESectionTableEntry* SgAsmNESection::*, &SgAsmNESection::p_sectionTableEntry>;
};
template <> struct describe_field_t<SgAsmNESection,SgAsmNERelocTable*,&SgAsmNESection::p_relocationTable> {
  using parent = SgAsmNESection;
  using field_type = SgAsmNERelocTable*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"relocationTable"};
  static constexpr char const * const typestr{"SgAsmNERelocTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmNESection::p_relocationTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESection, SgAsmNERelocTable* SgAsmNESection::*, &SgAsmNESection::p_relocationTable>;
};
template <> struct describe_node_t<SgAsmNESection> {
  using node = SgAsmNESection;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmNESection"};
  static constexpr unsigned long variant{244};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNESection,SgAsmNESectionTableEntry*,&SgAsmNESection::p_sectionTableEntry>, describe_field_t<SgAsmNESection,SgAsmNERelocTable*,&SgAsmNESection::p_relocationTable>>;
};
template <> struct node_from_variant_t<244> { using type = SgAsmNESection; };

// Class: AsmNESectionTable
template <> struct describe_field_t<SgAsmNESectionTable,unsigned,&SgAsmNESectionTable::p_flags> {
  using parent = SgAsmNESectionTable;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNESectionTable::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESectionTable, unsigned SgAsmNESectionTable::*, &SgAsmNESectionTable::p_flags>;
};
template <> struct describe_field_t<SgAsmNESectionTable,unsigned,&SgAsmNESectionTable::p_sector> {
  using parent = SgAsmNESectionTable;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"sector"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNESectionTable::p_sector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESectionTable, unsigned SgAsmNESectionTable::*, &SgAsmNESectionTable::p_sector>;
};
template <> struct describe_field_t<SgAsmNESectionTable,Rose::BinaryAnalysis::Address,&SgAsmNESectionTable::p_physicalSize> {
  using parent = SgAsmNESectionTable;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{2};
  static constexpr char const * const name{"physicalSize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNESectionTable::p_physicalSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESectionTable, Rose::BinaryAnalysis::Address SgAsmNESectionTable::*, &SgAsmNESectionTable::p_physicalSize>;
};
template <> struct describe_field_t<SgAsmNESectionTable,Rose::BinaryAnalysis::Address,&SgAsmNESectionTable::p_virtualSize> {
  using parent = SgAsmNESectionTable;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{3};
  static constexpr char const * const name{"virtualSize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNESectionTable::p_virtualSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESectionTable, Rose::BinaryAnalysis::Address SgAsmNESectionTable::*, &SgAsmNESectionTable::p_virtualSize>;
};
template <> struct describe_node_t<SgAsmNESectionTable> {
  using node = SgAsmNESectionTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmNESectionTable"};
  static constexpr unsigned long variant{245};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNESectionTable,unsigned,&SgAsmNESectionTable::p_flags>, describe_field_t<SgAsmNESectionTable,unsigned,&SgAsmNESectionTable::p_sector>, describe_field_t<SgAsmNESectionTable,Rose::BinaryAnalysis::Address,&SgAsmNESectionTable::p_physicalSize>, describe_field_t<SgAsmNESectionTable,Rose::BinaryAnalysis::Address,&SgAsmNESectionTable::p_virtualSize>>;
};
template <> struct node_from_variant_t<245> { using type = SgAsmNESectionTable; };

// Class: AsmNESectionTableEntry
template <> struct describe_field_t<SgAsmNESectionTableEntry,unsigned,&SgAsmNESectionTableEntry::p_flags> {
  using parent = SgAsmNESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNESectionTableEntry::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESectionTableEntry, unsigned SgAsmNESectionTableEntry::*, &SgAsmNESectionTableEntry::p_flags>;
};
template <> struct describe_field_t<SgAsmNESectionTableEntry,unsigned,&SgAsmNESectionTableEntry::p_sector> {
  using parent = SgAsmNESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"sector"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNESectionTableEntry::p_sector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESectionTableEntry, unsigned SgAsmNESectionTableEntry::*, &SgAsmNESectionTableEntry::p_sector>;
};
template <> struct describe_field_t<SgAsmNESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmNESectionTableEntry::p_physicalSize> {
  using parent = SgAsmNESectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{2};
  static constexpr char const * const name{"physicalSize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNESectionTableEntry::p_physicalSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESectionTableEntry, Rose::BinaryAnalysis::Address SgAsmNESectionTableEntry::*, &SgAsmNESectionTableEntry::p_physicalSize>;
};
template <> struct describe_field_t<SgAsmNESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmNESectionTableEntry::p_virtualSize> {
  using parent = SgAsmNESectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{3};
  static constexpr char const * const name{"virtualSize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmNESectionTableEntry::p_virtualSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmNESectionTableEntry, Rose::BinaryAnalysis::Address SgAsmNESectionTableEntry::*, &SgAsmNESectionTableEntry::p_virtualSize>;
};
template <> struct describe_node_t<SgAsmNESectionTableEntry> {
  using node = SgAsmNESectionTableEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmNESectionTableEntry"};
  static constexpr unsigned long variant{246};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmNESectionTableEntry,unsigned,&SgAsmNESectionTableEntry::p_flags>, describe_field_t<SgAsmNESectionTableEntry,unsigned,&SgAsmNESectionTableEntry::p_sector>, describe_field_t<SgAsmNESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmNESectionTableEntry::p_physicalSize>, describe_field_t<SgAsmNESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmNESectionTableEntry::p_virtualSize>>;
};
template <> struct node_from_variant_t<246> { using type = SgAsmNESectionTableEntry; };

// Class: AsmNEStringTable
template <> struct describe_node_t<SgAsmNEStringTable> {
  using node = SgAsmNEStringTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmNEStringTable"};
  static constexpr unsigned long variant{247};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<247> { using type = SgAsmNEStringTable; };

// Class: AsmNode
template <> struct describe_node_t<SgAsmNode> {
  using node = SgAsmNode;
  using base = SgNode;
  static constexpr char const * const name{"AsmNode"};
  static constexpr unsigned long variant{248};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmCilNode, SgAsmExecutableFileFormat, SgAsmExpression, SgAsmGenericFileList, SgAsmInstructionList, SgAsmInterpretation, SgAsmInterpretationList, SgAsmJvmNode, SgAsmOperandList, SgAsmStatement, SgAsmType>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<248> { using type = SgAsmNode; };

// Class: AsmOp
template <> struct describe_field_t<SgAsmOp,SgAsmOp::asm_operand_constraint_enum,&SgAsmOp::p_constraint> {
  using parent = SgAsmOp;
  using field_type = SgAsmOp::asm_operand_constraint_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"constraint"};
  static constexpr char const * const typestr{"SgAsmOp::asm_operand_constraint_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmOp::p_constraint};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmOp, SgAsmOp::asm_operand_constraint_enum SgAsmOp::*, &SgAsmOp::p_constraint>;
};
template <> struct describe_field_t<SgAsmOp,SgAsmOp::asm_operand_modifier_enum,&SgAsmOp::p_modifiers> {
  using parent = SgAsmOp;
  using field_type = SgAsmOp::asm_operand_modifier_enum;
  static constexpr size_t position{1};
  static constexpr char const * const name{"modifiers"};
  static constexpr char const * const typestr{"SgAsmOp::asm_operand_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmOp::p_modifiers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmOp, SgAsmOp::asm_operand_modifier_enum SgAsmOp::*, &SgAsmOp::p_modifiers>;
};
template <> struct describe_field_t<SgAsmOp,SgExpression*,&SgAsmOp::p_expression> {
  using parent = SgAsmOp;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmOp::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmOp, SgExpression* SgAsmOp::*, &SgAsmOp::p_expression>;
};
template <> struct describe_field_t<SgAsmOp,bool,&SgAsmOp::p_recordRawAsmOperandDescriptions> {
  using parent = SgAsmOp;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"recordRawAsmOperandDescriptions"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmOp::p_recordRawAsmOperandDescriptions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmOp, bool SgAsmOp::*, &SgAsmOp::p_recordRawAsmOperandDescriptions>;
};
template <> struct describe_field_t<SgAsmOp,bool,&SgAsmOp::p_isOutputOperand> {
  using parent = SgAsmOp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"isOutputOperand"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmOp::p_isOutputOperand};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmOp, bool SgAsmOp::*, &SgAsmOp::p_isOutputOperand>;
};
template <> struct describe_field_t<SgAsmOp,std::string,&SgAsmOp::p_constraintString> {
  using parent = SgAsmOp;
  using field_type = std::string;
  static constexpr size_t position{5};
  static constexpr char const * const name{"constraintString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmOp::p_constraintString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmOp, std::string SgAsmOp::*, &SgAsmOp::p_constraintString>;
};
template <> struct describe_field_t<SgAsmOp,std::string,&SgAsmOp::p_name> {
  using parent = SgAsmOp;
  using field_type = std::string;
  static constexpr size_t position{6};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmOp::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmOp, std::string SgAsmOp::*, &SgAsmOp::p_name>;
};
template <> struct describe_node_t<SgAsmOp> {
  using node = SgAsmOp;
  using base = SgExpression;
  static constexpr char const * const name{"AsmOp"};
  static constexpr unsigned long variant{249};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmOp,SgAsmOp::asm_operand_constraint_enum,&SgAsmOp::p_constraint>, describe_field_t<SgAsmOp,SgAsmOp::asm_operand_modifier_enum,&SgAsmOp::p_modifiers>, describe_field_t<SgAsmOp,SgExpression*,&SgAsmOp::p_expression>, describe_field_t<SgAsmOp,bool,&SgAsmOp::p_recordRawAsmOperandDescriptions>, describe_field_t<SgAsmOp,bool,&SgAsmOp::p_isOutputOperand>, describe_field_t<SgAsmOp,std::string,&SgAsmOp::p_constraintString>, describe_field_t<SgAsmOp,std::string,&SgAsmOp::p_name>>;
};
template <> struct node_from_variant_t<249> { using type = SgAsmOp; };

// Class: AsmOperandList
template <> struct describe_field_t<SgAsmOperandList,SgAsmExpressionPtrList,&SgAsmOperandList::p_operands> {
  using parent = SgAsmOperandList;
  using field_type = SgAsmExpressionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operands"};
  static constexpr char const * const typestr{"SgAsmExpressionPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmOperandList::p_operands};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmOperandList, SgAsmExpressionPtrList SgAsmOperandList::*, &SgAsmOperandList::p_operands>;
};
template <> struct describe_node_t<SgAsmOperandList> {
  using node = SgAsmOperandList;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmOperandList"};
  static constexpr unsigned long variant{250};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmOperandList,SgAsmExpressionPtrList,&SgAsmOperandList::p_operands>>;
};
template <> struct node_from_variant_t<250> { using type = SgAsmOperandList; };

// Class: AsmPEExportDirectory
template <> struct describe_field_t<SgAsmPEExportDirectory,unsigned,&SgAsmPEExportDirectory::p_res1> {
  using parent = SgAsmPEExportDirectory;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"res1"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_res1};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, unsigned SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_res1>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,time_t,&SgAsmPEExportDirectory::p_timestamp> {
  using parent = SgAsmPEExportDirectory;
  using field_type = time_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"timestamp"};
  static constexpr char const * const typestr{"time_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_timestamp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, time_t SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_timestamp>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,unsigned,&SgAsmPEExportDirectory::p_vmajor> {
  using parent = SgAsmPEExportDirectory;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"vmajor"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_vmajor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, unsigned SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_vmajor>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,unsigned,&SgAsmPEExportDirectory::p_vminor> {
  using parent = SgAsmPEExportDirectory;
  using field_type = unsigned;
  static constexpr size_t position{3};
  static constexpr char const * const name{"vminor"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_vminor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, unsigned SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_vminor>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportDirectory::p_name_rva> {
  using parent = SgAsmPEExportDirectory;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{4};
  static constexpr char const * const name{"name_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_name_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_name_rva>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,unsigned,&SgAsmPEExportDirectory::p_ord_base> {
  using parent = SgAsmPEExportDirectory;
  using field_type = unsigned;
  static constexpr size_t position{5};
  static constexpr char const * const name{"ord_base"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_ord_base};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, unsigned SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_ord_base>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,size_t,&SgAsmPEExportDirectory::p_expaddr_n> {
  using parent = SgAsmPEExportDirectory;
  using field_type = size_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"expaddr_n"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_expaddr_n};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, size_t SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_expaddr_n>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,size_t,&SgAsmPEExportDirectory::p_nameptr_n> {
  using parent = SgAsmPEExportDirectory;
  using field_type = size_t;
  static constexpr size_t position{7};
  static constexpr char const * const name{"nameptr_n"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_nameptr_n};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, size_t SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_nameptr_n>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportDirectory::p_expaddr_rva> {
  using parent = SgAsmPEExportDirectory;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{8};
  static constexpr char const * const name{"expaddr_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_expaddr_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_expaddr_rva>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportDirectory::p_nameptr_rva> {
  using parent = SgAsmPEExportDirectory;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{9};
  static constexpr char const * const name{"nameptr_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_nameptr_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_nameptr_rva>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportDirectory::p_ordinals_rva> {
  using parent = SgAsmPEExportDirectory;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{10};
  static constexpr char const * const name{"ordinals_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_ordinals_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_ordinals_rva>;
};
template <> struct describe_field_t<SgAsmPEExportDirectory,SgAsmGenericString*,&SgAsmPEExportDirectory::p_name> {
  using parent = SgAsmPEExportDirectory;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEExportDirectory::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportDirectory, SgAsmGenericString* SgAsmPEExportDirectory::*, &SgAsmPEExportDirectory::p_name>;
};
template <> struct describe_node_t<SgAsmPEExportDirectory> {
  using node = SgAsmPEExportDirectory;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPEExportDirectory"};
  static constexpr unsigned long variant{251};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEExportDirectory,unsigned,&SgAsmPEExportDirectory::p_res1>, describe_field_t<SgAsmPEExportDirectory,time_t,&SgAsmPEExportDirectory::p_timestamp>, describe_field_t<SgAsmPEExportDirectory,unsigned,&SgAsmPEExportDirectory::p_vmajor>, describe_field_t<SgAsmPEExportDirectory,unsigned,&SgAsmPEExportDirectory::p_vminor>, describe_field_t<SgAsmPEExportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportDirectory::p_name_rva>, describe_field_t<SgAsmPEExportDirectory,unsigned,&SgAsmPEExportDirectory::p_ord_base>, describe_field_t<SgAsmPEExportDirectory,size_t,&SgAsmPEExportDirectory::p_expaddr_n>, describe_field_t<SgAsmPEExportDirectory,size_t,&SgAsmPEExportDirectory::p_nameptr_n>, describe_field_t<SgAsmPEExportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportDirectory::p_expaddr_rva>, describe_field_t<SgAsmPEExportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportDirectory::p_nameptr_rva>, describe_field_t<SgAsmPEExportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportDirectory::p_ordinals_rva>, describe_field_t<SgAsmPEExportDirectory,SgAsmGenericString*,&SgAsmPEExportDirectory::p_name>>;
};
template <> struct node_from_variant_t<251> { using type = SgAsmPEExportDirectory; };

// Class: AsmPEExportEntry
template <> struct describe_field_t<SgAsmPEExportEntry,SgAsmGenericString*,&SgAsmPEExportEntry::p_name> {
  using parent = SgAsmPEExportEntry;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEExportEntry::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportEntry, SgAsmGenericString* SgAsmPEExportEntry::*, &SgAsmPEExportEntry::p_name>;
};
template <> struct describe_field_t<SgAsmPEExportEntry,unsigned,&SgAsmPEExportEntry::p_ordinal> {
  using parent = SgAsmPEExportEntry;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"ordinal"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportEntry::p_ordinal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportEntry, unsigned SgAsmPEExportEntry::*, &SgAsmPEExportEntry::p_ordinal>;
};
template <> struct describe_field_t<SgAsmPEExportEntry,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportEntry::p_exportRva> {
  using parent = SgAsmPEExportEntry;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{2};
  static constexpr char const * const name{"exportRva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEExportEntry::p_exportRva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportEntry, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEExportEntry::*, &SgAsmPEExportEntry::p_exportRva>;
};
template <> struct describe_field_t<SgAsmPEExportEntry,SgAsmGenericString*,&SgAsmPEExportEntry::p_forwarder> {
  using parent = SgAsmPEExportEntry;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"forwarder"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEExportEntry::p_forwarder};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportEntry, SgAsmGenericString* SgAsmPEExportEntry::*, &SgAsmPEExportEntry::p_forwarder>;
};
template <> struct describe_node_t<SgAsmPEExportEntry> {
  using node = SgAsmPEExportEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPEExportEntry"};
  static constexpr unsigned long variant{252};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEExportEntry,SgAsmGenericString*,&SgAsmPEExportEntry::p_name>, describe_field_t<SgAsmPEExportEntry,unsigned,&SgAsmPEExportEntry::p_ordinal>, describe_field_t<SgAsmPEExportEntry,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEExportEntry::p_exportRva>, describe_field_t<SgAsmPEExportEntry,SgAsmGenericString*,&SgAsmPEExportEntry::p_forwarder>>;
};
template <> struct node_from_variant_t<252> { using type = SgAsmPEExportEntry; };

// Class: AsmPEExportEntryList
template <> struct describe_field_t<SgAsmPEExportEntryList,SgAsmPEExportEntryPtrList,&SgAsmPEExportEntryList::p_exports> {
  using parent = SgAsmPEExportEntryList;
  using field_type = SgAsmPEExportEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"exports"};
  static constexpr char const * const typestr{"SgAsmPEExportEntryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEExportEntryList::p_exports};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportEntryList, SgAsmPEExportEntryPtrList SgAsmPEExportEntryList::*, &SgAsmPEExportEntryList::p_exports>;
};
template <> struct describe_node_t<SgAsmPEExportEntryList> {
  using node = SgAsmPEExportEntryList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPEExportEntryList"};
  static constexpr unsigned long variant{253};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEExportEntryList,SgAsmPEExportEntryPtrList,&SgAsmPEExportEntryList::p_exports>>;
};
template <> struct node_from_variant_t<253> { using type = SgAsmPEExportEntryList; };

// Class: AsmPEExportSection
template <> struct describe_field_t<SgAsmPEExportSection,SgAsmPEExportDirectory*,&SgAsmPEExportSection::p_exportDirectory> {
  using parent = SgAsmPEExportSection;
  using field_type = SgAsmPEExportDirectory*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"exportDirectory"};
  static constexpr char const * const typestr{"SgAsmPEExportDirectory*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEExportSection::p_exportDirectory};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportSection, SgAsmPEExportDirectory* SgAsmPEExportSection::*, &SgAsmPEExportSection::p_exportDirectory>;
};
template <> struct describe_field_t<SgAsmPEExportSection,SgAsmPEExportEntryList*,&SgAsmPEExportSection::p_exports> {
  using parent = SgAsmPEExportSection;
  using field_type = SgAsmPEExportEntryList*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"exports"};
  static constexpr char const * const typestr{"SgAsmPEExportEntryList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEExportSection::p_exports};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEExportSection, SgAsmPEExportEntryList* SgAsmPEExportSection::*, &SgAsmPEExportSection::p_exports>;
};
template <> struct describe_node_t<SgAsmPEExportSection> {
  using node = SgAsmPEExportSection;
  using base = SgAsmPESection;
  static constexpr char const * const name{"AsmPEExportSection"};
  static constexpr unsigned long variant{254};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEExportSection,SgAsmPEExportDirectory*,&SgAsmPEExportSection::p_exportDirectory>, describe_field_t<SgAsmPEExportSection,SgAsmPEExportEntryList*,&SgAsmPEExportSection::p_exports>>;
};
template <> struct node_from_variant_t<254> { using type = SgAsmPEExportSection; };

// Class: AsmPEFileHeader
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_cpu_type> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"e_cpu_type"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_cpu_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_cpu_type>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_nsections> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"e_nsections"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_nsections};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_nsections>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_time> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"e_time"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_time};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_time>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmPEFileHeader::p_e_coff_symtab> {
  using parent = SgAsmPEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{3};
  static constexpr char const * const name{"e_coff_symtab"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_coff_symtab};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, Rose::BinaryAnalysis::Address SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_coff_symtab>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmPEFileHeader::p_e_nt_hdr_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{4};
  static constexpr char const * const name{"e_nt_hdr_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_nt_hdr_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, Rose::BinaryAnalysis::Address SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_nt_hdr_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_coff_nsyms> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{5};
  static constexpr char const * const name{"e_coff_nsyms"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_coff_nsyms};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_coff_nsyms>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_flags> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{6};
  static constexpr char const * const name{"e_flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_flags>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_opt_magic> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{7};
  static constexpr char const * const name{"e_opt_magic"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_opt_magic};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_opt_magic>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_lmajor> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{8};
  static constexpr char const * const name{"e_lmajor"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_lmajor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_lmajor>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_lminor> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{9};
  static constexpr char const * const name{"e_lminor"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_lminor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_lminor>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_code_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{10};
  static constexpr char const * const name{"e_code_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_code_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_code_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_data_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{11};
  static constexpr char const * const name{"e_data_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_data_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_data_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_bss_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{12};
  static constexpr char const * const name{"e_bss_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_bss_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_bss_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEFileHeader::p_e_code_rva> {
  using parent = SgAsmPEFileHeader;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{13};
  static constexpr char const * const name{"e_code_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_code_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_code_rva>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEFileHeader::p_e_data_rva> {
  using parent = SgAsmPEFileHeader;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{14};
  static constexpr char const * const name{"e_data_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_data_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_data_rva>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_section_align> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{15};
  static constexpr char const * const name{"e_section_align"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_section_align};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_section_align>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_file_align> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{16};
  static constexpr char const * const name{"e_file_align"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_file_align};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_file_align>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_os_major> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{17};
  static constexpr char const * const name{"e_os_major"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_os_major};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_os_major>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_os_minor> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{18};
  static constexpr char const * const name{"e_os_minor"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_os_minor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_os_minor>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_user_major> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{19};
  static constexpr char const * const name{"e_user_major"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_user_major};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_user_major>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_user_minor> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{20};
  static constexpr char const * const name{"e_user_minor"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_user_minor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_user_minor>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_subsys_major> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{21};
  static constexpr char const * const name{"e_subsys_major"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_subsys_major};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_subsys_major>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_subsys_minor> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{22};
  static constexpr char const * const name{"e_subsys_minor"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_subsys_minor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_subsys_minor>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_reserved9> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{23};
  static constexpr char const * const name{"e_reserved9"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_reserved9};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_reserved9>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_image_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{24};
  static constexpr char const * const name{"e_image_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_image_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_image_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_header_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{25};
  static constexpr char const * const name{"e_header_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_header_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_header_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_file_checksum> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{26};
  static constexpr char const * const name{"e_file_checksum"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_file_checksum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_file_checksum>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_subsystem> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{27};
  static constexpr char const * const name{"e_subsystem"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_subsystem};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_subsystem>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_dll_flags> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{28};
  static constexpr char const * const name{"e_dll_flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_dll_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_dll_flags>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_stack_reserve_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{29};
  static constexpr char const * const name{"e_stack_reserve_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_stack_reserve_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_stack_reserve_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_stack_commit_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{30};
  static constexpr char const * const name{"e_stack_commit_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_stack_commit_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_stack_commit_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_heap_reserve_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{31};
  static constexpr char const * const name{"e_heap_reserve_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_heap_reserve_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_heap_reserve_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_heap_commit_size> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{32};
  static constexpr char const * const name{"e_heap_commit_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_heap_commit_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_heap_commit_size>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_loader_flags> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{33};
  static constexpr char const * const name{"e_loader_flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_loader_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_loader_flags>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_num_rvasize_pairs> {
  using parent = SgAsmPEFileHeader;
  using field_type = unsigned;
  static constexpr size_t position{34};
  static constexpr char const * const name{"e_num_rvasize_pairs"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_e_num_rvasize_pairs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, unsigned SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_e_num_rvasize_pairs>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,SgAsmPERVASizePairList*,&SgAsmPEFileHeader::p_rvaSizePairs> {
  using parent = SgAsmPEFileHeader;
  using field_type = SgAsmPERVASizePairList*;
  static constexpr size_t position{35};
  static constexpr char const * const name{"rvaSizePairs"};
  static constexpr char const * const typestr{"SgAsmPERVASizePairList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_rvaSizePairs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, SgAsmPERVASizePairList* SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_rvaSizePairs>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,SgAsmPESectionTable*,&SgAsmPEFileHeader::p_sectionTable> {
  using parent = SgAsmPEFileHeader;
  using field_type = SgAsmPESectionTable*;
  static constexpr size_t position{36};
  static constexpr char const * const name{"sectionTable"};
  static constexpr char const * const typestr{"SgAsmPESectionTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_sectionTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, SgAsmPESectionTable* SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_sectionTable>;
};
template <> struct describe_field_t<SgAsmPEFileHeader,SgAsmCoffSymbolTable*,&SgAsmPEFileHeader::p_coffSymbolTable> {
  using parent = SgAsmPEFileHeader;
  using field_type = SgAsmCoffSymbolTable*;
  static constexpr size_t position{37};
  static constexpr char const * const name{"coffSymbolTable"};
  static constexpr char const * const typestr{"SgAsmCoffSymbolTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEFileHeader::p_coffSymbolTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEFileHeader, SgAsmCoffSymbolTable* SgAsmPEFileHeader::*, &SgAsmPEFileHeader::p_coffSymbolTable>;
};
template <> struct describe_node_t<SgAsmPEFileHeader> {
  using node = SgAsmPEFileHeader;
  using base = SgAsmGenericHeader;
  static constexpr char const * const name{"AsmPEFileHeader"};
  static constexpr unsigned long variant{255};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_cpu_type>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_nsections>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_time>, describe_field_t<SgAsmPEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmPEFileHeader::p_e_coff_symtab>, describe_field_t<SgAsmPEFileHeader,Rose::BinaryAnalysis::Address,&SgAsmPEFileHeader::p_e_nt_hdr_size>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_coff_nsyms>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_flags>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_opt_magic>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_lmajor>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_lminor>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_code_size>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_data_size>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_bss_size>, describe_field_t<SgAsmPEFileHeader,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEFileHeader::p_e_code_rva>, describe_field_t<SgAsmPEFileHeader,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEFileHeader::p_e_data_rva>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_section_align>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_file_align>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_os_major>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_os_minor>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_user_major>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_user_minor>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_subsys_major>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_subsys_minor>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_reserved9>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_image_size>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_header_size>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_file_checksum>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_subsystem>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_dll_flags>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_stack_reserve_size>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_stack_commit_size>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_heap_reserve_size>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_heap_commit_size>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_loader_flags>, describe_field_t<SgAsmPEFileHeader,unsigned,&SgAsmPEFileHeader::p_e_num_rvasize_pairs>, describe_field_t<SgAsmPEFileHeader,SgAsmPERVASizePairList*,&SgAsmPEFileHeader::p_rvaSizePairs>, describe_field_t<SgAsmPEFileHeader,SgAsmPESectionTable*,&SgAsmPEFileHeader::p_sectionTable>, describe_field_t<SgAsmPEFileHeader,SgAsmCoffSymbolTable*,&SgAsmPEFileHeader::p_coffSymbolTable>>;
};
template <> struct node_from_variant_t<255> { using type = SgAsmPEFileHeader; };

// Class: AsmPEImportDirectory
template <> struct describe_field_t<SgAsmPEImportDirectory,SgAsmGenericString*,&SgAsmPEImportDirectory::p_dllName> {
  using parent = SgAsmPEImportDirectory;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"dllName"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_dllName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, SgAsmGenericString* SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_dllName>;
};
template <> struct describe_field_t<SgAsmPEImportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportDirectory::p_dllNameRva> {
  using parent = SgAsmPEImportDirectory;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{1};
  static constexpr char const * const name{"dllNameRva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_dllNameRva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_dllNameRva>;
};
template <> struct describe_field_t<SgAsmPEImportDirectory,size_t,&SgAsmPEImportDirectory::p_dll_name_nalloc> {
  using parent = SgAsmPEImportDirectory;
  using field_type = size_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"dll_name_nalloc"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_dll_name_nalloc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, size_t SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_dll_name_nalloc>;
};
template <> struct describe_field_t<SgAsmPEImportDirectory,time_t,&SgAsmPEImportDirectory::p_time> {
  using parent = SgAsmPEImportDirectory;
  using field_type = time_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"time"};
  static constexpr char const * const typestr{"time_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_time};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, time_t SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_time>;
};
template <> struct describe_field_t<SgAsmPEImportDirectory,unsigned,&SgAsmPEImportDirectory::p_forwarder_chain> {
  using parent = SgAsmPEImportDirectory;
  using field_type = unsigned;
  static constexpr size_t position{4};
  static constexpr char const * const name{"forwarder_chain"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_forwarder_chain};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, unsigned SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_forwarder_chain>;
};
template <> struct describe_field_t<SgAsmPEImportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportDirectory::p_ilt_rva> {
  using parent = SgAsmPEImportDirectory;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{5};
  static constexpr char const * const name{"ilt_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_ilt_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_ilt_rva>;
};
template <> struct describe_field_t<SgAsmPEImportDirectory,size_t,&SgAsmPEImportDirectory::p_ilt_nalloc> {
  using parent = SgAsmPEImportDirectory;
  using field_type = size_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"ilt_nalloc"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_ilt_nalloc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, size_t SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_ilt_nalloc>;
};
template <> struct describe_field_t<SgAsmPEImportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportDirectory::p_iat_rva> {
  using parent = SgAsmPEImportDirectory;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{7};
  static constexpr char const * const name{"iat_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_iat_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_iat_rva>;
};
template <> struct describe_field_t<SgAsmPEImportDirectory,size_t,&SgAsmPEImportDirectory::p_iat_nalloc> {
  using parent = SgAsmPEImportDirectory;
  using field_type = size_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"iat_nalloc"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_iat_nalloc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, size_t SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_iat_nalloc>;
};
template <> struct describe_field_t<SgAsmPEImportDirectory,SgAsmPEImportItemList*,&SgAsmPEImportDirectory::p_imports> {
  using parent = SgAsmPEImportDirectory;
  using field_type = SgAsmPEImportItemList*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"imports"};
  static constexpr char const * const typestr{"SgAsmPEImportItemList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectory::p_imports};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectory, SgAsmPEImportItemList* SgAsmPEImportDirectory::*, &SgAsmPEImportDirectory::p_imports>;
};
template <> struct describe_node_t<SgAsmPEImportDirectory> {
  using node = SgAsmPEImportDirectory;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPEImportDirectory"};
  static constexpr unsigned long variant{256};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEImportDirectory,SgAsmGenericString*,&SgAsmPEImportDirectory::p_dllName>, describe_field_t<SgAsmPEImportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportDirectory::p_dllNameRva>, describe_field_t<SgAsmPEImportDirectory,size_t,&SgAsmPEImportDirectory::p_dll_name_nalloc>, describe_field_t<SgAsmPEImportDirectory,time_t,&SgAsmPEImportDirectory::p_time>, describe_field_t<SgAsmPEImportDirectory,unsigned,&SgAsmPEImportDirectory::p_forwarder_chain>, describe_field_t<SgAsmPEImportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportDirectory::p_ilt_rva>, describe_field_t<SgAsmPEImportDirectory,size_t,&SgAsmPEImportDirectory::p_ilt_nalloc>, describe_field_t<SgAsmPEImportDirectory,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportDirectory::p_iat_rva>, describe_field_t<SgAsmPEImportDirectory,size_t,&SgAsmPEImportDirectory::p_iat_nalloc>, describe_field_t<SgAsmPEImportDirectory,SgAsmPEImportItemList*,&SgAsmPEImportDirectory::p_imports>>;
};
template <> struct node_from_variant_t<256> { using type = SgAsmPEImportDirectory; };

// Class: AsmPEImportDirectoryList
template <> struct describe_field_t<SgAsmPEImportDirectoryList,SgAsmPEImportDirectoryPtrList,&SgAsmPEImportDirectoryList::p_vector> {
  using parent = SgAsmPEImportDirectoryList;
  using field_type = SgAsmPEImportDirectoryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"vector"};
  static constexpr char const * const typestr{"SgAsmPEImportDirectoryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEImportDirectoryList::p_vector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportDirectoryList, SgAsmPEImportDirectoryPtrList SgAsmPEImportDirectoryList::*, &SgAsmPEImportDirectoryList::p_vector>;
};
template <> struct describe_node_t<SgAsmPEImportDirectoryList> {
  using node = SgAsmPEImportDirectoryList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPEImportDirectoryList"};
  static constexpr unsigned long variant{257};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEImportDirectoryList,SgAsmPEImportDirectoryPtrList,&SgAsmPEImportDirectoryList::p_vector>>;
};
template <> struct node_from_variant_t<257> { using type = SgAsmPEImportDirectoryList; };

// Class: AsmPEImportItem
template <> struct describe_field_t<SgAsmPEImportItem,bool,&SgAsmPEImportItem::p_by_ordinal> {
  using parent = SgAsmPEImportItem;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"by_ordinal"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportItem::p_by_ordinal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportItem, bool SgAsmPEImportItem::*, &SgAsmPEImportItem::p_by_ordinal>;
};
template <> struct describe_field_t<SgAsmPEImportItem,unsigned,&SgAsmPEImportItem::p_ordinal> {
  using parent = SgAsmPEImportItem;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"ordinal"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportItem::p_ordinal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportItem, unsigned SgAsmPEImportItem::*, &SgAsmPEImportItem::p_ordinal>;
};
template <> struct describe_field_t<SgAsmPEImportItem,unsigned,&SgAsmPEImportItem::p_hint> {
  using parent = SgAsmPEImportItem;
  using field_type = unsigned;
  static constexpr size_t position{2};
  static constexpr char const * const name{"hint"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportItem::p_hint};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportItem, unsigned SgAsmPEImportItem::*, &SgAsmPEImportItem::p_hint>;
};
template <> struct describe_field_t<SgAsmPEImportItem,SgAsmGenericString*,&SgAsmPEImportItem::p_name> {
  using parent = SgAsmPEImportItem;
  using field_type = SgAsmGenericString*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgAsmGenericString*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEImportItem::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportItem, SgAsmGenericString* SgAsmPEImportItem::*, &SgAsmPEImportItem::p_name>;
};
template <> struct describe_field_t<SgAsmPEImportItem,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportItem::p_hintname_rva> {
  using parent = SgAsmPEImportItem;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{4};
  static constexpr char const * const name{"hintname_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportItem::p_hintname_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportItem, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEImportItem::*, &SgAsmPEImportItem::p_hintname_rva>;
};
template <> struct describe_field_t<SgAsmPEImportItem,size_t,&SgAsmPEImportItem::p_hintname_nalloc> {
  using parent = SgAsmPEImportItem;
  using field_type = size_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"hintname_nalloc"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportItem::p_hintname_nalloc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportItem, size_t SgAsmPEImportItem::*, &SgAsmPEImportItem::p_hintname_nalloc>;
};
template <> struct describe_field_t<SgAsmPEImportItem,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportItem::p_bound_rva> {
  using parent = SgAsmPEImportItem;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{6};
  static constexpr char const * const name{"bound_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportItem::p_bound_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportItem, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPEImportItem::*, &SgAsmPEImportItem::p_bound_rva>;
};
template <> struct describe_field_t<SgAsmPEImportItem,bool,&SgAsmPEImportItem::p_iat_written> {
  using parent = SgAsmPEImportItem;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"iat_written"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEImportItem::p_iat_written};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportItem, bool SgAsmPEImportItem::*, &SgAsmPEImportItem::p_iat_written>;
};
template <> struct describe_node_t<SgAsmPEImportItem> {
  using node = SgAsmPEImportItem;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPEImportItem"};
  static constexpr unsigned long variant{258};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEImportItem,bool,&SgAsmPEImportItem::p_by_ordinal>, describe_field_t<SgAsmPEImportItem,unsigned,&SgAsmPEImportItem::p_ordinal>, describe_field_t<SgAsmPEImportItem,unsigned,&SgAsmPEImportItem::p_hint>, describe_field_t<SgAsmPEImportItem,SgAsmGenericString*,&SgAsmPEImportItem::p_name>, describe_field_t<SgAsmPEImportItem,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportItem::p_hintname_rva>, describe_field_t<SgAsmPEImportItem,size_t,&SgAsmPEImportItem::p_hintname_nalloc>, describe_field_t<SgAsmPEImportItem,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPEImportItem::p_bound_rva>, describe_field_t<SgAsmPEImportItem,bool,&SgAsmPEImportItem::p_iat_written>>;
};
template <> struct node_from_variant_t<258> { using type = SgAsmPEImportItem; };

// Class: AsmPEImportItemList
template <> struct describe_field_t<SgAsmPEImportItemList,SgAsmPEImportItemPtrList,&SgAsmPEImportItemList::p_vector> {
  using parent = SgAsmPEImportItemList;
  using field_type = SgAsmPEImportItemPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"vector"};
  static constexpr char const * const typestr{"SgAsmPEImportItemPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEImportItemList::p_vector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportItemList, SgAsmPEImportItemPtrList SgAsmPEImportItemList::*, &SgAsmPEImportItemList::p_vector>;
};
template <> struct describe_node_t<SgAsmPEImportItemList> {
  using node = SgAsmPEImportItemList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPEImportItemList"};
  static constexpr unsigned long variant{259};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEImportItemList,SgAsmPEImportItemPtrList,&SgAsmPEImportItemList::p_vector>>;
};
template <> struct node_from_variant_t<259> { using type = SgAsmPEImportItemList; };

// Class: AsmPEImportSection
template <> struct describe_field_t<SgAsmPEImportSection,SgAsmPEImportDirectoryList*,&SgAsmPEImportSection::p_importDirectories> {
  using parent = SgAsmPEImportSection;
  using field_type = SgAsmPEImportDirectoryList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"importDirectories"};
  static constexpr char const * const typestr{"SgAsmPEImportDirectoryList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPEImportSection::p_importDirectories};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEImportSection, SgAsmPEImportDirectoryList* SgAsmPEImportSection::*, &SgAsmPEImportSection::p_importDirectories>;
};
template <> struct describe_node_t<SgAsmPEImportSection> {
  using node = SgAsmPEImportSection;
  using base = SgAsmPESection;
  static constexpr char const * const name{"AsmPEImportSection"};
  static constexpr unsigned long variant{260};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEImportSection,SgAsmPEImportDirectoryList*,&SgAsmPEImportSection::p_importDirectories>>;
};
template <> struct node_from_variant_t<260> { using type = SgAsmPEImportSection; };

// Class: AsmPERVASizePair
template <> struct describe_field_t<SgAsmPERVASizePair,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPERVASizePair::p_e_rva> {
  using parent = SgAsmPERVASizePair;
  using field_type = Rose::BinaryAnalysis::RelativeVirtualAddress;
  static constexpr size_t position{0};
  static constexpr char const * const name{"e_rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RelativeVirtualAddress"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPERVASizePair::p_e_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPERVASizePair, Rose::BinaryAnalysis::RelativeVirtualAddress SgAsmPERVASizePair::*, &SgAsmPERVASizePair::p_e_rva>;
};
template <> struct describe_field_t<SgAsmPERVASizePair,Rose::BinaryAnalysis::Address,&SgAsmPERVASizePair::p_e_size> {
  using parent = SgAsmPERVASizePair;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{1};
  static constexpr char const * const name{"e_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPERVASizePair::p_e_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPERVASizePair, Rose::BinaryAnalysis::Address SgAsmPERVASizePair::*, &SgAsmPERVASizePair::p_e_size>;
};
template <> struct describe_field_t<SgAsmPERVASizePair,SgAsmGenericSection*,&SgAsmPERVASizePair::p_section> {
  using parent = SgAsmPERVASizePair;
  using field_type = SgAsmGenericSection*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"section"};
  static constexpr char const * const typestr{"SgAsmGenericSection*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPERVASizePair::p_section};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPERVASizePair, SgAsmGenericSection* SgAsmPERVASizePair::*, &SgAsmPERVASizePair::p_section>;
};
template <> struct describe_node_t<SgAsmPERVASizePair> {
  using node = SgAsmPERVASizePair;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPERVASizePair"};
  static constexpr unsigned long variant{261};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPERVASizePair,Rose::BinaryAnalysis::RelativeVirtualAddress,&SgAsmPERVASizePair::p_e_rva>, describe_field_t<SgAsmPERVASizePair,Rose::BinaryAnalysis::Address,&SgAsmPERVASizePair::p_e_size>, describe_field_t<SgAsmPERVASizePair,SgAsmGenericSection*,&SgAsmPERVASizePair::p_section>>;
};
template <> struct node_from_variant_t<261> { using type = SgAsmPERVASizePair; };

// Class: AsmPERVASizePairList
template <> struct describe_field_t<SgAsmPERVASizePairList,SgAsmPERVASizePairPtrList,&SgAsmPERVASizePairList::p_pairs> {
  using parent = SgAsmPERVASizePairList;
  using field_type = SgAsmPERVASizePairPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"pairs"};
  static constexpr char const * const typestr{"SgAsmPERVASizePairPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPERVASizePairList::p_pairs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPERVASizePairList, SgAsmPERVASizePairPtrList SgAsmPERVASizePairList::*, &SgAsmPERVASizePairList::p_pairs>;
};
template <> struct describe_node_t<SgAsmPERVASizePairList> {
  using node = SgAsmPERVASizePairList;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPERVASizePairList"};
  static constexpr unsigned long variant{262};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPERVASizePairList,SgAsmPERVASizePairPtrList,&SgAsmPERVASizePairList::p_pairs>>;
};
template <> struct node_from_variant_t<262> { using type = SgAsmPERVASizePairList; };

// Class: AsmPESection
template <> struct describe_field_t<SgAsmPESection,SgAsmPESectionTableEntry*,&SgAsmPESection::p_section_entry> {
  using parent = SgAsmPESection;
  using field_type = SgAsmPESectionTableEntry*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"section_entry"};
  static constexpr char const * const typestr{"SgAsmPESectionTableEntry*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPESection::p_section_entry};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESection, SgAsmPESectionTableEntry* SgAsmPESection::*, &SgAsmPESection::p_section_entry>;
};
template <> struct describe_node_t<SgAsmPESection> {
  using node = SgAsmPESection;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmPESection"};
  static constexpr unsigned long variant{263};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgAsmPEExportSection, SgAsmPEImportSection, SgAsmPEStringSection>;
  using fields_t = mp::List<describe_field_t<SgAsmPESection,SgAsmPESectionTableEntry*,&SgAsmPESection::p_section_entry>>;
};
template <> struct node_from_variant_t<263> { using type = SgAsmPESection; };

// Class: AsmPESectionTable
template <> struct describe_node_t<SgAsmPESectionTable> {
  using node = SgAsmPESectionTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmPESectionTable"};
  static constexpr unsigned long variant{264};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<264> { using type = SgAsmPESectionTable; };

// Class: AsmPESectionTableEntry
template <> struct describe_field_t<SgAsmPESectionTableEntry,std::string,&SgAsmPESectionTableEntry::p_name> {
  using parent = SgAsmPESectionTableEntry;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPESectionTableEntry::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESectionTableEntry, std::string SgAsmPESectionTableEntry::*, &SgAsmPESectionTableEntry::p_name>;
};
template <> struct describe_field_t<SgAsmPESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmPESectionTableEntry::p_virtual_size> {
  using parent = SgAsmPESectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{1};
  static constexpr char const * const name{"virtual_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPESectionTableEntry::p_virtual_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESectionTableEntry, Rose::BinaryAnalysis::Address SgAsmPESectionTableEntry::*, &SgAsmPESectionTableEntry::p_virtual_size>;
};
template <> struct describe_field_t<SgAsmPESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmPESectionTableEntry::p_rva> {
  using parent = SgAsmPESectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{2};
  static constexpr char const * const name{"rva"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPESectionTableEntry::p_rva};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESectionTableEntry, Rose::BinaryAnalysis::Address SgAsmPESectionTableEntry::*, &SgAsmPESectionTableEntry::p_rva>;
};
template <> struct describe_field_t<SgAsmPESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmPESectionTableEntry::p_physical_size> {
  using parent = SgAsmPESectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{3};
  static constexpr char const * const name{"physical_size"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPESectionTableEntry::p_physical_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESectionTableEntry, Rose::BinaryAnalysis::Address SgAsmPESectionTableEntry::*, &SgAsmPESectionTableEntry::p_physical_size>;
};
template <> struct describe_field_t<SgAsmPESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmPESectionTableEntry::p_physical_offset> {
  using parent = SgAsmPESectionTableEntry;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{4};
  static constexpr char const * const name{"physical_offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPESectionTableEntry::p_physical_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESectionTableEntry, Rose::BinaryAnalysis::Address SgAsmPESectionTableEntry::*, &SgAsmPESectionTableEntry::p_physical_offset>;
};
template <> struct describe_field_t<SgAsmPESectionTableEntry,unsigned,&SgAsmPESectionTableEntry::p_coff_line_nums> {
  using parent = SgAsmPESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{5};
  static constexpr char const * const name{"coff_line_nums"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPESectionTableEntry::p_coff_line_nums};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESectionTableEntry, unsigned SgAsmPESectionTableEntry::*, &SgAsmPESectionTableEntry::p_coff_line_nums>;
};
template <> struct describe_field_t<SgAsmPESectionTableEntry,unsigned,&SgAsmPESectionTableEntry::p_n_relocs> {
  using parent = SgAsmPESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{6};
  static constexpr char const * const name{"n_relocs"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPESectionTableEntry::p_n_relocs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESectionTableEntry, unsigned SgAsmPESectionTableEntry::*, &SgAsmPESectionTableEntry::p_n_relocs>;
};
template <> struct describe_field_t<SgAsmPESectionTableEntry,unsigned,&SgAsmPESectionTableEntry::p_n_coff_line_nums> {
  using parent = SgAsmPESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{7};
  static constexpr char const * const name{"n_coff_line_nums"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPESectionTableEntry::p_n_coff_line_nums};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESectionTableEntry, unsigned SgAsmPESectionTableEntry::*, &SgAsmPESectionTableEntry::p_n_coff_line_nums>;
};
template <> struct describe_field_t<SgAsmPESectionTableEntry,unsigned,&SgAsmPESectionTableEntry::p_flags> {
  using parent = SgAsmPESectionTableEntry;
  using field_type = unsigned;
  static constexpr size_t position{8};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPESectionTableEntry::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPESectionTableEntry, unsigned SgAsmPESectionTableEntry::*, &SgAsmPESectionTableEntry::p_flags>;
};
template <> struct describe_node_t<SgAsmPESectionTableEntry> {
  using node = SgAsmPESectionTableEntry;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmPESectionTableEntry"};
  static constexpr unsigned long variant{265};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPESectionTableEntry,std::string,&SgAsmPESectionTableEntry::p_name>, describe_field_t<SgAsmPESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmPESectionTableEntry::p_virtual_size>, describe_field_t<SgAsmPESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmPESectionTableEntry::p_rva>, describe_field_t<SgAsmPESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmPESectionTableEntry::p_physical_size>, describe_field_t<SgAsmPESectionTableEntry,Rose::BinaryAnalysis::Address,&SgAsmPESectionTableEntry::p_physical_offset>, describe_field_t<SgAsmPESectionTableEntry,unsigned,&SgAsmPESectionTableEntry::p_coff_line_nums>, describe_field_t<SgAsmPESectionTableEntry,unsigned,&SgAsmPESectionTableEntry::p_n_relocs>, describe_field_t<SgAsmPESectionTableEntry,unsigned,&SgAsmPESectionTableEntry::p_n_coff_line_nums>, describe_field_t<SgAsmPESectionTableEntry,unsigned,&SgAsmPESectionTableEntry::p_flags>>;
};
template <> struct node_from_variant_t<265> { using type = SgAsmPESectionTableEntry; };

// Class: AsmPEStringSection
template <> struct describe_field_t<SgAsmPEStringSection,SgAsmCoffStrtab*,&SgAsmPEStringSection::p_strtab> {
  using parent = SgAsmPEStringSection;
  using field_type = SgAsmCoffStrtab*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"strtab"};
  static constexpr char const * const typestr{"SgAsmCoffStrtab*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPEStringSection::p_strtab};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPEStringSection, SgAsmCoffStrtab* SgAsmPEStringSection::*, &SgAsmPEStringSection::p_strtab>;
};
template <> struct describe_node_t<SgAsmPEStringSection> {
  using node = SgAsmPEStringSection;
  using base = SgAsmPESection;
  static constexpr char const * const name{"AsmPEStringSection"};
  static constexpr unsigned long variant{266};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPEStringSection,SgAsmCoffStrtab*,&SgAsmPEStringSection::p_strtab>>;
};
template <> struct node_from_variant_t<266> { using type = SgAsmPEStringSection; };

// Class: AsmPowerpcInstruction
template <> struct describe_field_t<SgAsmPowerpcInstruction,Rose::BinaryAnalysis::PowerpcInstructionKind,&SgAsmPowerpcInstruction::p_kind> {
  using parent = SgAsmPowerpcInstruction;
  using field_type = Rose::BinaryAnalysis::PowerpcInstructionKind;
  static constexpr size_t position{0};
  static constexpr char const * const name{"kind"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::PowerpcInstructionKind"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmPowerpcInstruction::p_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPowerpcInstruction, Rose::BinaryAnalysis::PowerpcInstructionKind SgAsmPowerpcInstruction::*, &SgAsmPowerpcInstruction::p_kind>;
};
template <> struct describe_node_t<SgAsmPowerpcInstruction> {
  using node = SgAsmPowerpcInstruction;
  using base = SgAsmInstruction;
  static constexpr char const * const name{"AsmPowerpcInstruction"};
  static constexpr unsigned long variant{267};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPowerpcInstruction,Rose::BinaryAnalysis::PowerpcInstructionKind,&SgAsmPowerpcInstruction::p_kind>>;
};
template <> struct node_from_variant_t<267> { using type = SgAsmPowerpcInstruction; };

// Class: AsmRegisterNames
template <> struct describe_field_t<SgAsmRegisterNames,SgAsmRegisterReferenceExpressionPtrList,&SgAsmRegisterNames::p_registers> {
  using parent = SgAsmRegisterNames;
  using field_type = SgAsmRegisterReferenceExpressionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"registers"};
  static constexpr char const * const typestr{"SgAsmRegisterReferenceExpressionPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmRegisterNames::p_registers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmRegisterNames, SgAsmRegisterReferenceExpressionPtrList SgAsmRegisterNames::*, &SgAsmRegisterNames::p_registers>;
};
template <> struct describe_field_t<SgAsmRegisterNames,unsigned,&SgAsmRegisterNames::p_mask> {
  using parent = SgAsmRegisterNames;
  using field_type = unsigned;
  static constexpr size_t position{1};
  static constexpr char const * const name{"mask"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmRegisterNames::p_mask};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmRegisterNames, unsigned SgAsmRegisterNames::*, &SgAsmRegisterNames::p_mask>;
};
template <> struct describe_node_t<SgAsmRegisterNames> {
  using node = SgAsmRegisterNames;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmRegisterNames"};
  static constexpr unsigned long variant{268};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmRegisterNames,SgAsmRegisterReferenceExpressionPtrList,&SgAsmRegisterNames::p_registers>, describe_field_t<SgAsmRegisterNames,unsigned,&SgAsmRegisterNames::p_mask>>;
};
template <> struct node_from_variant_t<268> { using type = SgAsmRegisterNames; };

// Class: AsmRegisterReferenceExpression
template <> struct describe_field_t<SgAsmRegisterReferenceExpression,Rose::BinaryAnalysis::RegisterDescriptor,&SgAsmRegisterReferenceExpression::p_descriptor> {
  using parent = SgAsmRegisterReferenceExpression;
  using field_type = Rose::BinaryAnalysis::RegisterDescriptor;
  static constexpr size_t position{0};
  static constexpr char const * const name{"descriptor"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::RegisterDescriptor"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmRegisterReferenceExpression::p_descriptor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmRegisterReferenceExpression, Rose::BinaryAnalysis::RegisterDescriptor SgAsmRegisterReferenceExpression::*, &SgAsmRegisterReferenceExpression::p_descriptor>;
};
template <> struct describe_field_t<SgAsmRegisterReferenceExpression,int,&SgAsmRegisterReferenceExpression::p_adjustment> {
  using parent = SgAsmRegisterReferenceExpression;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"adjustment"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmRegisterReferenceExpression::p_adjustment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmRegisterReferenceExpression, int SgAsmRegisterReferenceExpression::*, &SgAsmRegisterReferenceExpression::p_adjustment>;
};
template <> struct describe_node_t<SgAsmRegisterReferenceExpression> {
  using node = SgAsmRegisterReferenceExpression;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmRegisterReferenceExpression"};
  static constexpr unsigned long variant{269};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmDirectRegisterExpression, SgAsmIndirectRegisterExpression>;
  using fields_t = mp::List<describe_field_t<SgAsmRegisterReferenceExpression,Rose::BinaryAnalysis::RegisterDescriptor,&SgAsmRegisterReferenceExpression::p_descriptor>, describe_field_t<SgAsmRegisterReferenceExpression,int,&SgAsmRegisterReferenceExpression::p_adjustment>>;
};
template <> struct node_from_variant_t<269> { using type = SgAsmRegisterReferenceExpression; };

// Class: AsmRiscOperation
template <> struct describe_field_t<SgAsmRiscOperation,SgAsmRiscOperation::RiscOperator,&SgAsmRiscOperation::p_riscOperator> {
  using parent = SgAsmRiscOperation;
  using field_type = SgAsmRiscOperation::RiscOperator;
  static constexpr size_t position{0};
  static constexpr char const * const name{"riscOperator"};
  static constexpr char const * const typestr{"SgAsmRiscOperation::RiscOperator"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmRiscOperation::p_riscOperator};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmRiscOperation, SgAsmRiscOperation::RiscOperator SgAsmRiscOperation::*, &SgAsmRiscOperation::p_riscOperator>;
};
template <> struct describe_field_t<SgAsmRiscOperation,SgAsmExprListExp*,&SgAsmRiscOperation::p_operands> {
  using parent = SgAsmRiscOperation;
  using field_type = SgAsmExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operands"};
  static constexpr char const * const typestr{"SgAsmExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmRiscOperation::p_operands};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmRiscOperation, SgAsmExprListExp* SgAsmRiscOperation::*, &SgAsmRiscOperation::p_operands>;
};
template <> struct describe_node_t<SgAsmRiscOperation> {
  using node = SgAsmRiscOperation;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmRiscOperation"};
  static constexpr unsigned long variant{270};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmRiscOperation,SgAsmRiscOperation::RiscOperator,&SgAsmRiscOperation::p_riscOperator>, describe_field_t<SgAsmRiscOperation,SgAsmExprListExp*,&SgAsmRiscOperation::p_operands>>;
};
template <> struct node_from_variant_t<270> { using type = SgAsmRiscOperation; };

// Class: AsmScalarType
template <> struct describe_field_t<SgAsmScalarType,Rose::BinaryAnalysis::ByteOrder::Endianness,&SgAsmScalarType::p_minorOrder> {
  using parent = SgAsmScalarType;
  using field_type = Rose::BinaryAnalysis::ByteOrder::Endianness;
  static constexpr size_t position{0};
  static constexpr char const * const name{"minorOrder"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::ByteOrder::Endianness"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmScalarType::p_minorOrder};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmScalarType, Rose::BinaryAnalysis::ByteOrder::Endianness SgAsmScalarType::*, &SgAsmScalarType::p_minorOrder>;
};
template <> struct describe_field_t<SgAsmScalarType,Rose::BinaryAnalysis::ByteOrder::Endianness,&SgAsmScalarType::p_majorOrder> {
  using parent = SgAsmScalarType;
  using field_type = Rose::BinaryAnalysis::ByteOrder::Endianness;
  static constexpr size_t position{1};
  static constexpr char const * const name{"majorOrder"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::ByteOrder::Endianness"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmScalarType::p_majorOrder};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmScalarType, Rose::BinaryAnalysis::ByteOrder::Endianness SgAsmScalarType::*, &SgAsmScalarType::p_majorOrder>;
};
template <> struct describe_field_t<SgAsmScalarType,size_t,&SgAsmScalarType::p_majorNBytes> {
  using parent = SgAsmScalarType;
  using field_type = size_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"majorNBytes"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmScalarType::p_majorNBytes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmScalarType, size_t SgAsmScalarType::*, &SgAsmScalarType::p_majorNBytes>;
};
template <> struct describe_field_t<SgAsmScalarType,size_t,&SgAsmScalarType::p_nBits> {
  using parent = SgAsmScalarType;
  using field_type = size_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"nBits"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmScalarType::p_nBits};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmScalarType, size_t SgAsmScalarType::*, &SgAsmScalarType::p_nBits>;
};
template <> struct describe_node_t<SgAsmScalarType> {
  using node = SgAsmScalarType;
  using base = SgAsmType;
  static constexpr char const * const name{"AsmScalarType"};
  static constexpr unsigned long variant{271};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmFloatType, SgAsmIntegerType, SgAsmPointerType>;
  using fields_t = mp::List<describe_field_t<SgAsmScalarType,Rose::BinaryAnalysis::ByteOrder::Endianness,&SgAsmScalarType::p_minorOrder>, describe_field_t<SgAsmScalarType,Rose::BinaryAnalysis::ByteOrder::Endianness,&SgAsmScalarType::p_majorOrder>, describe_field_t<SgAsmScalarType,size_t,&SgAsmScalarType::p_majorNBytes>, describe_field_t<SgAsmScalarType,size_t,&SgAsmScalarType::p_nBits>>;
};
template <> struct node_from_variant_t<271> { using type = SgAsmScalarType; };

// Class: AsmStatement
template <> struct describe_field_t<SgAsmStatement,Rose::BinaryAnalysis::Address,&SgAsmStatement::p_address> {
  using parent = SgAsmStatement;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{0};
  static constexpr char const * const name{"address"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStatement::p_address};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStatement, Rose::BinaryAnalysis::Address SgAsmStatement::*, &SgAsmStatement::p_address>;
};
template <> struct describe_field_t<SgAsmStatement,std::string,&SgAsmStatement::p_comment> {
  using parent = SgAsmStatement;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"comment"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStatement::p_comment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStatement, std::string SgAsmStatement::*, &SgAsmStatement::p_comment>;
};
template <> struct describe_node_t<SgAsmStatement> {
  using node = SgAsmStatement;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmStatement"};
  static constexpr unsigned long variant{272};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmBlock, SgAsmInstruction, SgAsmStaticData, SgAsmSynthesizedDeclaration>;
  using fields_t = mp::List<describe_field_t<SgAsmStatement,Rose::BinaryAnalysis::Address,&SgAsmStatement::p_address>, describe_field_t<SgAsmStatement,std::string,&SgAsmStatement::p_comment>>;
};
template <> struct node_from_variant_t<272> { using type = SgAsmStatement; };

// Class: AsmStaticData
template <> struct describe_field_t<SgAsmStaticData,SgUnsignedCharList,&SgAsmStaticData::p_rawBytes> {
  using parent = SgAsmStaticData;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"rawBytes"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStaticData::p_rawBytes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStaticData, SgUnsignedCharList SgAsmStaticData::*, &SgAsmStaticData::p_rawBytes>;
};
template <> struct describe_node_t<SgAsmStaticData> {
  using node = SgAsmStaticData;
  using base = SgAsmStatement;
  static constexpr char const * const name{"AsmStaticData"};
  static constexpr unsigned long variant{273};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmStaticData,SgUnsignedCharList,&SgAsmStaticData::p_rawBytes>>;
};
template <> struct node_from_variant_t<273> { using type = SgAsmStaticData; };

// Class: AsmStmt
template <> struct describe_field_t<SgAsmStmt,std::string,&SgAsmStmt::p_assemblyCode> {
  using parent = SgAsmStmt;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"assemblyCode"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStmt::p_assemblyCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStmt, std::string SgAsmStmt::*, &SgAsmStmt::p_assemblyCode>;
};
template <> struct describe_field_t<SgAsmStmt,bool,&SgAsmStmt::p_useGnuExtendedFormat> {
  using parent = SgAsmStmt;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"useGnuExtendedFormat"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStmt::p_useGnuExtendedFormat};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStmt, bool SgAsmStmt::*, &SgAsmStmt::p_useGnuExtendedFormat>;
};
template <> struct describe_field_t<SgAsmStmt,SgExpressionPtrList,&SgAsmStmt::p_operands> {
  using parent = SgAsmStmt;
  using field_type = SgExpressionPtrList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"operands"};
  static constexpr char const * const typestr{"SgExpressionPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmStmt::p_operands};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStmt, SgExpressionPtrList SgAsmStmt::*, &SgAsmStmt::p_operands>;
};
template <> struct describe_field_t<SgAsmStmt,SgAsmStmt::AsmRegisterNameList,&SgAsmStmt::p_clobberRegisterList> {
  using parent = SgAsmStmt;
  using field_type = SgAsmStmt::AsmRegisterNameList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"clobberRegisterList"};
  static constexpr char const * const typestr{"SgAsmStmt::AsmRegisterNameList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStmt::p_clobberRegisterList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStmt, SgAsmStmt::AsmRegisterNameList SgAsmStmt::*, &SgAsmStmt::p_clobberRegisterList>;
};
template <> struct describe_field_t<SgAsmStmt,bool,&SgAsmStmt::p_isVolatile> {
  using parent = SgAsmStmt;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"isVolatile"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStmt::p_isVolatile};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStmt, bool SgAsmStmt::*, &SgAsmStmt::p_isVolatile>;
};
template <> struct describe_node_t<SgAsmStmt> {
  using node = SgAsmStmt;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AsmStmt"};
  static constexpr unsigned long variant{274};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmStmt,std::string,&SgAsmStmt::p_assemblyCode>, describe_field_t<SgAsmStmt,bool,&SgAsmStmt::p_useGnuExtendedFormat>, describe_field_t<SgAsmStmt,SgExpressionPtrList,&SgAsmStmt::p_operands>, describe_field_t<SgAsmStmt,SgAsmStmt::AsmRegisterNameList,&SgAsmStmt::p_clobberRegisterList>, describe_field_t<SgAsmStmt,bool,&SgAsmStmt::p_isVolatile>>;
};
template <> struct node_from_variant_t<274> { using type = SgAsmStmt; };

// Class: AsmStoredString
template <> struct describe_field_t<SgAsmStoredString,SgAsmStringStorage*,&SgAsmStoredString::p_storage> {
  using parent = SgAsmStoredString;
  using field_type = SgAsmStringStorage*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"storage"};
  static constexpr char const * const typestr{"SgAsmStringStorage*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStoredString::p_storage};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStoredString, SgAsmStringStorage* SgAsmStoredString::*, &SgAsmStoredString::p_storage>;
};
template <> struct describe_node_t<SgAsmStoredString> {
  using node = SgAsmStoredString;
  using base = SgAsmGenericString;
  static constexpr char const * const name{"AsmStoredString"};
  static constexpr unsigned long variant{275};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmStoredString,SgAsmStringStorage*,&SgAsmStoredString::p_storage>>;
};
template <> struct node_from_variant_t<275> { using type = SgAsmStoredString; };

// Class: AsmStringStorage
template <> struct describe_field_t<SgAsmStringStorage,SgAsmGenericStrtab*,&SgAsmStringStorage::p_strtab> {
  using parent = SgAsmStringStorage;
  using field_type = SgAsmGenericStrtab*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"strtab"};
  static constexpr char const * const typestr{"SgAsmGenericStrtab*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStringStorage::p_strtab};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStringStorage, SgAsmGenericStrtab* SgAsmStringStorage::*, &SgAsmStringStorage::p_strtab>;
};
template <> struct describe_field_t<SgAsmStringStorage,std::string,&SgAsmStringStorage::p_string> {
  using parent = SgAsmStringStorage;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStringStorage::p_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStringStorage, std::string SgAsmStringStorage::*, &SgAsmStringStorage::p_string>;
};
template <> struct describe_field_t<SgAsmStringStorage,Rose::BinaryAnalysis::Address,&SgAsmStringStorage::p_offset> {
  using parent = SgAsmStringStorage;
  using field_type = Rose::BinaryAnalysis::Address;
  static constexpr size_t position{2};
  static constexpr char const * const name{"offset"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::Address"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStringStorage::p_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStringStorage, Rose::BinaryAnalysis::Address SgAsmStringStorage::*, &SgAsmStringStorage::p_offset>;
};
template <> struct describe_node_t<SgAsmStringStorage> {
  using node = SgAsmStringStorage;
  using base = SgAsmExecutableFileFormat;
  static constexpr char const * const name{"AsmStringStorage"};
  static constexpr unsigned long variant{276};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmStringStorage,SgAsmGenericStrtab*,&SgAsmStringStorage::p_strtab>, describe_field_t<SgAsmStringStorage,std::string,&SgAsmStringStorage::p_string>, describe_field_t<SgAsmStringStorage,Rose::BinaryAnalysis::Address,&SgAsmStringStorage::p_offset>>;
};
template <> struct node_from_variant_t<276> { using type = SgAsmStringStorage; };

// Class: AsmType
template <> struct describe_node_t<SgAsmType> {
  using node = SgAsmType;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmType"};
  static constexpr unsigned long variant{277};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmScalarType, SgAsmVectorType, SgAsmVoidType>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<277> { using type = SgAsmType; };

// Class: AsmUnaryExpression
template <> struct describe_field_t<SgAsmUnaryExpression,SgAsmExpression*,&SgAsmUnaryExpression::p_operand> {
  using parent = SgAsmUnaryExpression;
  using field_type = SgAsmExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand"};
  static constexpr char const * const typestr{"SgAsmExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmUnaryExpression::p_operand};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmUnaryExpression, SgAsmExpression* SgAsmUnaryExpression::*, &SgAsmUnaryExpression::p_operand>;
};
template <> struct describe_node_t<SgAsmUnaryExpression> {
  using node = SgAsmUnaryExpression;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmUnaryExpression"};
  static constexpr unsigned long variant{278};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmUnaryMinus, SgAsmUnaryPlus, SgAsmUnaryRrx, SgAsmUnarySignedExtend, SgAsmUnaryTruncate, SgAsmUnaryUnsignedExtend>;
  using fields_t = mp::List<describe_field_t<SgAsmUnaryExpression,SgAsmExpression*,&SgAsmUnaryExpression::p_operand>>;
};
template <> struct node_from_variant_t<278> { using type = SgAsmUnaryExpression; };

// Class: AsmUnaryMinus
template <> struct describe_node_t<SgAsmUnaryMinus> {
  using node = SgAsmUnaryMinus;
  using base = SgAsmUnaryExpression;
  static constexpr char const * const name{"AsmUnaryMinus"};
  static constexpr unsigned long variant{279};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<279> { using type = SgAsmUnaryMinus; };

// Class: AsmUnaryPlus
template <> struct describe_node_t<SgAsmUnaryPlus> {
  using node = SgAsmUnaryPlus;
  using base = SgAsmUnaryExpression;
  static constexpr char const * const name{"AsmUnaryPlus"};
  static constexpr unsigned long variant{280};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<280> { using type = SgAsmUnaryPlus; };

// Class: AsmUnaryRrx
template <> struct describe_node_t<SgAsmUnaryRrx> {
  using node = SgAsmUnaryRrx;
  using base = SgAsmUnaryExpression;
  static constexpr char const * const name{"AsmUnaryRrx"};
  static constexpr unsigned long variant{281};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<281> { using type = SgAsmUnaryRrx; };

// Class: AsmUnarySignedExtend
template <> struct describe_node_t<SgAsmUnarySignedExtend> {
  using node = SgAsmUnarySignedExtend;
  using base = SgAsmUnaryExpression;
  static constexpr char const * const name{"AsmUnarySignedExtend"};
  static constexpr unsigned long variant{282};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<282> { using type = SgAsmUnarySignedExtend; };

// Class: AsmUnaryUnsignedExtend
template <> struct describe_node_t<SgAsmUnaryUnsignedExtend> {
  using node = SgAsmUnaryUnsignedExtend;
  using base = SgAsmUnaryExpression;
  static constexpr char const * const name{"AsmUnaryUnsignedExtend"};
  static constexpr unsigned long variant{283};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<283> { using type = SgAsmUnaryUnsignedExtend; };

// Class: AsmUnaryTruncate
template <> struct describe_node_t<SgAsmUnaryTruncate> {
  using node = SgAsmUnaryTruncate;
  using base = SgAsmUnaryExpression;
  static constexpr char const * const name{"AsmUnaryTruncate"};
  static constexpr unsigned long variant{284};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<284> { using type = SgAsmUnaryTruncate; };

// Class: AsmValueExpression
template <> struct describe_field_t<SgAsmValueExpression,SgAsmValueExpression*,&SgAsmValueExpression::p_unfoldedExpression> {
  using parent = SgAsmValueExpression;
  using field_type = SgAsmValueExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"unfoldedExpression"};
  static constexpr char const * const typestr{"SgAsmValueExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmValueExpression::p_unfoldedExpression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmValueExpression, SgAsmValueExpression* SgAsmValueExpression::*, &SgAsmValueExpression::p_unfoldedExpression>;
};
template <> struct describe_field_t<SgAsmValueExpression,unsigned short,&SgAsmValueExpression::p_bitOffset> {
  using parent = SgAsmValueExpression;
  using field_type = unsigned short;
  static constexpr size_t position{1};
  static constexpr char const * const name{"bitOffset"};
  static constexpr char const * const typestr{"unsigned short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmValueExpression::p_bitOffset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmValueExpression, unsigned short SgAsmValueExpression::*, &SgAsmValueExpression::p_bitOffset>;
};
template <> struct describe_field_t<SgAsmValueExpression,unsigned short,&SgAsmValueExpression::p_bitSize> {
  using parent = SgAsmValueExpression;
  using field_type = unsigned short;
  static constexpr size_t position{2};
  static constexpr char const * const name{"bitSize"};
  static constexpr char const * const typestr{"unsigned short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmValueExpression::p_bitSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmValueExpression, unsigned short SgAsmValueExpression::*, &SgAsmValueExpression::p_bitSize>;
};
template <> struct describe_field_t<SgAsmValueExpression,SgSymbol*,&SgAsmValueExpression::p_symbol> {
  using parent = SgAsmValueExpression;
  using field_type = SgSymbol*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmValueExpression::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmValueExpression, SgSymbol* SgAsmValueExpression::*, &SgAsmValueExpression::p_symbol>;
};
template <> struct describe_node_t<SgAsmValueExpression> {
  using node = SgAsmValueExpression;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmValueExpression"};
  static constexpr unsigned long variant{285};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmConstantExpression>;
  using fields_t = mp::List<describe_field_t<SgAsmValueExpression,SgAsmValueExpression*,&SgAsmValueExpression::p_unfoldedExpression>, describe_field_t<SgAsmValueExpression,unsigned short,&SgAsmValueExpression::p_bitOffset>, describe_field_t<SgAsmValueExpression,unsigned short,&SgAsmValueExpression::p_bitSize>, describe_field_t<SgAsmValueExpression,SgSymbol*,&SgAsmValueExpression::p_symbol>>;
};
template <> struct node_from_variant_t<285> { using type = SgAsmValueExpression; };

// Class: AsmVectorType
template <> struct describe_field_t<SgAsmVectorType,size_t,&SgAsmVectorType::p_nElmts> {
  using parent = SgAsmVectorType;
  using field_type = size_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"nElmts"};
  static constexpr char const * const typestr{"size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmVectorType::p_nElmts};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmVectorType, size_t SgAsmVectorType::*, &SgAsmVectorType::p_nElmts>;
};
template <> struct describe_field_t<SgAsmVectorType,SgAsmType*,&SgAsmVectorType::p_elmtType> {
  using parent = SgAsmVectorType;
  using field_type = SgAsmType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"elmtType"};
  static constexpr char const * const typestr{"SgAsmType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmVectorType::p_elmtType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmVectorType, SgAsmType* SgAsmVectorType::*, &SgAsmVectorType::p_elmtType>;
};
template <> struct describe_node_t<SgAsmVectorType> {
  using node = SgAsmVectorType;
  using base = SgAsmType;
  static constexpr char const * const name{"AsmVectorType"};
  static constexpr unsigned long variant{286};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmVectorType,size_t,&SgAsmVectorType::p_nElmts>, describe_field_t<SgAsmVectorType,SgAsmType*,&SgAsmVectorType::p_elmtType>>;
};
template <> struct node_from_variant_t<286> { using type = SgAsmVectorType; };

// Class: AsmX86Instruction
template <> struct describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86InstructionKind,&SgAsmX86Instruction::p_kind> {
  using parent = SgAsmX86Instruction;
  using field_type = Rose::BinaryAnalysis::X86InstructionKind;
  static constexpr size_t position{0};
  static constexpr char const * const name{"kind"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::X86InstructionKind"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmX86Instruction::p_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmX86Instruction, Rose::BinaryAnalysis::X86InstructionKind SgAsmX86Instruction::*, &SgAsmX86Instruction::p_kind>;
};
template <> struct describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86InstructionSize,&SgAsmX86Instruction::p_baseSize> {
  using parent = SgAsmX86Instruction;
  using field_type = Rose::BinaryAnalysis::X86InstructionSize;
  static constexpr size_t position{1};
  static constexpr char const * const name{"baseSize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::X86InstructionSize"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmX86Instruction::p_baseSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmX86Instruction, Rose::BinaryAnalysis::X86InstructionSize SgAsmX86Instruction::*, &SgAsmX86Instruction::p_baseSize>;
};
template <> struct describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86InstructionSize,&SgAsmX86Instruction::p_operandSize> {
  using parent = SgAsmX86Instruction;
  using field_type = Rose::BinaryAnalysis::X86InstructionSize;
  static constexpr size_t position{2};
  static constexpr char const * const name{"operandSize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::X86InstructionSize"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmX86Instruction::p_operandSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmX86Instruction, Rose::BinaryAnalysis::X86InstructionSize SgAsmX86Instruction::*, &SgAsmX86Instruction::p_operandSize>;
};
template <> struct describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86InstructionSize,&SgAsmX86Instruction::p_addressSize> {
  using parent = SgAsmX86Instruction;
  using field_type = Rose::BinaryAnalysis::X86InstructionSize;
  static constexpr size_t position{3};
  static constexpr char const * const name{"addressSize"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::X86InstructionSize"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmX86Instruction::p_addressSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmX86Instruction, Rose::BinaryAnalysis::X86InstructionSize SgAsmX86Instruction::*, &SgAsmX86Instruction::p_addressSize>;
};
template <> struct describe_field_t<SgAsmX86Instruction,bool,&SgAsmX86Instruction::p_lockPrefix> {
  using parent = SgAsmX86Instruction;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"lockPrefix"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmX86Instruction::p_lockPrefix};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmX86Instruction, bool SgAsmX86Instruction::*, &SgAsmX86Instruction::p_lockPrefix>;
};
template <> struct describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86RepeatPrefix,&SgAsmX86Instruction::p_repeatPrefix> {
  using parent = SgAsmX86Instruction;
  using field_type = Rose::BinaryAnalysis::X86RepeatPrefix;
  static constexpr size_t position{5};
  static constexpr char const * const name{"repeatPrefix"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::X86RepeatPrefix"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmX86Instruction::p_repeatPrefix};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmX86Instruction, Rose::BinaryAnalysis::X86RepeatPrefix SgAsmX86Instruction::*, &SgAsmX86Instruction::p_repeatPrefix>;
};
template <> struct describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86BranchPrediction,&SgAsmX86Instruction::p_branchPrediction> {
  using parent = SgAsmX86Instruction;
  using field_type = Rose::BinaryAnalysis::X86BranchPrediction;
  static constexpr size_t position{6};
  static constexpr char const * const name{"branchPrediction"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::X86BranchPrediction"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmX86Instruction::p_branchPrediction};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmX86Instruction, Rose::BinaryAnalysis::X86BranchPrediction SgAsmX86Instruction::*, &SgAsmX86Instruction::p_branchPrediction>;
};
template <> struct describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86SegmentRegister,&SgAsmX86Instruction::p_segmentOverride> {
  using parent = SgAsmX86Instruction;
  using field_type = Rose::BinaryAnalysis::X86SegmentRegister;
  static constexpr size_t position{7};
  static constexpr char const * const name{"segmentOverride"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::X86SegmentRegister"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmX86Instruction::p_segmentOverride};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmX86Instruction, Rose::BinaryAnalysis::X86SegmentRegister SgAsmX86Instruction::*, &SgAsmX86Instruction::p_segmentOverride>;
};
template <> struct describe_node_t<SgAsmX86Instruction> {
  using node = SgAsmX86Instruction;
  using base = SgAsmInstruction;
  static constexpr char const * const name{"AsmX86Instruction"};
  static constexpr unsigned long variant{287};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86InstructionKind,&SgAsmX86Instruction::p_kind>, describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86InstructionSize,&SgAsmX86Instruction::p_baseSize>, describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86InstructionSize,&SgAsmX86Instruction::p_operandSize>, describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86InstructionSize,&SgAsmX86Instruction::p_addressSize>, describe_field_t<SgAsmX86Instruction,bool,&SgAsmX86Instruction::p_lockPrefix>, describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86RepeatPrefix,&SgAsmX86Instruction::p_repeatPrefix>, describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86BranchPrediction,&SgAsmX86Instruction::p_branchPrediction>, describe_field_t<SgAsmX86Instruction,Rose::BinaryAnalysis::X86SegmentRegister,&SgAsmX86Instruction::p_segmentOverride>>;
};
template <> struct node_from_variant_t<287> { using type = SgAsmX86Instruction; };

// Class: AsmBinaryAddressSymbol
template <> struct describe_field_t<SgAsmBinaryAddressSymbol,SgName,&SgAsmBinaryAddressSymbol::p_address_name> {
  using parent = SgAsmBinaryAddressSymbol;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"address_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBinaryAddressSymbol::p_address_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBinaryAddressSymbol, SgName SgAsmBinaryAddressSymbol::*, &SgAsmBinaryAddressSymbol::p_address_name>;
};
template <> struct describe_field_t<SgAsmBinaryAddressSymbol,SgAsmInstruction*,&SgAsmBinaryAddressSymbol::p_address> {
  using parent = SgAsmBinaryAddressSymbol;
  using field_type = SgAsmInstruction*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"address"};
  static constexpr char const * const typestr{"SgAsmInstruction*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBinaryAddressSymbol::p_address};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBinaryAddressSymbol, SgAsmInstruction* SgAsmBinaryAddressSymbol::*, &SgAsmBinaryAddressSymbol::p_address>;
};
template <> struct describe_node_t<SgAsmBinaryAddressSymbol> {
  using node = SgAsmBinaryAddressSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AsmBinaryAddressSymbol"};
  static constexpr unsigned long variant{288};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmBinaryAddressSymbol,SgName,&SgAsmBinaryAddressSymbol::p_address_name>, describe_field_t<SgAsmBinaryAddressSymbol,SgAsmInstruction*,&SgAsmBinaryAddressSymbol::p_address>>;
};
template <> struct node_from_variant_t<288> { using type = SgAsmBinaryAddressSymbol; };

// Class: AsmBinaryDataSymbol
template <> struct describe_field_t<SgAsmBinaryDataSymbol,SgName,&SgAsmBinaryDataSymbol::p_variable_name> {
  using parent = SgAsmBinaryDataSymbol;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"variable_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBinaryDataSymbol::p_variable_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBinaryDataSymbol, SgName SgAsmBinaryDataSymbol::*, &SgAsmBinaryDataSymbol::p_variable_name>;
};
template <> struct describe_field_t<SgAsmBinaryDataSymbol,SgAsmInstruction*,&SgAsmBinaryDataSymbol::p_address> {
  using parent = SgAsmBinaryDataSymbol;
  using field_type = SgAsmInstruction*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"address"};
  static constexpr char const * const typestr{"SgAsmInstruction*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmBinaryDataSymbol::p_address};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmBinaryDataSymbol, SgAsmInstruction* SgAsmBinaryDataSymbol::*, &SgAsmBinaryDataSymbol::p_address>;
};
template <> struct describe_node_t<SgAsmBinaryDataSymbol> {
  using node = SgAsmBinaryDataSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AsmBinaryDataSymbol"};
  static constexpr unsigned long variant{289};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmBinaryDataSymbol,SgName,&SgAsmBinaryDataSymbol::p_variable_name>, describe_field_t<SgAsmBinaryDataSymbol,SgAsmInstruction*,&SgAsmBinaryDataSymbol::p_address>>;
};
template <> struct node_from_variant_t<289> { using type = SgAsmBinaryDataSymbol; };

// Class: AssertStmt
template <> struct describe_field_t<SgAssertStmt,SgExpression*,&SgAssertStmt::p_test> {
  using parent = SgAssertStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"test"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAssertStmt::p_test};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAssertStmt, SgExpression* SgAssertStmt::*, &SgAssertStmt::p_test>;
};
template <> struct describe_field_t<SgAssertStmt,SgExpression*,&SgAssertStmt::p_exception_argument> {
  using parent = SgAssertStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"exception_argument"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAssertStmt::p_exception_argument};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAssertStmt, SgExpression* SgAssertStmt::*, &SgAssertStmt::p_exception_argument>;
};
template <> struct describe_node_t<SgAssertStmt> {
  using node = SgAssertStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AssertStmt"};
  static constexpr unsigned long variant{290};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAssertStmt,SgExpression*,&SgAssertStmt::p_test>, describe_field_t<SgAssertStmt,SgExpression*,&SgAssertStmt::p_exception_argument>>;
};
template <> struct node_from_variant_t<290> { using type = SgAssertStmt; };

// Class: AssignInitializer
template <> struct describe_field_t<SgAssignInitializer,SgExpression*,&SgAssignInitializer::p_operand_i> {
  using parent = SgAssignInitializer;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_i"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAssignInitializer::p_operand_i};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAssignInitializer, SgExpression* SgAssignInitializer::*, &SgAssignInitializer::p_operand_i>;
};
template <> struct describe_field_t<SgAssignInitializer,SgType*,&SgAssignInitializer::p_expression_type> {
  using parent = SgAssignInitializer;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAssignInitializer::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAssignInitializer, SgType* SgAssignInitializer::*, &SgAssignInitializer::p_expression_type>;
};
template <> struct describe_node_t<SgAssignInitializer> {
  using node = SgAssignInitializer;
  using base = SgInitializer;
  static constexpr char const * const name{"AssignInitializer"};
  static constexpr unsigned long variant{291};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAssignInitializer,SgExpression*,&SgAssignInitializer::p_operand_i>, describe_field_t<SgAssignInitializer,SgType*,&SgAssignInitializer::p_expression_type>>;
};
template <> struct node_from_variant_t<291> { using type = SgAssignInitializer; };

// Class: AssignOp
template <> struct describe_node_t<SgAssignOp> {
  using node = SgAssignOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"AssignOp"};
  static constexpr unsigned long variant{292};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<292> { using type = SgAssignOp; };

// Class: AssignStatement
template <> struct describe_field_t<SgAssignStatement,SgLabelRefExp*,&SgAssignStatement::p_label> {
  using parent = SgAssignStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAssignStatement::p_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAssignStatement, SgLabelRefExp* SgAssignStatement::*, &SgAssignStatement::p_label>;
};
template <> struct describe_field_t<SgAssignStatement,SgExpression*,&SgAssignStatement::p_value> {
  using parent = SgAssignStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAssignStatement::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAssignStatement, SgExpression* SgAssignStatement::*, &SgAssignStatement::p_value>;
};
template <> struct describe_node_t<SgAssignStatement> {
  using node = SgAssignStatement;
  using base = SgStatement;
  static constexpr char const * const name{"AssignStatement"};
  static constexpr unsigned long variant{293};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAssignStatement,SgLabelRefExp*,&SgAssignStatement::p_label>, describe_field_t<SgAssignStatement,SgExpression*,&SgAssignStatement::p_value>>;
};
template <> struct node_from_variant_t<293> { using type = SgAssignStatement; };

// Class: AssignedGotoStatement
template <> struct describe_field_t<SgAssignedGotoStatement,SgExprListExp*,&SgAssignedGotoStatement::p_targets> {
  using parent = SgAssignedGotoStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"targets"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAssignedGotoStatement::p_targets};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAssignedGotoStatement, SgExprListExp* SgAssignedGotoStatement::*, &SgAssignedGotoStatement::p_targets>;
};
template <> struct describe_node_t<SgAssignedGotoStatement> {
  using node = SgAssignedGotoStatement;
  using base = SgStatement;
  static constexpr char const * const name{"AssignedGotoStatement"};
  static constexpr unsigned long variant{294};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAssignedGotoStatement,SgExprListExp*,&SgAssignedGotoStatement::p_targets>>;
};
template <> struct node_from_variant_t<294> { using type = SgAssignedGotoStatement; };

// Class: AssociateStatement
template <> struct describe_field_t<SgAssociateStatement,SgDeclarationStatementPtrList,&SgAssociateStatement::p_associates> {
  using parent = SgAssociateStatement;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"associates"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAssociateStatement::p_associates};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAssociateStatement, SgDeclarationStatementPtrList SgAssociateStatement::*, &SgAssociateStatement::p_associates>;
};
template <> struct describe_field_t<SgAssociateStatement,SgBasicBlock*,&SgAssociateStatement::p_body> {
  using parent = SgAssociateStatement;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAssociateStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAssociateStatement, SgBasicBlock* SgAssociateStatement::*, &SgAssociateStatement::p_body>;
};
template <> struct describe_node_t<SgAssociateStatement> {
  using node = SgAssociateStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"AssociateStatement"};
  static constexpr unsigned long variant{295};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAssociateStatement,SgDeclarationStatementPtrList,&SgAssociateStatement::p_associates>, describe_field_t<SgAssociateStatement,SgBasicBlock*,&SgAssociateStatement::p_body>>;
};
template <> struct node_from_variant_t<295> { using type = SgAssociateStatement; };

// Class: AsteriskShapeExp
template <> struct describe_node_t<SgAsteriskShapeExp> {
  using node = SgAsteriskShapeExp;
  using base = SgExpression;
  static constexpr char const * const name{"AsteriskShapeExp"};
  static constexpr unsigned long variant{296};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<296> { using type = SgAsteriskShapeExp; };

// Class: AtOp
template <> struct describe_node_t<SgAtOp> {
  using node = SgAtOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"AtOp"};
  static constexpr unsigned long variant{297};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<297> { using type = SgAtOp; };

// Class: Attribute
template <> struct describe_field_t<SgAttribute,std::string,&SgAttribute::p_name> {
  using parent = SgAttribute;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAttribute::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAttribute, std::string SgAttribute::*, &SgAttribute::p_name>;
};
template <> struct describe_node_t<SgAttribute> {
  using node = SgAttribute;
  using base = SgSupport;
  static constexpr char const * const name{"Attribute"};
  static constexpr unsigned long variant{298};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgPragma, SgBitAttribute>;
  using fields_t = mp::List<describe_field_t<SgAttribute,std::string,&SgAttribute::p_name>>;
};
template <> struct node_from_variant_t<298> { using type = SgAttribute; };

// Class: AttributeSpecificationStatement
template <> struct describe_field_t<SgAttributeSpecificationStatement,SgStringList,&SgAttributeSpecificationStatement::p_name_list> {
  using parent = SgAttributeSpecificationStatement;
  using field_type = SgStringList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name_list"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAttributeSpecificationStatement::p_name_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAttributeSpecificationStatement, SgStringList SgAttributeSpecificationStatement::*, &SgAttributeSpecificationStatement::p_name_list>;
};
template <> struct describe_field_t<SgAttributeSpecificationStatement,SgAttributeSpecificationStatement::attribute_spec_enum,&SgAttributeSpecificationStatement::p_attribute_kind> {
  using parent = SgAttributeSpecificationStatement;
  using field_type = SgAttributeSpecificationStatement::attribute_spec_enum;
  static constexpr size_t position{1};
  static constexpr char const * const name{"attribute_kind"};
  static constexpr char const * const typestr{"SgAttributeSpecificationStatement::attribute_spec_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAttributeSpecificationStatement::p_attribute_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAttributeSpecificationStatement, SgAttributeSpecificationStatement::attribute_spec_enum SgAttributeSpecificationStatement::*, &SgAttributeSpecificationStatement::p_attribute_kind>;
};
template <> struct describe_field_t<SgAttributeSpecificationStatement,int,&SgAttributeSpecificationStatement::p_intent> {
  using parent = SgAttributeSpecificationStatement;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"intent"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAttributeSpecificationStatement::p_intent};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAttributeSpecificationStatement, int SgAttributeSpecificationStatement::*, &SgAttributeSpecificationStatement::p_intent>;
};
template <> struct describe_field_t<SgAttributeSpecificationStatement,SgExprListExp*,&SgAttributeSpecificationStatement::p_parameter_list> {
  using parent = SgAttributeSpecificationStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"parameter_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAttributeSpecificationStatement::p_parameter_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAttributeSpecificationStatement, SgExprListExp* SgAttributeSpecificationStatement::*, &SgAttributeSpecificationStatement::p_parameter_list>;
};
template <> struct describe_field_t<SgAttributeSpecificationStatement,SgDataStatementGroupPtrList,&SgAttributeSpecificationStatement::p_data_statement_group_list> {
  using parent = SgAttributeSpecificationStatement;
  using field_type = SgDataStatementGroupPtrList;
  static constexpr size_t position{4};
  static constexpr char const * const name{"data_statement_group_list"};
  static constexpr char const * const typestr{"SgDataStatementGroupPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAttributeSpecificationStatement::p_data_statement_group_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAttributeSpecificationStatement, SgDataStatementGroupPtrList SgAttributeSpecificationStatement::*, &SgAttributeSpecificationStatement::p_data_statement_group_list>;
};
template <> struct describe_field_t<SgAttributeSpecificationStatement,SgExprListExp*,&SgAttributeSpecificationStatement::p_bind_list> {
  using parent = SgAttributeSpecificationStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"bind_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAttributeSpecificationStatement::p_bind_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAttributeSpecificationStatement, SgExprListExp* SgAttributeSpecificationStatement::*, &SgAttributeSpecificationStatement::p_bind_list>;
};
template <> struct describe_field_t<SgAttributeSpecificationStatement,SgDimensionObjectPtrList,&SgAttributeSpecificationStatement::p_dimension_object_list> {
  using parent = SgAttributeSpecificationStatement;
  using field_type = SgDimensionObjectPtrList;
  static constexpr size_t position{6};
  static constexpr char const * const name{"dimension_object_list"};
  static constexpr char const * const typestr{"SgDimensionObjectPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAttributeSpecificationStatement::p_dimension_object_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAttributeSpecificationStatement, SgDimensionObjectPtrList SgAttributeSpecificationStatement::*, &SgAttributeSpecificationStatement::p_dimension_object_list>;
};
template <> struct describe_node_t<SgAttributeSpecificationStatement> {
  using node = SgAttributeSpecificationStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AttributeSpecificationStatement"};
  static constexpr unsigned long variant{299};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAttributeSpecificationStatement,SgStringList,&SgAttributeSpecificationStatement::p_name_list>, describe_field_t<SgAttributeSpecificationStatement,SgAttributeSpecificationStatement::attribute_spec_enum,&SgAttributeSpecificationStatement::p_attribute_kind>, describe_field_t<SgAttributeSpecificationStatement,int,&SgAttributeSpecificationStatement::p_intent>, describe_field_t<SgAttributeSpecificationStatement,SgExprListExp*,&SgAttributeSpecificationStatement::p_parameter_list>, describe_field_t<SgAttributeSpecificationStatement,SgDataStatementGroupPtrList,&SgAttributeSpecificationStatement::p_data_statement_group_list>, describe_field_t<SgAttributeSpecificationStatement,SgExprListExp*,&SgAttributeSpecificationStatement::p_bind_list>, describe_field_t<SgAttributeSpecificationStatement,SgDimensionObjectPtrList,&SgAttributeSpecificationStatement::p_dimension_object_list>>;
};
template <> struct node_from_variant_t<299> { using type = SgAttributeSpecificationStatement; };

// Class: AutoType
template <> struct describe_node_t<SgAutoType> {
  using node = SgAutoType;
  using base = SgType;
  static constexpr char const * const name{"AutoType"};
  static constexpr unsigned long variant{300};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<300> { using type = SgAutoType; };

// Class: AwaitExpression
template <> struct describe_field_t<SgAwaitExpression,SgExpression*,&SgAwaitExpression::p_value> {
  using parent = SgAwaitExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAwaitExpression::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAwaitExpression, SgExpression* SgAwaitExpression::*, &SgAwaitExpression::p_value>;
};
template <> struct describe_node_t<SgAwaitExpression> {
  using node = SgAwaitExpression;
  using base = SgExpression;
  static constexpr char const * const name{"AwaitExpression"};
  static constexpr unsigned long variant{301};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAwaitExpression,SgExpression*,&SgAwaitExpression::p_value>>;
};
template <> struct node_from_variant_t<301> { using type = SgAwaitExpression; };

// Class: BackspaceStatement
template <> struct describe_node_t<SgBackspaceStatement> {
  using node = SgBackspaceStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"BackspaceStatement"};
  static constexpr unsigned long variant{302};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<302> { using type = SgBackspaceStatement; };

// Class: BaseClass
template <> struct describe_field_t<SgBaseClass,SgClassDeclaration*,&SgBaseClass::p_base_class> {
  using parent = SgBaseClass;
  using field_type = SgClassDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_class"};
  static constexpr char const * const typestr{"SgClassDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgBaseClass::p_base_class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBaseClass, SgClassDeclaration* SgBaseClass::*, &SgBaseClass::p_base_class>;
};
template <> struct describe_field_t<SgBaseClass,bool,&SgBaseClass::p_isDirectBaseClass> {
  using parent = SgBaseClass;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"isDirectBaseClass"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBaseClass::p_isDirectBaseClass};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBaseClass, bool SgBaseClass::*, &SgBaseClass::p_isDirectBaseClass>;
};
template <> struct describe_field_t<SgBaseClass,SgBaseClassModifier*,&SgBaseClass::p_baseClassModifier> {
  using parent = SgBaseClass;
  using field_type = SgBaseClassModifier*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"baseClassModifier"};
  static constexpr char const * const typestr{"SgBaseClassModifier*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBaseClass::p_baseClassModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBaseClass, SgBaseClassModifier* SgBaseClass::*, &SgBaseClass::p_baseClassModifier>;
};
template <> struct describe_field_t<SgBaseClass,int,&SgBaseClass::p_name_qualification_length> {
  using parent = SgBaseClass;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBaseClass::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBaseClass, int SgBaseClass::*, &SgBaseClass::p_name_qualification_length>;
};
template <> struct describe_field_t<SgBaseClass,bool,&SgBaseClass::p_type_elaboration_required> {
  using parent = SgBaseClass;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBaseClass::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBaseClass, bool SgBaseClass::*, &SgBaseClass::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgBaseClass,bool,&SgBaseClass::p_global_qualification_required> {
  using parent = SgBaseClass;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBaseClass::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBaseClass, bool SgBaseClass::*, &SgBaseClass::p_global_qualification_required>;
};
template <> struct describe_node_t<SgBaseClass> {
  using node = SgBaseClass;
  using base = SgSupport;
  static constexpr char const * const name{"BaseClass"};
  static constexpr unsigned long variant{303};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgExpBaseClass, SgNonrealBaseClass>;
  using fields_t = mp::List<describe_field_t<SgBaseClass,SgClassDeclaration*,&SgBaseClass::p_base_class>, describe_field_t<SgBaseClass,bool,&SgBaseClass::p_isDirectBaseClass>, describe_field_t<SgBaseClass,SgBaseClassModifier*,&SgBaseClass::p_baseClassModifier>, describe_field_t<SgBaseClass,int,&SgBaseClass::p_name_qualification_length>, describe_field_t<SgBaseClass,bool,&SgBaseClass::p_type_elaboration_required>, describe_field_t<SgBaseClass,bool,&SgBaseClass::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<303> { using type = SgBaseClass; };

// Class: ExpBaseClass
template <> struct describe_field_t<SgExpBaseClass,SgExpression*,&SgExpBaseClass::p_base_class_exp> {
  using parent = SgExpBaseClass;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_class_exp"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgExpBaseClass::p_base_class_exp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExpBaseClass, SgExpression* SgExpBaseClass::*, &SgExpBaseClass::p_base_class_exp>;
};
template <> struct describe_node_t<SgExpBaseClass> {
  using node = SgExpBaseClass;
  using base = SgBaseClass;
  static constexpr char const * const name{"ExpBaseClass"};
  static constexpr unsigned long variant{304};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgExpBaseClass,SgExpression*,&SgExpBaseClass::p_base_class_exp>>;
};
template <> struct node_from_variant_t<304> { using type = SgExpBaseClass; };

// Class: BaseClassModifier
template <> struct describe_field_t<SgBaseClassModifier,SgBaseClassModifier::baseclass_modifier_enum,&SgBaseClassModifier::p_modifier> {
  using parent = SgBaseClassModifier;
  using field_type = SgBaseClassModifier::baseclass_modifier_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgBaseClassModifier::baseclass_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBaseClassModifier::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBaseClassModifier, SgBaseClassModifier::baseclass_modifier_enum SgBaseClassModifier::*, &SgBaseClassModifier::p_modifier>;
};
template <> struct describe_field_t<SgBaseClassModifier,SgAccessModifier,&SgBaseClassModifier::p_accessModifier> {
  using parent = SgBaseClassModifier;
  using field_type = SgAccessModifier;
  static constexpr size_t position{1};
  static constexpr char const * const name{"accessModifier"};
  static constexpr char const * const typestr{"SgAccessModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBaseClassModifier::p_accessModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBaseClassModifier, SgAccessModifier SgBaseClassModifier::*, &SgBaseClassModifier::p_accessModifier>;
};
template <> struct describe_node_t<SgBaseClassModifier> {
  using node = SgBaseClassModifier;
  using base = SgModifier;
  static constexpr char const * const name{"BaseClassModifier"};
  static constexpr unsigned long variant{305};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgBaseClassModifier,SgBaseClassModifier::baseclass_modifier_enum,&SgBaseClassModifier::p_modifier>, describe_field_t<SgBaseClassModifier,SgAccessModifier,&SgBaseClassModifier::p_accessModifier>>;
};
template <> struct node_from_variant_t<305> { using type = SgBaseClassModifier; };

// Class: BasicBlock
template <> struct describe_field_t<SgBasicBlock,SgStatementPtrList,&SgBasicBlock::p_statements> {
  using parent = SgBasicBlock;
  using field_type = SgStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"statements"};
  static constexpr char const * const typestr{"SgStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgBasicBlock::p_statements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBasicBlock, SgStatementPtrList SgBasicBlock::*, &SgBasicBlock::p_statements>;
};
template <> struct describe_field_t<SgBasicBlock,std::string,&SgBasicBlock::p_asm_function_body> {
  using parent = SgBasicBlock;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"asm_function_body"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBasicBlock::p_asm_function_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBasicBlock, std::string SgBasicBlock::*, &SgBasicBlock::p_asm_function_body>;
};
template <> struct describe_field_t<SgBasicBlock,std::string,&SgBasicBlock::p_string_label> {
  using parent = SgBasicBlock;
  using field_type = std::string;
  static constexpr size_t position{2};
  static constexpr char const * const name{"string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBasicBlock::p_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBasicBlock, std::string SgBasicBlock::*, &SgBasicBlock::p_string_label>;
};
template <> struct describe_node_t<SgBasicBlock> {
  using node = SgBasicBlock;
  using base = SgScopeStatement;
  static constexpr char const * const name{"BasicBlock"};
  static constexpr unsigned long variant{306};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgBasicBlock,SgStatementPtrList,&SgBasicBlock::p_statements>, describe_field_t<SgBasicBlock,std::string,&SgBasicBlock::p_asm_function_body>, describe_field_t<SgBasicBlock,std::string,&SgBasicBlock::p_string_label>>;
};
template <> struct node_from_variant_t<306> { using type = SgBasicBlock; };

// Class: BidirectionalGraph
template <> struct describe_node_t<SgBidirectionalGraph> {
  using node = SgBidirectionalGraph;
  using base = SgIncidenceDirectedGraph;
  static constexpr char const * const name{"BidirectionalGraph"};
  static constexpr unsigned long variant{307};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgStringKeyedBidirectionalGraph, SgIntKeyedBidirectionalGraph>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<307> { using type = SgBidirectionalGraph; };

// Class: BinaryComposite
template <> struct describe_field_t<SgBinaryComposite,SgAsmGenericFileList*,&SgBinaryComposite::p_genericFileList> {
  using parent = SgBinaryComposite;
  using field_type = SgAsmGenericFileList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"genericFileList"};
  static constexpr char const * const typestr{"SgAsmGenericFileList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgBinaryComposite::p_genericFileList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBinaryComposite, SgAsmGenericFileList* SgBinaryComposite::*, &SgBinaryComposite::p_genericFileList>;
};
template <> struct describe_field_t<SgBinaryComposite,SgAsmInterpretationList*,&SgBinaryComposite::p_interpretations> {
  using parent = SgBinaryComposite;
  using field_type = SgAsmInterpretationList*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"interpretations"};
  static constexpr char const * const typestr{"SgAsmInterpretationList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgBinaryComposite::p_interpretations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBinaryComposite, SgAsmInterpretationList* SgBinaryComposite::*, &SgBinaryComposite::p_interpretations>;
};
template <> struct describe_node_t<SgBinaryComposite> {
  using node = SgBinaryComposite;
  using base = SgFile;
  static constexpr char const * const name{"BinaryComposite"};
  static constexpr unsigned long variant{308};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgJvmComposite>;
  using fields_t = mp::List<describe_field_t<SgBinaryComposite,SgAsmGenericFileList*,&SgBinaryComposite::p_genericFileList>, describe_field_t<SgBinaryComposite,SgAsmInterpretationList*,&SgBinaryComposite::p_interpretations>>;
};
template <> struct node_from_variant_t<308> { using type = SgBinaryComposite; };

// Class: BinaryOp
template <> struct describe_field_t<SgBinaryOp,SgExpression*,&SgBinaryOp::p_lhs_operand_i> {
  using parent = SgBinaryOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lhs_operand_i"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgBinaryOp::p_lhs_operand_i};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBinaryOp, SgExpression* SgBinaryOp::*, &SgBinaryOp::p_lhs_operand_i>;
};
template <> struct describe_field_t<SgBinaryOp,SgExpression*,&SgBinaryOp::p_rhs_operand_i> {
  using parent = SgBinaryOp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"rhs_operand_i"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgBinaryOp::p_rhs_operand_i};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBinaryOp, SgExpression* SgBinaryOp::*, &SgBinaryOp::p_rhs_operand_i>;
};
template <> struct describe_field_t<SgBinaryOp,SgType*,&SgBinaryOp::p_expression_type> {
  using parent = SgBinaryOp;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBinaryOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBinaryOp, SgType* SgBinaryOp::*, &SgBinaryOp::p_expression_type>;
};
template <> struct describe_field_t<SgBinaryOp,SgExpression*,&SgBinaryOp::p_originalExpressionTree> {
  using parent = SgBinaryOp;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"originalExpressionTree"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBinaryOp::p_originalExpressionTree};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBinaryOp, SgExpression* SgBinaryOp::*, &SgBinaryOp::p_originalExpressionTree>;
};
template <> struct describe_node_t<SgBinaryOp> {
  using node = SgBinaryOp;
  using base = SgExpression;
  static constexpr char const * const name{"BinaryOp"};
  static constexpr unsigned long variant{309};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgArrowExp, SgDotExp, SgDotStarOp, SgArrowStarOp, SgEqualityOp, SgLessThanOp, SgGreaterThanOp, SgNotEqualOp, SgLessOrEqualOp, SgGreaterOrEqualOp, SgAddOp, SgSubtractOp, SgMultiplyOp, SgDivideOp, SgIntegerDivideOp, SgModOp, SgAndOp, SgOrOp, SgBitXorOp, SgBitAndOp, SgBitOrOp, SgBitEqvOp, SgCommaOpExp, SgLshiftOp, SgRshiftOp, SgPntrArrRefExp, SgScopeOp, SgAssignOp, SgExponentiationOp, SgJavaUnsignedRshiftOp, SgConcatenationOp, SgPointerAssignOp, SgUserDefinedBinaryOp, SgCompoundAssignOp, SgMembershipOp, SgSpaceshipOp, SgNonMembershipOp, SgIsOp, SgIsNotOp, SgDotDotExp, SgElementwiseOp, SgPowerOp, SgLeftDivideOp, SgRemOp, SgReplicationOp, SgAtOp>;
  using fields_t = mp::List<describe_field_t<SgBinaryOp,SgExpression*,&SgBinaryOp::p_lhs_operand_i>, describe_field_t<SgBinaryOp,SgExpression*,&SgBinaryOp::p_rhs_operand_i>, describe_field_t<SgBinaryOp,SgType*,&SgBinaryOp::p_expression_type>, describe_field_t<SgBinaryOp,SgExpression*,&SgBinaryOp::p_originalExpressionTree>>;
};
template <> struct node_from_variant_t<309> { using type = SgBinaryOp; };

// Class: BitAndOp
template <> struct describe_node_t<SgBitAndOp> {
  using node = SgBitAndOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"BitAndOp"};
  static constexpr unsigned long variant{310};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<310> { using type = SgBitAndOp; };

// Class: BitAttribute
template <> struct describe_field_t<SgBitAttribute,unsigned long int,&SgBitAttribute::p_bitflag> {
  using parent = SgBitAttribute;
  using field_type = unsigned long int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"bitflag"};
  static constexpr char const * const typestr{"unsigned long int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBitAttribute::p_bitflag};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBitAttribute, unsigned long int SgBitAttribute::*, &SgBitAttribute::p_bitflag>;
};
template <> struct describe_node_t<SgBitAttribute> {
  using node = SgBitAttribute;
  using base = SgAttribute;
  static constexpr char const * const name{"BitAttribute"};
  static constexpr unsigned long variant{311};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgFuncDecl_attr, SgClassDecl_attr>;
  using fields_t = mp::List<describe_field_t<SgBitAttribute,unsigned long int,&SgBitAttribute::p_bitflag>>;
};
template <> struct node_from_variant_t<311> { using type = SgBitAttribute; };

// Class: BitComplementOp
template <> struct describe_node_t<SgBitComplementOp> {
  using node = SgBitComplementOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"BitComplementOp"};
  static constexpr unsigned long variant{312};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<312> { using type = SgBitComplementOp; };

// Class: BitEqvOp
template <> struct describe_node_t<SgBitEqvOp> {
  using node = SgBitEqvOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"BitEqvOp"};
  static constexpr unsigned long variant{313};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<313> { using type = SgBitEqvOp; };

// Class: BitOrOp
template <> struct describe_node_t<SgBitOrOp> {
  using node = SgBitOrOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"BitOrOp"};
  static constexpr unsigned long variant{314};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<314> { using type = SgBitOrOp; };

// Class: BitXorOp
template <> struct describe_node_t<SgBitXorOp> {
  using node = SgBitXorOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"BitXorOp"};
  static constexpr unsigned long variant{315};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<315> { using type = SgBitXorOp; };

// Class: BlockDataStatement
template <> struct describe_field_t<SgBlockDataStatement,SgBasicBlock*,&SgBlockDataStatement::p_body> {
  using parent = SgBlockDataStatement;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBlockDataStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBlockDataStatement, SgBasicBlock* SgBlockDataStatement::*, &SgBlockDataStatement::p_body>;
};
template <> struct describe_node_t<SgBlockDataStatement> {
  using node = SgBlockDataStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"BlockDataStatement"};
  static constexpr unsigned long variant{316};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgBlockDataStatement,SgBasicBlock*,&SgBlockDataStatement::p_body>>;
};
template <> struct node_from_variant_t<316> { using type = SgBlockDataStatement; };

// Class: BoolValExp
template <> struct describe_field_t<SgBoolValExp,int,&SgBoolValExp::p_value> {
  using parent = SgBoolValExp;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBoolValExp::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBoolValExp, int SgBoolValExp::*, &SgBoolValExp::p_value>;
};
template <> struct describe_node_t<SgBoolValExp> {
  using node = SgBoolValExp;
  using base = SgValueExp;
  static constexpr char const * const name{"BoolValExp"};
  static constexpr unsigned long variant{317};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgBoolValExp,int,&SgBoolValExp::p_value>>;
};
template <> struct node_from_variant_t<317> { using type = SgBoolValExp; };

// Class: BreakStmt
template <> struct describe_field_t<SgBreakStmt,std::string,&SgBreakStmt::p_do_string_label> {
  using parent = SgBreakStmt;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"do_string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBreakStmt::p_do_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBreakStmt, std::string SgBreakStmt::*, &SgBreakStmt::p_do_string_label>;
};
template <> struct describe_node_t<SgBreakStmt> {
  using node = SgBreakStmt;
  using base = SgStatement;
  static constexpr char const * const name{"BreakStmt"};
  static constexpr unsigned long variant{318};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgBreakStmt,std::string,&SgBreakStmt::p_do_string_label>>;
};
template <> struct node_from_variant_t<318> { using type = SgBreakStmt; };

// Class: BracedInitializer
template <> struct describe_field_t<SgBracedInitializer,SgExprListExp*,&SgBracedInitializer::p_initializers> {
  using parent = SgBracedInitializer;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"initializers"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgBracedInitializer::p_initializers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBracedInitializer, SgExprListExp* SgBracedInitializer::*, &SgBracedInitializer::p_initializers>;
};
template <> struct describe_field_t<SgBracedInitializer,SgType*,&SgBracedInitializer::p_expression_type> {
  using parent = SgBracedInitializer;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgBracedInitializer::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgBracedInitializer, SgType* SgBracedInitializer::*, &SgBracedInitializer::p_expression_type>;
};
template <> struct describe_node_t<SgBracedInitializer> {
  using node = SgBracedInitializer;
  using base = SgInitializer;
  static constexpr char const * const name{"BracedInitializer"};
  static constexpr unsigned long variant{319};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgBracedInitializer,SgExprListExp*,&SgBracedInitializer::p_initializers>, describe_field_t<SgBracedInitializer,SgType*,&SgBracedInitializer::p_expression_type>>;
};
template <> struct node_from_variant_t<319> { using type = SgBracedInitializer; };

// Class: C_PreprocessorDirectiveStatement
template <> struct describe_field_t<SgC_PreprocessorDirectiveStatement,std::string,&SgC_PreprocessorDirectiveStatement::p_directiveString> {
  using parent = SgC_PreprocessorDirectiveStatement;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"directiveString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgC_PreprocessorDirectiveStatement::p_directiveString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgC_PreprocessorDirectiveStatement, std::string SgC_PreprocessorDirectiveStatement::*, &SgC_PreprocessorDirectiveStatement::p_directiveString>;
};
template <> struct describe_node_t<SgC_PreprocessorDirectiveStatement> {
  using node = SgC_PreprocessorDirectiveStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"C_PreprocessorDirectiveStatement"};
  static constexpr unsigned long variant{320};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgIncludeDirectiveStatement, SgDefineDirectiveStatement, SgUndefDirectiveStatement, SgIfdefDirectiveStatement, SgIfndefDirectiveStatement, SgIfDirectiveStatement, SgDeadIfDirectiveStatement, SgElseDirectiveStatement, SgElseifDirectiveStatement, SgEndifDirectiveStatement, SgLineDirectiveStatement, SgWarningDirectiveStatement, SgErrorDirectiveStatement, SgEmptyDirectiveStatement, SgIncludeNextDirectiveStatement, SgIdentDirectiveStatement, SgLinemarkerDirectiveStatement>;
  using fields_t = mp::List<describe_field_t<SgC_PreprocessorDirectiveStatement,std::string,&SgC_PreprocessorDirectiveStatement::p_directiveString>>;
};
template <> struct node_from_variant_t<320> { using type = SgC_PreprocessorDirectiveStatement; };

// Class: CaseOptionStmt
template <> struct describe_field_t<SgCaseOptionStmt,SgExpression*,&SgCaseOptionStmt::p_key> {
  using parent = SgCaseOptionStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"key"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCaseOptionStmt::p_key};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCaseOptionStmt, SgExpression* SgCaseOptionStmt::*, &SgCaseOptionStmt::p_key>;
};
template <> struct describe_field_t<SgCaseOptionStmt,SgStatement*,&SgCaseOptionStmt::p_body> {
  using parent = SgCaseOptionStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCaseOptionStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCaseOptionStmt, SgStatement* SgCaseOptionStmt::*, &SgCaseOptionStmt::p_body>;
};
template <> struct describe_field_t<SgCaseOptionStmt,SgExpression*,&SgCaseOptionStmt::p_key_range_end> {
  using parent = SgCaseOptionStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"key_range_end"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCaseOptionStmt::p_key_range_end};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCaseOptionStmt, SgExpression* SgCaseOptionStmt::*, &SgCaseOptionStmt::p_key_range_end>;
};
template <> struct describe_field_t<SgCaseOptionStmt,std::string,&SgCaseOptionStmt::p_case_construct_name> {
  using parent = SgCaseOptionStmt;
  using field_type = std::string;
  static constexpr size_t position{3};
  static constexpr char const * const name{"case_construct_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCaseOptionStmt::p_case_construct_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCaseOptionStmt, std::string SgCaseOptionStmt::*, &SgCaseOptionStmt::p_case_construct_name>;
};
template <> struct describe_field_t<SgCaseOptionStmt,bool,&SgCaseOptionStmt::p_has_fall_through> {
  using parent = SgCaseOptionStmt;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"has_fall_through"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCaseOptionStmt::p_has_fall_through};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCaseOptionStmt, bool SgCaseOptionStmt::*, &SgCaseOptionStmt::p_has_fall_through>;
};
template <> struct describe_node_t<SgCaseOptionStmt> {
  using node = SgCaseOptionStmt;
  using base = SgStatement;
  static constexpr char const * const name{"CaseOptionStmt"};
  static constexpr unsigned long variant{321};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCaseOptionStmt,SgExpression*,&SgCaseOptionStmt::p_key>, describe_field_t<SgCaseOptionStmt,SgStatement*,&SgCaseOptionStmt::p_body>, describe_field_t<SgCaseOptionStmt,SgExpression*,&SgCaseOptionStmt::p_key_range_end>, describe_field_t<SgCaseOptionStmt,std::string,&SgCaseOptionStmt::p_case_construct_name>, describe_field_t<SgCaseOptionStmt,bool,&SgCaseOptionStmt::p_has_fall_through>>;
};
template <> struct node_from_variant_t<321> { using type = SgCaseOptionStmt; };

// Class: CastExp
template <> struct describe_field_t<SgCastExp,SgCastExp::cast_type_enum,&SgCastExp::p_cast_type> {
  using parent = SgCastExp;
  using field_type = SgCastExp::cast_type_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"cast_type"};
  static constexpr char const * const typestr{"SgCastExp::cast_type_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCastExp::p_cast_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCastExp, SgCastExp::cast_type_enum SgCastExp::*, &SgCastExp::p_cast_type>;
};
template <> struct describe_field_t<SgCastExp,SgExpression*,&SgCastExp::p_originalExpressionTree> {
  using parent = SgCastExp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"originalExpressionTree"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCastExp::p_originalExpressionTree};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCastExp, SgExpression* SgCastExp::*, &SgCastExp::p_originalExpressionTree>;
};
template <> struct describe_field_t<SgCastExp,int,&SgCastExp::p_name_qualification_length> {
  using parent = SgCastExp;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCastExp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCastExp, int SgCastExp::*, &SgCastExp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgCastExp,bool,&SgCastExp::p_type_elaboration_required> {
  using parent = SgCastExp;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCastExp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCastExp, bool SgCastExp::*, &SgCastExp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgCastExp,bool,&SgCastExp::p_global_qualification_required> {
  using parent = SgCastExp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCastExp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCastExp, bool SgCastExp::*, &SgCastExp::p_global_qualification_required>;
};
template <> struct describe_field_t<SgCastExp,bool,&SgCastExp::p_castContainsBaseTypeDefiningDeclaration> {
  using parent = SgCastExp;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"castContainsBaseTypeDefiningDeclaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCastExp::p_castContainsBaseTypeDefiningDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCastExp, bool SgCastExp::*, &SgCastExp::p_castContainsBaseTypeDefiningDeclaration>;
};
template <> struct describe_field_t<SgCastExp,int,&SgCastExp::p_name_qualification_for_pointer_to_member_class_length> {
  using parent = SgCastExp;
  using field_type = int;
  static constexpr size_t position{6};
  static constexpr char const * const name{"name_qualification_for_pointer_to_member_class_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCastExp::p_name_qualification_for_pointer_to_member_class_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCastExp, int SgCastExp::*, &SgCastExp::p_name_qualification_for_pointer_to_member_class_length>;
};
template <> struct describe_field_t<SgCastExp,bool,&SgCastExp::p_type_elaboration_for_pointer_to_member_class_required> {
  using parent = SgCastExp;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"type_elaboration_for_pointer_to_member_class_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCastExp::p_type_elaboration_for_pointer_to_member_class_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCastExp, bool SgCastExp::*, &SgCastExp::p_type_elaboration_for_pointer_to_member_class_required>;
};
template <> struct describe_field_t<SgCastExp,bool,&SgCastExp::p_global_qualification_for_pointer_to_member_class_required> {
  using parent = SgCastExp;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"global_qualification_for_pointer_to_member_class_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCastExp::p_global_qualification_for_pointer_to_member_class_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCastExp, bool SgCastExp::*, &SgCastExp::p_global_qualification_for_pointer_to_member_class_required>;
};
template <> struct describe_node_t<SgCastExp> {
  using node = SgCastExp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"CastExp"};
  static constexpr unsigned long variant{322};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCastExp,SgCastExp::cast_type_enum,&SgCastExp::p_cast_type>, describe_field_t<SgCastExp,SgExpression*,&SgCastExp::p_originalExpressionTree>, describe_field_t<SgCastExp,int,&SgCastExp::p_name_qualification_length>, describe_field_t<SgCastExp,bool,&SgCastExp::p_type_elaboration_required>, describe_field_t<SgCastExp,bool,&SgCastExp::p_global_qualification_required>, describe_field_t<SgCastExp,bool,&SgCastExp::p_castContainsBaseTypeDefiningDeclaration>, describe_field_t<SgCastExp,int,&SgCastExp::p_name_qualification_for_pointer_to_member_class_length>, describe_field_t<SgCastExp,bool,&SgCastExp::p_type_elaboration_for_pointer_to_member_class_required>, describe_field_t<SgCastExp,bool,&SgCastExp::p_global_qualification_for_pointer_to_member_class_required>>;
};
template <> struct node_from_variant_t<322> { using type = SgCastExp; };

// Class: CatchOptionStmt
template <> struct describe_field_t<SgCatchOptionStmt,SgVariableDeclaration*,&SgCatchOptionStmt::p_condition> {
  using parent = SgCatchOptionStmt;
  using field_type = SgVariableDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"condition"};
  static constexpr char const * const typestr{"SgVariableDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCatchOptionStmt::p_condition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCatchOptionStmt, SgVariableDeclaration* SgCatchOptionStmt::*, &SgCatchOptionStmt::p_condition>;
};
template <> struct describe_field_t<SgCatchOptionStmt,SgStatement*,&SgCatchOptionStmt::p_body> {
  using parent = SgCatchOptionStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCatchOptionStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCatchOptionStmt, SgStatement* SgCatchOptionStmt::*, &SgCatchOptionStmt::p_body>;
};
template <> struct describe_field_t<SgCatchOptionStmt,SgTryStmt*,&SgCatchOptionStmt::p_trystmt> {
  using parent = SgCatchOptionStmt;
  using field_type = SgTryStmt*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"trystmt"};
  static constexpr char const * const typestr{"SgTryStmt*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCatchOptionStmt::p_trystmt};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCatchOptionStmt, SgTryStmt* SgCatchOptionStmt::*, &SgCatchOptionStmt::p_trystmt>;
};
template <> struct describe_node_t<SgCatchOptionStmt> {
  using node = SgCatchOptionStmt;
  using base = SgScopeStatement;
  static constexpr char const * const name{"CatchOptionStmt"};
  static constexpr unsigned long variant{323};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCatchOptionStmt,SgVariableDeclaration*,&SgCatchOptionStmt::p_condition>, describe_field_t<SgCatchOptionStmt,SgStatement*,&SgCatchOptionStmt::p_body>, describe_field_t<SgCatchOptionStmt,SgTryStmt*,&SgCatchOptionStmt::p_trystmt>>;
};
template <> struct node_from_variant_t<323> { using type = SgCatchOptionStmt; };

// Class: CatchStatementSeq
template <> struct describe_field_t<SgCatchStatementSeq,SgStatementPtrList,&SgCatchStatementSeq::p_catch_statement_seq> {
  using parent = SgCatchStatementSeq;
  using field_type = SgStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"catch_statement_seq"};
  static constexpr char const * const typestr{"SgStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCatchStatementSeq::p_catch_statement_seq};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCatchStatementSeq, SgStatementPtrList SgCatchStatementSeq::*, &SgCatchStatementSeq::p_catch_statement_seq>;
};
template <> struct describe_node_t<SgCatchStatementSeq> {
  using node = SgCatchStatementSeq;
  using base = SgStatement;
  static constexpr char const * const name{"CatchStatementSeq"};
  static constexpr unsigned long variant{324};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCatchStatementSeq,SgStatementPtrList,&SgCatchStatementSeq::p_catch_statement_seq>>;
};
template <> struct node_from_variant_t<324> { using type = SgCatchStatementSeq; };

// Class: CharVal
template <> struct describe_field_t<SgCharVal,char,&SgCharVal::p_value> {
  using parent = SgCharVal;
  using field_type = char;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"char"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCharVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCharVal, char SgCharVal::*, &SgCharVal::p_value>;
};
template <> struct describe_field_t<SgCharVal,std::string,&SgCharVal::p_valueString> {
  using parent = SgCharVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCharVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCharVal, std::string SgCharVal::*, &SgCharVal::p_valueString>;
};
template <> struct describe_node_t<SgCharVal> {
  using node = SgCharVal;
  using base = SgValueExp;
  static constexpr char const * const name{"CharVal"};
  static constexpr unsigned long variant{325};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCharVal,char,&SgCharVal::p_value>, describe_field_t<SgCharVal,std::string,&SgCharVal::p_valueString>>;
};
template <> struct node_from_variant_t<325> { using type = SgCharVal; };

// Class: Char16Val
template <> struct describe_field_t<SgChar16Val,unsigned short,&SgChar16Val::p_valueUL> {
  using parent = SgChar16Val;
  using field_type = unsigned short;
  static constexpr size_t position{0};
  static constexpr char const * const name{"valueUL"};
  static constexpr char const * const typestr{"unsigned short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgChar16Val::p_valueUL};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgChar16Val, unsigned short SgChar16Val::*, &SgChar16Val::p_valueUL>;
};
template <> struct describe_field_t<SgChar16Val,std::string,&SgChar16Val::p_valueString> {
  using parent = SgChar16Val;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgChar16Val::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgChar16Val, std::string SgChar16Val::*, &SgChar16Val::p_valueString>;
};
template <> struct describe_node_t<SgChar16Val> {
  using node = SgChar16Val;
  using base = SgValueExp;
  static constexpr char const * const name{"Char16Val"};
  static constexpr unsigned long variant{326};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgChar16Val,unsigned short,&SgChar16Val::p_valueUL>, describe_field_t<SgChar16Val,std::string,&SgChar16Val::p_valueString>>;
};
template <> struct node_from_variant_t<326> { using type = SgChar16Val; };

// Class: Char32Val
template <> struct describe_field_t<SgChar32Val,unsigned int,&SgChar32Val::p_valueUL> {
  using parent = SgChar32Val;
  using field_type = unsigned int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"valueUL"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgChar32Val::p_valueUL};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgChar32Val, unsigned int SgChar32Val::*, &SgChar32Val::p_valueUL>;
};
template <> struct describe_field_t<SgChar32Val,std::string,&SgChar32Val::p_valueString> {
  using parent = SgChar32Val;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgChar32Val::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgChar32Val, std::string SgChar32Val::*, &SgChar32Val::p_valueString>;
};
template <> struct describe_node_t<SgChar32Val> {
  using node = SgChar32Val;
  using base = SgValueExp;
  static constexpr char const * const name{"Char32Val"};
  static constexpr unsigned long variant{327};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgChar32Val,unsigned int,&SgChar32Val::p_valueUL>, describe_field_t<SgChar32Val,std::string,&SgChar32Val::p_valueString>>;
};
template <> struct node_from_variant_t<327> { using type = SgChar32Val; };

// Class: ChooseExpression
template <> struct describe_field_t<SgChooseExpression,SgExpression*,&SgChooseExpression::p_value> {
  using parent = SgChooseExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgChooseExpression::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgChooseExpression, SgExpression* SgChooseExpression::*, &SgChooseExpression::p_value>;
};
template <> struct describe_node_t<SgChooseExpression> {
  using node = SgChooseExpression;
  using base = SgExpression;
  static constexpr char const * const name{"ChooseExpression"};
  static constexpr unsigned long variant{328};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgChooseExpression,SgExpression*,&SgChooseExpression::p_value>>;
};
template <> struct node_from_variant_t<328> { using type = SgChooseExpression; };

// Class: ClassDecl_attr
template <> struct describe_node_t<SgClassDecl_attr> {
  using node = SgClassDecl_attr;
  using base = SgBitAttribute;
  static constexpr char const * const name{"ClassDecl_attr"};
  static constexpr unsigned long variant{329};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<329> { using type = SgClassDecl_attr; };

// Class: ClassDeclaration
template <> struct describe_field_t<SgClassDeclaration,SgName,&SgClassDeclaration::p_name> {
  using parent = SgClassDeclaration;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, SgName SgClassDeclaration::*, &SgClassDeclaration::p_name>;
};
template <> struct describe_field_t<SgClassDeclaration,SgClassDeclaration::class_types,&SgClassDeclaration::p_class_type> {
  using parent = SgClassDeclaration;
  using field_type = SgClassDeclaration::class_types;
  static constexpr size_t position{1};
  static constexpr char const * const name{"class_type"};
  static constexpr char const * const typestr{"SgClassDeclaration::class_types"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_class_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, SgClassDeclaration::class_types SgClassDeclaration::*, &SgClassDeclaration::p_class_type>;
};
template <> struct describe_field_t<SgClassDeclaration,SgClassType*,&SgClassDeclaration::p_type> {
  using parent = SgClassDeclaration;
  using field_type = SgClassType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgClassType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, SgClassType* SgClassDeclaration::*, &SgClassDeclaration::p_type>;
};
template <> struct describe_field_t<SgClassDeclaration,SgClassDefinition*,&SgClassDeclaration::p_definition> {
  using parent = SgClassDeclaration;
  using field_type = SgClassDefinition*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgClassDefinition*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, SgClassDefinition* SgClassDeclaration::*, &SgClassDeclaration::p_definition>;
};
template <> struct describe_field_t<SgClassDeclaration,SgScopeStatement*,&SgClassDeclaration::p_scope> {
  using parent = SgClassDeclaration;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, SgScopeStatement* SgClassDeclaration::*, &SgClassDeclaration::p_scope>;
};
template <> struct describe_field_t<SgClassDeclaration,SgDeclarationStatement::template_specialization_enum,&SgClassDeclaration::p_specialization> {
  using parent = SgClassDeclaration;
  using field_type = SgDeclarationStatement::template_specialization_enum;
  static constexpr size_t position{5};
  static constexpr char const * const name{"specialization"};
  static constexpr char const * const typestr{"SgDeclarationStatement::template_specialization_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_specialization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, SgDeclarationStatement::template_specialization_enum SgClassDeclaration::*, &SgClassDeclaration::p_specialization>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_from_template> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"from_template"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_from_template};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_from_template>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_fixupScope> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"fixupScope"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_fixupScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_fixupScope>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_isUnNamed> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"isUnNamed"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_isUnNamed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_isUnNamed>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_explicit_annotation_interface> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"explicit_annotation_interface"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_explicit_annotation_interface};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_explicit_annotation_interface>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_explicit_interface> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"explicit_interface"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_explicit_interface};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_explicit_interface>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_explicit_enum> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"explicit_enum"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_explicit_enum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_explicit_enum>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_explicit_anonymous> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{12};
  static constexpr char const * const name{"explicit_anonymous"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_explicit_anonymous};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_explicit_anonymous>;
};
template <> struct describe_field_t<SgClassDeclaration,SgExprListExp*,&SgClassDeclaration::p_decoratorList> {
  using parent = SgClassDeclaration;
  using field_type = SgExprListExp*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"decoratorList"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_decoratorList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, SgExprListExp* SgClassDeclaration::*, &SgClassDeclaration::p_decoratorList>;
};
template <> struct describe_field_t<SgClassDeclaration,int,&SgClassDeclaration::p_name_qualification_length> {
  using parent = SgClassDeclaration;
  using field_type = int;
  static constexpr size_t position{14};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, int SgClassDeclaration::*, &SgClassDeclaration::p_name_qualification_length>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_type_elaboration_required> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{15};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_global_qualification_required> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{16};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_global_qualification_required>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_isAutonomousDeclaration> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{17};
  static constexpr char const * const name{"isAutonomousDeclaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_isAutonomousDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_isAutonomousDeclaration>;
};
template <> struct describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_isRepresentingTemplateParameterInTemplateDeclaration> {
  using parent = SgClassDeclaration;
  using field_type = bool;
  static constexpr size_t position{18};
  static constexpr char const * const name{"isRepresentingTemplateParameterInTemplateDeclaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_isRepresentingTemplateParameterInTemplateDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, bool SgClassDeclaration::*, &SgClassDeclaration::p_isRepresentingTemplateParameterInTemplateDeclaration>;
};
template <> struct describe_field_t<SgClassDeclaration,SgBaseClass*,&SgClassDeclaration::p_adaParentType> {
  using parent = SgClassDeclaration;
  using field_type = SgBaseClass*;
  static constexpr size_t position{19};
  static constexpr char const * const name{"adaParentType"};
  static constexpr char const * const typestr{"SgBaseClass*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDeclaration::p_adaParentType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDeclaration, SgBaseClass* SgClassDeclaration::*, &SgClassDeclaration::p_adaParentType>;
};
template <> struct describe_node_t<SgClassDeclaration> {
  using node = SgClassDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"ClassDeclaration"};
  static constexpr unsigned long variant{330};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateClassDeclaration, SgTemplateInstantiationDecl, SgDerivedTypeStatement, SgModuleStatement, SgJavaPackageDeclaration, SgJovialTableStatement>;
  using fields_t = mp::List<describe_field_t<SgClassDeclaration,SgName,&SgClassDeclaration::p_name>, describe_field_t<SgClassDeclaration,SgClassDeclaration::class_types,&SgClassDeclaration::p_class_type>, describe_field_t<SgClassDeclaration,SgClassType*,&SgClassDeclaration::p_type>, describe_field_t<SgClassDeclaration,SgClassDefinition*,&SgClassDeclaration::p_definition>, describe_field_t<SgClassDeclaration,SgScopeStatement*,&SgClassDeclaration::p_scope>, describe_field_t<SgClassDeclaration,SgDeclarationStatement::template_specialization_enum,&SgClassDeclaration::p_specialization>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_from_template>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_fixupScope>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_isUnNamed>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_explicit_annotation_interface>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_explicit_interface>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_explicit_enum>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_explicit_anonymous>, describe_field_t<SgClassDeclaration,SgExprListExp*,&SgClassDeclaration::p_decoratorList>, describe_field_t<SgClassDeclaration,int,&SgClassDeclaration::p_name_qualification_length>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_type_elaboration_required>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_global_qualification_required>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_isAutonomousDeclaration>, describe_field_t<SgClassDeclaration,bool,&SgClassDeclaration::p_isRepresentingTemplateParameterInTemplateDeclaration>, describe_field_t<SgClassDeclaration,SgBaseClass*,&SgClassDeclaration::p_adaParentType>>;
};
template <> struct node_from_variant_t<330> { using type = SgClassDeclaration; };

// Class: ClassDefinition
template <> struct describe_field_t<SgClassDefinition,SgDeclarationStatementPtrList,&SgClassDefinition::p_members> {
  using parent = SgClassDefinition;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"members"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgClassDefinition::p_members};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDefinition, SgDeclarationStatementPtrList SgClassDefinition::*, &SgClassDefinition::p_members>;
};
template <> struct describe_field_t<SgClassDefinition,SgBaseClassPtrList,&SgClassDefinition::p_inheritances> {
  using parent = SgClassDefinition;
  using field_type = SgBaseClassPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"inheritances"};
  static constexpr char const * const typestr{"SgBaseClassPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDefinition::p_inheritances};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDefinition, SgBaseClassPtrList SgClassDefinition::*, &SgClassDefinition::p_inheritances>;
};
template <> struct describe_field_t<SgClassDefinition,unsigned int,&SgClassDefinition::p_packingAlignment> {
  using parent = SgClassDefinition;
  using field_type = unsigned int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"packingAlignment"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDefinition::p_packingAlignment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDefinition, unsigned int SgClassDefinition::*, &SgClassDefinition::p_packingAlignment>;
};
template <> struct describe_field_t<SgClassDefinition,bool,&SgClassDefinition::p_isSequence> {
  using parent = SgClassDefinition;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"isSequence"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDefinition::p_isSequence};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDefinition, bool SgClassDefinition::*, &SgClassDefinition::p_isSequence>;
};
template <> struct describe_field_t<SgClassDefinition,bool,&SgClassDefinition::p_isPrivate> {
  using parent = SgClassDefinition;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"isPrivate"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDefinition::p_isPrivate};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDefinition, bool SgClassDefinition::*, &SgClassDefinition::p_isPrivate>;
};
template <> struct describe_field_t<SgClassDefinition,bool,&SgClassDefinition::p_isAbstract> {
  using parent = SgClassDefinition;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"isAbstract"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassDefinition::p_isAbstract};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassDefinition, bool SgClassDefinition::*, &SgClassDefinition::p_isAbstract>;
};
template <> struct describe_node_t<SgClassDefinition> {
  using node = SgClassDefinition;
  using base = SgScopeStatement;
  static constexpr char const * const name{"ClassDefinition"};
  static constexpr unsigned long variant{331};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateInstantiationDefn, SgTemplateClassDefinition>;
  using fields_t = mp::List<describe_field_t<SgClassDefinition,SgDeclarationStatementPtrList,&SgClassDefinition::p_members>, describe_field_t<SgClassDefinition,SgBaseClassPtrList,&SgClassDefinition::p_inheritances>, describe_field_t<SgClassDefinition,unsigned int,&SgClassDefinition::p_packingAlignment>, describe_field_t<SgClassDefinition,bool,&SgClassDefinition::p_isSequence>, describe_field_t<SgClassDefinition,bool,&SgClassDefinition::p_isPrivate>, describe_field_t<SgClassDefinition,bool,&SgClassDefinition::p_isAbstract>>;
};
template <> struct node_from_variant_t<331> { using type = SgClassDefinition; };

// Class: ClassNameRefExp
template <> struct describe_field_t<SgClassNameRefExp,SgClassSymbol*,&SgClassNameRefExp::p_symbol> {
  using parent = SgClassNameRefExp;
  using field_type = SgClassSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgClassSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassNameRefExp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassNameRefExp, SgClassSymbol* SgClassNameRefExp::*, &SgClassNameRefExp::p_symbol>;
};
template <> struct describe_node_t<SgClassNameRefExp> {
  using node = SgClassNameRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"ClassNameRefExp"};
  static constexpr unsigned long variant{332};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgClassNameRefExp,SgClassSymbol*,&SgClassNameRefExp::p_symbol>>;
};
template <> struct node_from_variant_t<332> { using type = SgClassNameRefExp; };

// Class: ClassSymbol
template <> struct describe_field_t<SgClassSymbol,SgClassDeclaration*,&SgClassSymbol::p_declaration> {
  using parent = SgClassSymbol;
  using field_type = SgClassDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgClassDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgClassSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassSymbol, SgClassDeclaration* SgClassSymbol::*, &SgClassSymbol::p_declaration>;
};
template <> struct describe_node_t<SgClassSymbol> {
  using node = SgClassSymbol;
  using base = SgTypeSymbol;
  static constexpr char const * const name{"ClassSymbol"};
  static constexpr unsigned long variant{333};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateClassSymbol>;
  using fields_t = mp::List<describe_field_t<SgClassSymbol,SgClassDeclaration*,&SgClassSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<333> { using type = SgClassSymbol; };

// Class: ClassType
template <> struct describe_field_t<SgClassType,bool,&SgClassType::p_packed> {
  using parent = SgClassType;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"packed"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassType::p_packed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassType, bool SgClassType::*, &SgClassType::p_packed>;
};
template <> struct describe_node_t<SgClassType> {
  using node = SgClassType;
  using base = SgNamedType;
  static constexpr char const * const name{"ClassType"};
  static constexpr unsigned long variant{334};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgJavaParameterType, SgJovialTableType>;
  using fields_t = mp::List<describe_field_t<SgClassType,bool,&SgClassType::p_packed>>;
};
template <> struct node_from_variant_t<334> { using type = SgClassType; };

// Class: ClinkageDeclarationStatement
template <> struct describe_field_t<SgClinkageDeclarationStatement,std::string,&SgClinkageDeclarationStatement::p_languageSpecifier> {
  using parent = SgClinkageDeclarationStatement;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"languageSpecifier"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClinkageDeclarationStatement::p_languageSpecifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClinkageDeclarationStatement, std::string SgClinkageDeclarationStatement::*, &SgClinkageDeclarationStatement::p_languageSpecifier>;
};
template <> struct describe_node_t<SgClinkageDeclarationStatement> {
  using node = SgClinkageDeclarationStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"ClinkageDeclarationStatement"};
  static constexpr unsigned long variant{335};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgClinkageStartStatement, SgClinkageEndStatement>;
  using fields_t = mp::List<describe_field_t<SgClinkageDeclarationStatement,std::string,&SgClinkageDeclarationStatement::p_languageSpecifier>>;
};
template <> struct node_from_variant_t<335> { using type = SgClinkageDeclarationStatement; };

// Class: ClinkageEndStatement
template <> struct describe_node_t<SgClinkageEndStatement> {
  using node = SgClinkageEndStatement;
  using base = SgClinkageDeclarationStatement;
  static constexpr char const * const name{"ClinkageEndStatement"};
  static constexpr unsigned long variant{336};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<336> { using type = SgClinkageEndStatement; };

// Class: ClinkageStartStatement
template <> struct describe_node_t<SgClinkageStartStatement> {
  using node = SgClinkageStartStatement;
  using base = SgClinkageDeclarationStatement;
  static constexpr char const * const name{"ClinkageStartStatement"};
  static constexpr unsigned long variant{337};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<337> { using type = SgClinkageStartStatement; };

// Class: CloseStatement
template <> struct describe_field_t<SgCloseStatement,SgExpression*,&SgCloseStatement::p_status> {
  using parent = SgCloseStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"status"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCloseStatement::p_status};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCloseStatement, SgExpression* SgCloseStatement::*, &SgCloseStatement::p_status>;
};
template <> struct describe_node_t<SgCloseStatement> {
  using node = SgCloseStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"CloseStatement"};
  static constexpr unsigned long variant{338};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCloseStatement,SgExpression*,&SgCloseStatement::p_status>>;
};
template <> struct node_from_variant_t<338> { using type = SgCloseStatement; };

// Class: ColonShapeExp
template <> struct describe_node_t<SgColonShapeExp> {
  using node = SgColonShapeExp;
  using base = SgExpression;
  static constexpr char const * const name{"ColonShapeExp"};
  static constexpr unsigned long variant{339};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<339> { using type = SgColonShapeExp; };

// Class: CommaOpExp
template <> struct describe_node_t<SgCommaOpExp> {
  using node = SgCommaOpExp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"CommaOpExp"};
  static constexpr unsigned long variant{340};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<340> { using type = SgCommaOpExp; };

// Class: CommonBlock
template <> struct describe_field_t<SgCommonBlock,SgCommonBlockObjectPtrList,&SgCommonBlock::p_block_list> {
  using parent = SgCommonBlock;
  using field_type = SgCommonBlockObjectPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"block_list"};
  static constexpr char const * const typestr{"SgCommonBlockObjectPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCommonBlock::p_block_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCommonBlock, SgCommonBlockObjectPtrList SgCommonBlock::*, &SgCommonBlock::p_block_list>;
};
template <> struct describe_node_t<SgCommonBlock> {
  using node = SgCommonBlock;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"CommonBlock"};
  static constexpr unsigned long variant{341};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCommonBlock,SgCommonBlockObjectPtrList,&SgCommonBlock::p_block_list>>;
};
template <> struct node_from_variant_t<341> { using type = SgCommonBlock; };

// Class: CommonBlockObject
template <> struct describe_field_t<SgCommonBlockObject,std::string,&SgCommonBlockObject::p_block_name> {
  using parent = SgCommonBlockObject;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"block_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCommonBlockObject::p_block_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCommonBlockObject, std::string SgCommonBlockObject::*, &SgCommonBlockObject::p_block_name>;
};
template <> struct describe_field_t<SgCommonBlockObject,SgExprListExp*,&SgCommonBlockObject::p_variable_reference_list> {
  using parent = SgCommonBlockObject;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"variable_reference_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCommonBlockObject::p_variable_reference_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCommonBlockObject, SgExprListExp* SgCommonBlockObject::*, &SgCommonBlockObject::p_variable_reference_list>;
};
template <> struct describe_node_t<SgCommonBlockObject> {
  using node = SgCommonBlockObject;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"CommonBlockObject"};
  static constexpr unsigned long variant{342};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCommonBlockObject,std::string,&SgCommonBlockObject::p_block_name>, describe_field_t<SgCommonBlockObject,SgExprListExp*,&SgCommonBlockObject::p_variable_reference_list>>;
};
template <> struct node_from_variant_t<342> { using type = SgCommonBlockObject; };

// Class: CommonSymbol
template <> struct describe_field_t<SgCommonSymbol,SgInitializedName*,&SgCommonSymbol::p_declaration> {
  using parent = SgCommonSymbol;
  using field_type = SgInitializedName*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCommonSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCommonSymbol, SgInitializedName* SgCommonSymbol::*, &SgCommonSymbol::p_declaration>;
};
template <> struct describe_node_t<SgCommonSymbol> {
  using node = SgCommonSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"CommonSymbol"};
  static constexpr unsigned long variant{343};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCommonSymbol,SgInitializedName*,&SgCommonSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<343> { using type = SgCommonSymbol; };

// Class: ComplexVal
template <> struct describe_field_t<SgComplexVal,SgValueExp*,&SgComplexVal::p_real_value> {
  using parent = SgComplexVal;
  using field_type = SgValueExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"real_value"};
  static constexpr char const * const typestr{"SgValueExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgComplexVal::p_real_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgComplexVal, SgValueExp* SgComplexVal::*, &SgComplexVal::p_real_value>;
};
template <> struct describe_field_t<SgComplexVal,SgValueExp*,&SgComplexVal::p_imaginary_value> {
  using parent = SgComplexVal;
  using field_type = SgValueExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"imaginary_value"};
  static constexpr char const * const typestr{"SgValueExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgComplexVal::p_imaginary_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgComplexVal, SgValueExp* SgComplexVal::*, &SgComplexVal::p_imaginary_value>;
};
template <> struct describe_field_t<SgComplexVal,SgType*,&SgComplexVal::p_precisionType> {
  using parent = SgComplexVal;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"precisionType"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgComplexVal::p_precisionType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgComplexVal, SgType* SgComplexVal::*, &SgComplexVal::p_precisionType>;
};
template <> struct describe_field_t<SgComplexVal,std::string,&SgComplexVal::p_valueString> {
  using parent = SgComplexVal;
  using field_type = std::string;
  static constexpr size_t position{3};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgComplexVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgComplexVal, std::string SgComplexVal::*, &SgComplexVal::p_valueString>;
};
template <> struct describe_node_t<SgComplexVal> {
  using node = SgComplexVal;
  using base = SgValueExp;
  static constexpr char const * const name{"ComplexVal"};
  static constexpr unsigned long variant{344};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgComplexVal,SgValueExp*,&SgComplexVal::p_real_value>, describe_field_t<SgComplexVal,SgValueExp*,&SgComplexVal::p_imaginary_value>, describe_field_t<SgComplexVal,SgType*,&SgComplexVal::p_precisionType>, describe_field_t<SgComplexVal,std::string,&SgComplexVal::p_valueString>>;
};
template <> struct node_from_variant_t<344> { using type = SgComplexVal; };

// Class: Comprehension
template <> struct describe_field_t<SgComprehension,SgExpression*,&SgComprehension::p_target> {
  using parent = SgComprehension;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"target"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgComprehension::p_target};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgComprehension, SgExpression* SgComprehension::*, &SgComprehension::p_target>;
};
template <> struct describe_field_t<SgComprehension,SgExpression*,&SgComprehension::p_iter> {
  using parent = SgComprehension;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"iter"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgComprehension::p_iter};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgComprehension, SgExpression* SgComprehension::*, &SgComprehension::p_iter>;
};
template <> struct describe_field_t<SgComprehension,SgExprListExp*,&SgComprehension::p_filters> {
  using parent = SgComprehension;
  using field_type = SgExprListExp*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"filters"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgComprehension::p_filters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgComprehension, SgExprListExp* SgComprehension::*, &SgComprehension::p_filters>;
};
template <> struct describe_node_t<SgComprehension> {
  using node = SgComprehension;
  using base = SgExpression;
  static constexpr char const * const name{"Comprehension"};
  static constexpr unsigned long variant{345};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgComprehension,SgExpression*,&SgComprehension::p_target>, describe_field_t<SgComprehension,SgExpression*,&SgComprehension::p_iter>, describe_field_t<SgComprehension,SgExprListExp*,&SgComprehension::p_filters>>;
};
template <> struct node_from_variant_t<345> { using type = SgComprehension; };

// Class: CompoundAssignOp
template <> struct describe_node_t<SgCompoundAssignOp> {
  using node = SgCompoundAssignOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"CompoundAssignOp"};
  static constexpr unsigned long variant{347};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgPlusAssignOp, SgMinusAssignOp, SgAndAssignOp, SgIorAssignOp, SgMultAssignOp, SgDivAssignOp, SgModAssignOp, SgXorAssignOp, SgLshiftAssignOp, SgRshiftAssignOp, SgJavaUnsignedRshiftAssignOp, SgIntegerDivideAssignOp, SgExponentiationAssignOp>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<347> { using type = SgCompoundAssignOp; };

// Class: CompoundInitializer
template <> struct describe_field_t<SgCompoundInitializer,SgExprListExp*,&SgCompoundInitializer::p_initializers> {
  using parent = SgCompoundInitializer;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"initializers"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCompoundInitializer::p_initializers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCompoundInitializer, SgExprListExp* SgCompoundInitializer::*, &SgCompoundInitializer::p_initializers>;
};
template <> struct describe_field_t<SgCompoundInitializer,SgType*,&SgCompoundInitializer::p_expression_type> {
  using parent = SgCompoundInitializer;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCompoundInitializer::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCompoundInitializer, SgType* SgCompoundInitializer::*, &SgCompoundInitializer::p_expression_type>;
};
template <> struct describe_node_t<SgCompoundInitializer> {
  using node = SgCompoundInitializer;
  using base = SgInitializer;
  static constexpr char const * const name{"CompoundInitializer"};
  static constexpr unsigned long variant{348};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCompoundInitializer,SgExprListExp*,&SgCompoundInitializer::p_initializers>, describe_field_t<SgCompoundInitializer,SgType*,&SgCompoundInitializer::p_expression_type>>;
};
template <> struct node_from_variant_t<348> { using type = SgCompoundInitializer; };

// Class: CompoundLiteralExp
template <> struct describe_field_t<SgCompoundLiteralExp,SgVariableSymbol*,&SgCompoundLiteralExp::p_symbol> {
  using parent = SgCompoundLiteralExp;
  using field_type = SgVariableSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgVariableSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCompoundLiteralExp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCompoundLiteralExp, SgVariableSymbol* SgCompoundLiteralExp::*, &SgCompoundLiteralExp::p_symbol>;
};
template <> struct describe_node_t<SgCompoundLiteralExp> {
  using node = SgCompoundLiteralExp;
  using base = SgExpression;
  static constexpr char const * const name{"CompoundLiteralExp"};
  static constexpr unsigned long variant{349};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCompoundLiteralExp,SgVariableSymbol*,&SgCompoundLiteralExp::p_symbol>>;
};
template <> struct node_from_variant_t<349> { using type = SgCompoundLiteralExp; };

// Class: ComputedGotoStatement
template <> struct describe_field_t<SgComputedGotoStatement,SgExprListExp*,&SgComputedGotoStatement::p_labelList> {
  using parent = SgComputedGotoStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"labelList"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgComputedGotoStatement::p_labelList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgComputedGotoStatement, SgExprListExp* SgComputedGotoStatement::*, &SgComputedGotoStatement::p_labelList>;
};
template <> struct describe_field_t<SgComputedGotoStatement,SgExpression*,&SgComputedGotoStatement::p_label_index> {
  using parent = SgComputedGotoStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"label_index"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgComputedGotoStatement::p_label_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgComputedGotoStatement, SgExpression* SgComputedGotoStatement::*, &SgComputedGotoStatement::p_label_index>;
};
template <> struct describe_node_t<SgComputedGotoStatement> {
  using node = SgComputedGotoStatement;
  using base = SgStatement;
  static constexpr char const * const name{"ComputedGotoStatement"};
  static constexpr unsigned long variant{350};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgComputedGotoStatement,SgExprListExp*,&SgComputedGotoStatement::p_labelList>, describe_field_t<SgComputedGotoStatement,SgExpression*,&SgComputedGotoStatement::p_label_index>>;
};
template <> struct node_from_variant_t<350> { using type = SgComputedGotoStatement; };

// Class: ConcatenationOp
template <> struct describe_node_t<SgConcatenationOp> {
  using node = SgConcatenationOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"ConcatenationOp"};
  static constexpr unsigned long variant{351};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<351> { using type = SgConcatenationOp; };

// Class: ConditionalExp
template <> struct describe_field_t<SgConditionalExp,SgExpression*,&SgConditionalExp::p_conditional_exp> {
  using parent = SgConditionalExp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"conditional_exp"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgConditionalExp::p_conditional_exp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConditionalExp, SgExpression* SgConditionalExp::*, &SgConditionalExp::p_conditional_exp>;
};
template <> struct describe_field_t<SgConditionalExp,SgExpression*,&SgConditionalExp::p_true_exp> {
  using parent = SgConditionalExp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"true_exp"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgConditionalExp::p_true_exp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConditionalExp, SgExpression* SgConditionalExp::*, &SgConditionalExp::p_true_exp>;
};
template <> struct describe_field_t<SgConditionalExp,SgExpression*,&SgConditionalExp::p_false_exp> {
  using parent = SgConditionalExp;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"false_exp"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgConditionalExp::p_false_exp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConditionalExp, SgExpression* SgConditionalExp::*, &SgConditionalExp::p_false_exp>;
};
template <> struct describe_field_t<SgConditionalExp,SgType*,&SgConditionalExp::p_expression_type> {
  using parent = SgConditionalExp;
  using field_type = SgType*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConditionalExp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConditionalExp, SgType* SgConditionalExp::*, &SgConditionalExp::p_expression_type>;
};
template <> struct describe_node_t<SgConditionalExp> {
  using node = SgConditionalExp;
  using base = SgExpression;
  static constexpr char const * const name{"ConditionalExp"};
  static constexpr unsigned long variant{352};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgConditionalExp,SgExpression*,&SgConditionalExp::p_conditional_exp>, describe_field_t<SgConditionalExp,SgExpression*,&SgConditionalExp::p_true_exp>, describe_field_t<SgConditionalExp,SgExpression*,&SgConditionalExp::p_false_exp>, describe_field_t<SgConditionalExp,SgType*,&SgConditionalExp::p_expression_type>>;
};
template <> struct node_from_variant_t<352> { using type = SgConditionalExp; };

// Class: ConjugateOp
template <> struct describe_node_t<SgConjugateOp> {
  using node = SgConjugateOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"ConjugateOp"};
  static constexpr unsigned long variant{353};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<353> { using type = SgConjugateOp; };

// Class: ConstVolatileModifier
template <> struct describe_field_t<SgConstVolatileModifier,SgConstVolatileModifier::cv_modifier_enum,&SgConstVolatileModifier::p_modifier> {
  using parent = SgConstVolatileModifier;
  using field_type = SgConstVolatileModifier::cv_modifier_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgConstVolatileModifier::cv_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstVolatileModifier::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstVolatileModifier, SgConstVolatileModifier::cv_modifier_enum SgConstVolatileModifier::*, &SgConstVolatileModifier::p_modifier>;
};
template <> struct describe_node_t<SgConstVolatileModifier> {
  using node = SgConstVolatileModifier;
  using base = SgModifier;
  static constexpr char const * const name{"ConstVolatileModifier"};
  static constexpr unsigned long variant{354};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgConstVolatileModifier,SgConstVolatileModifier::cv_modifier_enum,&SgConstVolatileModifier::p_modifier>>;
};
template <> struct node_from_variant_t<354> { using type = SgConstVolatileModifier; };

// Class: ConstructorInitializer
template <> struct describe_field_t<SgConstructorInitializer,SgMemberFunctionDeclaration*,&SgConstructorInitializer::p_declaration> {
  using parent = SgConstructorInitializer;
  using field_type = SgMemberFunctionDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgMemberFunctionDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, SgMemberFunctionDeclaration* SgConstructorInitializer::*, &SgConstructorInitializer::p_declaration>;
};
template <> struct describe_field_t<SgConstructorInitializer,SgExprListExp*,&SgConstructorInitializer::p_args> {
  using parent = SgConstructorInitializer;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"args"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, SgExprListExp* SgConstructorInitializer::*, &SgConstructorInitializer::p_args>;
};
template <> struct describe_field_t<SgConstructorInitializer,SgType*,&SgConstructorInitializer::p_expression_type> {
  using parent = SgConstructorInitializer;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, SgType* SgConstructorInitializer::*, &SgConstructorInitializer::p_expression_type>;
};
template <> struct describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_need_name> {
  using parent = SgConstructorInitializer;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"need_name"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_need_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, bool SgConstructorInitializer::*, &SgConstructorInitializer::p_need_name>;
};
template <> struct describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_need_qualifier> {
  using parent = SgConstructorInitializer;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"need_qualifier"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_need_qualifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, bool SgConstructorInitializer::*, &SgConstructorInitializer::p_need_qualifier>;
};
template <> struct describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_need_parenthesis_after_name> {
  using parent = SgConstructorInitializer;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"need_parenthesis_after_name"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_need_parenthesis_after_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, bool SgConstructorInitializer::*, &SgConstructorInitializer::p_need_parenthesis_after_name>;
};
template <> struct describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_associated_class_unknown> {
  using parent = SgConstructorInitializer;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"associated_class_unknown"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_associated_class_unknown};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, bool SgConstructorInitializer::*, &SgConstructorInitializer::p_associated_class_unknown>;
};
template <> struct describe_field_t<SgConstructorInitializer,int,&SgConstructorInitializer::p_name_qualification_length> {
  using parent = SgConstructorInitializer;
  using field_type = int;
  static constexpr size_t position{7};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, int SgConstructorInitializer::*, &SgConstructorInitializer::p_name_qualification_length>;
};
template <> struct describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_type_elaboration_required> {
  using parent = SgConstructorInitializer;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, bool SgConstructorInitializer::*, &SgConstructorInitializer::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_global_qualification_required> {
  using parent = SgConstructorInitializer;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, bool SgConstructorInitializer::*, &SgConstructorInitializer::p_global_qualification_required>;
};
template <> struct describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_is_used_in_conditional> {
  using parent = SgConstructorInitializer;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"is_used_in_conditional"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgConstructorInitializer::p_is_used_in_conditional};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgConstructorInitializer, bool SgConstructorInitializer::*, &SgConstructorInitializer::p_is_used_in_conditional>;
};
template <> struct describe_node_t<SgConstructorInitializer> {
  using node = SgConstructorInitializer;
  using base = SgInitializer;
  static constexpr char const * const name{"ConstructorInitializer"};
  static constexpr unsigned long variant{355};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgConstructorInitializer,SgMemberFunctionDeclaration*,&SgConstructorInitializer::p_declaration>, describe_field_t<SgConstructorInitializer,SgExprListExp*,&SgConstructorInitializer::p_args>, describe_field_t<SgConstructorInitializer,SgType*,&SgConstructorInitializer::p_expression_type>, describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_need_name>, describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_need_qualifier>, describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_need_parenthesis_after_name>, describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_associated_class_unknown>, describe_field_t<SgConstructorInitializer,int,&SgConstructorInitializer::p_name_qualification_length>, describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_type_elaboration_required>, describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_global_qualification_required>, describe_field_t<SgConstructorInitializer,bool,&SgConstructorInitializer::p_is_used_in_conditional>>;
};
template <> struct node_from_variant_t<355> { using type = SgConstructorInitializer; };

// Class: ContainsStatement
template <> struct describe_node_t<SgContainsStatement> {
  using node = SgContainsStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"ContainsStatement"};
  static constexpr unsigned long variant{356};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<356> { using type = SgContainsStatement; };

// Class: ContinueStmt
template <> struct describe_field_t<SgContinueStmt,std::string,&SgContinueStmt::p_do_string_label> {
  using parent = SgContinueStmt;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"do_string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgContinueStmt::p_do_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgContinueStmt, std::string SgContinueStmt::*, &SgContinueStmt::p_do_string_label>;
};
template <> struct describe_node_t<SgContinueStmt> {
  using node = SgContinueStmt;
  using base = SgStatement;
  static constexpr char const * const name{"ContinueStmt"};
  static constexpr unsigned long variant{357};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgContinueStmt,std::string,&SgContinueStmt::p_do_string_label>>;
};
template <> struct node_from_variant_t<357> { using type = SgContinueStmt; };

// Class: CtorInitializerList
template <> struct describe_field_t<SgCtorInitializerList,SgInitializedNamePtrList,&SgCtorInitializerList::p_ctors> {
  using parent = SgCtorInitializerList;
  using field_type = SgInitializedNamePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"ctors"};
  static constexpr char const * const typestr{"SgInitializedNamePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCtorInitializerList::p_ctors};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCtorInitializerList, SgInitializedNamePtrList SgCtorInitializerList::*, &SgCtorInitializerList::p_ctors>;
};
template <> struct describe_node_t<SgCtorInitializerList> {
  using node = SgCtorInitializerList;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"CtorInitializerList"};
  static constexpr unsigned long variant{358};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCtorInitializerList,SgInitializedNamePtrList,&SgCtorInitializerList::p_ctors>>;
};
template <> struct node_from_variant_t<358> { using type = SgCtorInitializerList; };

// Class: DataStatementGroup
template <> struct describe_field_t<SgDataStatementGroup,SgDataStatementObjectPtrList,&SgDataStatementGroup::p_object_list> {
  using parent = SgDataStatementGroup;
  using field_type = SgDataStatementObjectPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"object_list"};
  static constexpr char const * const typestr{"SgDataStatementObjectPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDataStatementGroup::p_object_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDataStatementGroup, SgDataStatementObjectPtrList SgDataStatementGroup::*, &SgDataStatementGroup::p_object_list>;
};
template <> struct describe_field_t<SgDataStatementGroup,SgDataStatementValuePtrList,&SgDataStatementGroup::p_value_list> {
  using parent = SgDataStatementGroup;
  using field_type = SgDataStatementValuePtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"value_list"};
  static constexpr char const * const typestr{"SgDataStatementValuePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDataStatementGroup::p_value_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDataStatementGroup, SgDataStatementValuePtrList SgDataStatementGroup::*, &SgDataStatementGroup::p_value_list>;
};
template <> struct describe_node_t<SgDataStatementGroup> {
  using node = SgDataStatementGroup;
  using base = SgSupport;
  static constexpr char const * const name{"DataStatementGroup"};
  static constexpr unsigned long variant{359};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDataStatementGroup,SgDataStatementObjectPtrList,&SgDataStatementGroup::p_object_list>, describe_field_t<SgDataStatementGroup,SgDataStatementValuePtrList,&SgDataStatementGroup::p_value_list>>;
};
template <> struct node_from_variant_t<359> { using type = SgDataStatementGroup; };

// Class: DataStatementObject
template <> struct describe_field_t<SgDataStatementObject,SgExprListExp*,&SgDataStatementObject::p_variableReference_list> {
  using parent = SgDataStatementObject;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"variableReference_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDataStatementObject::p_variableReference_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDataStatementObject, SgExprListExp* SgDataStatementObject::*, &SgDataStatementObject::p_variableReference_list>;
};
template <> struct describe_node_t<SgDataStatementObject> {
  using node = SgDataStatementObject;
  using base = SgSupport;
  static constexpr char const * const name{"DataStatementObject"};
  static constexpr unsigned long variant{360};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDataStatementObject,SgExprListExp*,&SgDataStatementObject::p_variableReference_list>>;
};
template <> struct node_from_variant_t<360> { using type = SgDataStatementObject; };

// Class: DataStatementValue
template <> struct describe_field_t<SgDataStatementValue,SgDataStatementValue::data_statement_value_enum,&SgDataStatementValue::p_data_initialization_format> {
  using parent = SgDataStatementValue;
  using field_type = SgDataStatementValue::data_statement_value_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"data_initialization_format"};
  static constexpr char const * const typestr{"SgDataStatementValue::data_statement_value_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDataStatementValue::p_data_initialization_format};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDataStatementValue, SgDataStatementValue::data_statement_value_enum SgDataStatementValue::*, &SgDataStatementValue::p_data_initialization_format>;
};
template <> struct describe_field_t<SgDataStatementValue,SgExprListExp*,&SgDataStatementValue::p_initializer_list> {
  using parent = SgDataStatementValue;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"initializer_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDataStatementValue::p_initializer_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDataStatementValue, SgExprListExp* SgDataStatementValue::*, &SgDataStatementValue::p_initializer_list>;
};
template <> struct describe_field_t<SgDataStatementValue,SgExpression*,&SgDataStatementValue::p_repeat_expression> {
  using parent = SgDataStatementValue;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"repeat_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDataStatementValue::p_repeat_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDataStatementValue, SgExpression* SgDataStatementValue::*, &SgDataStatementValue::p_repeat_expression>;
};
template <> struct describe_field_t<SgDataStatementValue,SgExpression*,&SgDataStatementValue::p_constant_expression> {
  using parent = SgDataStatementValue;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"constant_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDataStatementValue::p_constant_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDataStatementValue, SgExpression* SgDataStatementValue::*, &SgDataStatementValue::p_constant_expression>;
};
template <> struct describe_node_t<SgDataStatementValue> {
  using node = SgDataStatementValue;
  using base = SgSupport;
  static constexpr char const * const name{"DataStatementValue"};
  static constexpr unsigned long variant{361};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDataStatementValue,SgDataStatementValue::data_statement_value_enum,&SgDataStatementValue::p_data_initialization_format>, describe_field_t<SgDataStatementValue,SgExprListExp*,&SgDataStatementValue::p_initializer_list>, describe_field_t<SgDataStatementValue,SgExpression*,&SgDataStatementValue::p_repeat_expression>, describe_field_t<SgDataStatementValue,SgExpression*,&SgDataStatementValue::p_constant_expression>>;
};
template <> struct node_from_variant_t<361> { using type = SgDataStatementValue; };

// Class: DeadIfDirectiveStatement
template <> struct describe_node_t<SgDeadIfDirectiveStatement> {
  using node = SgDeadIfDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"DeadIfDirectiveStatement"};
  static constexpr unsigned long variant{362};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<362> { using type = SgDeadIfDirectiveStatement; };

// Class: DeallocateStatement
template <> struct describe_field_t<SgDeallocateStatement,SgExprListExp*,&SgDeallocateStatement::p_expr_list> {
  using parent = SgDeallocateStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expr_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDeallocateStatement::p_expr_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeallocateStatement, SgExprListExp* SgDeallocateStatement::*, &SgDeallocateStatement::p_expr_list>;
};
template <> struct describe_field_t<SgDeallocateStatement,SgExpression*,&SgDeallocateStatement::p_stat_expression> {
  using parent = SgDeallocateStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"stat_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDeallocateStatement::p_stat_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeallocateStatement, SgExpression* SgDeallocateStatement::*, &SgDeallocateStatement::p_stat_expression>;
};
template <> struct describe_field_t<SgDeallocateStatement,SgExpression*,&SgDeallocateStatement::p_errmsg_expression> {
  using parent = SgDeallocateStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"errmsg_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDeallocateStatement::p_errmsg_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeallocateStatement, SgExpression* SgDeallocateStatement::*, &SgDeallocateStatement::p_errmsg_expression>;
};
template <> struct describe_node_t<SgDeallocateStatement> {
  using node = SgDeallocateStatement;
  using base = SgStatement;
  static constexpr char const * const name{"DeallocateStatement"};
  static constexpr unsigned long variant{363};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDeallocateStatement,SgExprListExp*,&SgDeallocateStatement::p_expr_list>, describe_field_t<SgDeallocateStatement,SgExpression*,&SgDeallocateStatement::p_stat_expression>, describe_field_t<SgDeallocateStatement,SgExpression*,&SgDeallocateStatement::p_errmsg_expression>>;
};
template <> struct node_from_variant_t<363> { using type = SgDeallocateStatement; };

// Class: DeclarationModifier
template <> struct describe_field_t<SgDeclarationModifier,SgBitVector,&SgDeclarationModifier::p_modifierVector> {
  using parent = SgDeclarationModifier;
  using field_type = SgBitVector;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifierVector"};
  static constexpr char const * const typestr{"SgBitVector"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationModifier::p_modifierVector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationModifier, SgBitVector SgDeclarationModifier::*, &SgDeclarationModifier::p_modifierVector>;
};
template <> struct describe_field_t<SgDeclarationModifier,SgTypeModifier,&SgDeclarationModifier::p_typeModifier> {
  using parent = SgDeclarationModifier;
  using field_type = SgTypeModifier;
  static constexpr size_t position{1};
  static constexpr char const * const name{"typeModifier"};
  static constexpr char const * const typestr{"SgTypeModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationModifier::p_typeModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationModifier, SgTypeModifier SgDeclarationModifier::*, &SgDeclarationModifier::p_typeModifier>;
};
template <> struct describe_field_t<SgDeclarationModifier,SgAccessModifier,&SgDeclarationModifier::p_accessModifier> {
  using parent = SgDeclarationModifier;
  using field_type = SgAccessModifier;
  static constexpr size_t position{2};
  static constexpr char const * const name{"accessModifier"};
  static constexpr char const * const typestr{"SgAccessModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationModifier::p_accessModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationModifier, SgAccessModifier SgDeclarationModifier::*, &SgDeclarationModifier::p_accessModifier>;
};
template <> struct describe_field_t<SgDeclarationModifier,SgStorageModifier,&SgDeclarationModifier::p_storageModifier> {
  using parent = SgDeclarationModifier;
  using field_type = SgStorageModifier;
  static constexpr size_t position{3};
  static constexpr char const * const name{"storageModifier"};
  static constexpr char const * const typestr{"SgStorageModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationModifier::p_storageModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationModifier, SgStorageModifier SgDeclarationModifier::*, &SgDeclarationModifier::p_storageModifier>;
};
template <> struct describe_field_t<SgDeclarationModifier,std::string,&SgDeclarationModifier::p_gnu_attribute_section_name> {
  using parent = SgDeclarationModifier;
  using field_type = std::string;
  static constexpr size_t position{4};
  static constexpr char const * const name{"gnu_attribute_section_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationModifier::p_gnu_attribute_section_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationModifier, std::string SgDeclarationModifier::*, &SgDeclarationModifier::p_gnu_attribute_section_name>;
};
template <> struct describe_field_t<SgDeclarationModifier,SgDeclarationModifier::gnu_declaration_visability_enum,&SgDeclarationModifier::p_gnu_attribute_visability> {
  using parent = SgDeclarationModifier;
  using field_type = SgDeclarationModifier::gnu_declaration_visability_enum;
  static constexpr size_t position{5};
  static constexpr char const * const name{"gnu_attribute_visability"};
  static constexpr char const * const typestr{"SgDeclarationModifier::gnu_declaration_visability_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationModifier::p_gnu_attribute_visability};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationModifier, SgDeclarationModifier::gnu_declaration_visability_enum SgDeclarationModifier::*, &SgDeclarationModifier::p_gnu_attribute_visability>;
};
template <> struct describe_field_t<SgDeclarationModifier,std::string,&SgDeclarationModifier::p_microsoft_uuid_string> {
  using parent = SgDeclarationModifier;
  using field_type = std::string;
  static constexpr size_t position{6};
  static constexpr char const * const name{"microsoft_uuid_string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationModifier::p_microsoft_uuid_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationModifier, std::string SgDeclarationModifier::*, &SgDeclarationModifier::p_microsoft_uuid_string>;
};
template <> struct describe_field_t<SgDeclarationModifier,std::string,&SgDeclarationModifier::p_microsoft_property_get_function_name> {
  using parent = SgDeclarationModifier;
  using field_type = std::string;
  static constexpr size_t position{7};
  static constexpr char const * const name{"microsoft_property_get_function_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationModifier::p_microsoft_property_get_function_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationModifier, std::string SgDeclarationModifier::*, &SgDeclarationModifier::p_microsoft_property_get_function_name>;
};
template <> struct describe_field_t<SgDeclarationModifier,std::string,&SgDeclarationModifier::p_microsoft_property_put_function_name> {
  using parent = SgDeclarationModifier;
  using field_type = std::string;
  static constexpr size_t position{8};
  static constexpr char const * const name{"microsoft_property_put_function_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationModifier::p_microsoft_property_put_function_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationModifier, std::string SgDeclarationModifier::*, &SgDeclarationModifier::p_microsoft_property_put_function_name>;
};
template <> struct describe_node_t<SgDeclarationModifier> {
  using node = SgDeclarationModifier;
  using base = SgModifier;
  static constexpr char const * const name{"DeclarationModifier"};
  static constexpr unsigned long variant{364};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDeclarationModifier,SgBitVector,&SgDeclarationModifier::p_modifierVector>, describe_field_t<SgDeclarationModifier,SgTypeModifier,&SgDeclarationModifier::p_typeModifier>, describe_field_t<SgDeclarationModifier,SgAccessModifier,&SgDeclarationModifier::p_accessModifier>, describe_field_t<SgDeclarationModifier,SgStorageModifier,&SgDeclarationModifier::p_storageModifier>, describe_field_t<SgDeclarationModifier,std::string,&SgDeclarationModifier::p_gnu_attribute_section_name>, describe_field_t<SgDeclarationModifier,SgDeclarationModifier::gnu_declaration_visability_enum,&SgDeclarationModifier::p_gnu_attribute_visability>, describe_field_t<SgDeclarationModifier,std::string,&SgDeclarationModifier::p_microsoft_uuid_string>, describe_field_t<SgDeclarationModifier,std::string,&SgDeclarationModifier::p_microsoft_property_get_function_name>, describe_field_t<SgDeclarationModifier,std::string,&SgDeclarationModifier::p_microsoft_property_put_function_name>>;
};
template <> struct node_from_variant_t<364> { using type = SgDeclarationModifier; };

// Class: DeclarationScope
template <> struct describe_node_t<SgDeclarationScope> {
  using node = SgDeclarationScope;
  using base = SgScopeStatement;
  static constexpr char const * const name{"DeclarationScope"};
  static constexpr unsigned long variant{365};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<365> { using type = SgDeclarationScope; };

// Class: DeclarationStatement
template <> struct describe_field_t<SgDeclarationStatement,unsigned int,&SgDeclarationStatement::p_decl_attributes> {
  using parent = SgDeclarationStatement;
  using field_type = unsigned int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"decl_attributes"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_decl_attributes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, unsigned int SgDeclarationStatement::*, &SgDeclarationStatement::p_decl_attributes>;
};
template <> struct describe_field_t<SgDeclarationStatement,std::string,&SgDeclarationStatement::p_linkage> {
  using parent = SgDeclarationStatement;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"linkage"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_linkage};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, std::string SgDeclarationStatement::*, &SgDeclarationStatement::p_linkage>;
};
template <> struct describe_field_t<SgDeclarationStatement,SgDeclarationModifier,&SgDeclarationStatement::p_declarationModifier> {
  using parent = SgDeclarationStatement;
  using field_type = SgDeclarationModifier;
  static constexpr size_t position{2};
  static constexpr char const * const name{"declarationModifier"};
  static constexpr char const * const typestr{"SgDeclarationModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_declarationModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, SgDeclarationModifier SgDeclarationStatement::*, &SgDeclarationStatement::p_declarationModifier>;
};
template <> struct describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_nameOnly> {
  using parent = SgDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"nameOnly"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_nameOnly};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, bool SgDeclarationStatement::*, &SgDeclarationStatement::p_nameOnly>;
};
template <> struct describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_forward> {
  using parent = SgDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"forward"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_forward};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, bool SgDeclarationStatement::*, &SgDeclarationStatement::p_forward>;
};
template <> struct describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_externBrace> {
  using parent = SgDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"externBrace"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_externBrace};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, bool SgDeclarationStatement::*, &SgDeclarationStatement::p_externBrace>;
};
template <> struct describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_skipElaborateType> {
  using parent = SgDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"skipElaborateType"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_skipElaborateType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, bool SgDeclarationStatement::*, &SgDeclarationStatement::p_skipElaborateType>;
};
template <> struct describe_field_t<SgDeclarationStatement,SgDeclarationStatement*,&SgDeclarationStatement::p_definingDeclaration> {
  using parent = SgDeclarationStatement;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"definingDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_definingDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, SgDeclarationStatement* SgDeclarationStatement::*, &SgDeclarationStatement::p_definingDeclaration>;
};
template <> struct describe_field_t<SgDeclarationStatement,SgDeclarationStatement*,&SgDeclarationStatement::p_firstNondefiningDeclaration> {
  using parent = SgDeclarationStatement;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"firstNondefiningDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_firstNondefiningDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, SgDeclarationStatement* SgDeclarationStatement::*, &SgDeclarationStatement::p_firstNondefiningDeclaration>;
};
template <> struct describe_field_t<SgDeclarationStatement,SgQualifiedNamePtrList,&SgDeclarationStatement::p_qualifiedNameList> {
  using parent = SgDeclarationStatement;
  using field_type = SgQualifiedNamePtrList;
  static constexpr size_t position{9};
  static constexpr char const * const name{"qualifiedNameList"};
  static constexpr char const * const typestr{"SgQualifiedNamePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_qualifiedNameList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, SgQualifiedNamePtrList SgDeclarationStatement::*, &SgDeclarationStatement::p_qualifiedNameList>;
};
template <> struct describe_field_t<SgDeclarationStatement,std::string,&SgDeclarationStatement::p_binding_label> {
  using parent = SgDeclarationStatement;
  using field_type = std::string;
  static constexpr size_t position{10};
  static constexpr char const * const name{"binding_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_binding_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, std::string SgDeclarationStatement::*, &SgDeclarationStatement::p_binding_label>;
};
template <> struct describe_field_t<SgDeclarationStatement,SgDeclarationScope*,&SgDeclarationStatement::p_declarationScope> {
  using parent = SgDeclarationStatement;
  using field_type = SgDeclarationScope*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"declarationScope"};
  static constexpr char const * const typestr{"SgDeclarationScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_declarationScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, SgDeclarationScope* SgDeclarationStatement::*, &SgDeclarationStatement::p_declarationScope>;
};
template <> struct describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_unparse_template_ast> {
  using parent = SgDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{12};
  static constexpr char const * const name{"unparse_template_ast"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_unparse_template_ast};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, bool SgDeclarationStatement::*, &SgDeclarationStatement::p_unparse_template_ast>;
};
template <> struct describe_field_t<SgDeclarationStatement,SgExprListExp*,&SgDeclarationStatement::p_adaAspects> {
  using parent = SgDeclarationStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"adaAspects"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclarationStatement::p_adaAspects};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclarationStatement, SgExprListExp* SgDeclarationStatement::*, &SgDeclarationStatement::p_adaAspects>;
};
template <> struct describe_node_t<SgDeclarationStatement> {
  using node = SgDeclarationStatement;
  using base = SgStatement;
  static constexpr char const * const name{"DeclarationStatement"};
  static constexpr unsigned long variant{366};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgFunctionParameterList, SgVariableDeclaration, SgVariableDefinition, SgClinkageDeclarationStatement, SgEnumDeclaration, SgAsmStmt, SgAttributeSpecificationStatement, SgFormatStatement, SgTemplateDeclaration, SgTemplateInstantiationDirectiveStatement, SgUseStatement, SgParameterStatement, SgNamespaceDeclarationStatement, SgEquivalenceStatement, SgInterfaceStatement, SgNamespaceAliasDeclarationStatement, SgCommonBlock, SgTypedefDeclaration, SgStatementFunctionStatement, SgCtorInitializerList, SgPragmaDeclaration, SgUsingDirectiveStatement, SgClassDeclaration, SgImplicitStatement, SgUsingDeclarationStatement, SgNamelistStatement, SgImportStatement, SgFunctionDeclaration, SgContainsStatement, SgC_PreprocessorDirectiveStatement, SgOmpThreadprivateStatement, SgFortranIncludeLine, SgJavaImportStatement, SgJavaPackageStatement, SgStmtDeclarationStatement, SgStaticAssertionDeclaration, SgOmpDeclareSimdStatement, SgMicrosoftAttributeDeclaration, SgJovialCompoolStatement, SgJovialDirectiveStatement, SgJovialDefineDeclaration, SgJovialLabelDeclaration, SgJovialOverlayDeclaration, SgNonrealDecl, SgEmptyDeclaration, SgAdaPackageBodyDecl, SgAdaPackageSpecDecl, SgAdaRenamingDecl, SgAdaTaskSpecDecl, SgAdaTaskBodyDecl, SgAdaTaskTypeDecl, SgAdaProtectedSpecDecl, SgAdaProtectedBodyDecl, SgAdaProtectedTypeDecl, SgAdaRepresentationClause, SgAdaComponentClause, SgAdaAttributeClause, SgAdaEnumRepresentationClause, SgAdaGenericDecl, SgAdaFormalTypeDecl, SgAdaDiscriminatedTypeDecl, SgAdaGenericInstanceDecl, SgAdaFormalPackageDecl, SgAdaParameterList, SgAdaVariantDecl>;
  using fields_t = mp::List<describe_field_t<SgDeclarationStatement,unsigned int,&SgDeclarationStatement::p_decl_attributes>, describe_field_t<SgDeclarationStatement,std::string,&SgDeclarationStatement::p_linkage>, describe_field_t<SgDeclarationStatement,SgDeclarationModifier,&SgDeclarationStatement::p_declarationModifier>, describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_nameOnly>, describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_forward>, describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_externBrace>, describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_skipElaborateType>, describe_field_t<SgDeclarationStatement,SgDeclarationStatement*,&SgDeclarationStatement::p_definingDeclaration>, describe_field_t<SgDeclarationStatement,SgDeclarationStatement*,&SgDeclarationStatement::p_firstNondefiningDeclaration>, describe_field_t<SgDeclarationStatement,SgQualifiedNamePtrList,&SgDeclarationStatement::p_qualifiedNameList>, describe_field_t<SgDeclarationStatement,std::string,&SgDeclarationStatement::p_binding_label>, describe_field_t<SgDeclarationStatement,SgDeclarationScope*,&SgDeclarationStatement::p_declarationScope>, describe_field_t<SgDeclarationStatement,bool,&SgDeclarationStatement::p_unparse_template_ast>, describe_field_t<SgDeclarationStatement,SgExprListExp*,&SgDeclarationStatement::p_adaAspects>>;
};
template <> struct node_from_variant_t<366> { using type = SgDeclarationStatement; };

// Class: DeclType
template <> struct describe_field_t<SgDeclType,SgExpression*,&SgDeclType::p_base_expression> {
  using parent = SgDeclType;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclType::p_base_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclType, SgExpression* SgDeclType::*, &SgDeclType::p_base_expression>;
};
template <> struct describe_field_t<SgDeclType,SgType*,&SgDeclType::p_base_type> {
  using parent = SgDeclType;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeclType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeclType, SgType* SgDeclType::*, &SgDeclType::p_base_type>;
};
template <> struct describe_node_t<SgDeclType> {
  using node = SgDeclType;
  using base = SgType;
  static constexpr char const * const name{"DeclType"};
  static constexpr unsigned long variant{367};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDeclType,SgExpression*,&SgDeclType::p_base_expression>, describe_field_t<SgDeclType,SgType*,&SgDeclType::p_base_type>>;
};
template <> struct node_from_variant_t<367> { using type = SgDeclType; };

// Class: DefaultOptionStmt
template <> struct describe_field_t<SgDefaultOptionStmt,SgStatement*,&SgDefaultOptionStmt::p_body> {
  using parent = SgDefaultOptionStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDefaultOptionStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDefaultOptionStmt, SgStatement* SgDefaultOptionStmt::*, &SgDefaultOptionStmt::p_body>;
};
template <> struct describe_field_t<SgDefaultOptionStmt,std::string,&SgDefaultOptionStmt::p_default_construct_name> {
  using parent = SgDefaultOptionStmt;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"default_construct_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDefaultOptionStmt::p_default_construct_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDefaultOptionStmt, std::string SgDefaultOptionStmt::*, &SgDefaultOptionStmt::p_default_construct_name>;
};
template <> struct describe_field_t<SgDefaultOptionStmt,bool,&SgDefaultOptionStmt::p_has_fall_through> {
  using parent = SgDefaultOptionStmt;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"has_fall_through"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDefaultOptionStmt::p_has_fall_through};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDefaultOptionStmt, bool SgDefaultOptionStmt::*, &SgDefaultOptionStmt::p_has_fall_through>;
};
template <> struct describe_node_t<SgDefaultOptionStmt> {
  using node = SgDefaultOptionStmt;
  using base = SgStatement;
  static constexpr char const * const name{"DefaultOptionStmt"};
  static constexpr unsigned long variant{368};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDefaultOptionStmt,SgStatement*,&SgDefaultOptionStmt::p_body>, describe_field_t<SgDefaultOptionStmt,std::string,&SgDefaultOptionStmt::p_default_construct_name>, describe_field_t<SgDefaultOptionStmt,bool,&SgDefaultOptionStmt::p_has_fall_through>>;
};
template <> struct node_from_variant_t<368> { using type = SgDefaultOptionStmt; };

// Class: DefaultSymbol
template <> struct describe_field_t<SgDefaultSymbol,SgType*,&SgDefaultSymbol::p_type> {
  using parent = SgDefaultSymbol;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDefaultSymbol::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDefaultSymbol, SgType* SgDefaultSymbol::*, &SgDefaultSymbol::p_type>;
};
template <> struct describe_node_t<SgDefaultSymbol> {
  using node = SgDefaultSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"DefaultSymbol"};
  static constexpr unsigned long variant{369};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDefaultSymbol,SgType*,&SgDefaultSymbol::p_type>>;
};
template <> struct node_from_variant_t<369> { using type = SgDefaultSymbol; };

// Class: DefineDirectiveStatement
template <> struct describe_node_t<SgDefineDirectiveStatement> {
  using node = SgDefineDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"DefineDirectiveStatement"};
  static constexpr unsigned long variant{370};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<370> { using type = SgDefineDirectiveStatement; };

// Class: DeleteExp
template <> struct describe_field_t<SgDeleteExp,SgExpression*,&SgDeleteExp::p_variable> {
  using parent = SgDeleteExp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"variable"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDeleteExp::p_variable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeleteExp, SgExpression* SgDeleteExp::*, &SgDeleteExp::p_variable>;
};
template <> struct describe_field_t<SgDeleteExp,short,&SgDeleteExp::p_is_array> {
  using parent = SgDeleteExp;
  using field_type = short;
  static constexpr size_t position{1};
  static constexpr char const * const name{"is_array"};
  static constexpr char const * const typestr{"short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeleteExp::p_is_array};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeleteExp, short SgDeleteExp::*, &SgDeleteExp::p_is_array>;
};
template <> struct describe_field_t<SgDeleteExp,short,&SgDeleteExp::p_need_global_specifier> {
  using parent = SgDeleteExp;
  using field_type = short;
  static constexpr size_t position{2};
  static constexpr char const * const name{"need_global_specifier"};
  static constexpr char const * const typestr{"short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeleteExp::p_need_global_specifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeleteExp, short SgDeleteExp::*, &SgDeleteExp::p_need_global_specifier>;
};
template <> struct describe_field_t<SgDeleteExp,SgFunctionDeclaration*,&SgDeleteExp::p_deleteOperatorDeclaration> {
  using parent = SgDeleteExp;
  using field_type = SgFunctionDeclaration*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"deleteOperatorDeclaration"};
  static constexpr char const * const typestr{"SgFunctionDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDeleteExp::p_deleteOperatorDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDeleteExp, SgFunctionDeclaration* SgDeleteExp::*, &SgDeleteExp::p_deleteOperatorDeclaration>;
};
template <> struct describe_node_t<SgDeleteExp> {
  using node = SgDeleteExp;
  using base = SgExpression;
  static constexpr char const * const name{"DeleteExp"};
  static constexpr unsigned long variant{371};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDeleteExp,SgExpression*,&SgDeleteExp::p_variable>, describe_field_t<SgDeleteExp,short,&SgDeleteExp::p_is_array>, describe_field_t<SgDeleteExp,short,&SgDeleteExp::p_need_global_specifier>, describe_field_t<SgDeleteExp,SgFunctionDeclaration*,&SgDeleteExp::p_deleteOperatorDeclaration>>;
};
template <> struct node_from_variant_t<371> { using type = SgDeleteExp; };

// Class: DerivedTypeStatement
template <> struct describe_field_t<SgDerivedTypeStatement,SgLabelRefExp*,&SgDerivedTypeStatement::p_end_numeric_label> {
  using parent = SgDerivedTypeStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDerivedTypeStatement::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDerivedTypeStatement, SgLabelRefExp* SgDerivedTypeStatement::*, &SgDerivedTypeStatement::p_end_numeric_label>;
};
template <> struct describe_node_t<SgDerivedTypeStatement> {
  using node = SgDerivedTypeStatement;
  using base = SgClassDeclaration;
  static constexpr char const * const name{"DerivedTypeStatement"};
  static constexpr unsigned long variant{372};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDerivedTypeStatement,SgLabelRefExp*,&SgDerivedTypeStatement::p_end_numeric_label>>;
};
template <> struct node_from_variant_t<372> { using type = SgDerivedTypeStatement; };

// Class: DesignatedInitializer
template <> struct describe_field_t<SgDesignatedInitializer,SgExprListExp*,&SgDesignatedInitializer::p_designatorList> {
  using parent = SgDesignatedInitializer;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"designatorList"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDesignatedInitializer::p_designatorList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDesignatedInitializer, SgExprListExp* SgDesignatedInitializer::*, &SgDesignatedInitializer::p_designatorList>;
};
template <> struct describe_field_t<SgDesignatedInitializer,SgInitializer*,&SgDesignatedInitializer::p_memberInit> {
  using parent = SgDesignatedInitializer;
  using field_type = SgInitializer*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"memberInit"};
  static constexpr char const * const typestr{"SgInitializer*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDesignatedInitializer::p_memberInit};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDesignatedInitializer, SgInitializer* SgDesignatedInitializer::*, &SgDesignatedInitializer::p_memberInit>;
};
template <> struct describe_node_t<SgDesignatedInitializer> {
  using node = SgDesignatedInitializer;
  using base = SgInitializer;
  static constexpr char const * const name{"DesignatedInitializer"};
  static constexpr unsigned long variant{373};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDesignatedInitializer,SgExprListExp*,&SgDesignatedInitializer::p_designatorList>, describe_field_t<SgDesignatedInitializer,SgInitializer*,&SgDesignatedInitializer::p_memberInit>>;
};
template <> struct node_from_variant_t<373> { using type = SgDesignatedInitializer; };

// Class: DictionaryComprehension
template <> struct describe_field_t<SgDictionaryComprehension,SgKeyDatumPair*,&SgDictionaryComprehension::p_element> {
  using parent = SgDictionaryComprehension;
  using field_type = SgKeyDatumPair*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"element"};
  static constexpr char const * const typestr{"SgKeyDatumPair*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDictionaryComprehension::p_element};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDictionaryComprehension, SgKeyDatumPair* SgDictionaryComprehension::*, &SgDictionaryComprehension::p_element>;
};
template <> struct describe_field_t<SgDictionaryComprehension,SgExprListExp*,&SgDictionaryComprehension::p_generators> {
  using parent = SgDictionaryComprehension;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"generators"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDictionaryComprehension::p_generators};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDictionaryComprehension, SgExprListExp* SgDictionaryComprehension::*, &SgDictionaryComprehension::p_generators>;
};
template <> struct describe_node_t<SgDictionaryComprehension> {
  using node = SgDictionaryComprehension;
  using base = SgExpression;
  static constexpr char const * const name{"DictionaryComprehension"};
  static constexpr unsigned long variant{374};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDictionaryComprehension,SgKeyDatumPair*,&SgDictionaryComprehension::p_element>, describe_field_t<SgDictionaryComprehension,SgExprListExp*,&SgDictionaryComprehension::p_generators>>;
};
template <> struct node_from_variant_t<374> { using type = SgDictionaryComprehension; };

// Class: DictionaryExp
template <> struct describe_field_t<SgDictionaryExp,SgKeyDatumPairPtrList,&SgDictionaryExp::p_key_datum_pairs> {
  using parent = SgDictionaryExp;
  using field_type = SgKeyDatumPairPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"key_datum_pairs"};
  static constexpr char const * const typestr{"SgKeyDatumPairPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDictionaryExp::p_key_datum_pairs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDictionaryExp, SgKeyDatumPairPtrList SgDictionaryExp::*, &SgDictionaryExp::p_key_datum_pairs>;
};
template <> struct describe_node_t<SgDictionaryExp> {
  using node = SgDictionaryExp;
  using base = SgExpression;
  static constexpr char const * const name{"DictionaryExp"};
  static constexpr unsigned long variant{375};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDictionaryExp,SgKeyDatumPairPtrList,&SgDictionaryExp::p_key_datum_pairs>>;
};
template <> struct node_from_variant_t<375> { using type = SgDictionaryExp; };

// Class: DimensionObject
template <> struct describe_field_t<SgDimensionObject,SgInitializedName*,&SgDimensionObject::p_array> {
  using parent = SgDimensionObject;
  using field_type = SgInitializedName*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"array"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDimensionObject::p_array};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDimensionObject, SgInitializedName* SgDimensionObject::*, &SgDimensionObject::p_array>;
};
template <> struct describe_field_t<SgDimensionObject,SgExprListExp*,&SgDimensionObject::p_shape> {
  using parent = SgDimensionObject;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"shape"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDimensionObject::p_shape};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDimensionObject, SgExprListExp* SgDimensionObject::*, &SgDimensionObject::p_shape>;
};
template <> struct describe_node_t<SgDimensionObject> {
  using node = SgDimensionObject;
  using base = SgSupport;
  static constexpr char const * const name{"DimensionObject"};
  static constexpr unsigned long variant{376};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDimensionObject,SgInitializedName*,&SgDimensionObject::p_array>, describe_field_t<SgDimensionObject,SgExprListExp*,&SgDimensionObject::p_shape>>;
};
template <> struct node_from_variant_t<376> { using type = SgDimensionObject; };

// Class: DirectedGraphEdge
template <> struct describe_node_t<SgDirectedGraphEdge> {
  using node = SgDirectedGraphEdge;
  using base = SgGraphEdge;
  static constexpr char const * const name{"DirectedGraphEdge"};
  static constexpr unsigned long variant{378};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<378> { using type = SgDirectedGraphEdge; };

// Class: Directory
template <> struct describe_field_t<SgDirectory,std::string,&SgDirectory::p_name> {
  using parent = SgDirectory;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDirectory::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDirectory, std::string SgDirectory::*, &SgDirectory::p_name>;
};
template <> struct describe_field_t<SgDirectory,SgFileList*,&SgDirectory::p_fileList> {
  using parent = SgDirectory;
  using field_type = SgFileList*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"fileList"};
  static constexpr char const * const typestr{"SgFileList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDirectory::p_fileList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDirectory, SgFileList* SgDirectory::*, &SgDirectory::p_fileList>;
};
template <> struct describe_field_t<SgDirectory,SgDirectoryList*,&SgDirectory::p_directoryList> {
  using parent = SgDirectory;
  using field_type = SgDirectoryList*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"directoryList"};
  static constexpr char const * const typestr{"SgDirectoryList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDirectory::p_directoryList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDirectory, SgDirectoryList* SgDirectory::*, &SgDirectory::p_directoryList>;
};
template <> struct describe_field_t<SgDirectory,AstAttributeMechanism*,&SgDirectory::p_attributeMechanism> {
  using parent = SgDirectory;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDirectory::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDirectory, AstAttributeMechanism* SgDirectory::*, &SgDirectory::p_attributeMechanism>;
};
template <> struct describe_node_t<SgDirectory> {
  using node = SgDirectory;
  using base = SgSupport;
  static constexpr char const * const name{"Directory"};
  static constexpr unsigned long variant{380};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDirectory,std::string,&SgDirectory::p_name>, describe_field_t<SgDirectory,SgFileList*,&SgDirectory::p_fileList>, describe_field_t<SgDirectory,SgDirectoryList*,&SgDirectory::p_directoryList>, describe_field_t<SgDirectory,AstAttributeMechanism*,&SgDirectory::p_attributeMechanism>>;
};
template <> struct node_from_variant_t<380> { using type = SgDirectory; };

// Class: DirectoryList
template <> struct describe_field_t<SgDirectoryList,SgDirectoryPtrList,&SgDirectoryList::p_listOfDirectories> {
  using parent = SgDirectoryList;
  using field_type = SgDirectoryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"listOfDirectories"};
  static constexpr char const * const typestr{"SgDirectoryPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDirectoryList::p_listOfDirectories};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDirectoryList, SgDirectoryPtrList SgDirectoryList::*, &SgDirectoryList::p_listOfDirectories>;
};
template <> struct describe_node_t<SgDirectoryList> {
  using node = SgDirectoryList;
  using base = SgSupport;
  static constexpr char const * const name{"DirectoryList"};
  static constexpr unsigned long variant{381};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDirectoryList,SgDirectoryPtrList,&SgDirectoryList::p_listOfDirectories>>;
};
template <> struct node_from_variant_t<381> { using type = SgDirectoryList; };

// Class: DivAssignOp
template <> struct describe_node_t<SgDivAssignOp> {
  using node = SgDivAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"DivAssignOp"};
  static constexpr unsigned long variant{382};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<382> { using type = SgDivAssignOp; };

// Class: DivideOp
template <> struct describe_node_t<SgDivideOp> {
  using node = SgDivideOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"DivideOp"};
  static constexpr unsigned long variant{383};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<383> { using type = SgDivideOp; };

// Class: DoWhileStmt
template <> struct describe_field_t<SgDoWhileStmt,SgStatement*,&SgDoWhileStmt::p_body> {
  using parent = SgDoWhileStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDoWhileStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDoWhileStmt, SgStatement* SgDoWhileStmt::*, &SgDoWhileStmt::p_body>;
};
template <> struct describe_field_t<SgDoWhileStmt,SgStatement*,&SgDoWhileStmt::p_condition> {
  using parent = SgDoWhileStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"condition"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgDoWhileStmt::p_condition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDoWhileStmt, SgStatement* SgDoWhileStmt::*, &SgDoWhileStmt::p_condition>;
};
template <> struct describe_node_t<SgDoWhileStmt> {
  using node = SgDoWhileStmt;
  using base = SgScopeStatement;
  static constexpr char const * const name{"DoWhileStmt"};
  static constexpr unsigned long variant{384};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDoWhileStmt,SgStatement*,&SgDoWhileStmt::p_body>, describe_field_t<SgDoWhileStmt,SgStatement*,&SgDoWhileStmt::p_condition>>;
};
template <> struct node_from_variant_t<384> { using type = SgDoWhileStmt; };

// Class: DotExp
template <> struct describe_node_t<SgDotExp> {
  using node = SgDotExp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"DotExp"};
  static constexpr unsigned long variant{385};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<385> { using type = SgDotExp; };

// Class: DotStarOp
template <> struct describe_node_t<SgDotStarOp> {
  using node = SgDotStarOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"DotStarOp"};
  static constexpr unsigned long variant{386};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<386> { using type = SgDotStarOp; };

// Class: DoubleVal
template <> struct describe_field_t<SgDoubleVal,double,&SgDoubleVal::p_value> {
  using parent = SgDoubleVal;
  using field_type = double;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"double"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDoubleVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDoubleVal, double SgDoubleVal::*, &SgDoubleVal::p_value>;
};
template <> struct describe_field_t<SgDoubleVal,std::string,&SgDoubleVal::p_valueString> {
  using parent = SgDoubleVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgDoubleVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgDoubleVal, std::string SgDoubleVal::*, &SgDoubleVal::p_valueString>;
};
template <> struct describe_node_t<SgDoubleVal> {
  using node = SgDoubleVal;
  using base = SgValueExp;
  static constexpr char const * const name{"DoubleVal"};
  static constexpr unsigned long variant{387};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgDoubleVal,double,&SgDoubleVal::p_value>, describe_field_t<SgDoubleVal,std::string,&SgDoubleVal::p_valueString>>;
};
template <> struct node_from_variant_t<387> { using type = SgDoubleVal; };

// Class: ElaboratedTypeModifier
template <> struct describe_field_t<SgElaboratedTypeModifier,SgElaboratedTypeModifier::elaborated_type_modifier_enum,&SgElaboratedTypeModifier::p_modifier> {
  using parent = SgElaboratedTypeModifier;
  using field_type = SgElaboratedTypeModifier::elaborated_type_modifier_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgElaboratedTypeModifier::elaborated_type_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgElaboratedTypeModifier::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgElaboratedTypeModifier, SgElaboratedTypeModifier::elaborated_type_modifier_enum SgElaboratedTypeModifier::*, &SgElaboratedTypeModifier::p_modifier>;
};
template <> struct describe_node_t<SgElaboratedTypeModifier> {
  using node = SgElaboratedTypeModifier;
  using base = SgModifier;
  static constexpr char const * const name{"ElaboratedTypeModifier"};
  static constexpr unsigned long variant{388};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgElaboratedTypeModifier,SgElaboratedTypeModifier::elaborated_type_modifier_enum,&SgElaboratedTypeModifier::p_modifier>>;
};
template <> struct node_from_variant_t<388> { using type = SgElaboratedTypeModifier; };

// Class: ElementwiseOp
template <> struct describe_node_t<SgElementwiseOp> {
  using node = SgElementwiseOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"ElementwiseOp"};
  static constexpr unsigned long variant{389};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgElementwiseMultiplyOp, SgElementwisePowerOp, SgElementwiseLeftDivideOp, SgElementwiseDivideOp, SgElementwiseAddOp, SgElementwiseSubtractOp>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<389> { using type = SgElementwiseOp; };

// Class: ElementwiseAddOp
template <> struct describe_node_t<SgElementwiseAddOp> {
  using node = SgElementwiseAddOp;
  using base = SgElementwiseOp;
  static constexpr char const * const name{"ElementwiseAddOp"};
  static constexpr unsigned long variant{390};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<390> { using type = SgElementwiseAddOp; };

// Class: ElementwiseDivideOp
template <> struct describe_node_t<SgElementwiseDivideOp> {
  using node = SgElementwiseDivideOp;
  using base = SgElementwiseOp;
  static constexpr char const * const name{"ElementwiseDivideOp"};
  static constexpr unsigned long variant{391};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<391> { using type = SgElementwiseDivideOp; };

// Class: ElementwiseLeftDivideOp
template <> struct describe_node_t<SgElementwiseLeftDivideOp> {
  using node = SgElementwiseLeftDivideOp;
  using base = SgElementwiseOp;
  static constexpr char const * const name{"ElementwiseLeftDivideOp"};
  static constexpr unsigned long variant{392};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<392> { using type = SgElementwiseLeftDivideOp; };

// Class: ElementwiseMultiplyOp
template <> struct describe_node_t<SgElementwiseMultiplyOp> {
  using node = SgElementwiseMultiplyOp;
  using base = SgElementwiseOp;
  static constexpr char const * const name{"ElementwiseMultiplyOp"};
  static constexpr unsigned long variant{393};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<393> { using type = SgElementwiseMultiplyOp; };

// Class: ElementwisePowerOp
template <> struct describe_node_t<SgElementwisePowerOp> {
  using node = SgElementwisePowerOp;
  using base = SgElementwiseOp;
  static constexpr char const * const name{"ElementwisePowerOp"};
  static constexpr unsigned long variant{394};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<394> { using type = SgElementwisePowerOp; };

// Class: ElementwiseSubtractOp
template <> struct describe_node_t<SgElementwiseSubtractOp> {
  using node = SgElementwiseSubtractOp;
  using base = SgElementwiseOp;
  static constexpr char const * const name{"ElementwiseSubtractOp"};
  static constexpr unsigned long variant{395};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<395> { using type = SgElementwiseSubtractOp; };

// Class: ElseDirectiveStatement
template <> struct describe_node_t<SgElseDirectiveStatement> {
  using node = SgElseDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"ElseDirectiveStatement"};
  static constexpr unsigned long variant{396};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<396> { using type = SgElseDirectiveStatement; };

// Class: ElseWhereStatement
template <> struct describe_field_t<SgElseWhereStatement,SgExpression*,&SgElseWhereStatement::p_condition> {
  using parent = SgElseWhereStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"condition"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgElseWhereStatement::p_condition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgElseWhereStatement, SgExpression* SgElseWhereStatement::*, &SgElseWhereStatement::p_condition>;
};
template <> struct describe_field_t<SgElseWhereStatement,SgBasicBlock*,&SgElseWhereStatement::p_body> {
  using parent = SgElseWhereStatement;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgElseWhereStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgElseWhereStatement, SgBasicBlock* SgElseWhereStatement::*, &SgElseWhereStatement::p_body>;
};
template <> struct describe_field_t<SgElseWhereStatement,SgElseWhereStatement*,&SgElseWhereStatement::p_elsewhere> {
  using parent = SgElseWhereStatement;
  using field_type = SgElseWhereStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"elsewhere"};
  static constexpr char const * const typestr{"SgElseWhereStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgElseWhereStatement::p_elsewhere};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgElseWhereStatement, SgElseWhereStatement* SgElseWhereStatement::*, &SgElseWhereStatement::p_elsewhere>;
};
template <> struct describe_node_t<SgElseWhereStatement> {
  using node = SgElseWhereStatement;
  using base = SgStatement;
  static constexpr char const * const name{"ElseWhereStatement"};
  static constexpr unsigned long variant{397};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgElseWhereStatement,SgExpression*,&SgElseWhereStatement::p_condition>, describe_field_t<SgElseWhereStatement,SgBasicBlock*,&SgElseWhereStatement::p_body>, describe_field_t<SgElseWhereStatement,SgElseWhereStatement*,&SgElseWhereStatement::p_elsewhere>>;
};
template <> struct node_from_variant_t<397> { using type = SgElseWhereStatement; };

// Class: ElseifDirectiveStatement
template <> struct describe_node_t<SgElseifDirectiveStatement> {
  using node = SgElseifDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"ElseifDirectiveStatement"};
  static constexpr unsigned long variant{398};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<398> { using type = SgElseifDirectiveStatement; };

// Class: EmptyDeclaration
template <> struct describe_node_t<SgEmptyDeclaration> {
  using node = SgEmptyDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"EmptyDeclaration"};
  static constexpr unsigned long variant{399};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<399> { using type = SgEmptyDeclaration; };

// Class: EmptyDirectiveStatement
template <> struct describe_node_t<SgEmptyDirectiveStatement> {
  using node = SgEmptyDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"EmptyDirectiveStatement"};
  static constexpr unsigned long variant{400};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<400> { using type = SgEmptyDirectiveStatement; };

// Class: EndfileStatement
template <> struct describe_node_t<SgEndfileStatement> {
  using node = SgEndfileStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"EndfileStatement"};
  static constexpr unsigned long variant{401};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<401> { using type = SgEndfileStatement; };

// Class: EndifDirectiveStatement
template <> struct describe_node_t<SgEndifDirectiveStatement> {
  using node = SgEndifDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"EndifDirectiveStatement"};
  static constexpr unsigned long variant{402};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<402> { using type = SgEndifDirectiveStatement; };

// Class: EntryStatement
template <> struct describe_field_t<SgEntryStatement,SgInitializedName*,&SgEntryStatement::p_result_name> {
  using parent = SgEntryStatement;
  using field_type = SgInitializedName*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"result_name"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgEntryStatement::p_result_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEntryStatement, SgInitializedName* SgEntryStatement::*, &SgEntryStatement::p_result_name>;
};
template <> struct describe_node_t<SgEntryStatement> {
  using node = SgEntryStatement;
  using base = SgFunctionDeclaration;
  static constexpr char const * const name{"EntryStatement"};
  static constexpr unsigned long variant{403};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgEntryStatement,SgInitializedName*,&SgEntryStatement::p_result_name>>;
};
template <> struct node_from_variant_t<403> { using type = SgEntryStatement; };

// Class: EnumDeclaration
template <> struct describe_field_t<SgEnumDeclaration,SgName,&SgEnumDeclaration::p_name> {
  using parent = SgEnumDeclaration;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, SgName SgEnumDeclaration::*, &SgEnumDeclaration::p_name>;
};
template <> struct describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_embedded> {
  using parent = SgEnumDeclaration;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"embedded"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_embedded};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, bool SgEnumDeclaration::*, &SgEnumDeclaration::p_embedded>;
};
template <> struct describe_field_t<SgEnumDeclaration,SgEnumType*,&SgEnumDeclaration::p_type> {
  using parent = SgEnumDeclaration;
  using field_type = SgEnumType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgEnumType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, SgEnumType* SgEnumDeclaration::*, &SgEnumDeclaration::p_type>;
};
template <> struct describe_field_t<SgEnumDeclaration,SgType*,&SgEnumDeclaration::p_adaParentType> {
  using parent = SgEnumDeclaration;
  using field_type = SgType*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"adaParentType"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_adaParentType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, SgType* SgEnumDeclaration::*, &SgEnumDeclaration::p_adaParentType>;
};
template <> struct describe_field_t<SgEnumDeclaration,SgInitializedNamePtrList,&SgEnumDeclaration::p_enumerators> {
  using parent = SgEnumDeclaration;
  using field_type = SgInitializedNamePtrList;
  static constexpr size_t position{4};
  static constexpr char const * const name{"enumerators"};
  static constexpr char const * const typestr{"SgInitializedNamePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_enumerators};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, SgInitializedNamePtrList SgEnumDeclaration::*, &SgEnumDeclaration::p_enumerators>;
};
template <> struct describe_field_t<SgEnumDeclaration,SgScopeStatement*,&SgEnumDeclaration::p_scope> {
  using parent = SgEnumDeclaration;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, SgScopeStatement* SgEnumDeclaration::*, &SgEnumDeclaration::p_scope>;
};
template <> struct describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_isUnNamed> {
  using parent = SgEnumDeclaration;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"isUnNamed"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_isUnNamed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, bool SgEnumDeclaration::*, &SgEnumDeclaration::p_isUnNamed>;
};
template <> struct describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_isAutonomousDeclaration> {
  using parent = SgEnumDeclaration;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"isAutonomousDeclaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_isAutonomousDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, bool SgEnumDeclaration::*, &SgEnumDeclaration::p_isAutonomousDeclaration>;
};
template <> struct describe_field_t<SgEnumDeclaration,SgType*,&SgEnumDeclaration::p_field_type> {
  using parent = SgEnumDeclaration;
  using field_type = SgType*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"field_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_field_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, SgType* SgEnumDeclaration::*, &SgEnumDeclaration::p_field_type>;
};
template <> struct describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_isScopedEnum> {
  using parent = SgEnumDeclaration;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"isScopedEnum"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_isScopedEnum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, bool SgEnumDeclaration::*, &SgEnumDeclaration::p_isScopedEnum>;
};
template <> struct describe_field_t<SgEnumDeclaration,int,&SgEnumDeclaration::p_name_qualification_length> {
  using parent = SgEnumDeclaration;
  using field_type = int;
  static constexpr size_t position{10};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, int SgEnumDeclaration::*, &SgEnumDeclaration::p_name_qualification_length>;
};
template <> struct describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_type_elaboration_required> {
  using parent = SgEnumDeclaration;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, bool SgEnumDeclaration::*, &SgEnumDeclaration::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_global_qualification_required> {
  using parent = SgEnumDeclaration;
  using field_type = bool;
  static constexpr size_t position{12};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumDeclaration::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumDeclaration, bool SgEnumDeclaration::*, &SgEnumDeclaration::p_global_qualification_required>;
};
template <> struct describe_node_t<SgEnumDeclaration> {
  using node = SgEnumDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"EnumDeclaration"};
  static constexpr unsigned long variant{404};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgEnumDeclaration,SgName,&SgEnumDeclaration::p_name>, describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_embedded>, describe_field_t<SgEnumDeclaration,SgEnumType*,&SgEnumDeclaration::p_type>, describe_field_t<SgEnumDeclaration,SgType*,&SgEnumDeclaration::p_adaParentType>, describe_field_t<SgEnumDeclaration,SgInitializedNamePtrList,&SgEnumDeclaration::p_enumerators>, describe_field_t<SgEnumDeclaration,SgScopeStatement*,&SgEnumDeclaration::p_scope>, describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_isUnNamed>, describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_isAutonomousDeclaration>, describe_field_t<SgEnumDeclaration,SgType*,&SgEnumDeclaration::p_field_type>, describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_isScopedEnum>, describe_field_t<SgEnumDeclaration,int,&SgEnumDeclaration::p_name_qualification_length>, describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_type_elaboration_required>, describe_field_t<SgEnumDeclaration,bool,&SgEnumDeclaration::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<404> { using type = SgEnumDeclaration; };

// Class: EnumFieldSymbol
template <> struct describe_field_t<SgEnumFieldSymbol,SgInitializedName*,&SgEnumFieldSymbol::p_declaration> {
  using parent = SgEnumFieldSymbol;
  using field_type = SgInitializedName*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumFieldSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumFieldSymbol, SgInitializedName* SgEnumFieldSymbol::*, &SgEnumFieldSymbol::p_declaration>;
};
template <> struct describe_node_t<SgEnumFieldSymbol> {
  using node = SgEnumFieldSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"EnumFieldSymbol"};
  static constexpr unsigned long variant{405};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgEnumFieldSymbol,SgInitializedName*,&SgEnumFieldSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<405> { using type = SgEnumFieldSymbol; };

// Class: EnumSymbol
template <> struct describe_field_t<SgEnumSymbol,SgEnumDeclaration*,&SgEnumSymbol::p_declaration> {
  using parent = SgEnumSymbol;
  using field_type = SgEnumDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgEnumDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgEnumSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumSymbol, SgEnumDeclaration* SgEnumSymbol::*, &SgEnumSymbol::p_declaration>;
};
template <> struct describe_node_t<SgEnumSymbol> {
  using node = SgEnumSymbol;
  using base = SgTypeSymbol;
  static constexpr char const * const name{"EnumSymbol"};
  static constexpr unsigned long variant{406};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgEnumSymbol,SgEnumDeclaration*,&SgEnumSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<406> { using type = SgEnumSymbol; };

// Class: EnumType
template <> struct describe_node_t<SgEnumType> {
  using node = SgEnumType;
  using base = SgNamedType;
  static constexpr char const * const name{"EnumType"};
  static constexpr unsigned long variant{407};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<407> { using type = SgEnumType; };

// Class: EnumVal
template <> struct describe_field_t<SgEnumVal,long long int,&SgEnumVal::p_value> {
  using parent = SgEnumVal;
  using field_type = long long int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"long long int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumVal, long long int SgEnumVal::*, &SgEnumVal::p_value>;
};
template <> struct describe_field_t<SgEnumVal,SgEnumDeclaration*,&SgEnumVal::p_declaration> {
  using parent = SgEnumVal;
  using field_type = SgEnumDeclaration*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgEnumDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumVal::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumVal, SgEnumDeclaration* SgEnumVal::*, &SgEnumVal::p_declaration>;
};
template <> struct describe_field_t<SgEnumVal,SgName,&SgEnumVal::p_name> {
  using parent = SgEnumVal;
  using field_type = SgName;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumVal::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumVal, SgName SgEnumVal::*, &SgEnumVal::p_name>;
};
template <> struct describe_field_t<SgEnumVal,bool,&SgEnumVal::p_requiresNameQualification> {
  using parent = SgEnumVal;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"requiresNameQualification"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumVal::p_requiresNameQualification};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumVal, bool SgEnumVal::*, &SgEnumVal::p_requiresNameQualification>;
};
template <> struct describe_field_t<SgEnumVal,int,&SgEnumVal::p_name_qualification_length> {
  using parent = SgEnumVal;
  using field_type = int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumVal::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumVal, int SgEnumVal::*, &SgEnumVal::p_name_qualification_length>;
};
template <> struct describe_field_t<SgEnumVal,bool,&SgEnumVal::p_type_elaboration_required> {
  using parent = SgEnumVal;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumVal::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumVal, bool SgEnumVal::*, &SgEnumVal::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgEnumVal,bool,&SgEnumVal::p_global_qualification_required> {
  using parent = SgEnumVal;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEnumVal::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEnumVal, bool SgEnumVal::*, &SgEnumVal::p_global_qualification_required>;
};
template <> struct describe_node_t<SgEnumVal> {
  using node = SgEnumVal;
  using base = SgValueExp;
  static constexpr char const * const name{"EnumVal"};
  static constexpr unsigned long variant{408};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgEnumVal,long long int,&SgEnumVal::p_value>, describe_field_t<SgEnumVal,SgEnumDeclaration*,&SgEnumVal::p_declaration>, describe_field_t<SgEnumVal,SgName,&SgEnumVal::p_name>, describe_field_t<SgEnumVal,bool,&SgEnumVal::p_requiresNameQualification>, describe_field_t<SgEnumVal,int,&SgEnumVal::p_name_qualification_length>, describe_field_t<SgEnumVal,bool,&SgEnumVal::p_type_elaboration_required>, describe_field_t<SgEnumVal,bool,&SgEnumVal::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<408> { using type = SgEnumVal; };

// Class: EqualityOp
template <> struct describe_node_t<SgEqualityOp> {
  using node = SgEqualityOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"EqualityOp"};
  static constexpr unsigned long variant{409};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<409> { using type = SgEqualityOp; };

// Class: EquivalenceStatement
template <> struct describe_field_t<SgEquivalenceStatement,SgExprListExp*,&SgEquivalenceStatement::p_equivalence_set_list> {
  using parent = SgEquivalenceStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"equivalence_set_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgEquivalenceStatement::p_equivalence_set_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgEquivalenceStatement, SgExprListExp* SgEquivalenceStatement::*, &SgEquivalenceStatement::p_equivalence_set_list>;
};
template <> struct describe_node_t<SgEquivalenceStatement> {
  using node = SgEquivalenceStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"EquivalenceStatement"};
  static constexpr unsigned long variant{410};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgEquivalenceStatement,SgExprListExp*,&SgEquivalenceStatement::p_equivalence_set_list>>;
};
template <> struct node_from_variant_t<410> { using type = SgEquivalenceStatement; };

// Class: ErrorDirectiveStatement
template <> struct describe_node_t<SgErrorDirectiveStatement> {
  using node = SgErrorDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"ErrorDirectiveStatement"};
  static constexpr unsigned long variant{411};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<411> { using type = SgErrorDirectiveStatement; };

// Class: ExecStatement
template <> struct describe_field_t<SgExecStatement,SgExpression*,&SgExecStatement::p_executable> {
  using parent = SgExecStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"executable"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgExecStatement::p_executable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExecStatement, SgExpression* SgExecStatement::*, &SgExecStatement::p_executable>;
};
template <> struct describe_field_t<SgExecStatement,SgExpression*,&SgExecStatement::p_globals> {
  using parent = SgExecStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"globals"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgExecStatement::p_globals};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExecStatement, SgExpression* SgExecStatement::*, &SgExecStatement::p_globals>;
};
template <> struct describe_field_t<SgExecStatement,SgExpression*,&SgExecStatement::p_locals> {
  using parent = SgExecStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"locals"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgExecStatement::p_locals};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExecStatement, SgExpression* SgExecStatement::*, &SgExecStatement::p_locals>;
};
template <> struct describe_node_t<SgExecStatement> {
  using node = SgExecStatement;
  using base = SgStatement;
  static constexpr char const * const name{"ExecStatement"};
  static constexpr unsigned long variant{412};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgExecStatement,SgExpression*,&SgExecStatement::p_executable>, describe_field_t<SgExecStatement,SgExpression*,&SgExecStatement::p_globals>, describe_field_t<SgExecStatement,SgExpression*,&SgExecStatement::p_locals>>;
};
template <> struct node_from_variant_t<412> { using type = SgExecStatement; };

// Class: ExponentiationOp
template <> struct describe_node_t<SgExponentiationOp> {
  using node = SgExponentiationOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"ExponentiationOp"};
  static constexpr unsigned long variant{413};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<413> { using type = SgExponentiationOp; };

// Class: ExponentiationAssignOp
template <> struct describe_node_t<SgExponentiationAssignOp> {
  using node = SgExponentiationAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"ExponentiationAssignOp"};
  static constexpr unsigned long variant{414};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<414> { using type = SgExponentiationAssignOp; };

// Class: ExprListExp
template <> struct describe_field_t<SgExprListExp,SgExpressionPtrList,&SgExprListExp::p_expressions> {
  using parent = SgExprListExp;
  using field_type = SgExpressionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expressions"};
  static constexpr char const * const typestr{"SgExpressionPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgExprListExp::p_expressions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExprListExp, SgExpressionPtrList SgExprListExp::*, &SgExprListExp::p_expressions>;
};
template <> struct describe_node_t<SgExprListExp> {
  using node = SgExprListExp;
  using base = SgExpression;
  static constexpr char const * const name{"ExprListExp"};
  static constexpr unsigned long variant{415};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgListExp, SgTupleExp, SgMatrixExp>;
  using fields_t = mp::List<describe_field_t<SgExprListExp,SgExpressionPtrList,&SgExprListExp::p_expressions>>;
};
template <> struct node_from_variant_t<415> { using type = SgExprListExp; };

// Class: ExprStatement
template <> struct describe_field_t<SgExprStatement,SgExpression*,&SgExprStatement::p_expression> {
  using parent = SgExprStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgExprStatement::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExprStatement, SgExpression* SgExprStatement::*, &SgExprStatement::p_expression>;
};
template <> struct describe_node_t<SgExprStatement> {
  using node = SgExprStatement;
  using base = SgStatement;
  static constexpr char const * const name{"ExprStatement"};
  static constexpr unsigned long variant{416};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgExprStatement,SgExpression*,&SgExprStatement::p_expression>>;
};
template <> struct node_from_variant_t<416> { using type = SgExprStatement; };

// Class: Expression
template <> struct describe_field_t<SgExpression,bool,&SgExpression::p_need_paren> {
  using parent = SgExpression;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"need_paren"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgExpression::p_need_paren};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExpression, bool SgExpression::*, &SgExpression::p_need_paren>;
};
template <> struct describe_field_t<SgExpression,bool,&SgExpression::p_lvalue> {
  using parent = SgExpression;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"lvalue"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgExpression::p_lvalue};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExpression, bool SgExpression::*, &SgExpression::p_lvalue>;
};
template <> struct describe_field_t<SgExpression,bool,&SgExpression::p_global_qualified_name> {
  using parent = SgExpression;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"global_qualified_name"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgExpression::p_global_qualified_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExpression, bool SgExpression::*, &SgExpression::p_global_qualified_name>;
};
template <> struct describe_field_t<SgExpression,Sg_File_Info*,&SgExpression::p_operatorPosition> {
  using parent = SgExpression;
  using field_type = Sg_File_Info*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"operatorPosition"};
  static constexpr char const * const typestr{"Sg_File_Info*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgExpression::p_operatorPosition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgExpression, Sg_File_Info* SgExpression::*, &SgExpression::p_operatorPosition>;
};
template <> struct describe_node_t<SgExpression> {
  using node = SgExpression;
  using base = SgLocatedNode;
  static constexpr char const * const name{"Expression"};
  static constexpr unsigned long variant{417};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgUnaryOp, SgBinaryOp, SgExprListExp, SgValueExp, SgCallExpression, SgUpcLocalsizeofExpression, SgUpcBlocksizeofExpression, SgUpcElemsizeofExpression, SgJavaInstanceOfOp, SgSuperExp, SgTypeIdOp, SgConditionalExp, SgNewExp, SgDeleteExp, SgThisExp, SgRefExp, SgInitializer, SgVarArgStartOp, SgVarArgOp, SgVarArgEndOp, SgVarArgCopyOp, SgVarArgStartOneOperandOp, SgNullExpression, SgVariantExpression, SgSubscriptExpression, SgColonShapeExp, SgAsteriskShapeExp, SgImpliedDo, SgIOItemExpression, SgActualArgumentExpression, SgStatementExpression, SgAsmOp, SgCudaKernelExecConfig, SgUnknownArrayOrFunctionReference, SgPseudoDestructorRefExp, SgCAFCoExpression, SgSizeOfOp, SgLambdaRefExp, SgDictionaryExp, SgKeyDatumPair, SgReferenceExp, SgComprehension, SgListComprehension, SgSetComprehension, SgDictionaryComprehension, SgNaryOp, SgStringConversion, SgYieldExpression, SgAlignOfOp, SgRangeExp, SgMagicColonExp, SgTypeTraitBuiltinOperator, SgCompoundLiteralExp, SgJavaAnnotation, SgJavaTypeExpression, SgTypeExpression, SgClassExp, SgFunctionParameterRefExp, SgLambdaExp, SgHereExp, SgAtExp, SgFinishExp, SgNoexceptOp, SgAdaTaskRefExp, SgAdaProtectedRefExp, SgFoldExpression, SgAwaitExpression, SgChooseExpression, SgAdaAttributeExp, SgJovialTablePresetExp, SgJovialPresetPositionExp, SgAdaOthersExp, SgAdaRenamingRefExp, SgAdaUnitRefExp>;
  using fields_t = mp::List<describe_field_t<SgExpression,bool,&SgExpression::p_need_paren>, describe_field_t<SgExpression,bool,&SgExpression::p_lvalue>, describe_field_t<SgExpression,bool,&SgExpression::p_global_qualified_name>, describe_field_t<SgExpression,Sg_File_Info*,&SgExpression::p_operatorPosition>>;
};
template <> struct node_from_variant_t<417> { using type = SgExpression; };

// Class: ExpressionRoot
template <> struct describe_node_t<SgExpressionRoot> {
  using node = SgExpressionRoot;
  using base = SgUnaryOp;
  static constexpr char const * const name{"ExpressionRoot"};
  static constexpr unsigned long variant{418};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<418> { using type = SgExpressionRoot; };

// Class: File
template <> struct describe_field_t<SgFile,Sg_File_Info*,&SgFile::p_startOfConstruct> {
  using parent = SgFile;
  using field_type = Sg_File_Info*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"startOfConstruct"};
  static constexpr char const * const typestr{"Sg_File_Info*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_startOfConstruct};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, Sg_File_Info* SgFile::*, &SgFile::p_startOfConstruct>;
};
template <> struct describe_field_t<SgFile,SgStringList,&SgFile::p_originalCommandLineArgumentList> {
  using parent = SgFile;
  using field_type = SgStringList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"originalCommandLineArgumentList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_originalCommandLineArgumentList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, SgStringList SgFile::*, &SgFile::p_originalCommandLineArgumentList>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_verbose> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"verbose"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_verbose};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_verbose>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_output_warnings> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"output_warnings"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_output_warnings};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_output_warnings>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_C_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"C_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_C_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_C_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_Cxx_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"Cxx_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_Cxx_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_Cxx_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_Fortran_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"Fortran_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_Fortran_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_Fortran_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_CoArrayFortran_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"CoArrayFortran_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_CoArrayFortran_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_CoArrayFortran_only>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_upc_threads> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{8};
  static constexpr char const * const name{"upc_threads"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_upc_threads};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_upc_threads>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_Java_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"Java_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_Java_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_Java_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_Jvm_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"Jvm_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_Jvm_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_Jvm_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_Jovial_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"Jovial_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_Jovial_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_Jovial_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_PHP_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{12};
  static constexpr char const * const name{"PHP_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_PHP_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_PHP_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_Python_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{13};
  static constexpr char const * const name{"Python_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_Python_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_Python_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_Cuda_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{14};
  static constexpr char const * const name{"Cuda_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_Cuda_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_Cuda_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_OpenCL_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{15};
  static constexpr char const * const name{"OpenCL_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_OpenCL_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_OpenCL_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_Csharp_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{16};
  static constexpr char const * const name{"Csharp_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_Csharp_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_Csharp_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_Ada_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{17};
  static constexpr char const * const name{"Ada_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_Ada_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_Ada_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_requires_C_preprocessor> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{18};
  static constexpr char const * const name{"requires_C_preprocessor"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_requires_C_preprocessor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_requires_C_preprocessor>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_binary_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{19};
  static constexpr char const * const name{"binary_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_binary_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_binary_only>;
};
template <> struct describe_field_t<SgFile,SgFile::outputFormatOption_enum,&SgFile::p_inputFormat> {
  using parent = SgFile;
  using field_type = SgFile::outputFormatOption_enum;
  static constexpr size_t position{20};
  static constexpr char const * const name{"inputFormat"};
  static constexpr char const * const typestr{"SgFile::outputFormatOption_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_inputFormat};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, SgFile::outputFormatOption_enum SgFile::*, &SgFile::p_inputFormat>;
};
template <> struct describe_field_t<SgFile,SgFile::outputFormatOption_enum,&SgFile::p_outputFormat> {
  using parent = SgFile;
  using field_type = SgFile::outputFormatOption_enum;
  static constexpr size_t position{21};
  static constexpr char const * const name{"outputFormat"};
  static constexpr char const * const typestr{"SgFile::outputFormatOption_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_outputFormat};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, SgFile::outputFormatOption_enum SgFile::*, &SgFile::p_outputFormat>;
};
template <> struct describe_field_t<SgFile,SgFile::outputFormatOption_enum,&SgFile::p_backendCompileFormat> {
  using parent = SgFile;
  using field_type = SgFile::outputFormatOption_enum;
  static constexpr size_t position{22};
  static constexpr char const * const name{"backendCompileFormat"};
  static constexpr char const * const typestr{"SgFile::outputFormatOption_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_backendCompileFormat};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, SgFile::outputFormatOption_enum SgFile::*, &SgFile::p_backendCompileFormat>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_fortran_implicit_none> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{23};
  static constexpr char const * const name{"fortran_implicit_none"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_fortran_implicit_none};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_fortran_implicit_none>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_openmp> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{24};
  static constexpr char const * const name{"openmp"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_openmp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_openmp>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_openmp_parse_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{25};
  static constexpr char const * const name{"openmp_parse_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_openmp_parse_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_openmp_parse_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_openmp_ast_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{26};
  static constexpr char const * const name{"openmp_ast_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_openmp_ast_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_openmp_ast_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_openmp_lowering> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{27};
  static constexpr char const * const name{"openmp_lowering"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_openmp_lowering};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_openmp_lowering>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_openacc> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{28};
  static constexpr char const * const name{"openacc"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_openacc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_openacc>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_openacc_parse_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{29};
  static constexpr char const * const name{"openacc_parse_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_openacc_parse_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_openacc_parse_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_openacc_ast_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{30};
  static constexpr char const * const name{"openacc_ast_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_openacc_ast_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_openacc_ast_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_cray_pointer_support> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{31};
  static constexpr char const * const name{"cray_pointer_support"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_cray_pointer_support};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_cray_pointer_support>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_failsafe> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{32};
  static constexpr char const * const name{"failsafe"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_failsafe};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_failsafe>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_output_parser_actions> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{33};
  static constexpr char const * const name{"output_parser_actions"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_output_parser_actions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_output_parser_actions>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_exit_after_parser> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{34};
  static constexpr char const * const name{"exit_after_parser"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_exit_after_parser};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_exit_after_parser>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_skip_syntax_check> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{35};
  static constexpr char const * const name{"skip_syntax_check"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_skip_syntax_check};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_skip_syntax_check>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_skip_parser> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{36};
  static constexpr char const * const name{"skip_parser"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_skip_parser};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_skip_parser>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_relax_syntax_check> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{37};
  static constexpr char const * const name{"relax_syntax_check"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_relax_syntax_check};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_relax_syntax_check>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_skip_translation_from_edg_ast_to_rose_ast> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{38};
  static constexpr char const * const name{"skip_translation_from_edg_ast_to_rose_ast"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_skip_translation_from_edg_ast_to_rose_ast};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_skip_translation_from_edg_ast_to_rose_ast>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_skip_transformation> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{39};
  static constexpr char const * const name{"skip_transformation"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_skip_transformation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_skip_transformation>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_skip_unparse> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{40};
  static constexpr char const * const name{"skip_unparse"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_skip_unparse};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_skip_unparse>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_skipfinalCompileStep> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{41};
  static constexpr char const * const name{"skipfinalCompileStep"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_skipfinalCompileStep};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_skipfinalCompileStep>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_includes> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{42};
  static constexpr char const * const name{"unparse_includes"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_includes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_includes>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_line_directives> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{43};
  static constexpr char const * const name{"unparse_line_directives"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_line_directives};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_line_directives>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_function_calls_using_operator_syntax> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{44};
  static constexpr char const * const name{"unparse_function_calls_using_operator_syntax"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_function_calls_using_operator_syntax};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_function_calls_using_operator_syntax>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_function_calls_using_operator_names> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{45};
  static constexpr char const * const name{"unparse_function_calls_using_operator_names"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_function_calls_using_operator_names};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_function_calls_using_operator_names>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_instruction_addresses> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{46};
  static constexpr char const * const name{"unparse_instruction_addresses"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_instruction_addresses};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_instruction_addresses>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_raw_memory_contents> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{47};
  static constexpr char const * const name{"unparse_raw_memory_contents"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_raw_memory_contents};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_raw_memory_contents>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_binary_file_format> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{48};
  static constexpr char const * const name{"unparse_binary_file_format"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_binary_file_format};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_binary_file_format>;
};
template <> struct describe_field_t<SgFile,SgFile::languageOption_enum,&SgFile::p_outputLanguage> {
  using parent = SgFile;
  using field_type = SgFile::languageOption_enum;
  static constexpr size_t position{49};
  static constexpr char const * const name{"outputLanguage"};
  static constexpr char const * const typestr{"SgFile::languageOption_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_outputLanguage};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, SgFile::languageOption_enum SgFile::*, &SgFile::p_outputLanguage>;
};
template <> struct describe_field_t<SgFile,SgFile::languageOption_enum,&SgFile::p_inputLanguage> {
  using parent = SgFile;
  using field_type = SgFile::languageOption_enum;
  static constexpr size_t position{50};
  static constexpr char const * const name{"inputLanguage"};
  static constexpr char const * const typestr{"SgFile::languageOption_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_inputLanguage};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, SgFile::languageOption_enum SgFile::*, &SgFile::p_inputLanguage>;
};
template <> struct describe_field_t<SgFile,std::string,&SgFile::p_sourceFileNameWithPath> {
  using parent = SgFile;
  using field_type = std::string;
  static constexpr size_t position{51};
  static constexpr char const * const name{"sourceFileNameWithPath"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileNameWithPath};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, std::string SgFile::*, &SgFile::p_sourceFileNameWithPath>;
};
template <> struct describe_field_t<SgFile,std::string,&SgFile::p_sourceFileNameWithoutPath> {
  using parent = SgFile;
  using field_type = std::string;
  static constexpr size_t position{52};
  static constexpr char const * const name{"sourceFileNameWithoutPath"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileNameWithoutPath};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, std::string SgFile::*, &SgFile::p_sourceFileNameWithoutPath>;
};
template <> struct describe_field_t<SgFile,std::string,&SgFile::p_unparse_output_filename> {
  using parent = SgFile;
  using field_type = std::string;
  static constexpr size_t position{53};
  static constexpr char const * const name{"unparse_output_filename"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_output_filename};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, std::string SgFile::*, &SgFile::p_unparse_output_filename>;
};
template <> struct describe_field_t<SgFile,std::string,&SgFile::p_objectFileNameWithPath> {
  using parent = SgFile;
  using field_type = std::string;
  static constexpr size_t position{54};
  static constexpr char const * const name{"objectFileNameWithPath"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_objectFileNameWithPath};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, std::string SgFile::*, &SgFile::p_objectFileNameWithPath>;
};
template <> struct describe_field_t<SgFile,std::string,&SgFile::p_objectFileNameWithoutPath> {
  using parent = SgFile;
  using field_type = std::string;
  static constexpr size_t position{55};
  static constexpr char const * const name{"objectFileNameWithoutPath"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_objectFileNameWithoutPath};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, std::string SgFile::*, &SgFile::p_objectFileNameWithoutPath>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_useBackendOnly> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{56};
  static constexpr char const * const name{"useBackendOnly"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_useBackendOnly};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_useBackendOnly>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_compileOnly> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{57};
  static constexpr char const * const name{"compileOnly"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_compileOnly};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_compileOnly>;
};
template <> struct describe_field_t<SgFile,std::string,&SgFile::p_savedFrontendCommandLine> {
  using parent = SgFile;
  using field_type = std::string;
  static constexpr size_t position{58};
  static constexpr char const * const name{"savedFrontendCommandLine"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_savedFrontendCommandLine};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, std::string SgFile::*, &SgFile::p_savedFrontendCommandLine>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_no_implicit_templates> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{59};
  static constexpr char const * const name{"no_implicit_templates"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_no_implicit_templates};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_no_implicit_templates>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_no_implicit_inline_templates> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{60};
  static constexpr char const * const name{"no_implicit_inline_templates"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_no_implicit_inline_templates};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_no_implicit_inline_templates>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_skip_commentsAndDirectives> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{61};
  static constexpr char const * const name{"skip_commentsAndDirectives"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_skip_commentsAndDirectives};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_skip_commentsAndDirectives>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_collectAllCommentsAndDirectives> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{62};
  static constexpr char const * const name{"collectAllCommentsAndDirectives"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_collectAllCommentsAndDirectives};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_collectAllCommentsAndDirectives>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_translateCommentsAndDirectivesIntoAST> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{63};
  static constexpr char const * const name{"translateCommentsAndDirectivesIntoAST"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_translateCommentsAndDirectivesIntoAST};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_translateCommentsAndDirectivesIntoAST>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparseHeaderFiles> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{64};
  static constexpr char const * const name{"unparseHeaderFiles"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparseHeaderFiles};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparseHeaderFiles>;
};
template <> struct describe_field_t<SgFile,ROSEAttributesListContainerPtr,&SgFile::p_preprocessorDirectivesAndCommentsList> {
  using parent = SgFile;
  using field_type = ROSEAttributesListContainerPtr;
  static constexpr size_t position{65};
  static constexpr char const * const name{"preprocessorDirectivesAndCommentsList"};
  static constexpr char const * const typestr{"ROSEAttributesListContainerPtr"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_preprocessorDirectivesAndCommentsList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, ROSEAttributesListContainerPtr SgFile::*, &SgFile::p_preprocessorDirectivesAndCommentsList>;
};
template <> struct describe_field_t<SgFile,AstAttributeMechanism*,&SgFile::p_attributeMechanism> {
  using parent = SgFile;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{66};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, AstAttributeMechanism* SgFile::*, &SgFile::p_attributeMechanism>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_KCC_frontend> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{67};
  static constexpr char const * const name{"KCC_frontend"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_KCC_frontend};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_KCC_frontend>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_new_frontend> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{68};
  static constexpr char const * const name{"new_frontend"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_new_frontend};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_new_frontend>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_disable_edg_backend> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{69};
  static constexpr char const * const name{"disable_edg_backend"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_disable_edg_backend};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_disable_edg_backend>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_disable_sage_backend> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{70};
  static constexpr char const * const name{"disable_sage_backend"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_disable_sage_backend};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_disable_sage_backend>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_testingLevel> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{71};
  static constexpr char const * const name{"testingLevel"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_testingLevel};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_testingLevel>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_preinit_il> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{72};
  static constexpr char const * const name{"preinit_il"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_preinit_il};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_preinit_il>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_enable_cp_backend> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{73};
  static constexpr char const * const name{"enable_cp_backend"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_enable_cp_backend};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_enable_cp_backend>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_markGeneratedFiles> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{74};
  static constexpr char const * const name{"markGeneratedFiles"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_markGeneratedFiles};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_markGeneratedFiles>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_negative_test> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{75};
  static constexpr char const * const name{"negative_test"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_negative_test};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_negative_test>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_strict_language_handling> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{76};
  static constexpr char const * const name{"strict_language_handling"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_strict_language_handling};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_strict_language_handling>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_wave> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{77};
  static constexpr char const * const name{"wave"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_wave};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_wave>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_embedColorCodesInGeneratedCode> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{78};
  static constexpr char const * const name{"embedColorCodesInGeneratedCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_embedColorCodesInGeneratedCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_embedColorCodesInGeneratedCode>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_generateSourcePositionCodes> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{79};
  static constexpr char const * const name{"generateSourcePositionCodes"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_generateSourcePositionCodes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_generateSourcePositionCodes>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesCppFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{80};
  static constexpr char const * const name{"sourceFileUsesCppFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesCppFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesCppFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortranFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{81};
  static constexpr char const * const name{"sourceFileUsesFortranFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesFortranFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesFortranFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran77FileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{82};
  static constexpr char const * const name{"sourceFileUsesFortran77FileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesFortran77FileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesFortran77FileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran90FileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{83};
  static constexpr char const * const name{"sourceFileUsesFortran90FileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesFortran90FileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesFortran90FileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran95FileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{84};
  static constexpr char const * const name{"sourceFileUsesFortran95FileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesFortran95FileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesFortran95FileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran2003FileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{85};
  static constexpr char const * const name{"sourceFileUsesFortran2003FileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesFortran2003FileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesFortran2003FileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran2008FileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{86};
  static constexpr char const * const name{"sourceFileUsesFortran2008FileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesFortran2008FileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesFortran2008FileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesCoArrayFortranFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{87};
  static constexpr char const * const name{"sourceFileUsesCoArrayFortranFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesCoArrayFortranFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesCoArrayFortranFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesPHPFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{88};
  static constexpr char const * const name{"sourceFileUsesPHPFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesPHPFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesPHPFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesPythonFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{89};
  static constexpr char const * const name{"sourceFileUsesPythonFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesPythonFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesPythonFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesJavaFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{90};
  static constexpr char const * const name{"sourceFileUsesJavaFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesJavaFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesJavaFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesJvmFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{91};
  static constexpr char const * const name{"sourceFileUsesJvmFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesJvmFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesJvmFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesBinaryFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{92};
  static constexpr char const * const name{"sourceFileUsesBinaryFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesBinaryFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesBinaryFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileTypeIsUnknown> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{93};
  static constexpr char const * const name{"sourceFileTypeIsUnknown"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileTypeIsUnknown};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileTypeIsUnknown>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesCsharpFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{94};
  static constexpr char const * const name{"sourceFileUsesCsharpFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesCsharpFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesCsharpFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesAdaFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{95};
  static constexpr char const * const name{"sourceFileUsesAdaFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesAdaFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesAdaFileExtension>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesJovialFileExtension> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{96};
  static constexpr char const * const name{"sourceFileUsesJovialFileExtension"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_sourceFileUsesJovialFileExtension};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_sourceFileUsesJovialFileExtension>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_detect_dangling_pointers> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{97};
  static constexpr char const * const name{"detect_dangling_pointers"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_detect_dangling_pointers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_detect_dangling_pointers>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_experimental_flang_frontend> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{98};
  static constexpr char const * const name{"experimental_flang_frontend"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_experimental_flang_frontend};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_experimental_flang_frontend>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_read_executable_file_format_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{99};
  static constexpr char const * const name{"read_executable_file_format_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_read_executable_file_format_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_read_executable_file_format_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_visualize_executable_file_format_skip_symbols> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{100};
  static constexpr char const * const name{"visualize_executable_file_format_skip_symbols"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_visualize_executable_file_format_skip_symbols};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_visualize_executable_file_format_skip_symbols>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_visualize_dwarf_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{101};
  static constexpr char const * const name{"visualize_dwarf_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_visualize_dwarf_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_visualize_dwarf_only>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_read_instructions_only> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{102};
  static constexpr char const * const name{"read_instructions_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_read_instructions_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_read_instructions_only>;
};
template <> struct describe_field_t<SgFile,SgStringList,&SgFile::p_libraryArchiveObjectFileNameList> {
  using parent = SgFile;
  using field_type = SgStringList;
  static constexpr size_t position{103};
  static constexpr char const * const name{"libraryArchiveObjectFileNameList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_libraryArchiveObjectFileNameList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, SgStringList SgFile::*, &SgFile::p_libraryArchiveObjectFileNameList>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_isLibraryArchive> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{104};
  static constexpr char const * const name{"isLibraryArchive"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_isLibraryArchive};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_isLibraryArchive>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_isObjectFile> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{105};
  static constexpr char const * const name{"isObjectFile"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_isObjectFile};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_isObjectFile>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_tokens> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{106};
  static constexpr char const * const name{"unparse_tokens"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_tokens};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_tokens>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_unparse_tokens_testing> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{107};
  static constexpr char const * const name{"unparse_tokens_testing"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_tokens_testing};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_unparse_tokens_testing>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_using_leading_and_trailing_token_mappings> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{108};
  static constexpr char const * const name{"unparse_using_leading_and_trailing_token_mappings"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_using_leading_and_trailing_token_mappings};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_using_leading_and_trailing_token_mappings>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_template_ast> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{109};
  static constexpr char const * const name{"unparse_template_ast"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_template_ast};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_template_ast>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_skipAstConsistancyTests> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{110};
  static constexpr char const * const name{"skipAstConsistancyTests"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_skipAstConsistancyTests};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_skipAstConsistancyTests>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_multifile_support> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{111};
  static constexpr char const * const name{"multifile_support"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_multifile_support};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_multifile_support>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_optimization> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{112};
  static constexpr char const * const name{"optimization"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_optimization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_optimization>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_use_token_stream_to_improve_source_position_info> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{113};
  static constexpr char const * const name{"use_token_stream_to_improve_source_position_info"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_use_token_stream_to_improve_source_position_info};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_use_token_stream_to_improve_source_position_info>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_suppress_variable_declaration_normalization> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{114};
  static constexpr char const * const name{"suppress_variable_declaration_normalization"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_suppress_variable_declaration_normalization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_suppress_variable_declaration_normalization>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_edg_il_to_graphviz> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{115};
  static constexpr char const * const name{"edg_il_to_graphviz"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_edg_il_to_graphviz};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_edg_il_to_graphviz>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_clang_il_to_graphviz> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{116};
  static constexpr char const * const name{"clang_il_to_graphviz"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_clang_il_to_graphviz};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_clang_il_to_graphviz>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_no_optimize_flag_for_frontend> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{117};
  static constexpr char const * const name{"no_optimize_flag_for_frontend"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_no_optimize_flag_for_frontend};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_no_optimize_flag_for_frontend>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparse_edg_normalized_method_ROSE_1392> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{118};
  static constexpr char const * const name{"unparse_edg_normalized_method_ROSE_1392"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparse_edg_normalized_method_ROSE_1392};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparse_edg_normalized_method_ROSE_1392>;
};
template <> struct describe_field_t<SgFile,SgFile::standard_enum,&SgFile::p_standard> {
  using parent = SgFile;
  using field_type = SgFile::standard_enum;
  static constexpr size_t position{119};
  static constexpr char const * const name{"standard"};
  static constexpr char const * const typestr{"SgFile::standard_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_standard};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, SgFile::standard_enum SgFile::*, &SgFile::p_standard>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_gnu_standard> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{120};
  static constexpr char const * const name{"gnu_standard"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_gnu_standard};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_gnu_standard>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_frontendErrorCode> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{121};
  static constexpr char const * const name{"frontendErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_frontendErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_frontendErrorCode>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_javacErrorCode> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{122};
  static constexpr char const * const name{"javacErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_javacErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_javacErrorCode>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_ecjErrorCode> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{123};
  static constexpr char const * const name{"ecjErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_ecjErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_ecjErrorCode>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_midendErrorCode> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{124};
  static constexpr char const * const name{"midendErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_midendErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_midendErrorCode>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_unparserErrorCode> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{125};
  static constexpr char const * const name{"unparserErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparserErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_unparserErrorCode>;
};
template <> struct describe_field_t<SgFile,int,&SgFile::p_backendCompilerErrorCode> {
  using parent = SgFile;
  using field_type = int;
  static constexpr size_t position{126};
  static constexpr char const * const name{"backendCompilerErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_backendCompilerErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, int SgFile::*, &SgFile::p_backendCompilerErrorCode>;
};
template <> struct describe_field_t<SgFile,bool,&SgFile::p_unparsedFileFailedCompilation> {
  using parent = SgFile;
  using field_type = bool;
  static constexpr size_t position{127};
  static constexpr char const * const name{"unparsedFileFailedCompilation"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFile::p_unparsedFileFailedCompilation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFile, bool SgFile::*, &SgFile::p_unparsedFileFailedCompilation>;
};
template <> struct describe_node_t<SgFile> {
  using node = SgFile;
  using base = SgSupport;
  static constexpr char const * const name{"File"};
  static constexpr unsigned long variant{419};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgSourceFile, SgUnknownFile, SgBinaryComposite>;
  using fields_t = mp::List<describe_field_t<SgFile,Sg_File_Info*,&SgFile::p_startOfConstruct>, describe_field_t<SgFile,SgStringList,&SgFile::p_originalCommandLineArgumentList>, describe_field_t<SgFile,int,&SgFile::p_verbose>, describe_field_t<SgFile,bool,&SgFile::p_output_warnings>, describe_field_t<SgFile,bool,&SgFile::p_C_only>, describe_field_t<SgFile,bool,&SgFile::p_Cxx_only>, describe_field_t<SgFile,bool,&SgFile::p_Fortran_only>, describe_field_t<SgFile,bool,&SgFile::p_CoArrayFortran_only>, describe_field_t<SgFile,int,&SgFile::p_upc_threads>, describe_field_t<SgFile,bool,&SgFile::p_Java_only>, describe_field_t<SgFile,bool,&SgFile::p_Jvm_only>, describe_field_t<SgFile,bool,&SgFile::p_Jovial_only>, describe_field_t<SgFile,bool,&SgFile::p_PHP_only>, describe_field_t<SgFile,bool,&SgFile::p_Python_only>, describe_field_t<SgFile,bool,&SgFile::p_Cuda_only>, describe_field_t<SgFile,bool,&SgFile::p_OpenCL_only>, describe_field_t<SgFile,bool,&SgFile::p_Csharp_only>, describe_field_t<SgFile,bool,&SgFile::p_Ada_only>, describe_field_t<SgFile,bool,&SgFile::p_requires_C_preprocessor>, describe_field_t<SgFile,bool,&SgFile::p_binary_only>, describe_field_t<SgFile,SgFile::outputFormatOption_enum,&SgFile::p_inputFormat>, describe_field_t<SgFile,SgFile::outputFormatOption_enum,&SgFile::p_outputFormat>, describe_field_t<SgFile,SgFile::outputFormatOption_enum,&SgFile::p_backendCompileFormat>, describe_field_t<SgFile,bool,&SgFile::p_fortran_implicit_none>, describe_field_t<SgFile,bool,&SgFile::p_openmp>, describe_field_t<SgFile,bool,&SgFile::p_openmp_parse_only>, describe_field_t<SgFile,bool,&SgFile::p_openmp_ast_only>, describe_field_t<SgFile,bool,&SgFile::p_openmp_lowering>, describe_field_t<SgFile,bool,&SgFile::p_openacc>, describe_field_t<SgFile,bool,&SgFile::p_openacc_parse_only>, describe_field_t<SgFile,bool,&SgFile::p_openacc_ast_only>, describe_field_t<SgFile,bool,&SgFile::p_cray_pointer_support>, describe_field_t<SgFile,bool,&SgFile::p_failsafe>, describe_field_t<SgFile,bool,&SgFile::p_output_parser_actions>, describe_field_t<SgFile,bool,&SgFile::p_exit_after_parser>, describe_field_t<SgFile,bool,&SgFile::p_skip_syntax_check>, describe_field_t<SgFile,bool,&SgFile::p_skip_parser>, describe_field_t<SgFile,bool,&SgFile::p_relax_syntax_check>, describe_field_t<SgFile,bool,&SgFile::p_skip_translation_from_edg_ast_to_rose_ast>, describe_field_t<SgFile,bool,&SgFile::p_skip_transformation>, describe_field_t<SgFile,bool,&SgFile::p_skip_unparse>, describe_field_t<SgFile,bool,&SgFile::p_skipfinalCompileStep>, describe_field_t<SgFile,bool,&SgFile::p_unparse_includes>, describe_field_t<SgFile,bool,&SgFile::p_unparse_line_directives>, describe_field_t<SgFile,bool,&SgFile::p_unparse_function_calls_using_operator_syntax>, describe_field_t<SgFile,bool,&SgFile::p_unparse_function_calls_using_operator_names>, describe_field_t<SgFile,bool,&SgFile::p_unparse_instruction_addresses>, describe_field_t<SgFile,bool,&SgFile::p_unparse_raw_memory_contents>, describe_field_t<SgFile,bool,&SgFile::p_unparse_binary_file_format>, describe_field_t<SgFile,SgFile::languageOption_enum,&SgFile::p_outputLanguage>, describe_field_t<SgFile,SgFile::languageOption_enum,&SgFile::p_inputLanguage>, describe_field_t<SgFile,std::string,&SgFile::p_sourceFileNameWithPath>, describe_field_t<SgFile,std::string,&SgFile::p_sourceFileNameWithoutPath>, describe_field_t<SgFile,std::string,&SgFile::p_unparse_output_filename>, describe_field_t<SgFile,std::string,&SgFile::p_objectFileNameWithPath>, describe_field_t<SgFile,std::string,&SgFile::p_objectFileNameWithoutPath>, describe_field_t<SgFile,bool,&SgFile::p_useBackendOnly>, describe_field_t<SgFile,bool,&SgFile::p_compileOnly>, describe_field_t<SgFile,std::string,&SgFile::p_savedFrontendCommandLine>, describe_field_t<SgFile,bool,&SgFile::p_no_implicit_templates>, describe_field_t<SgFile,bool,&SgFile::p_no_implicit_inline_templates>, describe_field_t<SgFile,bool,&SgFile::p_skip_commentsAndDirectives>, describe_field_t<SgFile,bool,&SgFile::p_collectAllCommentsAndDirectives>, describe_field_t<SgFile,bool,&SgFile::p_translateCommentsAndDirectivesIntoAST>, describe_field_t<SgFile,bool,&SgFile::p_unparseHeaderFiles>, describe_field_t<SgFile,ROSEAttributesListContainerPtr,&SgFile::p_preprocessorDirectivesAndCommentsList>, describe_field_t<SgFile,AstAttributeMechanism*,&SgFile::p_attributeMechanism>, describe_field_t<SgFile,bool,&SgFile::p_KCC_frontend>, describe_field_t<SgFile,bool,&SgFile::p_new_frontend>, describe_field_t<SgFile,bool,&SgFile::p_disable_edg_backend>, describe_field_t<SgFile,bool,&SgFile::p_disable_sage_backend>, describe_field_t<SgFile,int,&SgFile::p_testingLevel>, describe_field_t<SgFile,bool,&SgFile::p_preinit_il>, describe_field_t<SgFile,bool,&SgFile::p_enable_cp_backend>, describe_field_t<SgFile,bool,&SgFile::p_markGeneratedFiles>, describe_field_t<SgFile,bool,&SgFile::p_negative_test>, describe_field_t<SgFile,bool,&SgFile::p_strict_language_handling>, describe_field_t<SgFile,bool,&SgFile::p_wave>, describe_field_t<SgFile,int,&SgFile::p_embedColorCodesInGeneratedCode>, describe_field_t<SgFile,int,&SgFile::p_generateSourcePositionCodes>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesCppFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortranFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran77FileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran90FileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran95FileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran2003FileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesFortran2008FileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesCoArrayFortranFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesPHPFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesPythonFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesJavaFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesJvmFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesBinaryFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileTypeIsUnknown>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesCsharpFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesAdaFileExtension>, describe_field_t<SgFile,bool,&SgFile::p_sourceFileUsesJovialFileExtension>, describe_field_t<SgFile,int,&SgFile::p_detect_dangling_pointers>, describe_field_t<SgFile,bool,&SgFile::p_experimental_flang_frontend>, describe_field_t<SgFile,bool,&SgFile::p_read_executable_file_format_only>, describe_field_t<SgFile,bool,&SgFile::p_visualize_executable_file_format_skip_symbols>, describe_field_t<SgFile,bool,&SgFile::p_visualize_dwarf_only>, describe_field_t<SgFile,bool,&SgFile::p_read_instructions_only>, describe_field_t<SgFile,SgStringList,&SgFile::p_libraryArchiveObjectFileNameList>, describe_field_t<SgFile,bool,&SgFile::p_isLibraryArchive>, describe_field_t<SgFile,bool,&SgFile::p_isObjectFile>, describe_field_t<SgFile,bool,&SgFile::p_unparse_tokens>, describe_field_t<SgFile,int,&SgFile::p_unparse_tokens_testing>, describe_field_t<SgFile,bool,&SgFile::p_unparse_using_leading_and_trailing_token_mappings>, describe_field_t<SgFile,bool,&SgFile::p_unparse_template_ast>, describe_field_t<SgFile,bool,&SgFile::p_skipAstConsistancyTests>, describe_field_t<SgFile,bool,&SgFile::p_multifile_support>, describe_field_t<SgFile,bool,&SgFile::p_optimization>, describe_field_t<SgFile,bool,&SgFile::p_use_token_stream_to_improve_source_position_info>, describe_field_t<SgFile,bool,&SgFile::p_suppress_variable_declaration_normalization>, describe_field_t<SgFile,bool,&SgFile::p_edg_il_to_graphviz>, describe_field_t<SgFile,bool,&SgFile::p_clang_il_to_graphviz>, describe_field_t<SgFile,bool,&SgFile::p_no_optimize_flag_for_frontend>, describe_field_t<SgFile,bool,&SgFile::p_unparse_edg_normalized_method_ROSE_1392>, describe_field_t<SgFile,SgFile::standard_enum,&SgFile::p_standard>, describe_field_t<SgFile,bool,&SgFile::p_gnu_standard>, describe_field_t<SgFile,int,&SgFile::p_frontendErrorCode>, describe_field_t<SgFile,int,&SgFile::p_javacErrorCode>, describe_field_t<SgFile,int,&SgFile::p_ecjErrorCode>, describe_field_t<SgFile,int,&SgFile::p_midendErrorCode>, describe_field_t<SgFile,int,&SgFile::p_unparserErrorCode>, describe_field_t<SgFile,int,&SgFile::p_backendCompilerErrorCode>, describe_field_t<SgFile,bool,&SgFile::p_unparsedFileFailedCompilation>>;
};
template <> struct node_from_variant_t<419> { using type = SgFile; };

// Class: FileList
template <> struct describe_field_t<SgFileList,SgFilePtrList,&SgFileList::p_listOfFiles> {
  using parent = SgFileList;
  using field_type = SgFilePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"listOfFiles"};
  static constexpr char const * const typestr{"SgFilePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFileList::p_listOfFiles};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFileList, SgFilePtrList SgFileList::*, &SgFileList::p_listOfFiles>;
};
template <> struct describe_field_t<SgFileList,AstAttributeMechanism*,&SgFileList::p_attributeMechanism> {
  using parent = SgFileList;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFileList::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFileList, AstAttributeMechanism* SgFileList::*, &SgFileList::p_attributeMechanism>;
};
template <> struct describe_node_t<SgFileList> {
  using node = SgFileList;
  using base = SgSupport;
  static constexpr char const * const name{"FileList"};
  static constexpr unsigned long variant{420};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFileList,SgFilePtrList,&SgFileList::p_listOfFiles>, describe_field_t<SgFileList,AstAttributeMechanism*,&SgFileList::p_attributeMechanism>>;
};
template <> struct node_from_variant_t<420> { using type = SgFileList; };

// Class: FloatVal
template <> struct describe_field_t<SgFloatVal,float,&SgFloatVal::p_value> {
  using parent = SgFloatVal;
  using field_type = float;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"float"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFloatVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFloatVal, float SgFloatVal::*, &SgFloatVal::p_value>;
};
template <> struct describe_field_t<SgFloatVal,std::string,&SgFloatVal::p_valueString> {
  using parent = SgFloatVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFloatVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFloatVal, std::string SgFloatVal::*, &SgFloatVal::p_valueString>;
};
template <> struct describe_node_t<SgFloatVal> {
  using node = SgFloatVal;
  using base = SgValueExp;
  static constexpr char const * const name{"FloatVal"};
  static constexpr unsigned long variant{421};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFloatVal,float,&SgFloatVal::p_value>, describe_field_t<SgFloatVal,std::string,&SgFloatVal::p_valueString>>;
};
template <> struct node_from_variant_t<421> { using type = SgFloatVal; };

// Class: Float128Val
template <> struct describe_field_t<SgFloat128Val,long double,&SgFloat128Val::p_value> {
  using parent = SgFloat128Val;
  using field_type = long double;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"long double"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFloat128Val::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFloat128Val, long double SgFloat128Val::*, &SgFloat128Val::p_value>;
};
template <> struct describe_field_t<SgFloat128Val,std::string,&SgFloat128Val::p_valueString> {
  using parent = SgFloat128Val;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFloat128Val::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFloat128Val, std::string SgFloat128Val::*, &SgFloat128Val::p_valueString>;
};
template <> struct describe_node_t<SgFloat128Val> {
  using node = SgFloat128Val;
  using base = SgValueExp;
  static constexpr char const * const name{"Float128Val"};
  static constexpr unsigned long variant{422};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFloat128Val,long double,&SgFloat128Val::p_value>, describe_field_t<SgFloat128Val,std::string,&SgFloat128Val::p_valueString>>;
};
template <> struct node_from_variant_t<422> { using type = SgFloat128Val; };

// Class: Float80Val
template <> struct describe_field_t<SgFloat80Val,long double,&SgFloat80Val::p_value> {
  using parent = SgFloat80Val;
  using field_type = long double;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"long double"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFloat80Val::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFloat80Val, long double SgFloat80Val::*, &SgFloat80Val::p_value>;
};
template <> struct describe_field_t<SgFloat80Val,std::string,&SgFloat80Val::p_valueString> {
  using parent = SgFloat80Val;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFloat80Val::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFloat80Val, std::string SgFloat80Val::*, &SgFloat80Val::p_valueString>;
};
template <> struct describe_node_t<SgFloat80Val> {
  using node = SgFloat80Val;
  using base = SgValueExp;
  static constexpr char const * const name{"Float80Val"};
  static constexpr unsigned long variant{423};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFloat80Val,long double,&SgFloat80Val::p_value>, describe_field_t<SgFloat80Val,std::string,&SgFloat80Val::p_valueString>>;
};
template <> struct node_from_variant_t<423> { using type = SgFloat80Val; };

// Class: FoldExpression
template <> struct describe_field_t<SgFoldExpression,SgExpression*,&SgFoldExpression::p_operands> {
  using parent = SgFoldExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operands"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFoldExpression::p_operands};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFoldExpression, SgExpression* SgFoldExpression::*, &SgFoldExpression::p_operands>;
};
template <> struct describe_field_t<SgFoldExpression,std::string,&SgFoldExpression::p_operator_token> {
  using parent = SgFoldExpression;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operator_token"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFoldExpression::p_operator_token};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFoldExpression, std::string SgFoldExpression::*, &SgFoldExpression::p_operator_token>;
};
template <> struct describe_field_t<SgFoldExpression,bool,&SgFoldExpression::p_is_left_associative> {
  using parent = SgFoldExpression;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"is_left_associative"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFoldExpression::p_is_left_associative};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFoldExpression, bool SgFoldExpression::*, &SgFoldExpression::p_is_left_associative>;
};
template <> struct describe_node_t<SgFoldExpression> {
  using node = SgFoldExpression;
  using base = SgExpression;
  static constexpr char const * const name{"FoldExpression"};
  static constexpr unsigned long variant{424};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFoldExpression,SgExpression*,&SgFoldExpression::p_operands>, describe_field_t<SgFoldExpression,std::string,&SgFoldExpression::p_operator_token>, describe_field_t<SgFoldExpression,bool,&SgFoldExpression::p_is_left_associative>>;
};
template <> struct node_from_variant_t<424> { using type = SgFoldExpression; };

// Class: FlushStatement
template <> struct describe_node_t<SgFlushStatement> {
  using node = SgFlushStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"FlushStatement"};
  static constexpr unsigned long variant{425};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<425> { using type = SgFlushStatement; };

// Class: ForAllStatement
template <> struct describe_field_t<SgForAllStatement,SgExprListExp*,&SgForAllStatement::p_forall_header> {
  using parent = SgForAllStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"forall_header"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgForAllStatement::p_forall_header};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForAllStatement, SgExprListExp* SgForAllStatement::*, &SgForAllStatement::p_forall_header>;
};
template <> struct describe_field_t<SgForAllStatement,SgBasicBlock*,&SgForAllStatement::p_body> {
  using parent = SgForAllStatement;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgForAllStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForAllStatement, SgBasicBlock* SgForAllStatement::*, &SgForAllStatement::p_body>;
};
template <> struct describe_field_t<SgForAllStatement,bool,&SgForAllStatement::p_has_end_statement> {
  using parent = SgForAllStatement;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"has_end_statement"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgForAllStatement::p_has_end_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForAllStatement, bool SgForAllStatement::*, &SgForAllStatement::p_has_end_statement>;
};
template <> struct describe_field_t<SgForAllStatement,std::string,&SgForAllStatement::p_string_label> {
  using parent = SgForAllStatement;
  using field_type = std::string;
  static constexpr size_t position{3};
  static constexpr char const * const name{"string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgForAllStatement::p_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForAllStatement, std::string SgForAllStatement::*, &SgForAllStatement::p_string_label>;
};
template <> struct describe_field_t<SgForAllStatement,SgLabelRefExp*,&SgForAllStatement::p_end_numeric_label> {
  using parent = SgForAllStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgForAllStatement::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForAllStatement, SgLabelRefExp* SgForAllStatement::*, &SgForAllStatement::p_end_numeric_label>;
};
template <> struct describe_field_t<SgForAllStatement,SgForAllStatement::forall_statement_kind_enum,&SgForAllStatement::p_forall_statement_kind> {
  using parent = SgForAllStatement;
  using field_type = SgForAllStatement::forall_statement_kind_enum;
  static constexpr size_t position{5};
  static constexpr char const * const name{"forall_statement_kind"};
  static constexpr char const * const typestr{"SgForAllStatement::forall_statement_kind_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgForAllStatement::p_forall_statement_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForAllStatement, SgForAllStatement::forall_statement_kind_enum SgForAllStatement::*, &SgForAllStatement::p_forall_statement_kind>;
};
template <> struct describe_node_t<SgForAllStatement> {
  using node = SgForAllStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"ForAllStatement"};
  static constexpr unsigned long variant{426};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgForAllStatement,SgExprListExp*,&SgForAllStatement::p_forall_header>, describe_field_t<SgForAllStatement,SgBasicBlock*,&SgForAllStatement::p_body>, describe_field_t<SgForAllStatement,bool,&SgForAllStatement::p_has_end_statement>, describe_field_t<SgForAllStatement,std::string,&SgForAllStatement::p_string_label>, describe_field_t<SgForAllStatement,SgLabelRefExp*,&SgForAllStatement::p_end_numeric_label>, describe_field_t<SgForAllStatement,SgForAllStatement::forall_statement_kind_enum,&SgForAllStatement::p_forall_statement_kind>>;
};
template <> struct node_from_variant_t<426> { using type = SgForAllStatement; };

// Class: ForInitStatement
template <> struct describe_field_t<SgForInitStatement,SgStatementPtrList,&SgForInitStatement::p_init_stmt> {
  using parent = SgForInitStatement;
  using field_type = SgStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"init_stmt"};
  static constexpr char const * const typestr{"SgStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgForInitStatement::p_init_stmt};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForInitStatement, SgStatementPtrList SgForInitStatement::*, &SgForInitStatement::p_init_stmt>;
};
template <> struct describe_node_t<SgForInitStatement> {
  using node = SgForInitStatement;
  using base = SgStatement;
  static constexpr char const * const name{"ForInitStatement"};
  static constexpr unsigned long variant{427};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgForInitStatement,SgStatementPtrList,&SgForInitStatement::p_init_stmt>>;
};
template <> struct node_from_variant_t<427> { using type = SgForInitStatement; };

// Class: ForStatement
template <> struct describe_field_t<SgForStatement,SgForInitStatement*,&SgForStatement::p_for_init_stmt> {
  using parent = SgForStatement;
  using field_type = SgForInitStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"for_init_stmt"};
  static constexpr char const * const typestr{"SgForInitStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgForStatement::p_for_init_stmt};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForStatement, SgForInitStatement* SgForStatement::*, &SgForStatement::p_for_init_stmt>;
};
template <> struct describe_field_t<SgForStatement,SgStatement*,&SgForStatement::p_test> {
  using parent = SgForStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"test"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgForStatement::p_test};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForStatement, SgStatement* SgForStatement::*, &SgForStatement::p_test>;
};
template <> struct describe_field_t<SgForStatement,SgExpression*,&SgForStatement::p_increment> {
  using parent = SgForStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"increment"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgForStatement::p_increment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForStatement, SgExpression* SgForStatement::*, &SgForStatement::p_increment>;
};
template <> struct describe_field_t<SgForStatement,SgStatement*,&SgForStatement::p_loop_body> {
  using parent = SgForStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"loop_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgForStatement::p_loop_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForStatement, SgStatement* SgForStatement::*, &SgForStatement::p_loop_body>;
};
template <> struct describe_field_t<SgForStatement,SgStatement*,&SgForStatement::p_else_body> {
  using parent = SgForStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"else_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgForStatement::p_else_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForStatement, SgStatement* SgForStatement::*, &SgForStatement::p_else_body>;
};
template <> struct describe_field_t<SgForStatement,std::string,&SgForStatement::p_string_label> {
  using parent = SgForStatement;
  using field_type = std::string;
  static constexpr size_t position{5};
  static constexpr char const * const name{"string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgForStatement::p_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgForStatement, std::string SgForStatement::*, &SgForStatement::p_string_label>;
};
template <> struct describe_node_t<SgForStatement> {
  using node = SgForStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"ForStatement"};
  static constexpr unsigned long variant{428};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgForStatement,SgForInitStatement*,&SgForStatement::p_for_init_stmt>, describe_field_t<SgForStatement,SgStatement*,&SgForStatement::p_test>, describe_field_t<SgForStatement,SgExpression*,&SgForStatement::p_increment>, describe_field_t<SgForStatement,SgStatement*,&SgForStatement::p_loop_body>, describe_field_t<SgForStatement,SgStatement*,&SgForStatement::p_else_body>, describe_field_t<SgForStatement,std::string,&SgForStatement::p_string_label>>;
};
template <> struct node_from_variant_t<428> { using type = SgForStatement; };

// Class: FormatItem
template <> struct describe_field_t<SgFormatItem,int,&SgFormatItem::p_repeat_specification> {
  using parent = SgFormatItem;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"repeat_specification"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFormatItem::p_repeat_specification};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFormatItem, int SgFormatItem::*, &SgFormatItem::p_repeat_specification>;
};
template <> struct describe_field_t<SgFormatItem,SgExpression*,&SgFormatItem::p_data> {
  using parent = SgFormatItem;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"data"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFormatItem::p_data};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFormatItem, SgExpression* SgFormatItem::*, &SgFormatItem::p_data>;
};
template <> struct describe_field_t<SgFormatItem,SgFormatItemList*,&SgFormatItem::p_format_item_list> {
  using parent = SgFormatItem;
  using field_type = SgFormatItemList*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"format_item_list"};
  static constexpr char const * const typestr{"SgFormatItemList*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFormatItem::p_format_item_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFormatItem, SgFormatItemList* SgFormatItem::*, &SgFormatItem::p_format_item_list>;
};
template <> struct describe_node_t<SgFormatItem> {
  using node = SgFormatItem;
  using base = SgSupport;
  static constexpr char const * const name{"FormatItem"};
  static constexpr unsigned long variant{429};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFormatItem,int,&SgFormatItem::p_repeat_specification>, describe_field_t<SgFormatItem,SgExpression*,&SgFormatItem::p_data>, describe_field_t<SgFormatItem,SgFormatItemList*,&SgFormatItem::p_format_item_list>>;
};
template <> struct node_from_variant_t<429> { using type = SgFormatItem; };

// Class: FormatItemList
template <> struct describe_field_t<SgFormatItemList,SgFormatItemPtrList,&SgFormatItemList::p_format_item_list> {
  using parent = SgFormatItemList;
  using field_type = SgFormatItemPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"format_item_list"};
  static constexpr char const * const typestr{"SgFormatItemPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFormatItemList::p_format_item_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFormatItemList, SgFormatItemPtrList SgFormatItemList::*, &SgFormatItemList::p_format_item_list>;
};
template <> struct describe_node_t<SgFormatItemList> {
  using node = SgFormatItemList;
  using base = SgSupport;
  static constexpr char const * const name{"FormatItemList"};
  static constexpr unsigned long variant{430};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFormatItemList,SgFormatItemPtrList,&SgFormatItemList::p_format_item_list>>;
};
template <> struct node_from_variant_t<430> { using type = SgFormatItemList; };

// Class: FormatStatement
template <> struct describe_field_t<SgFormatStatement,SgFormatItemList*,&SgFormatStatement::p_format_item_list> {
  using parent = SgFormatStatement;
  using field_type = SgFormatItemList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"format_item_list"};
  static constexpr char const * const typestr{"SgFormatItemList*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFormatStatement::p_format_item_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFormatStatement, SgFormatItemList* SgFormatStatement::*, &SgFormatStatement::p_format_item_list>;
};
template <> struct describe_node_t<SgFormatStatement> {
  using node = SgFormatStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"FormatStatement"};
  static constexpr unsigned long variant{431};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFormatStatement,SgFormatItemList*,&SgFormatStatement::p_format_item_list>>;
};
template <> struct node_from_variant_t<431> { using type = SgFormatStatement; };

// Class: FortranDo
template <> struct describe_field_t<SgFortranDo,SgExpression*,&SgFortranDo::p_initialization> {
  using parent = SgFortranDo;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"initialization"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFortranDo::p_initialization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranDo, SgExpression* SgFortranDo::*, &SgFortranDo::p_initialization>;
};
template <> struct describe_field_t<SgFortranDo,SgExpression*,&SgFortranDo::p_bound> {
  using parent = SgFortranDo;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"bound"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFortranDo::p_bound};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranDo, SgExpression* SgFortranDo::*, &SgFortranDo::p_bound>;
};
template <> struct describe_field_t<SgFortranDo,SgExpression*,&SgFortranDo::p_increment> {
  using parent = SgFortranDo;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"increment"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFortranDo::p_increment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranDo, SgExpression* SgFortranDo::*, &SgFortranDo::p_increment>;
};
template <> struct describe_field_t<SgFortranDo,SgBasicBlock*,&SgFortranDo::p_body> {
  using parent = SgFortranDo;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFortranDo::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranDo, SgBasicBlock* SgFortranDo::*, &SgFortranDo::p_body>;
};
template <> struct describe_field_t<SgFortranDo,SgLabelRefExp*,&SgFortranDo::p_end_numeric_label> {
  using parent = SgFortranDo;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFortranDo::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranDo, SgLabelRefExp* SgFortranDo::*, &SgFortranDo::p_end_numeric_label>;
};
template <> struct describe_field_t<SgFortranDo,std::string,&SgFortranDo::p_string_label> {
  using parent = SgFortranDo;
  using field_type = std::string;
  static constexpr size_t position{5};
  static constexpr char const * const name{"string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFortranDo::p_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranDo, std::string SgFortranDo::*, &SgFortranDo::p_string_label>;
};
template <> struct describe_field_t<SgFortranDo,bool,&SgFortranDo::p_old_style> {
  using parent = SgFortranDo;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"old_style"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFortranDo::p_old_style};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranDo, bool SgFortranDo::*, &SgFortranDo::p_old_style>;
};
template <> struct describe_field_t<SgFortranDo,bool,&SgFortranDo::p_has_end_statement> {
  using parent = SgFortranDo;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"has_end_statement"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFortranDo::p_has_end_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranDo, bool SgFortranDo::*, &SgFortranDo::p_has_end_statement>;
};
template <> struct describe_node_t<SgFortranDo> {
  using node = SgFortranDo;
  using base = SgScopeStatement;
  static constexpr char const * const name{"FortranDo"};
  static constexpr unsigned long variant{432};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgFortranNonblockedDo>;
  using fields_t = mp::List<describe_field_t<SgFortranDo,SgExpression*,&SgFortranDo::p_initialization>, describe_field_t<SgFortranDo,SgExpression*,&SgFortranDo::p_bound>, describe_field_t<SgFortranDo,SgExpression*,&SgFortranDo::p_increment>, describe_field_t<SgFortranDo,SgBasicBlock*,&SgFortranDo::p_body>, describe_field_t<SgFortranDo,SgLabelRefExp*,&SgFortranDo::p_end_numeric_label>, describe_field_t<SgFortranDo,std::string,&SgFortranDo::p_string_label>, describe_field_t<SgFortranDo,bool,&SgFortranDo::p_old_style>, describe_field_t<SgFortranDo,bool,&SgFortranDo::p_has_end_statement>>;
};
template <> struct node_from_variant_t<432> { using type = SgFortranDo; };

// Class: FortranIncludeLine
template <> struct describe_field_t<SgFortranIncludeLine,std::string,&SgFortranIncludeLine::p_filename> {
  using parent = SgFortranIncludeLine;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"filename"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFortranIncludeLine::p_filename};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranIncludeLine, std::string SgFortranIncludeLine::*, &SgFortranIncludeLine::p_filename>;
};
template <> struct describe_node_t<SgFortranIncludeLine> {
  using node = SgFortranIncludeLine;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"FortranIncludeLine"};
  static constexpr unsigned long variant{433};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFortranIncludeLine,std::string,&SgFortranIncludeLine::p_filename>>;
};
template <> struct node_from_variant_t<433> { using type = SgFortranIncludeLine; };

// Class: FortranNonblockedDo
template <> struct describe_field_t<SgFortranNonblockedDo,SgStatement*,&SgFortranNonblockedDo::p_end_statement> {
  using parent = SgFortranNonblockedDo;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"end_statement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFortranNonblockedDo::p_end_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFortranNonblockedDo, SgStatement* SgFortranNonblockedDo::*, &SgFortranNonblockedDo::p_end_statement>;
};
template <> struct describe_node_t<SgFortranNonblockedDo> {
  using node = SgFortranNonblockedDo;
  using base = SgFortranDo;
  static constexpr char const * const name{"FortranNonblockedDo"};
  static constexpr unsigned long variant{434};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFortranNonblockedDo,SgStatement*,&SgFortranNonblockedDo::p_end_statement>>;
};
template <> struct node_from_variant_t<434> { using type = SgFortranNonblockedDo; };

// Class: FuncDecl_attr
template <> struct describe_node_t<SgFuncDecl_attr> {
  using node = SgFuncDecl_attr;
  using base = SgBitAttribute;
  static constexpr char const * const name{"FuncDecl_attr"};
  static constexpr unsigned long variant{435};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<435> { using type = SgFuncDecl_attr; };

// Class: FunctionCallExp
template <> struct describe_field_t<SgFunctionCallExp,bool,&SgFunctionCallExp::p_uses_operator_syntax> {
  using parent = SgFunctionCallExp;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"uses_operator_syntax"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionCallExp::p_uses_operator_syntax};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionCallExp, bool SgFunctionCallExp::*, &SgFunctionCallExp::p_uses_operator_syntax>;
};
template <> struct describe_field_t<SgFunctionCallExp,bool,&SgFunctionCallExp::p_usesObjectCallSyntax> {
  using parent = SgFunctionCallExp;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"usesObjectCallSyntax"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionCallExp::p_usesObjectCallSyntax};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionCallExp, bool SgFunctionCallExp::*, &SgFunctionCallExp::p_usesObjectCallSyntax>;
};
template <> struct describe_node_t<SgFunctionCallExp> {
  using node = SgFunctionCallExp;
  using base = SgCallExpression;
  static constexpr char const * const name{"FunctionCallExp"};
  static constexpr unsigned long variant{436};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgCudaKernelCallExp>;
  using fields_t = mp::List<describe_field_t<SgFunctionCallExp,bool,&SgFunctionCallExp::p_uses_operator_syntax>, describe_field_t<SgFunctionCallExp,bool,&SgFunctionCallExp::p_usesObjectCallSyntax>>;
};
template <> struct node_from_variant_t<436> { using type = SgFunctionCallExp; };

// Class: FunctionDeclaration
template <> struct describe_field_t<SgFunctionDeclaration,SgName,&SgFunctionDeclaration::p_name> {
  using parent = SgFunctionDeclaration;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgName SgFunctionDeclaration::*, &SgFunctionDeclaration::p_name>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgFunctionParameterList*,&SgFunctionDeclaration::p_parameterList> {
  using parent = SgFunctionDeclaration;
  using field_type = SgFunctionParameterList*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"parameterList"};
  static constexpr char const * const typestr{"SgFunctionParameterList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_parameterList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgFunctionParameterList* SgFunctionDeclaration::*, &SgFunctionDeclaration::p_parameterList>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgFunctionModifier,&SgFunctionDeclaration::p_functionModifier> {
  using parent = SgFunctionDeclaration;
  using field_type = SgFunctionModifier;
  static constexpr size_t position{2};
  static constexpr char const * const name{"functionModifier"};
  static constexpr char const * const typestr{"SgFunctionModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_functionModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgFunctionModifier SgFunctionDeclaration::*, &SgFunctionDeclaration::p_functionModifier>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgSpecialFunctionModifier,&SgFunctionDeclaration::p_specialFunctionModifier> {
  using parent = SgFunctionDeclaration;
  using field_type = SgSpecialFunctionModifier;
  static constexpr size_t position{3};
  static constexpr char const * const name{"specialFunctionModifier"};
  static constexpr char const * const typestr{"SgSpecialFunctionModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_specialFunctionModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgSpecialFunctionModifier SgFunctionDeclaration::*, &SgFunctionDeclaration::p_specialFunctionModifier>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgTypePtrList,&SgFunctionDeclaration::p_exceptionSpecification> {
  using parent = SgFunctionDeclaration;
  using field_type = SgTypePtrList;
  static constexpr size_t position{4};
  static constexpr char const * const name{"exceptionSpecification"};
  static constexpr char const * const typestr{"SgTypePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_exceptionSpecification};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgTypePtrList SgFunctionDeclaration::*, &SgFunctionDeclaration::p_exceptionSpecification>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_named_in_end_statement> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"named_in_end_statement"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_named_in_end_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_named_in_end_statement>;
};
template <> struct describe_field_t<SgFunctionDeclaration,std::string,&SgFunctionDeclaration::p_asm_name> {
  using parent = SgFunctionDeclaration;
  using field_type = std::string;
  static constexpr size_t position{6};
  static constexpr char const * const name{"asm_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_asm_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, std::string SgFunctionDeclaration::*, &SgFunctionDeclaration::p_asm_name>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgExprListExp*,&SgFunctionDeclaration::p_decoratorList> {
  using parent = SgFunctionDeclaration;
  using field_type = SgExprListExp*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"decoratorList"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_decoratorList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgExprListExp* SgFunctionDeclaration::*, &SgFunctionDeclaration::p_decoratorList>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_ada_formal_subprogram_decl> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"ada_formal_subprogram_decl"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_ada_formal_subprogram_decl};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_ada_formal_subprogram_decl>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_ada_formal_decl_with_box> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"ada_formal_decl_with_box"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_ada_formal_decl_with_box};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_ada_formal_decl_with_box>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgFunctionType*,&SgFunctionDeclaration::p_type> {
  using parent = SgFunctionDeclaration;
  using field_type = SgFunctionType*;
  static constexpr size_t position{10};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgFunctionType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgFunctionType* SgFunctionDeclaration::*, &SgFunctionDeclaration::p_type>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgFunctionDefinition*,&SgFunctionDeclaration::p_definition> {
  using parent = SgFunctionDeclaration;
  using field_type = SgFunctionDefinition*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgFunctionDefinition*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgFunctionDefinition* SgFunctionDeclaration::*, &SgFunctionDeclaration::p_definition>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_oldStyleDefinition> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{12};
  static constexpr char const * const name{"oldStyleDefinition"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_oldStyleDefinition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_oldStyleDefinition>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgScopeStatement*,&SgFunctionDeclaration::p_scope> {
  using parent = SgFunctionDeclaration;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgScopeStatement* SgFunctionDeclaration::*, &SgFunctionDeclaration::p_scope>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgDeclarationStatement::template_specialization_enum,&SgFunctionDeclaration::p_specialization> {
  using parent = SgFunctionDeclaration;
  using field_type = SgDeclarationStatement::template_specialization_enum;
  static constexpr size_t position{14};
  static constexpr char const * const name{"specialization"};
  static constexpr char const * const typestr{"SgDeclarationStatement::template_specialization_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_specialization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgDeclarationStatement::template_specialization_enum SgFunctionDeclaration::*, &SgFunctionDeclaration::p_specialization>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_requiresNameQualificationOnReturnType> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{15};
  static constexpr char const * const name{"requiresNameQualificationOnReturnType"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_requiresNameQualificationOnReturnType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_requiresNameQualificationOnReturnType>;
};
template <> struct describe_field_t<SgFunctionDeclaration,std::string,&SgFunctionDeclaration::p_gnu_extension_section> {
  using parent = SgFunctionDeclaration;
  using field_type = std::string;
  static constexpr size_t position{16};
  static constexpr char const * const name{"gnu_extension_section"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_gnu_extension_section};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, std::string SgFunctionDeclaration::*, &SgFunctionDeclaration::p_gnu_extension_section>;
};
template <> struct describe_field_t<SgFunctionDeclaration,std::string,&SgFunctionDeclaration::p_gnu_extension_alias> {
  using parent = SgFunctionDeclaration;
  using field_type = std::string;
  static constexpr size_t position{17};
  static constexpr char const * const name{"gnu_extension_alias"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_gnu_extension_alias};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, std::string SgFunctionDeclaration::*, &SgFunctionDeclaration::p_gnu_extension_alias>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgDeclarationStatement::gnu_extension_visability_attribute_enum,&SgFunctionDeclaration::p_gnu_extension_visability> {
  using parent = SgFunctionDeclaration;
  using field_type = SgDeclarationStatement::gnu_extension_visability_attribute_enum;
  static constexpr size_t position{18};
  static constexpr char const * const name{"gnu_extension_visability"};
  static constexpr char const * const typestr{"SgDeclarationStatement::gnu_extension_visability_attribute_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_gnu_extension_visability};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgDeclarationStatement::gnu_extension_visability_attribute_enum SgFunctionDeclaration::*, &SgFunctionDeclaration::p_gnu_extension_visability>;
};
template <> struct describe_field_t<SgFunctionDeclaration,int,&SgFunctionDeclaration::p_name_qualification_length> {
  using parent = SgFunctionDeclaration;
  using field_type = int;
  static constexpr size_t position{19};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, int SgFunctionDeclaration::*, &SgFunctionDeclaration::p_name_qualification_length>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_type_elaboration_required> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{20};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_global_qualification_required> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{21};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_global_qualification_required>;
};
template <> struct describe_field_t<SgFunctionDeclaration,int,&SgFunctionDeclaration::p_name_qualification_length_for_return_type> {
  using parent = SgFunctionDeclaration;
  using field_type = int;
  static constexpr size_t position{22};
  static constexpr char const * const name{"name_qualification_length_for_return_type"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_name_qualification_length_for_return_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, int SgFunctionDeclaration::*, &SgFunctionDeclaration::p_name_qualification_length_for_return_type>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_type_elaboration_required_for_return_type> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{23};
  static constexpr char const * const name{"type_elaboration_required_for_return_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_type_elaboration_required_for_return_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_type_elaboration_required_for_return_type>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_global_qualification_required_for_return_type> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{24};
  static constexpr char const * const name{"global_qualification_required_for_return_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_global_qualification_required_for_return_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_global_qualification_required_for_return_type>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_prototypeIsWithoutParameters> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{25};
  static constexpr char const * const name{"prototypeIsWithoutParameters"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_prototypeIsWithoutParameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_prototypeIsWithoutParameters>;
};
template <> struct describe_field_t<SgFunctionDeclaration,int,&SgFunctionDeclaration::p_gnu_regparm_attribute> {
  using parent = SgFunctionDeclaration;
  using field_type = int;
  static constexpr size_t position{26};
  static constexpr char const * const name{"gnu_regparm_attribute"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_gnu_regparm_attribute};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, int SgFunctionDeclaration::*, &SgFunctionDeclaration::p_gnu_regparm_attribute>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgFunctionType*,&SgFunctionDeclaration::p_type_syntax> {
  using parent = SgFunctionDeclaration;
  using field_type = SgFunctionType*;
  static constexpr size_t position{27};
  static constexpr char const * const name{"type_syntax"};
  static constexpr char const * const typestr{"SgFunctionType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_type_syntax};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgFunctionType* SgFunctionDeclaration::*, &SgFunctionDeclaration::p_type_syntax>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_type_syntax_is_available> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{28};
  static constexpr char const * const name{"type_syntax_is_available"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_type_syntax_is_available};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_type_syntax_is_available>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgFunctionParameterList*,&SgFunctionDeclaration::p_parameterList_syntax> {
  using parent = SgFunctionDeclaration;
  using field_type = SgFunctionParameterList*;
  static constexpr size_t position{29};
  static constexpr char const * const name{"parameterList_syntax"};
  static constexpr char const * const typestr{"SgFunctionParameterList*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_parameterList_syntax};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgFunctionParameterList* SgFunctionDeclaration::*, &SgFunctionDeclaration::p_parameterList_syntax>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_using_C11_Noreturn_keyword> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{30};
  static constexpr char const * const name{"using_C11_Noreturn_keyword"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_using_C11_Noreturn_keyword};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_using_C11_Noreturn_keyword>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_is_constexpr> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{31};
  static constexpr char const * const name{"is_constexpr"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_is_constexpr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_is_constexpr>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_using_new_function_return_type_syntax> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{32};
  static constexpr char const * const name{"using_new_function_return_type_syntax"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_using_new_function_return_type_syntax};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_using_new_function_return_type_syntax>;
};
template <> struct describe_field_t<SgFunctionDeclaration,SgFunctionParameterScope*,&SgFunctionDeclaration::p_functionParameterScope> {
  using parent = SgFunctionDeclaration;
  using field_type = SgFunctionParameterScope*;
  static constexpr size_t position{33};
  static constexpr char const * const name{"functionParameterScope"};
  static constexpr char const * const typestr{"SgFunctionParameterScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_functionParameterScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, SgFunctionParameterScope* SgFunctionDeclaration::*, &SgFunctionDeclaration::p_functionParameterScope>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_marked_as_edg_normalization> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{34};
  static constexpr char const * const name{"marked_as_edg_normalization"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_marked_as_edg_normalization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_marked_as_edg_normalization>;
};
template <> struct describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_is_implicit_function> {
  using parent = SgFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{35};
  static constexpr char const * const name{"is_implicit_function"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDeclaration::p_is_implicit_function};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDeclaration, bool SgFunctionDeclaration::*, &SgFunctionDeclaration::p_is_implicit_function>;
};
template <> struct describe_node_t<SgFunctionDeclaration> {
  using node = SgFunctionDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"FunctionDeclaration"};
  static constexpr unsigned long variant{437};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateFunctionDeclaration, SgMemberFunctionDeclaration, SgTemplateInstantiationFunctionDecl, SgProgramHeaderStatement, SgProcedureHeaderStatement, SgEntryStatement, SgAdaEntryDecl, SgAdaFunctionRenamingDecl>;
  using fields_t = mp::List<describe_field_t<SgFunctionDeclaration,SgName,&SgFunctionDeclaration::p_name>, describe_field_t<SgFunctionDeclaration,SgFunctionParameterList*,&SgFunctionDeclaration::p_parameterList>, describe_field_t<SgFunctionDeclaration,SgFunctionModifier,&SgFunctionDeclaration::p_functionModifier>, describe_field_t<SgFunctionDeclaration,SgSpecialFunctionModifier,&SgFunctionDeclaration::p_specialFunctionModifier>, describe_field_t<SgFunctionDeclaration,SgTypePtrList,&SgFunctionDeclaration::p_exceptionSpecification>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_named_in_end_statement>, describe_field_t<SgFunctionDeclaration,std::string,&SgFunctionDeclaration::p_asm_name>, describe_field_t<SgFunctionDeclaration,SgExprListExp*,&SgFunctionDeclaration::p_decoratorList>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_ada_formal_subprogram_decl>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_ada_formal_decl_with_box>, describe_field_t<SgFunctionDeclaration,SgFunctionType*,&SgFunctionDeclaration::p_type>, describe_field_t<SgFunctionDeclaration,SgFunctionDefinition*,&SgFunctionDeclaration::p_definition>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_oldStyleDefinition>, describe_field_t<SgFunctionDeclaration,SgScopeStatement*,&SgFunctionDeclaration::p_scope>, describe_field_t<SgFunctionDeclaration,SgDeclarationStatement::template_specialization_enum,&SgFunctionDeclaration::p_specialization>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_requiresNameQualificationOnReturnType>, describe_field_t<SgFunctionDeclaration,std::string,&SgFunctionDeclaration::p_gnu_extension_section>, describe_field_t<SgFunctionDeclaration,std::string,&SgFunctionDeclaration::p_gnu_extension_alias>, describe_field_t<SgFunctionDeclaration,SgDeclarationStatement::gnu_extension_visability_attribute_enum,&SgFunctionDeclaration::p_gnu_extension_visability>, describe_field_t<SgFunctionDeclaration,int,&SgFunctionDeclaration::p_name_qualification_length>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_type_elaboration_required>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_global_qualification_required>, describe_field_t<SgFunctionDeclaration,int,&SgFunctionDeclaration::p_name_qualification_length_for_return_type>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_type_elaboration_required_for_return_type>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_global_qualification_required_for_return_type>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_prototypeIsWithoutParameters>, describe_field_t<SgFunctionDeclaration,int,&SgFunctionDeclaration::p_gnu_regparm_attribute>, describe_field_t<SgFunctionDeclaration,SgFunctionType*,&SgFunctionDeclaration::p_type_syntax>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_type_syntax_is_available>, describe_field_t<SgFunctionDeclaration,SgFunctionParameterList*,&SgFunctionDeclaration::p_parameterList_syntax>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_using_C11_Noreturn_keyword>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_is_constexpr>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_using_new_function_return_type_syntax>, describe_field_t<SgFunctionDeclaration,SgFunctionParameterScope*,&SgFunctionDeclaration::p_functionParameterScope>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_marked_as_edg_normalization>, describe_field_t<SgFunctionDeclaration,bool,&SgFunctionDeclaration::p_is_implicit_function>>;
};
template <> struct node_from_variant_t<437> { using type = SgFunctionDeclaration; };

// Class: FunctionDefinition
template <> struct describe_field_t<SgFunctionDefinition,SgBasicBlock*,&SgFunctionDefinition::p_body> {
  using parent = SgFunctionDefinition;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionDefinition::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDefinition, SgBasicBlock* SgFunctionDefinition::*, &SgFunctionDefinition::p_body>;
};
template <> struct describe_field_t<SgFunctionDefinition,std::map<SgNode*,int>,&SgFunctionDefinition::p_scope_number_list> {
  using parent = SgFunctionDefinition;
  using field_type = std::map<SgNode*,int>;
  static constexpr size_t position{1};
  static constexpr char const * const name{"scope_number_list"};
  static constexpr char const * const typestr{"std::map<SgNode*,int>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionDefinition::p_scope_number_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionDefinition, std::map<SgNode*,int> SgFunctionDefinition::*, &SgFunctionDefinition::p_scope_number_list>;
};
template <> struct describe_node_t<SgFunctionDefinition> {
  using node = SgFunctionDefinition;
  using base = SgScopeStatement;
  static constexpr char const * const name{"FunctionDefinition"};
  static constexpr unsigned long variant{438};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateFunctionDefinition>;
  using fields_t = mp::List<describe_field_t<SgFunctionDefinition,SgBasicBlock*,&SgFunctionDefinition::p_body>, describe_field_t<SgFunctionDefinition,std::map<SgNode*,int>,&SgFunctionDefinition::p_scope_number_list>>;
};
template <> struct node_from_variant_t<438> { using type = SgFunctionDefinition; };

// Class: FunctionParameterScope
template <> struct describe_field_t<SgFunctionParameterScope,SgDeclarationStatementPtrList,&SgFunctionParameterScope::p_declarations> {
  using parent = SgFunctionParameterScope;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declarations"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionParameterScope::p_declarations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionParameterScope, SgDeclarationStatementPtrList SgFunctionParameterScope::*, &SgFunctionParameterScope::p_declarations>;
};
template <> struct describe_node_t<SgFunctionParameterScope> {
  using node = SgFunctionParameterScope;
  using base = SgScopeStatement;
  static constexpr char const * const name{"FunctionParameterScope"};
  static constexpr unsigned long variant{439};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFunctionParameterScope,SgDeclarationStatementPtrList,&SgFunctionParameterScope::p_declarations>>;
};
template <> struct node_from_variant_t<439> { using type = SgFunctionParameterScope; };

// Class: FunctionModifier
template <> struct describe_field_t<SgFunctionModifier,SgBitVector,&SgFunctionModifier::p_modifierVector> {
  using parent = SgFunctionModifier;
  using field_type = SgBitVector;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifierVector"};
  static constexpr char const * const typestr{"SgBitVector"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionModifier::p_modifierVector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionModifier, SgBitVector SgFunctionModifier::*, &SgFunctionModifier::p_modifierVector>;
};
template <> struct describe_field_t<SgFunctionModifier,unsigned long int,&SgFunctionModifier::p_gnu_attribute_constructor_destructor_priority> {
  using parent = SgFunctionModifier;
  using field_type = unsigned long int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"gnu_attribute_constructor_destructor_priority"};
  static constexpr char const * const typestr{"unsigned long int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionModifier::p_gnu_attribute_constructor_destructor_priority};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionModifier, unsigned long int SgFunctionModifier::*, &SgFunctionModifier::p_gnu_attribute_constructor_destructor_priority>;
};
template <> struct describe_field_t<SgFunctionModifier,std::string,&SgFunctionModifier::p_gnu_attribute_named_weak_reference> {
  using parent = SgFunctionModifier;
  using field_type = std::string;
  static constexpr size_t position{2};
  static constexpr char const * const name{"gnu_attribute_named_weak_reference"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionModifier::p_gnu_attribute_named_weak_reference};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionModifier, std::string SgFunctionModifier::*, &SgFunctionModifier::p_gnu_attribute_named_weak_reference>;
};
template <> struct describe_field_t<SgFunctionModifier,std::string,&SgFunctionModifier::p_gnu_attribute_named_alias> {
  using parent = SgFunctionModifier;
  using field_type = std::string;
  static constexpr size_t position{3};
  static constexpr char const * const name{"gnu_attribute_named_alias"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionModifier::p_gnu_attribute_named_alias};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionModifier, std::string SgFunctionModifier::*, &SgFunctionModifier::p_gnu_attribute_named_alias>;
};
template <> struct describe_field_t<SgFunctionModifier,SgType *,&SgFunctionModifier::p_opencl_vec_type> {
  using parent = SgFunctionModifier;
  using field_type = SgType *;
  static constexpr size_t position{4};
  static constexpr char const * const name{"opencl_vec_type"};
  static constexpr char const * const typestr{"SgType *"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionModifier::p_opencl_vec_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionModifier, SgType * SgFunctionModifier::*, &SgFunctionModifier::p_opencl_vec_type>;
};
template <> struct describe_field_t<SgFunctionModifier,SgFunctionModifier::opencl_work_group_size_t,&SgFunctionModifier::p_opencl_work_group_size> {
  using parent = SgFunctionModifier;
  using field_type = SgFunctionModifier::opencl_work_group_size_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"opencl_work_group_size"};
  static constexpr char const * const typestr{"SgFunctionModifier::opencl_work_group_size_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionModifier::p_opencl_work_group_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionModifier, SgFunctionModifier::opencl_work_group_size_t SgFunctionModifier::*, &SgFunctionModifier::p_opencl_work_group_size>;
};
template <> struct describe_node_t<SgFunctionModifier> {
  using node = SgFunctionModifier;
  using base = SgModifier;
  static constexpr char const * const name{"FunctionModifier"};
  static constexpr unsigned long variant{440};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFunctionModifier,SgBitVector,&SgFunctionModifier::p_modifierVector>, describe_field_t<SgFunctionModifier,unsigned long int,&SgFunctionModifier::p_gnu_attribute_constructor_destructor_priority>, describe_field_t<SgFunctionModifier,std::string,&SgFunctionModifier::p_gnu_attribute_named_weak_reference>, describe_field_t<SgFunctionModifier,std::string,&SgFunctionModifier::p_gnu_attribute_named_alias>, describe_field_t<SgFunctionModifier,SgType *,&SgFunctionModifier::p_opencl_vec_type>, describe_field_t<SgFunctionModifier,SgFunctionModifier::opencl_work_group_size_t,&SgFunctionModifier::p_opencl_work_group_size>>;
};
template <> struct node_from_variant_t<440> { using type = SgFunctionModifier; };

// Class: FunctionParameterList
template <> struct describe_field_t<SgFunctionParameterList,SgInitializedNamePtrList,&SgFunctionParameterList::p_args> {
  using parent = SgFunctionParameterList;
  using field_type = SgInitializedNamePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"args"};
  static constexpr char const * const typestr{"SgInitializedNamePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionParameterList::p_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionParameterList, SgInitializedNamePtrList SgFunctionParameterList::*, &SgFunctionParameterList::p_args>;
};
template <> struct describe_node_t<SgFunctionParameterList> {
  using node = SgFunctionParameterList;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"FunctionParameterList"};
  static constexpr unsigned long variant{441};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFunctionParameterList,SgInitializedNamePtrList,&SgFunctionParameterList::p_args>>;
};
template <> struct node_from_variant_t<441> { using type = SgFunctionParameterList; };

// Class: FunctionParameterRefExp
template <> struct describe_field_t<SgFunctionParameterRefExp,int,&SgFunctionParameterRefExp::p_parameter_number> {
  using parent = SgFunctionParameterRefExp;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"parameter_number"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionParameterRefExp::p_parameter_number};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionParameterRefExp, int SgFunctionParameterRefExp::*, &SgFunctionParameterRefExp::p_parameter_number>;
};
template <> struct describe_field_t<SgFunctionParameterRefExp,int,&SgFunctionParameterRefExp::p_parameter_levels_up> {
  using parent = SgFunctionParameterRefExp;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"parameter_levels_up"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionParameterRefExp::p_parameter_levels_up};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionParameterRefExp, int SgFunctionParameterRefExp::*, &SgFunctionParameterRefExp::p_parameter_levels_up>;
};
template <> struct describe_field_t<SgFunctionParameterRefExp,SgExpression*,&SgFunctionParameterRefExp::p_parameter_expression> {
  using parent = SgFunctionParameterRefExp;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"parameter_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionParameterRefExp::p_parameter_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionParameterRefExp, SgExpression* SgFunctionParameterRefExp::*, &SgFunctionParameterRefExp::p_parameter_expression>;
};
template <> struct describe_field_t<SgFunctionParameterRefExp,SgType*,&SgFunctionParameterRefExp::p_parameter_type> {
  using parent = SgFunctionParameterRefExp;
  using field_type = SgType*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"parameter_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionParameterRefExp::p_parameter_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionParameterRefExp, SgType* SgFunctionParameterRefExp::*, &SgFunctionParameterRefExp::p_parameter_type>;
};
template <> struct describe_node_t<SgFunctionParameterRefExp> {
  using node = SgFunctionParameterRefExp;
  using base = SgExpression;
  static constexpr char const * const name{"FunctionParameterRefExp"};
  static constexpr unsigned long variant{442};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFunctionParameterRefExp,int,&SgFunctionParameterRefExp::p_parameter_number>, describe_field_t<SgFunctionParameterRefExp,int,&SgFunctionParameterRefExp::p_parameter_levels_up>, describe_field_t<SgFunctionParameterRefExp,SgExpression*,&SgFunctionParameterRefExp::p_parameter_expression>, describe_field_t<SgFunctionParameterRefExp,SgType*,&SgFunctionParameterRefExp::p_parameter_type>>;
};
template <> struct node_from_variant_t<442> { using type = SgFunctionParameterRefExp; };

// Class: FunctionParameterTypeList
template <> struct describe_field_t<SgFunctionParameterTypeList,SgTypePtrList,&SgFunctionParameterTypeList::p_arguments> {
  using parent = SgFunctionParameterTypeList;
  using field_type = SgTypePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"arguments"};
  static constexpr char const * const typestr{"SgTypePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionParameterTypeList::p_arguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionParameterTypeList, SgTypePtrList SgFunctionParameterTypeList::*, &SgFunctionParameterTypeList::p_arguments>;
};
template <> struct describe_node_t<SgFunctionParameterTypeList> {
  using node = SgFunctionParameterTypeList;
  using base = SgSupport;
  static constexpr char const * const name{"FunctionParameterTypeList"};
  static constexpr unsigned long variant{443};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFunctionParameterTypeList,SgTypePtrList,&SgFunctionParameterTypeList::p_arguments>>;
};
template <> struct node_from_variant_t<443> { using type = SgFunctionParameterTypeList; };

// Class: FunctionRefExp
template <> struct describe_field_t<SgFunctionRefExp,SgFunctionSymbol*,&SgFunctionRefExp::p_symbol_i> {
  using parent = SgFunctionRefExp;
  using field_type = SgFunctionSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol_i"};
  static constexpr char const * const typestr{"SgFunctionSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionRefExp::p_symbol_i};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionRefExp, SgFunctionSymbol* SgFunctionRefExp::*, &SgFunctionRefExp::p_symbol_i>;
};
template <> struct describe_field_t<SgFunctionRefExp,SgFunctionType*,&SgFunctionRefExp::p_function_type> {
  using parent = SgFunctionRefExp;
  using field_type = SgFunctionType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"function_type"};
  static constexpr char const * const typestr{"SgFunctionType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionRefExp::p_function_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionRefExp, SgFunctionType* SgFunctionRefExp::*, &SgFunctionRefExp::p_function_type>;
};
template <> struct describe_field_t<SgFunctionRefExp,SgExpression*,&SgFunctionRefExp::p_originalExpressionTree> {
  using parent = SgFunctionRefExp;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"originalExpressionTree"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionRefExp::p_originalExpressionTree};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionRefExp, SgExpression* SgFunctionRefExp::*, &SgFunctionRefExp::p_originalExpressionTree>;
};
template <> struct describe_field_t<SgFunctionRefExp,int,&SgFunctionRefExp::p_name_qualification_length> {
  using parent = SgFunctionRefExp;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionRefExp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionRefExp, int SgFunctionRefExp::*, &SgFunctionRefExp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgFunctionRefExp,bool,&SgFunctionRefExp::p_type_elaboration_required> {
  using parent = SgFunctionRefExp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionRefExp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionRefExp, bool SgFunctionRefExp::*, &SgFunctionRefExp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgFunctionRefExp,bool,&SgFunctionRefExp::p_global_qualification_required> {
  using parent = SgFunctionRefExp;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionRefExp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionRefExp, bool SgFunctionRefExp::*, &SgFunctionRefExp::p_global_qualification_required>;
};
template <> struct describe_node_t<SgFunctionRefExp> {
  using node = SgFunctionRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"FunctionRefExp"};
  static constexpr unsigned long variant{444};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFunctionRefExp,SgFunctionSymbol*,&SgFunctionRefExp::p_symbol_i>, describe_field_t<SgFunctionRefExp,SgFunctionType*,&SgFunctionRefExp::p_function_type>, describe_field_t<SgFunctionRefExp,SgExpression*,&SgFunctionRefExp::p_originalExpressionTree>, describe_field_t<SgFunctionRefExp,int,&SgFunctionRefExp::p_name_qualification_length>, describe_field_t<SgFunctionRefExp,bool,&SgFunctionRefExp::p_type_elaboration_required>, describe_field_t<SgFunctionRefExp,bool,&SgFunctionRefExp::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<444> { using type = SgFunctionRefExp; };

// Class: FunctionSymbol
template <> struct describe_field_t<SgFunctionSymbol,SgFunctionDeclaration*,&SgFunctionSymbol::p_declaration> {
  using parent = SgFunctionSymbol;
  using field_type = SgFunctionDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgFunctionDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionSymbol, SgFunctionDeclaration* SgFunctionSymbol::*, &SgFunctionSymbol::p_declaration>;
};
template <> struct describe_node_t<SgFunctionSymbol> {
  using node = SgFunctionSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"FunctionSymbol"};
  static constexpr unsigned long variant{445};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgMemberFunctionSymbol, SgTemplateFunctionSymbol, SgRenameSymbol, SgAdaInheritedFunctionSymbol>;
  using fields_t = mp::List<describe_field_t<SgFunctionSymbol,SgFunctionDeclaration*,&SgFunctionSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<445> { using type = SgFunctionSymbol; };

// Class: FunctionType
template <> struct describe_field_t<SgFunctionType,SgType*,&SgFunctionType::p_return_type> {
  using parent = SgFunctionType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"return_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionType::p_return_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionType, SgType* SgFunctionType::*, &SgFunctionType::p_return_type>;
};
template <> struct describe_field_t<SgFunctionType,bool,&SgFunctionType::p_has_ellipses> {
  using parent = SgFunctionType;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"has_ellipses"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionType::p_has_ellipses};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionType, bool SgFunctionType::*, &SgFunctionType::p_has_ellipses>;
};
template <> struct describe_field_t<SgFunctionType,SgType*,&SgFunctionType::p_orig_return_type> {
  using parent = SgFunctionType;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"orig_return_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFunctionType::p_orig_return_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionType, SgType* SgFunctionType::*, &SgFunctionType::p_orig_return_type>;
};
template <> struct describe_field_t<SgFunctionType,SgFunctionParameterTypeList*,&SgFunctionType::p_argument_list> {
  using parent = SgFunctionType;
  using field_type = SgFunctionParameterTypeList*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"argument_list"};
  static constexpr char const * const typestr{"SgFunctionParameterTypeList*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionType::p_argument_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionType, SgFunctionParameterTypeList* SgFunctionType::*, &SgFunctionType::p_argument_list>;
};
template <> struct describe_node_t<SgFunctionType> {
  using node = SgFunctionType;
  using base = SgType;
  static constexpr char const * const name{"FunctionType"};
  static constexpr unsigned long variant{446};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgMemberFunctionType>;
  using fields_t = mp::List<describe_field_t<SgFunctionType,SgType*,&SgFunctionType::p_return_type>, describe_field_t<SgFunctionType,bool,&SgFunctionType::p_has_ellipses>, describe_field_t<SgFunctionType,SgType*,&SgFunctionType::p_orig_return_type>, describe_field_t<SgFunctionType,SgFunctionParameterTypeList*,&SgFunctionType::p_argument_list>>;
};
template <> struct node_from_variant_t<446> { using type = SgFunctionType; };

// Class: FunctionTypeSymbol
template <> struct describe_field_t<SgFunctionTypeSymbol,SgName,&SgFunctionTypeSymbol::p_name> {
  using parent = SgFunctionTypeSymbol;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionTypeSymbol::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionTypeSymbol, SgName SgFunctionTypeSymbol::*, &SgFunctionTypeSymbol::p_name>;
};
template <> struct describe_field_t<SgFunctionTypeSymbol,SgType*,&SgFunctionTypeSymbol::p_type> {
  using parent = SgFunctionTypeSymbol;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionTypeSymbol::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionTypeSymbol, SgType* SgFunctionTypeSymbol::*, &SgFunctionTypeSymbol::p_type>;
};
template <> struct describe_node_t<SgFunctionTypeSymbol> {
  using node = SgFunctionTypeSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"FunctionTypeSymbol"};
  static constexpr unsigned long variant{447};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFunctionTypeSymbol,SgName,&SgFunctionTypeSymbol::p_name>, describe_field_t<SgFunctionTypeSymbol,SgType*,&SgFunctionTypeSymbol::p_type>>;
};
template <> struct node_from_variant_t<447> { using type = SgFunctionTypeSymbol; };

// Class: FunctionTypeTable
template <> struct describe_field_t<SgFunctionTypeTable,SgSymbolTable*,&SgFunctionTypeTable::p_function_type_table> {
  using parent = SgFunctionTypeTable;
  using field_type = SgSymbolTable*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"function_type_table"};
  static constexpr char const * const typestr{"SgSymbolTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgFunctionTypeTable::p_function_type_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFunctionTypeTable, SgSymbolTable* SgFunctionTypeTable::*, &SgFunctionTypeTable::p_function_type_table>;
};
template <> struct describe_node_t<SgFunctionTypeTable> {
  using node = SgFunctionTypeTable;
  using base = SgStatement;
  static constexpr char const * const name{"FunctionTypeTable"};
  static constexpr unsigned long variant{448};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFunctionTypeTable,SgSymbolTable*,&SgFunctionTypeTable::p_function_type_table>>;
};
template <> struct node_from_variant_t<448> { using type = SgFunctionTypeTable; };

// Class: TypeTable
template <> struct describe_field_t<SgTypeTable,SgSymbolTable*,&SgTypeTable::p_type_table> {
  using parent = SgTypeTable;
  using field_type = SgSymbolTable*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"type_table"};
  static constexpr char const * const typestr{"SgSymbolTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeTable::p_type_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeTable, SgSymbolTable* SgTypeTable::*, &SgTypeTable::p_type_table>;
};
template <> struct describe_node_t<SgTypeTable> {
  using node = SgTypeTable;
  using base = SgSupport;
  static constexpr char const * const name{"TypeTable"};
  static constexpr unsigned long variant{449};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeTable,SgSymbolTable*,&SgTypeTable::p_type_table>>;
};
template <> struct node_from_variant_t<449> { using type = SgTypeTable; };

// Class: Global
template <> struct describe_field_t<SgGlobal,SgDeclarationStatementPtrList,&SgGlobal::p_declarations> {
  using parent = SgGlobal;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declarations"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgGlobal::p_declarations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGlobal, SgDeclarationStatementPtrList SgGlobal::*, &SgGlobal::p_declarations>;
};
template <> struct describe_node_t<SgGlobal> {
  using node = SgGlobal;
  using base = SgScopeStatement;
  static constexpr char const * const name{"Global"};
  static constexpr unsigned long variant{450};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgGlobal,SgDeclarationStatementPtrList,&SgGlobal::p_declarations>>;
};
template <> struct node_from_variant_t<450> { using type = SgGlobal; };

// Class: GotoStatement
template <> struct describe_field_t<SgGotoStatement,SgLabelStatement*,&SgGotoStatement::p_label> {
  using parent = SgGotoStatement;
  using field_type = SgLabelStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"label"};
  static constexpr char const * const typestr{"SgLabelStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGotoStatement::p_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGotoStatement, SgLabelStatement* SgGotoStatement::*, &SgGotoStatement::p_label>;
};
template <> struct describe_field_t<SgGotoStatement,SgLabelRefExp*,&SgGotoStatement::p_label_expression> {
  using parent = SgGotoStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"label_expression"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGotoStatement::p_label_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGotoStatement, SgLabelRefExp* SgGotoStatement::*, &SgGotoStatement::p_label_expression>;
};
template <> struct describe_field_t<SgGotoStatement,SgExpression*,&SgGotoStatement::p_selector_expression> {
  using parent = SgGotoStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"selector_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGotoStatement::p_selector_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGotoStatement, SgExpression* SgGotoStatement::*, &SgGotoStatement::p_selector_expression>;
};
template <> struct describe_node_t<SgGotoStatement> {
  using node = SgGotoStatement;
  using base = SgStatement;
  static constexpr char const * const name{"GotoStatement"};
  static constexpr unsigned long variant{451};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgGotoStatement,SgLabelStatement*,&SgGotoStatement::p_label>, describe_field_t<SgGotoStatement,SgLabelRefExp*,&SgGotoStatement::p_label_expression>, describe_field_t<SgGotoStatement,SgExpression*,&SgGotoStatement::p_selector_expression>>;
};
template <> struct node_from_variant_t<451> { using type = SgGotoStatement; };

// Class: Graph
template <> struct describe_field_t<SgGraph,std::string,&SgGraph::p_name> {
  using parent = SgGraph;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, std::string SgGraph::*, &SgGraph::p_name>;
};
template <> struct describe_field_t<SgGraph,rose_graph_integer_node_hash_map,&SgGraph::p_node_index_to_node_map> {
  using parent = SgGraph;
  using field_type = rose_graph_integer_node_hash_map;
  static constexpr size_t position{1};
  static constexpr char const * const name{"node_index_to_node_map"};
  static constexpr char const * const typestr{"rose_graph_integer_node_hash_map"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_node_index_to_node_map};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, rose_graph_integer_node_hash_map SgGraph::*, &SgGraph::p_node_index_to_node_map>;
};
template <> struct describe_field_t<SgGraph,rose_graph_integer_edge_hash_map,&SgGraph::p_edge_index_to_edge_map> {
  using parent = SgGraph;
  using field_type = rose_graph_integer_edge_hash_map;
  static constexpr size_t position{2};
  static constexpr char const * const name{"edge_index_to_edge_map"};
  static constexpr char const * const typestr{"rose_graph_integer_edge_hash_map"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_edge_index_to_edge_map};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, rose_graph_integer_edge_hash_map SgGraph::*, &SgGraph::p_edge_index_to_edge_map>;
};
template <> struct describe_field_t<SgGraph,rose_graph_integerpair_edge_hash_multimap,&SgGraph::p_node_index_pair_to_edge_multimap> {
  using parent = SgGraph;
  using field_type = rose_graph_integerpair_edge_hash_multimap;
  static constexpr size_t position{3};
  static constexpr char const * const name{"node_index_pair_to_edge_multimap"};
  static constexpr char const * const typestr{"rose_graph_integerpair_edge_hash_multimap"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_node_index_pair_to_edge_multimap};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, rose_graph_integerpair_edge_hash_multimap SgGraph::*, &SgGraph::p_node_index_pair_to_edge_multimap>;
};
template <> struct describe_field_t<SgGraph,rose_graph_string_integer_hash_multimap,&SgGraph::p_string_to_node_index_multimap> {
  using parent = SgGraph;
  using field_type = rose_graph_string_integer_hash_multimap;
  static constexpr size_t position{4};
  static constexpr char const * const name{"string_to_node_index_multimap"};
  static constexpr char const * const typestr{"rose_graph_string_integer_hash_multimap"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_string_to_node_index_multimap};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, rose_graph_string_integer_hash_multimap SgGraph::*, &SgGraph::p_string_to_node_index_multimap>;
};
template <> struct describe_field_t<SgGraph,rose_graph_string_integer_hash_multimap,&SgGraph::p_string_to_edge_index_multimap> {
  using parent = SgGraph;
  using field_type = rose_graph_string_integer_hash_multimap;
  static constexpr size_t position{5};
  static constexpr char const * const name{"string_to_edge_index_multimap"};
  static constexpr char const * const typestr{"rose_graph_string_integer_hash_multimap"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_string_to_edge_index_multimap};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, rose_graph_string_integer_hash_multimap SgGraph::*, &SgGraph::p_string_to_edge_index_multimap>;
};
template <> struct describe_field_t<SgGraph,rose_graph_integer_edge_hash_multimap,&SgGraph::p_node_index_to_edge_multimap> {
  using parent = SgGraph;
  using field_type = rose_graph_integer_edge_hash_multimap;
  static constexpr size_t position{6};
  static constexpr char const * const name{"node_index_to_edge_multimap"};
  static constexpr char const * const typestr{"rose_graph_integer_edge_hash_multimap"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_node_index_to_edge_multimap};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, rose_graph_integer_edge_hash_multimap SgGraph::*, &SgGraph::p_node_index_to_edge_multimap>;
};
template <> struct describe_field_t<SgGraph,int,&SgGraph::p_index> {
  using parent = SgGraph;
  using field_type = int;
  static constexpr size_t position{7};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, int SgGraph::*, &SgGraph::p_index>;
};
template <> struct describe_field_t<SgGraph,SgBoostEdgeList,&SgGraph::p_boost_edges> {
  using parent = SgGraph;
  using field_type = SgBoostEdgeList;
  static constexpr size_t position{8};
  static constexpr char const * const name{"boost_edges"};
  static constexpr char const * const typestr{"SgBoostEdgeList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_boost_edges};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, SgBoostEdgeList SgGraph::*, &SgGraph::p_boost_edges>;
};
template <> struct describe_field_t<SgGraph,SgBoostEdgeWeightList,&SgGraph::p_boost_edge_weights> {
  using parent = SgGraph;
  using field_type = SgBoostEdgeWeightList;
  static constexpr size_t position{9};
  static constexpr char const * const name{"boost_edge_weights"};
  static constexpr char const * const typestr{"SgBoostEdgeWeightList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_boost_edge_weights};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, SgBoostEdgeWeightList SgGraph::*, &SgGraph::p_boost_edge_weights>;
};
template <> struct describe_field_t<SgGraph,AstAttributeMechanism*,&SgGraph::p_attributeMechanism> {
  using parent = SgGraph;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{10};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, AstAttributeMechanism* SgGraph::*, &SgGraph::p_attributeMechanism>;
};
template <> struct describe_field_t<SgGraph,std::map<int, std::string>,&SgGraph::p_properties> {
  using parent = SgGraph;
  using field_type = std::map<int, std::string>;
  static constexpr size_t position{11};
  static constexpr char const * const name{"properties"};
  static constexpr char const * const typestr{"std::map<int, std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraph::p_properties};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraph, std::map<int, std::string> SgGraph::*, &SgGraph::p_properties>;
};
template <> struct describe_node_t<SgGraph> {
  using node = SgGraph;
  using base = SgSupport;
  static constexpr char const * const name{"Graph"};
  static constexpr unsigned long variant{452};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgIncidenceDirectedGraph, SgIncidenceUndirectedGraph>;
  using fields_t = mp::List<describe_field_t<SgGraph,std::string,&SgGraph::p_name>, describe_field_t<SgGraph,rose_graph_integer_node_hash_map,&SgGraph::p_node_index_to_node_map>, describe_field_t<SgGraph,rose_graph_integer_edge_hash_map,&SgGraph::p_edge_index_to_edge_map>, describe_field_t<SgGraph,rose_graph_integerpair_edge_hash_multimap,&SgGraph::p_node_index_pair_to_edge_multimap>, describe_field_t<SgGraph,rose_graph_string_integer_hash_multimap,&SgGraph::p_string_to_node_index_multimap>, describe_field_t<SgGraph,rose_graph_string_integer_hash_multimap,&SgGraph::p_string_to_edge_index_multimap>, describe_field_t<SgGraph,rose_graph_integer_edge_hash_multimap,&SgGraph::p_node_index_to_edge_multimap>, describe_field_t<SgGraph,int,&SgGraph::p_index>, describe_field_t<SgGraph,SgBoostEdgeList,&SgGraph::p_boost_edges>, describe_field_t<SgGraph,SgBoostEdgeWeightList,&SgGraph::p_boost_edge_weights>, describe_field_t<SgGraph,AstAttributeMechanism*,&SgGraph::p_attributeMechanism>, describe_field_t<SgGraph,std::map<int, std::string>,&SgGraph::p_properties>>;
};
template <> struct node_from_variant_t<452> { using type = SgGraph; };

// Class: GraphEdge
template <> struct describe_field_t<SgGraphEdge,SgGraphNode*,&SgGraphEdge::p_node_A> {
  using parent = SgGraphEdge;
  using field_type = SgGraphNode*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"node_A"};
  static constexpr char const * const typestr{"SgGraphNode*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphEdge::p_node_A};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphEdge, SgGraphNode* SgGraphEdge::*, &SgGraphEdge::p_node_A>;
};
template <> struct describe_field_t<SgGraphEdge,SgGraphNode*,&SgGraphEdge::p_node_B> {
  using parent = SgGraphEdge;
  using field_type = SgGraphNode*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"node_B"};
  static constexpr char const * const typestr{"SgGraphNode*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphEdge::p_node_B};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphEdge, SgGraphNode* SgGraphEdge::*, &SgGraphEdge::p_node_B>;
};
template <> struct describe_field_t<SgGraphEdge,std::string,&SgGraphEdge::p_name> {
  using parent = SgGraphEdge;
  using field_type = std::string;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphEdge::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphEdge, std::string SgGraphEdge::*, &SgGraphEdge::p_name>;
};
template <> struct describe_field_t<SgGraphEdge,int,&SgGraphEdge::p_index> {
  using parent = SgGraphEdge;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphEdge::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphEdge, int SgGraphEdge::*, &SgGraphEdge::p_index>;
};
template <> struct describe_field_t<SgGraphEdge,AstAttributeMechanism*,&SgGraphEdge::p_attributeMechanism> {
  using parent = SgGraphEdge;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphEdge::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphEdge, AstAttributeMechanism* SgGraphEdge::*, &SgGraphEdge::p_attributeMechanism>;
};
template <> struct describe_field_t<SgGraphEdge,std::map<int, std::string>,&SgGraphEdge::p_properties> {
  using parent = SgGraphEdge;
  using field_type = std::map<int, std::string>;
  static constexpr size_t position{5};
  static constexpr char const * const name{"properties"};
  static constexpr char const * const typestr{"std::map<int, std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphEdge::p_properties};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphEdge, std::map<int, std::string> SgGraphEdge::*, &SgGraphEdge::p_properties>;
};
template <> struct describe_node_t<SgGraphEdge> {
  using node = SgGraphEdge;
  using base = SgSupport;
  static constexpr char const * const name{"GraphEdge"};
  static constexpr unsigned long variant{453};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgDirectedGraphEdge, SgUndirectedGraphEdge>;
  using fields_t = mp::List<describe_field_t<SgGraphEdge,SgGraphNode*,&SgGraphEdge::p_node_A>, describe_field_t<SgGraphEdge,SgGraphNode*,&SgGraphEdge::p_node_B>, describe_field_t<SgGraphEdge,std::string,&SgGraphEdge::p_name>, describe_field_t<SgGraphEdge,int,&SgGraphEdge::p_index>, describe_field_t<SgGraphEdge,AstAttributeMechanism*,&SgGraphEdge::p_attributeMechanism>, describe_field_t<SgGraphEdge,std::map<int, std::string>,&SgGraphEdge::p_properties>>;
};
template <> struct node_from_variant_t<453> { using type = SgGraphEdge; };

// Class: GraphEdgeList
template <> struct describe_node_t<SgGraphEdgeList> {
  using node = SgGraphEdgeList;
  using base = SgSupport;
  static constexpr char const * const name{"GraphEdgeList"};
  static constexpr unsigned long variant{454};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<454> { using type = SgGraphEdgeList; };

// Class: GraphNode
template <> struct describe_field_t<SgGraphNode,std::string,&SgGraphNode::p_name> {
  using parent = SgGraphNode;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphNode::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphNode, std::string SgGraphNode::*, &SgGraphNode::p_name>;
};
template <> struct describe_field_t<SgGraphNode,SgNode*,&SgGraphNode::p_SgNode> {
  using parent = SgGraphNode;
  using field_type = SgNode*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"SgNode"};
  static constexpr char const * const typestr{"SgNode*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphNode::p_SgNode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphNode, SgNode* SgGraphNode::*, &SgGraphNode::p_SgNode>;
};
template <> struct describe_field_t<SgGraphNode,int,&SgGraphNode::p_index> {
  using parent = SgGraphNode;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphNode::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphNode, int SgGraphNode::*, &SgGraphNode::p_index>;
};
template <> struct describe_field_t<SgGraphNode,AstAttributeMechanism*,&SgGraphNode::p_attributeMechanism> {
  using parent = SgGraphNode;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphNode::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphNode, AstAttributeMechanism* SgGraphNode::*, &SgGraphNode::p_attributeMechanism>;
};
template <> struct describe_field_t<SgGraphNode,std::map<int, std::string>,&SgGraphNode::p_properties> {
  using parent = SgGraphNode;
  using field_type = std::map<int, std::string>;
  static constexpr size_t position{4};
  static constexpr char const * const name{"properties"};
  static constexpr char const * const typestr{"std::map<int, std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgGraphNode::p_properties};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgGraphNode, std::map<int, std::string> SgGraphNode::*, &SgGraphNode::p_properties>;
};
template <> struct describe_node_t<SgGraphNode> {
  using node = SgGraphNode;
  using base = SgSupport;
  static constexpr char const * const name{"GraphNode"};
  static constexpr unsigned long variant{455};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgGraphNode,std::string,&SgGraphNode::p_name>, describe_field_t<SgGraphNode,SgNode*,&SgGraphNode::p_SgNode>, describe_field_t<SgGraphNode,int,&SgGraphNode::p_index>, describe_field_t<SgGraphNode,AstAttributeMechanism*,&SgGraphNode::p_attributeMechanism>, describe_field_t<SgGraphNode,std::map<int, std::string>,&SgGraphNode::p_properties>>;
};
template <> struct node_from_variant_t<455> { using type = SgGraphNode; };

// Class: GraphNodeList
template <> struct describe_node_t<SgGraphNodeList> {
  using node = SgGraphNodeList;
  using base = SgSupport;
  static constexpr char const * const name{"GraphNodeList"};
  static constexpr unsigned long variant{456};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<456> { using type = SgGraphNodeList; };

// Class: GreaterOrEqualOp
template <> struct describe_node_t<SgGreaterOrEqualOp> {
  using node = SgGreaterOrEqualOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"GreaterOrEqualOp"};
  static constexpr unsigned long variant{457};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<457> { using type = SgGreaterOrEqualOp; };

// Class: GreaterThanOp
template <> struct describe_node_t<SgGreaterThanOp> {
  using node = SgGreaterThanOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"GreaterThanOp"};
  static constexpr unsigned long variant{458};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<458> { using type = SgGreaterThanOp; };

// Class: IOItemExpression
template <> struct describe_field_t<SgIOItemExpression,SgName,&SgIOItemExpression::p_name> {
  using parent = SgIOItemExpression;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIOItemExpression::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIOItemExpression, SgName SgIOItemExpression::*, &SgIOItemExpression::p_name>;
};
template <> struct describe_field_t<SgIOItemExpression,SgExpression*,&SgIOItemExpression::p_io_item> {
  using parent = SgIOItemExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"io_item"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIOItemExpression::p_io_item};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIOItemExpression, SgExpression* SgIOItemExpression::*, &SgIOItemExpression::p_io_item>;
};
template <> struct describe_node_t<SgIOItemExpression> {
  using node = SgIOItemExpression;
  using base = SgExpression;
  static constexpr char const * const name{"IOItemExpression"};
  static constexpr unsigned long variant{459};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgIOItemExpression,SgName,&SgIOItemExpression::p_name>, describe_field_t<SgIOItemExpression,SgExpression*,&SgIOItemExpression::p_io_item>>;
};
template <> struct node_from_variant_t<459> { using type = SgIOItemExpression; };

// Class: IOStatement
template <> struct describe_field_t<SgIOStatement,SgIOStatement::io_statement_enum,&SgIOStatement::p_io_statement> {
  using parent = SgIOStatement;
  using field_type = SgIOStatement::io_statement_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"io_statement"};
  static constexpr char const * const typestr{"SgIOStatement::io_statement_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIOStatement::p_io_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIOStatement, SgIOStatement::io_statement_enum SgIOStatement::*, &SgIOStatement::p_io_statement>;
};
template <> struct describe_field_t<SgIOStatement,SgExprListExp*,&SgIOStatement::p_io_stmt_list> {
  using parent = SgIOStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"io_stmt_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIOStatement::p_io_stmt_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIOStatement, SgExprListExp* SgIOStatement::*, &SgIOStatement::p_io_stmt_list>;
};
template <> struct describe_field_t<SgIOStatement,SgExpression*,&SgIOStatement::p_unit> {
  using parent = SgIOStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"unit"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIOStatement::p_unit};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIOStatement, SgExpression* SgIOStatement::*, &SgIOStatement::p_unit>;
};
template <> struct describe_field_t<SgIOStatement,SgExpression*,&SgIOStatement::p_iostat> {
  using parent = SgIOStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"iostat"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIOStatement::p_iostat};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIOStatement, SgExpression* SgIOStatement::*, &SgIOStatement::p_iostat>;
};
template <> struct describe_field_t<SgIOStatement,SgExpression*,&SgIOStatement::p_err> {
  using parent = SgIOStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"err"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIOStatement::p_err};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIOStatement, SgExpression* SgIOStatement::*, &SgIOStatement::p_err>;
};
template <> struct describe_field_t<SgIOStatement,SgExpression*,&SgIOStatement::p_iomsg> {
  using parent = SgIOStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"iomsg"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIOStatement::p_iomsg};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIOStatement, SgExpression* SgIOStatement::*, &SgIOStatement::p_iomsg>;
};
template <> struct describe_node_t<SgIOStatement> {
  using node = SgIOStatement;
  using base = SgStatement;
  static constexpr char const * const name{"IOStatement"};
  static constexpr unsigned long variant{460};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgPrintStatement, SgReadStatement, SgWriteStatement, SgOpenStatement, SgCloseStatement, SgInquireStatement, SgFlushStatement, SgBackspaceStatement, SgRewindStatement, SgEndfileStatement, SgWaitStatement>;
  using fields_t = mp::List<describe_field_t<SgIOStatement,SgIOStatement::io_statement_enum,&SgIOStatement::p_io_statement>, describe_field_t<SgIOStatement,SgExprListExp*,&SgIOStatement::p_io_stmt_list>, describe_field_t<SgIOStatement,SgExpression*,&SgIOStatement::p_unit>, describe_field_t<SgIOStatement,SgExpression*,&SgIOStatement::p_iostat>, describe_field_t<SgIOStatement,SgExpression*,&SgIOStatement::p_err>, describe_field_t<SgIOStatement,SgExpression*,&SgIOStatement::p_iomsg>>;
};
template <> struct node_from_variant_t<460> { using type = SgIOStatement; };

// Class: IdentDirectiveStatement
template <> struct describe_node_t<SgIdentDirectiveStatement> {
  using node = SgIdentDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"IdentDirectiveStatement"};
  static constexpr unsigned long variant{461};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<461> { using type = SgIdentDirectiveStatement; };

// Class: IfDirectiveStatement
template <> struct describe_node_t<SgIfDirectiveStatement> {
  using node = SgIfDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"IfDirectiveStatement"};
  static constexpr unsigned long variant{462};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<462> { using type = SgIfDirectiveStatement; };

// Class: IfStmt
template <> struct describe_field_t<SgIfStmt,SgStatement*,&SgIfStmt::p_conditional> {
  using parent = SgIfStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"conditional"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIfStmt::p_conditional};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, SgStatement* SgIfStmt::*, &SgIfStmt::p_conditional>;
};
template <> struct describe_field_t<SgIfStmt,SgStatement*,&SgIfStmt::p_true_body> {
  using parent = SgIfStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"true_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIfStmt::p_true_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, SgStatement* SgIfStmt::*, &SgIfStmt::p_true_body>;
};
template <> struct describe_field_t<SgIfStmt,SgStatement*,&SgIfStmt::p_false_body> {
  using parent = SgIfStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"false_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIfStmt::p_false_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, SgStatement* SgIfStmt::*, &SgIfStmt::p_false_body>;
};
template <> struct describe_field_t<SgIfStmt,bool,&SgIfStmt::p_is_if_constexpr_statement> {
  using parent = SgIfStmt;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"is_if_constexpr_statement"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIfStmt::p_is_if_constexpr_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, bool SgIfStmt::*, &SgIfStmt::p_is_if_constexpr_statement>;
};
template <> struct describe_field_t<SgIfStmt,bool,&SgIfStmt::p_if_constexpr_value_known> {
  using parent = SgIfStmt;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"if_constexpr_value_known"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIfStmt::p_if_constexpr_value_known};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, bool SgIfStmt::*, &SgIfStmt::p_if_constexpr_value_known>;
};
template <> struct describe_field_t<SgIfStmt,bool,&SgIfStmt::p_if_constexpr_value> {
  using parent = SgIfStmt;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"if_constexpr_value"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIfStmt::p_if_constexpr_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, bool SgIfStmt::*, &SgIfStmt::p_if_constexpr_value>;
};
template <> struct describe_field_t<SgIfStmt,SgLabelRefExp*,&SgIfStmt::p_else_numeric_label> {
  using parent = SgIfStmt;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"else_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIfStmt::p_else_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, SgLabelRefExp* SgIfStmt::*, &SgIfStmt::p_else_numeric_label>;
};
template <> struct describe_field_t<SgIfStmt,std::string,&SgIfStmt::p_string_label> {
  using parent = SgIfStmt;
  using field_type = std::string;
  static constexpr size_t position{7};
  static constexpr char const * const name{"string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIfStmt::p_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, std::string SgIfStmt::*, &SgIfStmt::p_string_label>;
};
template <> struct describe_field_t<SgIfStmt,SgLabelRefExp*,&SgIfStmt::p_end_numeric_label> {
  using parent = SgIfStmt;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIfStmt::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, SgLabelRefExp* SgIfStmt::*, &SgIfStmt::p_end_numeric_label>;
};
template <> struct describe_field_t<SgIfStmt,bool,&SgIfStmt::p_has_end_statement> {
  using parent = SgIfStmt;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"has_end_statement"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIfStmt::p_has_end_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, bool SgIfStmt::*, &SgIfStmt::p_has_end_statement>;
};
template <> struct describe_field_t<SgIfStmt,bool,&SgIfStmt::p_use_then_keyword> {
  using parent = SgIfStmt;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"use_then_keyword"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIfStmt::p_use_then_keyword};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, bool SgIfStmt::*, &SgIfStmt::p_use_then_keyword>;
};
template <> struct describe_field_t<SgIfStmt,bool,&SgIfStmt::p_is_else_if_statement> {
  using parent = SgIfStmt;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"is_else_if_statement"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIfStmt::p_is_else_if_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIfStmt, bool SgIfStmt::*, &SgIfStmt::p_is_else_if_statement>;
};
template <> struct describe_node_t<SgIfStmt> {
  using node = SgIfStmt;
  using base = SgScopeStatement;
  static constexpr char const * const name{"IfStmt"};
  static constexpr unsigned long variant{463};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgIfStmt,SgStatement*,&SgIfStmt::p_conditional>, describe_field_t<SgIfStmt,SgStatement*,&SgIfStmt::p_true_body>, describe_field_t<SgIfStmt,SgStatement*,&SgIfStmt::p_false_body>, describe_field_t<SgIfStmt,bool,&SgIfStmt::p_is_if_constexpr_statement>, describe_field_t<SgIfStmt,bool,&SgIfStmt::p_if_constexpr_value_known>, describe_field_t<SgIfStmt,bool,&SgIfStmt::p_if_constexpr_value>, describe_field_t<SgIfStmt,SgLabelRefExp*,&SgIfStmt::p_else_numeric_label>, describe_field_t<SgIfStmt,std::string,&SgIfStmt::p_string_label>, describe_field_t<SgIfStmt,SgLabelRefExp*,&SgIfStmt::p_end_numeric_label>, describe_field_t<SgIfStmt,bool,&SgIfStmt::p_has_end_statement>, describe_field_t<SgIfStmt,bool,&SgIfStmt::p_use_then_keyword>, describe_field_t<SgIfStmt,bool,&SgIfStmt::p_is_else_if_statement>>;
};
template <> struct node_from_variant_t<463> { using type = SgIfStmt; };

// Class: IfdefDirectiveStatement
template <> struct describe_node_t<SgIfdefDirectiveStatement> {
  using node = SgIfdefDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"IfdefDirectiveStatement"};
  static constexpr unsigned long variant{464};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<464> { using type = SgIfdefDirectiveStatement; };

// Class: IfndefDirectiveStatement
template <> struct describe_node_t<SgIfndefDirectiveStatement> {
  using node = SgIfndefDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"IfndefDirectiveStatement"};
  static constexpr unsigned long variant{465};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<465> { using type = SgIfndefDirectiveStatement; };

// Class: ImageControlStatement
template <> struct describe_field_t<SgImageControlStatement,SgImageControlStatement::image_control_statement_enum,&SgImageControlStatement::p_image_control_statement> {
  using parent = SgImageControlStatement;
  using field_type = SgImageControlStatement::image_control_statement_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"image_control_statement"};
  static constexpr char const * const typestr{"SgImageControlStatement::image_control_statement_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgImageControlStatement::p_image_control_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImageControlStatement, SgImageControlStatement::image_control_statement_enum SgImageControlStatement::*, &SgImageControlStatement::p_image_control_statement>;
};
template <> struct describe_field_t<SgImageControlStatement,SgExpression*,&SgImageControlStatement::p_stat> {
  using parent = SgImageControlStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"stat"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgImageControlStatement::p_stat};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImageControlStatement, SgExpression* SgImageControlStatement::*, &SgImageControlStatement::p_stat>;
};
template <> struct describe_field_t<SgImageControlStatement,SgExpression*,&SgImageControlStatement::p_err_msg> {
  using parent = SgImageControlStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"err_msg"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgImageControlStatement::p_err_msg};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImageControlStatement, SgExpression* SgImageControlStatement::*, &SgImageControlStatement::p_err_msg>;
};
template <> struct describe_field_t<SgImageControlStatement,SgExpression*,&SgImageControlStatement::p_acquired_lock> {
  using parent = SgImageControlStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"acquired_lock"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgImageControlStatement::p_acquired_lock};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImageControlStatement, SgExpression* SgImageControlStatement::*, &SgImageControlStatement::p_acquired_lock>;
};
template <> struct describe_node_t<SgImageControlStatement> {
  using node = SgImageControlStatement;
  using base = SgStatement;
  static constexpr char const * const name{"ImageControlStatement"};
  static constexpr unsigned long variant{466};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgSyncAllStatement, SgSyncImagesStatement, SgSyncMemoryStatement, SgSyncTeamStatement, SgLockStatement, SgUnlockStatement>;
  using fields_t = mp::List<describe_field_t<SgImageControlStatement,SgImageControlStatement::image_control_statement_enum,&SgImageControlStatement::p_image_control_statement>, describe_field_t<SgImageControlStatement,SgExpression*,&SgImageControlStatement::p_stat>, describe_field_t<SgImageControlStatement,SgExpression*,&SgImageControlStatement::p_err_msg>, describe_field_t<SgImageControlStatement,SgExpression*,&SgImageControlStatement::p_acquired_lock>>;
};
template <> struct node_from_variant_t<466> { using type = SgImageControlStatement; };

// Class: ImagPartOp
template <> struct describe_node_t<SgImagPartOp> {
  using node = SgImagPartOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"ImagPartOp"};
  static constexpr unsigned long variant{467};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<467> { using type = SgImagPartOp; };

// Class: ImplicitStatement
template <> struct describe_field_t<SgImplicitStatement,bool,&SgImplicitStatement::p_implicit_none> {
  using parent = SgImplicitStatement;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"implicit_none"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgImplicitStatement::p_implicit_none};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImplicitStatement, bool SgImplicitStatement::*, &SgImplicitStatement::p_implicit_none>;
};
template <> struct describe_field_t<SgImplicitStatement,SgImplicitStatement::implicit_spec_enum,&SgImplicitStatement::p_implicit_spec> {
  using parent = SgImplicitStatement;
  using field_type = SgImplicitStatement::implicit_spec_enum;
  static constexpr size_t position{1};
  static constexpr char const * const name{"implicit_spec"};
  static constexpr char const * const typestr{"SgImplicitStatement::implicit_spec_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgImplicitStatement::p_implicit_spec};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImplicitStatement, SgImplicitStatement::implicit_spec_enum SgImplicitStatement::*, &SgImplicitStatement::p_implicit_spec>;
};
template <> struct describe_field_t<SgImplicitStatement,SgInitializedNamePtrList,&SgImplicitStatement::p_variables> {
  using parent = SgImplicitStatement;
  using field_type = SgInitializedNamePtrList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"variables"};
  static constexpr char const * const typestr{"SgInitializedNamePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgImplicitStatement::p_variables};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImplicitStatement, SgInitializedNamePtrList SgImplicitStatement::*, &SgImplicitStatement::p_variables>;
};
template <> struct describe_node_t<SgImplicitStatement> {
  using node = SgImplicitStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"ImplicitStatement"};
  static constexpr unsigned long variant{468};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgImplicitStatement,bool,&SgImplicitStatement::p_implicit_none>, describe_field_t<SgImplicitStatement,SgImplicitStatement::implicit_spec_enum,&SgImplicitStatement::p_implicit_spec>, describe_field_t<SgImplicitStatement,SgInitializedNamePtrList,&SgImplicitStatement::p_variables>>;
};
template <> struct node_from_variant_t<468> { using type = SgImplicitStatement; };

// Class: ImpliedDo
template <> struct describe_field_t<SgImpliedDo,SgExpression*,&SgImpliedDo::p_do_var_initialization> {
  using parent = SgImpliedDo;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"do_var_initialization"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgImpliedDo::p_do_var_initialization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImpliedDo, SgExpression* SgImpliedDo::*, &SgImpliedDo::p_do_var_initialization>;
};
template <> struct describe_field_t<SgImpliedDo,SgExpression*,&SgImpliedDo::p_last_val> {
  using parent = SgImpliedDo;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"last_val"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgImpliedDo::p_last_val};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImpliedDo, SgExpression* SgImpliedDo::*, &SgImpliedDo::p_last_val>;
};
template <> struct describe_field_t<SgImpliedDo,SgExpression*,&SgImpliedDo::p_increment> {
  using parent = SgImpliedDo;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"increment"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgImpliedDo::p_increment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImpliedDo, SgExpression* SgImpliedDo::*, &SgImpliedDo::p_increment>;
};
template <> struct describe_field_t<SgImpliedDo,SgExprListExp*,&SgImpliedDo::p_object_list> {
  using parent = SgImpliedDo;
  using field_type = SgExprListExp*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"object_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgImpliedDo::p_object_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImpliedDo, SgExprListExp* SgImpliedDo::*, &SgImpliedDo::p_object_list>;
};
template <> struct describe_field_t<SgImpliedDo,SgScopeStatement*,&SgImpliedDo::p_implied_do_scope> {
  using parent = SgImpliedDo;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"implied_do_scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgImpliedDo::p_implied_do_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImpliedDo, SgScopeStatement* SgImpliedDo::*, &SgImpliedDo::p_implied_do_scope>;
};
template <> struct describe_node_t<SgImpliedDo> {
  using node = SgImpliedDo;
  using base = SgExpression;
  static constexpr char const * const name{"ImpliedDo"};
  static constexpr unsigned long variant{469};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgImpliedDo,SgExpression*,&SgImpliedDo::p_do_var_initialization>, describe_field_t<SgImpliedDo,SgExpression*,&SgImpliedDo::p_last_val>, describe_field_t<SgImpliedDo,SgExpression*,&SgImpliedDo::p_increment>, describe_field_t<SgImpliedDo,SgExprListExp*,&SgImpliedDo::p_object_list>, describe_field_t<SgImpliedDo,SgScopeStatement*,&SgImpliedDo::p_implied_do_scope>>;
};
template <> struct node_from_variant_t<469> { using type = SgImpliedDo; };

// Class: ImportStatement
template <> struct describe_field_t<SgImportStatement,SgExpressionPtrList,&SgImportStatement::p_import_list> {
  using parent = SgImportStatement;
  using field_type = SgExpressionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"import_list"};
  static constexpr char const * const typestr{"SgExpressionPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgImportStatement::p_import_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgImportStatement, SgExpressionPtrList SgImportStatement::*, &SgImportStatement::p_import_list>;
};
template <> struct describe_node_t<SgImportStatement> {
  using node = SgImportStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"ImportStatement"};
  static constexpr unsigned long variant{470};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgImportStatement,SgExpressionPtrList,&SgImportStatement::p_import_list>>;
};
template <> struct node_from_variant_t<470> { using type = SgImportStatement; };

// Class: IncidenceDirectedGraph
template <> struct describe_field_t<SgIncidenceDirectedGraph,rose_graph_integer_edge_hash_multimap,&SgIncidenceDirectedGraph::p_node_index_to_edge_multimap_edgesOut> {
  using parent = SgIncidenceDirectedGraph;
  using field_type = rose_graph_integer_edge_hash_multimap;
  static constexpr size_t position{0};
  static constexpr char const * const name{"node_index_to_edge_multimap_edgesOut"};
  static constexpr char const * const typestr{"rose_graph_integer_edge_hash_multimap"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncidenceDirectedGraph::p_node_index_to_edge_multimap_edgesOut};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncidenceDirectedGraph, rose_graph_integer_edge_hash_multimap SgIncidenceDirectedGraph::*, &SgIncidenceDirectedGraph::p_node_index_to_edge_multimap_edgesOut>;
};
template <> struct describe_field_t<SgIncidenceDirectedGraph,rose_graph_integer_edge_hash_multimap,&SgIncidenceDirectedGraph::p_node_index_to_edge_multimap_edgesIn> {
  using parent = SgIncidenceDirectedGraph;
  using field_type = rose_graph_integer_edge_hash_multimap;
  static constexpr size_t position{1};
  static constexpr char const * const name{"node_index_to_edge_multimap_edgesIn"};
  static constexpr char const * const typestr{"rose_graph_integer_edge_hash_multimap"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncidenceDirectedGraph::p_node_index_to_edge_multimap_edgesIn};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncidenceDirectedGraph, rose_graph_integer_edge_hash_multimap SgIncidenceDirectedGraph::*, &SgIncidenceDirectedGraph::p_node_index_to_edge_multimap_edgesIn>;
};
template <> struct describe_node_t<SgIncidenceDirectedGraph> {
  using node = SgIncidenceDirectedGraph;
  using base = SgGraph;
  static constexpr char const * const name{"IncidenceDirectedGraph"};
  static constexpr unsigned long variant{471};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgBidirectionalGraph>;
  using fields_t = mp::List<describe_field_t<SgIncidenceDirectedGraph,rose_graph_integer_edge_hash_multimap,&SgIncidenceDirectedGraph::p_node_index_to_edge_multimap_edgesOut>, describe_field_t<SgIncidenceDirectedGraph,rose_graph_integer_edge_hash_multimap,&SgIncidenceDirectedGraph::p_node_index_to_edge_multimap_edgesIn>>;
};
template <> struct node_from_variant_t<471> { using type = SgIncidenceDirectedGraph; };

// Class: IncidenceUndirectedGraph
template <> struct describe_node_t<SgIncidenceUndirectedGraph> {
  using node = SgIncidenceUndirectedGraph;
  using base = SgGraph;
  static constexpr char const * const name{"IncidenceUndirectedGraph"};
  static constexpr unsigned long variant{472};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<472> { using type = SgIncidenceUndirectedGraph; };

// Class: IncludeDirectiveStatement
template <> struct describe_field_t<SgIncludeDirectiveStatement,SgHeaderFileBody*,&SgIncludeDirectiveStatement::p_headerFileBody> {
  using parent = SgIncludeDirectiveStatement;
  using field_type = SgHeaderFileBody*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"headerFileBody"};
  static constexpr char const * const typestr{"SgHeaderFileBody*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIncludeDirectiveStatement::p_headerFileBody};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeDirectiveStatement, SgHeaderFileBody* SgIncludeDirectiveStatement::*, &SgIncludeDirectiveStatement::p_headerFileBody>;
};
template <> struct describe_field_t<SgIncludeDirectiveStatement,SgIncludeFile*,&SgIncludeDirectiveStatement::p_include_file_heirarchy> {
  using parent = SgIncludeDirectiveStatement;
  using field_type = SgIncludeFile*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"include_file_heirarchy"};
  static constexpr char const * const typestr{"SgIncludeFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeDirectiveStatement::p_include_file_heirarchy};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeDirectiveStatement, SgIncludeFile* SgIncludeDirectiveStatement::*, &SgIncludeDirectiveStatement::p_include_file_heirarchy>;
};
template <> struct describe_field_t<SgIncludeDirectiveStatement,std::string,&SgIncludeDirectiveStatement::p_name_used_in_include_directive> {
  using parent = SgIncludeDirectiveStatement;
  using field_type = std::string;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name_used_in_include_directive"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeDirectiveStatement::p_name_used_in_include_directive};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeDirectiveStatement, std::string SgIncludeDirectiveStatement::*, &SgIncludeDirectiveStatement::p_name_used_in_include_directive>;
};
template <> struct describe_node_t<SgIncludeDirectiveStatement> {
  using node = SgIncludeDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"IncludeDirectiveStatement"};
  static constexpr unsigned long variant{473};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgIncludeDirectiveStatement,SgHeaderFileBody*,&SgIncludeDirectiveStatement::p_headerFileBody>, describe_field_t<SgIncludeDirectiveStatement,SgIncludeFile*,&SgIncludeDirectiveStatement::p_include_file_heirarchy>, describe_field_t<SgIncludeDirectiveStatement,std::string,&SgIncludeDirectiveStatement::p_name_used_in_include_directive>>;
};
template <> struct node_from_variant_t<473> { using type = SgIncludeDirectiveStatement; };

// Class: IncludeFile
template <> struct describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_filename> {
  using parent = SgIncludeFile;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"filename"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_filename};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgName SgIncludeFile::*, &SgIncludeFile::p_filename>;
};
template <> struct describe_field_t<SgIncludeFile,SgSourceFile*,&SgIncludeFile::p_source_file> {
  using parent = SgIncludeFile;
  using field_type = SgSourceFile*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"source_file"};
  static constexpr char const * const typestr{"SgSourceFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_source_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgSourceFile* SgIncludeFile::*, &SgIncludeFile::p_source_file>;
};
template <> struct describe_field_t<SgIncludeFile,SgIncludeFilePtrList,&SgIncludeFile::p_include_file_list> {
  using parent = SgIncludeFile;
  using field_type = SgIncludeFilePtrList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"include_file_list"};
  static constexpr char const * const typestr{"SgIncludeFilePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_include_file_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgIncludeFilePtrList SgIncludeFile::*, &SgIncludeFile::p_include_file_list>;
};
template <> struct describe_field_t<SgIncludeFile,unsigned int,&SgIncludeFile::p_first_source_sequence_number> {
  using parent = SgIncludeFile;
  using field_type = unsigned int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"first_source_sequence_number"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_first_source_sequence_number};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, unsigned int SgIncludeFile::*, &SgIncludeFile::p_first_source_sequence_number>;
};
template <> struct describe_field_t<SgIncludeFile,unsigned int,&SgIncludeFile::p_last_source_sequence_number> {
  using parent = SgIncludeFile;
  using field_type = unsigned int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"last_source_sequence_number"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_last_source_sequence_number};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, unsigned int SgIncludeFile::*, &SgIncludeFile::p_last_source_sequence_number>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isIncludedMoreThanOnce> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"isIncludedMoreThanOnce"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_isIncludedMoreThanOnce};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_isIncludedMoreThanOnce>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isPrimaryUse> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"isPrimaryUse"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_isPrimaryUse};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_isPrimaryUse>;
};
template <> struct describe_field_t<SgIncludeFile,std::string,&SgIncludeFile::p_file_hash> {
  using parent = SgIncludeFile;
  using field_type = std::string;
  static constexpr size_t position{7};
  static constexpr char const * const name{"file_hash"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_file_hash};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, std::string SgIncludeFile::*, &SgIncludeFile::p_file_hash>;
};
template <> struct describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_name_used_in_include_directive> {
  using parent = SgIncludeFile;
  using field_type = SgName;
  static constexpr size_t position{8};
  static constexpr char const * const name{"name_used_in_include_directive"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_name_used_in_include_directive};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgName SgIncludeFile::*, &SgIncludeFile::p_name_used_in_include_directive>;
};
template <> struct describe_field_t<SgIncludeFile,SgSourceFile*,&SgIncludeFile::p_source_file_of_translation_unit> {
  using parent = SgIncludeFile;
  using field_type = SgSourceFile*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"source_file_of_translation_unit"};
  static constexpr char const * const typestr{"SgSourceFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_source_file_of_translation_unit};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgSourceFile* SgIncludeFile::*, &SgIncludeFile::p_source_file_of_translation_unit>;
};
template <> struct describe_field_t<SgIncludeFile,SgSourceFile*,&SgIncludeFile::p_including_source_file> {
  using parent = SgIncludeFile;
  using field_type = SgSourceFile*;
  static constexpr size_t position{10};
  static constexpr char const * const name{"including_source_file"};
  static constexpr char const * const typestr{"SgSourceFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_including_source_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgSourceFile* SgIncludeFile::*, &SgIncludeFile::p_including_source_file>;
};
template <> struct describe_field_t<SgIncludeFile,SgIncludeFile*,&SgIncludeFile::p_parent_include_file> {
  using parent = SgIncludeFile;
  using field_type = SgIncludeFile*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"parent_include_file"};
  static constexpr char const * const typestr{"SgIncludeFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_parent_include_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgIncludeFile* SgIncludeFile::*, &SgIncludeFile::p_parent_include_file>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isSystemInclude> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{12};
  static constexpr char const * const name{"isSystemInclude"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_isSystemInclude};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_isSystemInclude>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isPreinclude> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{13};
  static constexpr char const * const name{"isPreinclude"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_isPreinclude};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_isPreinclude>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_requires_explict_path_for_unparsed_headers> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{14};
  static constexpr char const * const name{"requires_explict_path_for_unparsed_headers"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_requires_explict_path_for_unparsed_headers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_requires_explict_path_for_unparsed_headers>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_can_be_supported_using_token_based_unparsing> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{15};
  static constexpr char const * const name{"can_be_supported_using_token_based_unparsing"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_can_be_supported_using_token_based_unparsing};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_can_be_supported_using_token_based_unparsing>;
};
template <> struct describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_directory_prefix> {
  using parent = SgIncludeFile;
  using field_type = SgName;
  static constexpr size_t position{16};
  static constexpr char const * const name{"directory_prefix"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_directory_prefix};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgName SgIncludeFile::*, &SgIncludeFile::p_directory_prefix>;
};
template <> struct describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_name_without_path> {
  using parent = SgIncludeFile;
  using field_type = SgName;
  static constexpr size_t position{17};
  static constexpr char const * const name{"name_without_path"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_name_without_path};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgName SgIncludeFile::*, &SgIncludeFile::p_name_without_path>;
};
template <> struct describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_applicationRootDirectory> {
  using parent = SgIncludeFile;
  using field_type = SgName;
  static constexpr size_t position{18};
  static constexpr char const * const name{"applicationRootDirectory"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_applicationRootDirectory};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgName SgIncludeFile::*, &SgIncludeFile::p_applicationRootDirectory>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_will_be_unparsed> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{19};
  static constexpr char const * const name{"will_be_unparsed"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_will_be_unparsed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_will_be_unparsed>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isRoseSystemInclude> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{20};
  static constexpr char const * const name{"isRoseSystemInclude"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_isRoseSystemInclude};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_isRoseSystemInclude>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_from_system_include_dir> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{21};
  static constexpr char const * const name{"from_system_include_dir"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_from_system_include_dir};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_from_system_include_dir>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_preinclude_macros_only> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{22};
  static constexpr char const * const name{"preinclude_macros_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_preinclude_macros_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_preinclude_macros_only>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isApplicationFile> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{23};
  static constexpr char const * const name{"isApplicationFile"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_isApplicationFile};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_isApplicationFile>;
};
template <> struct describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isRootSourceFile> {
  using parent = SgIncludeFile;
  using field_type = bool;
  static constexpr size_t position{24};
  static constexpr char const * const name{"isRootSourceFile"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_isRootSourceFile};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, bool SgIncludeFile::*, &SgIncludeFile::p_isRootSourceFile>;
};
template <> struct describe_field_t<SgIncludeFile,SgStatement*,&SgIncludeFile::p_firstStatement> {
  using parent = SgIncludeFile;
  using field_type = SgStatement*;
  static constexpr size_t position{25};
  static constexpr char const * const name{"firstStatement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_firstStatement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgStatement* SgIncludeFile::*, &SgIncludeFile::p_firstStatement>;
};
template <> struct describe_field_t<SgIncludeFile,SgStatement*,&SgIncludeFile::p_lastStatement> {
  using parent = SgIncludeFile;
  using field_type = SgStatement*;
  static constexpr size_t position{26};
  static constexpr char const * const name{"lastStatement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIncludeFile::p_lastStatement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIncludeFile, SgStatement* SgIncludeFile::*, &SgIncludeFile::p_lastStatement>;
};
template <> struct describe_node_t<SgIncludeFile> {
  using node = SgIncludeFile;
  using base = SgSupport;
  static constexpr char const * const name{"IncludeFile"};
  static constexpr unsigned long variant{474};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_filename>, describe_field_t<SgIncludeFile,SgSourceFile*,&SgIncludeFile::p_source_file>, describe_field_t<SgIncludeFile,SgIncludeFilePtrList,&SgIncludeFile::p_include_file_list>, describe_field_t<SgIncludeFile,unsigned int,&SgIncludeFile::p_first_source_sequence_number>, describe_field_t<SgIncludeFile,unsigned int,&SgIncludeFile::p_last_source_sequence_number>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isIncludedMoreThanOnce>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isPrimaryUse>, describe_field_t<SgIncludeFile,std::string,&SgIncludeFile::p_file_hash>, describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_name_used_in_include_directive>, describe_field_t<SgIncludeFile,SgSourceFile*,&SgIncludeFile::p_source_file_of_translation_unit>, describe_field_t<SgIncludeFile,SgSourceFile*,&SgIncludeFile::p_including_source_file>, describe_field_t<SgIncludeFile,SgIncludeFile*,&SgIncludeFile::p_parent_include_file>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isSystemInclude>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isPreinclude>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_requires_explict_path_for_unparsed_headers>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_can_be_supported_using_token_based_unparsing>, describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_directory_prefix>, describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_name_without_path>, describe_field_t<SgIncludeFile,SgName,&SgIncludeFile::p_applicationRootDirectory>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_will_be_unparsed>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isRoseSystemInclude>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_from_system_include_dir>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_preinclude_macros_only>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isApplicationFile>, describe_field_t<SgIncludeFile,bool,&SgIncludeFile::p_isRootSourceFile>, describe_field_t<SgIncludeFile,SgStatement*,&SgIncludeFile::p_firstStatement>, describe_field_t<SgIncludeFile,SgStatement*,&SgIncludeFile::p_lastStatement>>;
};
template <> struct node_from_variant_t<474> { using type = SgIncludeFile; };

// Class: IncludeNextDirectiveStatement
template <> struct describe_node_t<SgIncludeNextDirectiveStatement> {
  using node = SgIncludeNextDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"IncludeNextDirectiveStatement"};
  static constexpr unsigned long variant{475};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<475> { using type = SgIncludeNextDirectiveStatement; };

// Class: InitializedName
template <> struct describe_field_t<SgInitializedName,SgName,&SgInitializedName::p_name> {
  using parent = SgInitializedName;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgName SgInitializedName::*, &SgInitializedName::p_name>;
};
template <> struct describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_microsoft_uuid_string> {
  using parent = SgInitializedName;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"microsoft_uuid_string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_microsoft_uuid_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, std::string SgInitializedName::*, &SgInitializedName::p_microsoft_uuid_string>;
};
template <> struct describe_field_t<SgInitializedName,SgType*,&SgInitializedName::p_typeptr> {
  using parent = SgInitializedName;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"typeptr"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_typeptr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgType* SgInitializedName::*, &SgInitializedName::p_typeptr>;
};
template <> struct describe_field_t<SgInitializedName,SgInitializer*,&SgInitializedName::p_initptr> {
  using parent = SgInitializedName;
  using field_type = SgInitializer*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"initptr"};
  static constexpr char const * const typestr{"SgInitializer*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgInitializedName::p_initptr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgInitializer* SgInitializedName::*, &SgInitializedName::p_initptr>;
};
template <> struct describe_field_t<SgInitializedName,SgInitializedName*,&SgInitializedName::p_prev_decl_item> {
  using parent = SgInitializedName;
  using field_type = SgInitializedName*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"prev_decl_item"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_prev_decl_item};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgInitializedName* SgInitializedName::*, &SgInitializedName::p_prev_decl_item>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_is_initializer> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"is_initializer"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_is_initializer};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_is_initializer>;
};
template <> struct describe_field_t<SgInitializedName,SgDeclarationStatement*,&SgInitializedName::p_declptr> {
  using parent = SgInitializedName;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"declptr"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_declptr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgDeclarationStatement* SgInitializedName::*, &SgInitializedName::p_declptr>;
};
template <> struct describe_field_t<SgInitializedName,SgStorageModifier*,&SgInitializedName::p_storageModifier> {
  using parent = SgInitializedName;
  using field_type = SgStorageModifier*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"storageModifier"};
  static constexpr char const * const typestr{"SgStorageModifier*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_storageModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgStorageModifier* SgInitializedName::*, &SgInitializedName::p_storageModifier>;
};
template <> struct describe_field_t<SgInitializedName,SgScopeStatement*,&SgInitializedName::p_scope> {
  using parent = SgInitializedName;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgScopeStatement* SgInitializedName::*, &SgInitializedName::p_scope>;
};
template <> struct describe_field_t<SgInitializedName,SgInitializedName::preinitialization_enum,&SgInitializedName::p_preinitialization> {
  using parent = SgInitializedName;
  using field_type = SgInitializedName::preinitialization_enum;
  static constexpr size_t position{9};
  static constexpr char const * const name{"preinitialization"};
  static constexpr char const * const typestr{"SgInitializedName::preinitialization_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_preinitialization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgInitializedName::preinitialization_enum SgInitializedName::*, &SgInitializedName::p_preinitialization>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_isCoArray> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"isCoArray"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_isCoArray};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_isCoArray>;
};
template <> struct describe_field_t<SgInitializedName,SgInitializedName::asm_register_name_enum,&SgInitializedName::p_register_name_code> {
  using parent = SgInitializedName;
  using field_type = SgInitializedName::asm_register_name_enum;
  static constexpr size_t position{11};
  static constexpr char const * const name{"register_name_code"};
  static constexpr char const * const typestr{"SgInitializedName::asm_register_name_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_register_name_code};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgInitializedName::asm_register_name_enum SgInitializedName::*, &SgInitializedName::p_register_name_code>;
};
template <> struct describe_field_t<SgInitializedName,SgInitializedName::excess_specifier_enum,&SgInitializedName::p_excess_specifier> {
  using parent = SgInitializedName;
  using field_type = SgInitializedName::excess_specifier_enum;
  static constexpr size_t position{12};
  static constexpr char const * const name{"excess_specifier"};
  static constexpr char const * const typestr{"SgInitializedName::excess_specifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_excess_specifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgInitializedName::excess_specifier_enum SgInitializedName::*, &SgInitializedName::p_excess_specifier>;
};
template <> struct describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_register_name_string> {
  using parent = SgInitializedName;
  using field_type = std::string;
  static constexpr size_t position{13};
  static constexpr char const * const name{"register_name_string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_register_name_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, std::string SgInitializedName::*, &SgInitializedName::p_register_name_string>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_requiresGlobalNameQualificationOnType> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{14};
  static constexpr char const * const name{"requiresGlobalNameQualificationOnType"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_requiresGlobalNameQualificationOnType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_requiresGlobalNameQualificationOnType>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_shapeDeferred> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{15};
  static constexpr char const * const name{"shapeDeferred"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_shapeDeferred};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_shapeDeferred>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_initializationDeferred> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{16};
  static constexpr char const * const name{"initializationDeferred"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_initializationDeferred};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_initializationDeferred>;
};
template <> struct describe_field_t<SgInitializedName,SgBitVector,&SgInitializedName::p_gnu_attribute_modifierVector> {
  using parent = SgInitializedName;
  using field_type = SgBitVector;
  static constexpr size_t position{17};
  static constexpr char const * const name{"gnu_attribute_modifierVector"};
  static constexpr char const * const typestr{"SgBitVector"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_gnu_attribute_modifierVector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgBitVector SgInitializedName::*, &SgInitializedName::p_gnu_attribute_modifierVector>;
};
template <> struct describe_field_t<SgInitializedName,unsigned long int,&SgInitializedName::p_gnu_attribute_initialization_priority> {
  using parent = SgInitializedName;
  using field_type = unsigned long int;
  static constexpr size_t position{18};
  static constexpr char const * const name{"gnu_attribute_initialization_priority"};
  static constexpr char const * const typestr{"unsigned long int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_gnu_attribute_initialization_priority};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, unsigned long int SgInitializedName::*, &SgInitializedName::p_gnu_attribute_initialization_priority>;
};
template <> struct describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_gnu_attribute_named_weak_reference> {
  using parent = SgInitializedName;
  using field_type = std::string;
  static constexpr size_t position{19};
  static constexpr char const * const name{"gnu_attribute_named_weak_reference"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_gnu_attribute_named_weak_reference};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, std::string SgInitializedName::*, &SgInitializedName::p_gnu_attribute_named_weak_reference>;
};
template <> struct describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_gnu_attribute_named_alias> {
  using parent = SgInitializedName;
  using field_type = std::string;
  static constexpr size_t position{20};
  static constexpr char const * const name{"gnu_attribute_named_alias"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_gnu_attribute_named_alias};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, std::string SgInitializedName::*, &SgInitializedName::p_gnu_attribute_named_alias>;
};
template <> struct describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_gnu_attribute_cleanup_function> {
  using parent = SgInitializedName;
  using field_type = std::string;
  static constexpr size_t position{21};
  static constexpr char const * const name{"gnu_attribute_cleanup_function"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_gnu_attribute_cleanup_function};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, std::string SgInitializedName::*, &SgInitializedName::p_gnu_attribute_cleanup_function>;
};
template <> struct describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_gnu_attribute_section_name> {
  using parent = SgInitializedName;
  using field_type = std::string;
  static constexpr size_t position{22};
  static constexpr char const * const name{"gnu_attribute_section_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_gnu_attribute_section_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, std::string SgInitializedName::*, &SgInitializedName::p_gnu_attribute_section_name>;
};
template <> struct describe_field_t<SgInitializedName,int,&SgInitializedName::p_gnu_attribute_alignment> {
  using parent = SgInitializedName;
  using field_type = int;
  static constexpr size_t position{23};
  static constexpr char const * const name{"gnu_attribute_alignment"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_gnu_attribute_alignment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, int SgInitializedName::*, &SgInitializedName::p_gnu_attribute_alignment>;
};
template <> struct describe_field_t<SgInitializedName,SgDeclarationModifier::gnu_declaration_visability_enum,&SgInitializedName::p_gnu_attribute_visability> {
  using parent = SgInitializedName;
  using field_type = SgDeclarationModifier::gnu_declaration_visability_enum;
  static constexpr size_t position{24};
  static constexpr char const * const name{"gnu_attribute_visability"};
  static constexpr char const * const typestr{"SgDeclarationModifier::gnu_declaration_visability_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_gnu_attribute_visability};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgDeclarationModifier::gnu_declaration_visability_enum SgInitializedName::*, &SgInitializedName::p_gnu_attribute_visability>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_protected_declaration> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{25};
  static constexpr char const * const name{"protected_declaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_protected_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_protected_declaration>;
};
template <> struct describe_field_t<SgInitializedName,int,&SgInitializedName::p_name_qualification_length> {
  using parent = SgInitializedName;
  using field_type = int;
  static constexpr size_t position{26};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, int SgInitializedName::*, &SgInitializedName::p_name_qualification_length>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_type_elaboration_required> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{27};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_global_qualification_required> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{28};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_global_qualification_required>;
};
template <> struct describe_field_t<SgInitializedName,int,&SgInitializedName::p_name_qualification_length_for_type> {
  using parent = SgInitializedName;
  using field_type = int;
  static constexpr size_t position{29};
  static constexpr char const * const name{"name_qualification_length_for_type"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_name_qualification_length_for_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, int SgInitializedName::*, &SgInitializedName::p_name_qualification_length_for_type>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_type_elaboration_required_for_type> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{30};
  static constexpr char const * const name{"type_elaboration_required_for_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_type_elaboration_required_for_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_type_elaboration_required_for_type>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_global_qualification_required_for_type> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{31};
  static constexpr char const * const name{"global_qualification_required_for_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_global_qualification_required_for_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_global_qualification_required_for_type>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_hasArrayTypeWithEmptyBracketSyntax> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{32};
  static constexpr char const * const name{"hasArrayTypeWithEmptyBracketSyntax"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_hasArrayTypeWithEmptyBracketSyntax};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_hasArrayTypeWithEmptyBracketSyntax>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_using_C11_Alignas_keyword> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{33};
  static constexpr char const * const name{"using_C11_Alignas_keyword"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_using_C11_Alignas_keyword};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_using_C11_Alignas_keyword>;
};
template <> struct describe_field_t<SgInitializedName,SgNode*,&SgInitializedName::p_constant_or_type_argument_for_Alignas_keyword> {
  using parent = SgInitializedName;
  using field_type = SgNode*;
  static constexpr size_t position{34};
  static constexpr char const * const name{"constant_or_type_argument_for_Alignas_keyword"};
  static constexpr char const * const typestr{"SgNode*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_constant_or_type_argument_for_Alignas_keyword};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgNode* SgInitializedName::*, &SgInitializedName::p_constant_or_type_argument_for_Alignas_keyword>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_using_auto_keyword> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{35};
  static constexpr char const * const name{"using_auto_keyword"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_using_auto_keyword};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_using_auto_keyword>;
};
template <> struct describe_field_t<SgInitializedName,SgType *,&SgInitializedName::p_auto_decltype> {
  using parent = SgInitializedName;
  using field_type = SgType *;
  static constexpr size_t position{36};
  static constexpr char const * const name{"auto_decltype"};
  static constexpr char const * const typestr{"SgType *"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_auto_decltype};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, SgType * SgInitializedName::*, &SgInitializedName::p_auto_decltype>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_using_device_keyword> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{37};
  static constexpr char const * const name{"using_device_keyword"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_using_device_keyword};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_using_device_keyword>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_is_braced_initialized> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{38};
  static constexpr char const * const name{"is_braced_initialized"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_is_braced_initialized};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_is_braced_initialized>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_using_assignment_copy_constructor_syntax> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{39};
  static constexpr char const * const name{"using_assignment_copy_constructor_syntax"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_using_assignment_copy_constructor_syntax};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_using_assignment_copy_constructor_syntax>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_needs_definitions> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{40};
  static constexpr char const * const name{"needs_definitions"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_needs_definitions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_needs_definitions>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_is_parameter_pack> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{41};
  static constexpr char const * const name{"is_parameter_pack"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_is_parameter_pack};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_is_parameter_pack>;
};
template <> struct describe_field_t<SgInitializedName,bool,&SgInitializedName::p_is_pack_element> {
  using parent = SgInitializedName;
  using field_type = bool;
  static constexpr size_t position{42};
  static constexpr char const * const name{"is_pack_element"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializedName::p_is_pack_element};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializedName, bool SgInitializedName::*, &SgInitializedName::p_is_pack_element>;
};
template <> struct describe_node_t<SgInitializedName> {
  using node = SgInitializedName;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"InitializedName"};
  static constexpr unsigned long variant{476};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgInitializedName,SgName,&SgInitializedName::p_name>, describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_microsoft_uuid_string>, describe_field_t<SgInitializedName,SgType*,&SgInitializedName::p_typeptr>, describe_field_t<SgInitializedName,SgInitializer*,&SgInitializedName::p_initptr>, describe_field_t<SgInitializedName,SgInitializedName*,&SgInitializedName::p_prev_decl_item>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_is_initializer>, describe_field_t<SgInitializedName,SgDeclarationStatement*,&SgInitializedName::p_declptr>, describe_field_t<SgInitializedName,SgStorageModifier*,&SgInitializedName::p_storageModifier>, describe_field_t<SgInitializedName,SgScopeStatement*,&SgInitializedName::p_scope>, describe_field_t<SgInitializedName,SgInitializedName::preinitialization_enum,&SgInitializedName::p_preinitialization>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_isCoArray>, describe_field_t<SgInitializedName,SgInitializedName::asm_register_name_enum,&SgInitializedName::p_register_name_code>, describe_field_t<SgInitializedName,SgInitializedName::excess_specifier_enum,&SgInitializedName::p_excess_specifier>, describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_register_name_string>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_requiresGlobalNameQualificationOnType>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_shapeDeferred>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_initializationDeferred>, describe_field_t<SgInitializedName,SgBitVector,&SgInitializedName::p_gnu_attribute_modifierVector>, describe_field_t<SgInitializedName,unsigned long int,&SgInitializedName::p_gnu_attribute_initialization_priority>, describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_gnu_attribute_named_weak_reference>, describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_gnu_attribute_named_alias>, describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_gnu_attribute_cleanup_function>, describe_field_t<SgInitializedName,std::string,&SgInitializedName::p_gnu_attribute_section_name>, describe_field_t<SgInitializedName,int,&SgInitializedName::p_gnu_attribute_alignment>, describe_field_t<SgInitializedName,SgDeclarationModifier::gnu_declaration_visability_enum,&SgInitializedName::p_gnu_attribute_visability>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_protected_declaration>, describe_field_t<SgInitializedName,int,&SgInitializedName::p_name_qualification_length>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_type_elaboration_required>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_global_qualification_required>, describe_field_t<SgInitializedName,int,&SgInitializedName::p_name_qualification_length_for_type>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_type_elaboration_required_for_type>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_global_qualification_required_for_type>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_hasArrayTypeWithEmptyBracketSyntax>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_using_C11_Alignas_keyword>, describe_field_t<SgInitializedName,SgNode*,&SgInitializedName::p_constant_or_type_argument_for_Alignas_keyword>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_using_auto_keyword>, describe_field_t<SgInitializedName,SgType *,&SgInitializedName::p_auto_decltype>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_using_device_keyword>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_is_braced_initialized>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_using_assignment_copy_constructor_syntax>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_needs_definitions>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_is_parameter_pack>, describe_field_t<SgInitializedName,bool,&SgInitializedName::p_is_pack_element>>;
};
template <> struct node_from_variant_t<476> { using type = SgInitializedName; };

// Class: Initializer
template <> struct describe_field_t<SgInitializer,bool,&SgInitializer::p_is_explicit_cast> {
  using parent = SgInitializer;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"is_explicit_cast"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializer::p_is_explicit_cast};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializer, bool SgInitializer::*, &SgInitializer::p_is_explicit_cast>;
};
template <> struct describe_field_t<SgInitializer,bool,&SgInitializer::p_is_braced_initialized> {
  using parent = SgInitializer;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"is_braced_initialized"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInitializer::p_is_braced_initialized};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInitializer, bool SgInitializer::*, &SgInitializer::p_is_braced_initialized>;
};
template <> struct describe_node_t<SgInitializer> {
  using node = SgInitializer;
  using base = SgExpression;
  static constexpr char const * const name{"Initializer"};
  static constexpr unsigned long variant{477};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAggregateInitializer, SgCompoundInitializer, SgConstructorInitializer, SgAssignInitializer, SgDesignatedInitializer, SgBracedInitializer, SgAdaAncestorInitializer>;
  using fields_t = mp::List<describe_field_t<SgInitializer,bool,&SgInitializer::p_is_explicit_cast>, describe_field_t<SgInitializer,bool,&SgInitializer::p_is_braced_initialized>>;
};
template <> struct node_from_variant_t<477> { using type = SgInitializer; };

// Class: InquireStatement
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_file> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"file"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_file>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_access> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"access"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_access};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_access>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_form> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"form"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_form};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_form>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_recl> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"recl"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_recl};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_recl>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_blank> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"blank"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_blank};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_blank>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_exist> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"exist"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_exist};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_exist>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_opened> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"opened"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_opened};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_opened>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_number> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"number"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_number};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_number>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_named> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"named"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_named};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_named>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_name> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_name>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_sequential> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{10};
  static constexpr char const * const name{"sequential"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_sequential};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_sequential>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_direct> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"direct"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_direct};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_direct>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_formatted> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{12};
  static constexpr char const * const name{"formatted"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_formatted};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_formatted>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_unformatted> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"unformatted"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_unformatted};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_unformatted>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_nextrec> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{14};
  static constexpr char const * const name{"nextrec"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_nextrec};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_nextrec>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_position> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{15};
  static constexpr char const * const name{"position"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_position};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_position>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_action> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{16};
  static constexpr char const * const name{"action"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_action};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_action>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_read> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{17};
  static constexpr char const * const name{"read"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_read};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_read>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_write> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{18};
  static constexpr char const * const name{"write"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_write};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_write>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_readwrite> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{19};
  static constexpr char const * const name{"readwrite"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_readwrite};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_readwrite>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_delim> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{20};
  static constexpr char const * const name{"delim"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_delim};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_delim>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_pad> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{21};
  static constexpr char const * const name{"pad"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_pad};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_pad>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_asynchronous> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{22};
  static constexpr char const * const name{"asynchronous"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_asynchronous};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_asynchronous>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_decimal> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{23};
  static constexpr char const * const name{"decimal"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_decimal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_decimal>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_stream> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{24};
  static constexpr char const * const name{"stream"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_stream};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_stream>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_size> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{25};
  static constexpr char const * const name{"size"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_size>;
};
template <> struct describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_pending> {
  using parent = SgInquireStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{26};
  static constexpr char const * const name{"pending"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_pending};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgExpression* SgInquireStatement::*, &SgInquireStatement::p_pending>;
};
template <> struct describe_field_t<SgInquireStatement,SgVarRefExp*,&SgInquireStatement::p_iolengthExp> {
  using parent = SgInquireStatement;
  using field_type = SgVarRefExp*;
  static constexpr size_t position{27};
  static constexpr char const * const name{"iolengthExp"};
  static constexpr char const * const typestr{"SgVarRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInquireStatement::p_iolengthExp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInquireStatement, SgVarRefExp* SgInquireStatement::*, &SgInquireStatement::p_iolengthExp>;
};
template <> struct describe_node_t<SgInquireStatement> {
  using node = SgInquireStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"InquireStatement"};
  static constexpr unsigned long variant{478};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_file>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_access>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_form>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_recl>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_blank>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_exist>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_opened>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_number>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_named>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_name>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_sequential>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_direct>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_formatted>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_unformatted>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_nextrec>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_position>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_action>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_read>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_write>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_readwrite>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_delim>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_pad>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_asynchronous>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_decimal>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_stream>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_size>, describe_field_t<SgInquireStatement,SgExpression*,&SgInquireStatement::p_pending>, describe_field_t<SgInquireStatement,SgVarRefExp*,&SgInquireStatement::p_iolengthExp>>;
};
template <> struct node_from_variant_t<478> { using type = SgInquireStatement; };

// Class: IntKeyedBidirectionalGraph
template <> struct describe_node_t<SgIntKeyedBidirectionalGraph> {
  using node = SgIntKeyedBidirectionalGraph;
  using base = SgBidirectionalGraph;
  static constexpr char const * const name{"IntKeyedBidirectionalGraph"};
  static constexpr unsigned long variant{479};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<479> { using type = SgIntKeyedBidirectionalGraph; };

// Class: IntVal
template <> struct describe_field_t<SgIntVal,int,&SgIntVal::p_value> {
  using parent = SgIntVal;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIntVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIntVal, int SgIntVal::*, &SgIntVal::p_value>;
};
template <> struct describe_field_t<SgIntVal,std::string,&SgIntVal::p_valueString> {
  using parent = SgIntVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIntVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIntVal, std::string SgIntVal::*, &SgIntVal::p_valueString>;
};
template <> struct describe_node_t<SgIntVal> {
  using node = SgIntVal;
  using base = SgValueExp;
  static constexpr char const * const name{"IntVal"};
  static constexpr unsigned long variant{480};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgIntVal,int,&SgIntVal::p_value>, describe_field_t<SgIntVal,std::string,&SgIntVal::p_valueString>>;
};
template <> struct node_from_variant_t<480> { using type = SgIntVal; };

// Class: IntegerDivideOp
template <> struct describe_node_t<SgIntegerDivideOp> {
  using node = SgIntegerDivideOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"IntegerDivideOp"};
  static constexpr unsigned long variant{481};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<481> { using type = SgIntegerDivideOp; };

// Class: IntegerDivideAssignOp
template <> struct describe_node_t<SgIntegerDivideAssignOp> {
  using node = SgIntegerDivideAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"IntegerDivideAssignOp"};
  static constexpr unsigned long variant{482};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<482> { using type = SgIntegerDivideAssignOp; };

// Class: InterfaceBody
template <> struct describe_field_t<SgInterfaceBody,SgName,&SgInterfaceBody::p_function_name> {
  using parent = SgInterfaceBody;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"function_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInterfaceBody::p_function_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInterfaceBody, SgName SgInterfaceBody::*, &SgInterfaceBody::p_function_name>;
};
template <> struct describe_field_t<SgInterfaceBody,SgFunctionDeclaration*,&SgInterfaceBody::p_functionDeclaration> {
  using parent = SgInterfaceBody;
  using field_type = SgFunctionDeclaration*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"functionDeclaration"};
  static constexpr char const * const typestr{"SgFunctionDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInterfaceBody::p_functionDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInterfaceBody, SgFunctionDeclaration* SgInterfaceBody::*, &SgInterfaceBody::p_functionDeclaration>;
};
template <> struct describe_field_t<SgInterfaceBody,bool,&SgInterfaceBody::p_use_function_name> {
  using parent = SgInterfaceBody;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"use_function_name"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInterfaceBody::p_use_function_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInterfaceBody, bool SgInterfaceBody::*, &SgInterfaceBody::p_use_function_name>;
};
template <> struct describe_node_t<SgInterfaceBody> {
  using node = SgInterfaceBody;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"InterfaceBody"};
  static constexpr unsigned long variant{483};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgInterfaceBody,SgName,&SgInterfaceBody::p_function_name>, describe_field_t<SgInterfaceBody,SgFunctionDeclaration*,&SgInterfaceBody::p_functionDeclaration>, describe_field_t<SgInterfaceBody,bool,&SgInterfaceBody::p_use_function_name>>;
};
template <> struct node_from_variant_t<483> { using type = SgInterfaceBody; };

// Class: HeaderFileBody
template <> struct describe_field_t<SgHeaderFileBody,SgSourceFile*,&SgHeaderFileBody::p_include_file> {
  using parent = SgHeaderFileBody;
  using field_type = SgSourceFile*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"include_file"};
  static constexpr char const * const typestr{"SgSourceFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgHeaderFileBody::p_include_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgHeaderFileBody, SgSourceFile* SgHeaderFileBody::*, &SgHeaderFileBody::p_include_file>;
};
template <> struct describe_node_t<SgHeaderFileBody> {
  using node = SgHeaderFileBody;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"HeaderFileBody"};
  static constexpr unsigned long variant{484};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgHeaderFileBody,SgSourceFile*,&SgHeaderFileBody::p_include_file>>;
};
template <> struct node_from_variant_t<484> { using type = SgHeaderFileBody; };

// Class: HeaderFileReport
template <> struct describe_field_t<SgHeaderFileReport,SgSourceFile*,&SgHeaderFileReport::p_source_file> {
  using parent = SgHeaderFileReport;
  using field_type = SgSourceFile*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"source_file"};
  static constexpr char const * const typestr{"SgSourceFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgHeaderFileReport::p_source_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgHeaderFileReport, SgSourceFile* SgHeaderFileReport::*, &SgHeaderFileReport::p_source_file>;
};
template <> struct describe_field_t<SgHeaderFileReport,SgSourceFilePtrList,&SgHeaderFileReport::p_include_file_list> {
  using parent = SgHeaderFileReport;
  using field_type = SgSourceFilePtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"include_file_list"};
  static constexpr char const * const typestr{"SgSourceFilePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgHeaderFileReport::p_include_file_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgHeaderFileReport, SgSourceFilePtrList SgHeaderFileReport::*, &SgHeaderFileReport::p_include_file_list>;
};
template <> struct describe_node_t<SgHeaderFileReport> {
  using node = SgHeaderFileReport;
  using base = SgSupport;
  static constexpr char const * const name{"HeaderFileReport"};
  static constexpr unsigned long variant{485};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgHeaderFileReport,SgSourceFile*,&SgHeaderFileReport::p_source_file>, describe_field_t<SgHeaderFileReport,SgSourceFilePtrList,&SgHeaderFileReport::p_include_file_list>>;
};
template <> struct node_from_variant_t<485> { using type = SgHeaderFileReport; };

// Class: InterfaceStatement
template <> struct describe_field_t<SgInterfaceStatement,SgName,&SgInterfaceStatement::p_name> {
  using parent = SgInterfaceStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInterfaceStatement::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInterfaceStatement, SgName SgInterfaceStatement::*, &SgInterfaceStatement::p_name>;
};
template <> struct describe_field_t<SgInterfaceStatement,SgInterfaceStatement::generic_spec_enum,&SgInterfaceStatement::p_generic_spec> {
  using parent = SgInterfaceStatement;
  using field_type = SgInterfaceStatement::generic_spec_enum;
  static constexpr size_t position{1};
  static constexpr char const * const name{"generic_spec"};
  static constexpr char const * const typestr{"SgInterfaceStatement::generic_spec_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInterfaceStatement::p_generic_spec};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInterfaceStatement, SgInterfaceStatement::generic_spec_enum SgInterfaceStatement::*, &SgInterfaceStatement::p_generic_spec>;
};
template <> struct describe_field_t<SgInterfaceStatement,SgInterfaceBodyPtrList,&SgInterfaceStatement::p_interface_body_list> {
  using parent = SgInterfaceStatement;
  using field_type = SgInterfaceBodyPtrList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"interface_body_list"};
  static constexpr char const * const typestr{"SgInterfaceBodyPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgInterfaceStatement::p_interface_body_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInterfaceStatement, SgInterfaceBodyPtrList SgInterfaceStatement::*, &SgInterfaceStatement::p_interface_body_list>;
};
template <> struct describe_field_t<SgInterfaceStatement,SgLabelRefExp*,&SgInterfaceStatement::p_end_numeric_label> {
  using parent = SgInterfaceStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInterfaceStatement::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInterfaceStatement, SgLabelRefExp* SgInterfaceStatement::*, &SgInterfaceStatement::p_end_numeric_label>;
};
template <> struct describe_node_t<SgInterfaceStatement> {
  using node = SgInterfaceStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"InterfaceStatement"};
  static constexpr unsigned long variant{486};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgInterfaceStatement,SgName,&SgInterfaceStatement::p_name>, describe_field_t<SgInterfaceStatement,SgInterfaceStatement::generic_spec_enum,&SgInterfaceStatement::p_generic_spec>, describe_field_t<SgInterfaceStatement,SgInterfaceBodyPtrList,&SgInterfaceStatement::p_interface_body_list>, describe_field_t<SgInterfaceStatement,SgLabelRefExp*,&SgInterfaceStatement::p_end_numeric_label>>;
};
template <> struct node_from_variant_t<486> { using type = SgInterfaceStatement; };

// Class: InterfaceSymbol
template <> struct describe_field_t<SgInterfaceSymbol,SgInterfaceStatement*,&SgInterfaceSymbol::p_declaration> {
  using parent = SgInterfaceSymbol;
  using field_type = SgInterfaceStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgInterfaceStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgInterfaceSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgInterfaceSymbol, SgInterfaceStatement* SgInterfaceSymbol::*, &SgInterfaceSymbol::p_declaration>;
};
template <> struct describe_node_t<SgInterfaceSymbol> {
  using node = SgInterfaceSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"InterfaceSymbol"};
  static constexpr unsigned long variant{487};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgInterfaceSymbol,SgInterfaceStatement*,&SgInterfaceSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<487> { using type = SgInterfaceSymbol; };

// Class: IntrinsicSymbol
template <> struct describe_field_t<SgIntrinsicSymbol,SgInitializedName*,&SgIntrinsicSymbol::p_declaration> {
  using parent = SgIntrinsicSymbol;
  using field_type = SgInitializedName*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgIntrinsicSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgIntrinsicSymbol, SgInitializedName* SgIntrinsicSymbol::*, &SgIntrinsicSymbol::p_declaration>;
};
template <> struct describe_node_t<SgIntrinsicSymbol> {
  using node = SgIntrinsicSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"IntrinsicSymbol"};
  static constexpr unsigned long variant{488};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgIntrinsicSymbol,SgInitializedName*,&SgIntrinsicSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<488> { using type = SgIntrinsicSymbol; };

// Class: IsOp
template <> struct describe_node_t<SgIsOp> {
  using node = SgIsOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"IsOp"};
  static constexpr unsigned long variant{489};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<489> { using type = SgIsOp; };

// Class: IsNotOp
template <> struct describe_node_t<SgIsNotOp> {
  using node = SgIsNotOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"IsNotOp"};
  static constexpr unsigned long variant{490};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<490> { using type = SgIsNotOp; };

// Class: IorAssignOp
template <> struct describe_node_t<SgIorAssignOp> {
  using node = SgIorAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"IorAssignOp"};
  static constexpr unsigned long variant{491};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<491> { using type = SgIorAssignOp; };

// Class: JovialBitType
template <> struct describe_field_t<SgJovialBitType,SgExpression*,&SgJovialBitType::p_size> {
  using parent = SgJovialBitType;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"size"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialBitType::p_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialBitType, SgExpression* SgJovialBitType::*, &SgJovialBitType::p_size>;
};
template <> struct describe_node_t<SgJovialBitType> {
  using node = SgJovialBitType;
  using base = SgType;
  static constexpr char const * const name{"JovialBitType"};
  static constexpr unsigned long variant{492};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialBitType,SgExpression*,&SgJovialBitType::p_size>>;
};
template <> struct node_from_variant_t<492> { using type = SgJovialBitType; };

// Class: JovialBitVal
template <> struct describe_field_t<SgJovialBitVal,std::string,&SgJovialBitVal::p_valueString> {
  using parent = SgJovialBitVal;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialBitVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialBitVal, std::string SgJovialBitVal::*, &SgJovialBitVal::p_valueString>;
};
template <> struct describe_node_t<SgJovialBitVal> {
  using node = SgJovialBitVal;
  using base = SgValueExp;
  static constexpr char const * const name{"JovialBitVal"};
  static constexpr unsigned long variant{493};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialBitVal,std::string,&SgJovialBitVal::p_valueString>>;
};
template <> struct node_from_variant_t<493> { using type = SgJovialBitVal; };

// Class: JovialTableType
template <> struct describe_field_t<SgJovialTableType,SgType*,&SgJovialTableType::p_base_type> {
  using parent = SgJovialTableType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialTableType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableType, SgType* SgJovialTableType::*, &SgJovialTableType::p_base_type>;
};
template <> struct describe_field_t<SgJovialTableType,SgExprListExp*,&SgJovialTableType::p_dim_info> {
  using parent = SgJovialTableType;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"dim_info"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialTableType::p_dim_info};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableType, SgExprListExp* SgJovialTableType::*, &SgJovialTableType::p_dim_info>;
};
template <> struct describe_field_t<SgJovialTableType,int,&SgJovialTableType::p_rank> {
  using parent = SgJovialTableType;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"rank"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialTableType::p_rank};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableType, int SgJovialTableType::*, &SgJovialTableType::p_rank>;
};
template <> struct describe_field_t<SgJovialTableType,SgJovialTableType::StructureSpecifier,&SgJovialTableType::p_structure_specifier> {
  using parent = SgJovialTableType;
  using field_type = SgJovialTableType::StructureSpecifier;
  static constexpr size_t position{3};
  static constexpr char const * const name{"structure_specifier"};
  static constexpr char const * const typestr{"SgJovialTableType::StructureSpecifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialTableType::p_structure_specifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableType, SgJovialTableType::StructureSpecifier SgJovialTableType::*, &SgJovialTableType::p_structure_specifier>;
};
template <> struct describe_field_t<SgJovialTableType,unsigned int,&SgJovialTableType::p_bits_per_entry> {
  using parent = SgJovialTableType;
  using field_type = unsigned int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"bits_per_entry"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialTableType::p_bits_per_entry};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableType, unsigned int SgJovialTableType::*, &SgJovialTableType::p_bits_per_entry>;
};
template <> struct describe_node_t<SgJovialTableType> {
  using node = SgJovialTableType;
  using base = SgClassType;
  static constexpr char const * const name{"JovialTableType"};
  static constexpr unsigned long variant{494};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialTableType,SgType*,&SgJovialTableType::p_base_type>, describe_field_t<SgJovialTableType,SgExprListExp*,&SgJovialTableType::p_dim_info>, describe_field_t<SgJovialTableType,int,&SgJovialTableType::p_rank>, describe_field_t<SgJovialTableType,SgJovialTableType::StructureSpecifier,&SgJovialTableType::p_structure_specifier>, describe_field_t<SgJovialTableType,unsigned int,&SgJovialTableType::p_bits_per_entry>>;
};
template <> struct node_from_variant_t<494> { using type = SgJovialTableType; };

// Class: JovialCompoolStatement
template <> struct describe_field_t<SgJovialCompoolStatement,SgName,&SgJovialCompoolStatement::p_name> {
  using parent = SgJovialCompoolStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialCompoolStatement::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialCompoolStatement, SgName SgJovialCompoolStatement::*, &SgJovialCompoolStatement::p_name>;
};
template <> struct describe_node_t<SgJovialCompoolStatement> {
  using node = SgJovialCompoolStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"JovialCompoolStatement"};
  static constexpr unsigned long variant{495};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialCompoolStatement,SgName,&SgJovialCompoolStatement::p_name>>;
};
template <> struct node_from_variant_t<495> { using type = SgJovialCompoolStatement; };

// Class: JovialForThenStatement
template <> struct describe_field_t<SgJovialForThenStatement,SgExpression*,&SgJovialForThenStatement::p_initialization> {
  using parent = SgJovialForThenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"initialization"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialForThenStatement::p_initialization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialForThenStatement, SgExpression* SgJovialForThenStatement::*, &SgJovialForThenStatement::p_initialization>;
};
template <> struct describe_field_t<SgJovialForThenStatement,SgExpression*,&SgJovialForThenStatement::p_while_expression> {
  using parent = SgJovialForThenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"while_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialForThenStatement::p_while_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialForThenStatement, SgExpression* SgJovialForThenStatement::*, &SgJovialForThenStatement::p_while_expression>;
};
template <> struct describe_field_t<SgJovialForThenStatement,SgExpression*,&SgJovialForThenStatement::p_by_or_then_expression> {
  using parent = SgJovialForThenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"by_or_then_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialForThenStatement::p_by_or_then_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialForThenStatement, SgExpression* SgJovialForThenStatement::*, &SgJovialForThenStatement::p_by_or_then_expression>;
};
template <> struct describe_field_t<SgJovialForThenStatement,SgBasicBlock*,&SgJovialForThenStatement::p_loop_body> {
  using parent = SgJovialForThenStatement;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"loop_body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialForThenStatement::p_loop_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialForThenStatement, SgBasicBlock* SgJovialForThenStatement::*, &SgJovialForThenStatement::p_loop_body>;
};
template <> struct describe_field_t<SgJovialForThenStatement,SgJovialForThenStatement::loop_statement_type_enum,&SgJovialForThenStatement::p_loop_statement_type> {
  using parent = SgJovialForThenStatement;
  using field_type = SgJovialForThenStatement::loop_statement_type_enum;
  static constexpr size_t position{4};
  static constexpr char const * const name{"loop_statement_type"};
  static constexpr char const * const typestr{"SgJovialForThenStatement::loop_statement_type_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialForThenStatement::p_loop_statement_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialForThenStatement, SgJovialForThenStatement::loop_statement_type_enum SgJovialForThenStatement::*, &SgJovialForThenStatement::p_loop_statement_type>;
};
template <> struct describe_node_t<SgJovialForThenStatement> {
  using node = SgJovialForThenStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"JovialForThenStatement"};
  static constexpr unsigned long variant{496};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialForThenStatement,SgExpression*,&SgJovialForThenStatement::p_initialization>, describe_field_t<SgJovialForThenStatement,SgExpression*,&SgJovialForThenStatement::p_while_expression>, describe_field_t<SgJovialForThenStatement,SgExpression*,&SgJovialForThenStatement::p_by_or_then_expression>, describe_field_t<SgJovialForThenStatement,SgBasicBlock*,&SgJovialForThenStatement::p_loop_body>, describe_field_t<SgJovialForThenStatement,SgJovialForThenStatement::loop_statement_type_enum,&SgJovialForThenStatement::p_loop_statement_type>>;
};
template <> struct node_from_variant_t<496> { using type = SgJovialForThenStatement; };

// Class: JovialDefineDeclaration
template <> struct describe_field_t<SgJovialDefineDeclaration,std::string,&SgJovialDefineDeclaration::p_define_string> {
  using parent = SgJovialDefineDeclaration;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"define_string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialDefineDeclaration::p_define_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialDefineDeclaration, std::string SgJovialDefineDeclaration::*, &SgJovialDefineDeclaration::p_define_string>;
};
template <> struct describe_node_t<SgJovialDefineDeclaration> {
  using node = SgJovialDefineDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"JovialDefineDeclaration"};
  static constexpr unsigned long variant{497};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialDefineDeclaration,std::string,&SgJovialDefineDeclaration::p_define_string>>;
};
template <> struct node_from_variant_t<497> { using type = SgJovialDefineDeclaration; };

// Class: JovialDirectiveStatement
template <> struct describe_field_t<SgJovialDirectiveStatement,std::string,&SgJovialDirectiveStatement::p_content_string> {
  using parent = SgJovialDirectiveStatement;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"content_string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialDirectiveStatement::p_content_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialDirectiveStatement, std::string SgJovialDirectiveStatement::*, &SgJovialDirectiveStatement::p_content_string>;
};
template <> struct describe_field_t<SgJovialDirectiveStatement,SgJovialDirectiveStatement::directive_types,&SgJovialDirectiveStatement::p_directive_type> {
  using parent = SgJovialDirectiveStatement;
  using field_type = SgJovialDirectiveStatement::directive_types;
  static constexpr size_t position{1};
  static constexpr char const * const name{"directive_type"};
  static constexpr char const * const typestr{"SgJovialDirectiveStatement::directive_types"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialDirectiveStatement::p_directive_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialDirectiveStatement, SgJovialDirectiveStatement::directive_types SgJovialDirectiveStatement::*, &SgJovialDirectiveStatement::p_directive_type>;
};
template <> struct describe_node_t<SgJovialDirectiveStatement> {
  using node = SgJovialDirectiveStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"JovialDirectiveStatement"};
  static constexpr unsigned long variant{498};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialDirectiveStatement,std::string,&SgJovialDirectiveStatement::p_content_string>, describe_field_t<SgJovialDirectiveStatement,SgJovialDirectiveStatement::directive_types,&SgJovialDirectiveStatement::p_directive_type>>;
};
template <> struct node_from_variant_t<498> { using type = SgJovialDirectiveStatement; };

// Class: JovialOverlayDeclaration
template <> struct describe_field_t<SgJovialOverlayDeclaration,SgExpression*,&SgJovialOverlayDeclaration::p_address> {
  using parent = SgJovialOverlayDeclaration;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"address"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialOverlayDeclaration::p_address};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialOverlayDeclaration, SgExpression* SgJovialOverlayDeclaration::*, &SgJovialOverlayDeclaration::p_address>;
};
template <> struct describe_field_t<SgJovialOverlayDeclaration,SgExprListExp*,&SgJovialOverlayDeclaration::p_overlay> {
  using parent = SgJovialOverlayDeclaration;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"overlay"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialOverlayDeclaration::p_overlay};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialOverlayDeclaration, SgExprListExp* SgJovialOverlayDeclaration::*, &SgJovialOverlayDeclaration::p_overlay>;
};
template <> struct describe_node_t<SgJovialOverlayDeclaration> {
  using node = SgJovialOverlayDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"JovialOverlayDeclaration"};
  static constexpr unsigned long variant{499};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialOverlayDeclaration,SgExpression*,&SgJovialOverlayDeclaration::p_address>, describe_field_t<SgJovialOverlayDeclaration,SgExprListExp*,&SgJovialOverlayDeclaration::p_overlay>>;
};
template <> struct node_from_variant_t<499> { using type = SgJovialOverlayDeclaration; };

// Class: JovialPresetPositionExp
template <> struct describe_field_t<SgJovialPresetPositionExp,SgExprListExp*,&SgJovialPresetPositionExp::p_indices> {
  using parent = SgJovialPresetPositionExp;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"indices"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialPresetPositionExp::p_indices};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialPresetPositionExp, SgExprListExp* SgJovialPresetPositionExp::*, &SgJovialPresetPositionExp::p_indices>;
};
template <> struct describe_field_t<SgJovialPresetPositionExp,SgExpression*,&SgJovialPresetPositionExp::p_value> {
  using parent = SgJovialPresetPositionExp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialPresetPositionExp::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialPresetPositionExp, SgExpression* SgJovialPresetPositionExp::*, &SgJovialPresetPositionExp::p_value>;
};
template <> struct describe_node_t<SgJovialPresetPositionExp> {
  using node = SgJovialPresetPositionExp;
  using base = SgExpression;
  static constexpr char const * const name{"JovialPresetPositionExp"};
  static constexpr unsigned long variant{500};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialPresetPositionExp,SgExprListExp*,&SgJovialPresetPositionExp::p_indices>, describe_field_t<SgJovialPresetPositionExp,SgExpression*,&SgJovialPresetPositionExp::p_value>>;
};
template <> struct node_from_variant_t<500> { using type = SgJovialPresetPositionExp; };

// Class: JovialTablePresetExp
template <> struct describe_field_t<SgJovialTablePresetExp,SgExprListExp*,&SgJovialTablePresetExp::p_preset_list> {
  using parent = SgJovialTablePresetExp;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"preset_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJovialTablePresetExp::p_preset_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTablePresetExp, SgExprListExp* SgJovialTablePresetExp::*, &SgJovialTablePresetExp::p_preset_list>;
};
template <> struct describe_node_t<SgJovialTablePresetExp> {
  using node = SgJovialTablePresetExp;
  using base = SgExpression;
  static constexpr char const * const name{"JovialTablePresetExp"};
  static constexpr unsigned long variant{501};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialTablePresetExp,SgExprListExp*,&SgJovialTablePresetExp::p_preset_list>>;
};
template <> struct node_from_variant_t<501> { using type = SgJovialTablePresetExp; };

// Class: JovialTableStatement
template <> struct describe_field_t<SgJovialTableStatement,SgExpression*,&SgJovialTableStatement::p_table_entry_size> {
  using parent = SgJovialTableStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"table_entry_size"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialTableStatement::p_table_entry_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableStatement, SgExpression* SgJovialTableStatement::*, &SgJovialTableStatement::p_table_entry_size>;
};
template <> struct describe_field_t<SgJovialTableStatement,bool,&SgJovialTableStatement::p_has_table_entry_size> {
  using parent = SgJovialTableStatement;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"has_table_entry_size"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialTableStatement::p_has_table_entry_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableStatement, bool SgJovialTableStatement::*, &SgJovialTableStatement::p_has_table_entry_size>;
};
template <> struct describe_field_t<SgJovialTableStatement,SgJovialTableStatement::WordsPerEntry,&SgJovialTableStatement::p_words_per_entry> {
  using parent = SgJovialTableStatement;
  using field_type = SgJovialTableStatement::WordsPerEntry;
  static constexpr size_t position{2};
  static constexpr char const * const name{"words_per_entry"};
  static constexpr char const * const typestr{"SgJovialTableStatement::WordsPerEntry"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialTableStatement::p_words_per_entry};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableStatement, SgJovialTableStatement::WordsPerEntry SgJovialTableStatement::*, &SgJovialTableStatement::p_words_per_entry>;
};
template <> struct describe_field_t<SgJovialTableStatement,std::string,&SgJovialTableStatement::p_like_table_name> {
  using parent = SgJovialTableStatement;
  using field_type = std::string;
  static constexpr size_t position{3};
  static constexpr char const * const name{"like_table_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialTableStatement::p_like_table_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableStatement, std::string SgJovialTableStatement::*, &SgJovialTableStatement::p_like_table_name>;
};
template <> struct describe_field_t<SgJovialTableStatement,bool,&SgJovialTableStatement::p_has_like_option> {
  using parent = SgJovialTableStatement;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"has_like_option"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialTableStatement::p_has_like_option};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialTableStatement, bool SgJovialTableStatement::*, &SgJovialTableStatement::p_has_like_option>;
};
template <> struct describe_node_t<SgJovialTableStatement> {
  using node = SgJovialTableStatement;
  using base = SgClassDeclaration;
  static constexpr char const * const name{"JovialTableStatement"};
  static constexpr unsigned long variant{502};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialTableStatement,SgExpression*,&SgJovialTableStatement::p_table_entry_size>, describe_field_t<SgJovialTableStatement,bool,&SgJovialTableStatement::p_has_table_entry_size>, describe_field_t<SgJovialTableStatement,SgJovialTableStatement::WordsPerEntry,&SgJovialTableStatement::p_words_per_entry>, describe_field_t<SgJovialTableStatement,std::string,&SgJovialTableStatement::p_like_table_name>, describe_field_t<SgJovialTableStatement,bool,&SgJovialTableStatement::p_has_like_option>>;
};
template <> struct node_from_variant_t<502> { using type = SgJovialTableStatement; };

// Class: KeyDatumPair
template <> struct describe_field_t<SgKeyDatumPair,SgExpression*,&SgKeyDatumPair::p_key> {
  using parent = SgKeyDatumPair;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"key"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgKeyDatumPair::p_key};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgKeyDatumPair, SgExpression* SgKeyDatumPair::*, &SgKeyDatumPair::p_key>;
};
template <> struct describe_field_t<SgKeyDatumPair,SgExpression*,&SgKeyDatumPair::p_datum> {
  using parent = SgKeyDatumPair;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"datum"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgKeyDatumPair::p_datum};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgKeyDatumPair, SgExpression* SgKeyDatumPair::*, &SgKeyDatumPair::p_datum>;
};
template <> struct describe_node_t<SgKeyDatumPair> {
  using node = SgKeyDatumPair;
  using base = SgExpression;
  static constexpr char const * const name{"KeyDatumPair"};
  static constexpr unsigned long variant{503};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgKeyDatumPair,SgExpression*,&SgKeyDatumPair::p_key>, describe_field_t<SgKeyDatumPair,SgExpression*,&SgKeyDatumPair::p_datum>>;
};
template <> struct node_from_variant_t<503> { using type = SgKeyDatumPair; };

// Class: CudaKernelExecConfig
template <> struct describe_field_t<SgCudaKernelExecConfig,SgExpression*,&SgCudaKernelExecConfig::p_grid> {
  using parent = SgCudaKernelExecConfig;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"grid"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCudaKernelExecConfig::p_grid};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCudaKernelExecConfig, SgExpression* SgCudaKernelExecConfig::*, &SgCudaKernelExecConfig::p_grid>;
};
template <> struct describe_field_t<SgCudaKernelExecConfig,SgExpression*,&SgCudaKernelExecConfig::p_blocks> {
  using parent = SgCudaKernelExecConfig;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"blocks"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCudaKernelExecConfig::p_blocks};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCudaKernelExecConfig, SgExpression* SgCudaKernelExecConfig::*, &SgCudaKernelExecConfig::p_blocks>;
};
template <> struct describe_field_t<SgCudaKernelExecConfig,SgExpression*,&SgCudaKernelExecConfig::p_shared> {
  using parent = SgCudaKernelExecConfig;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"shared"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCudaKernelExecConfig::p_shared};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCudaKernelExecConfig, SgExpression* SgCudaKernelExecConfig::*, &SgCudaKernelExecConfig::p_shared>;
};
template <> struct describe_field_t<SgCudaKernelExecConfig,SgExpression*,&SgCudaKernelExecConfig::p_stream> {
  using parent = SgCudaKernelExecConfig;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"stream"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCudaKernelExecConfig::p_stream};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCudaKernelExecConfig, SgExpression* SgCudaKernelExecConfig::*, &SgCudaKernelExecConfig::p_stream>;
};
template <> struct describe_node_t<SgCudaKernelExecConfig> {
  using node = SgCudaKernelExecConfig;
  using base = SgExpression;
  static constexpr char const * const name{"CudaKernelExecConfig"};
  static constexpr unsigned long variant{504};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCudaKernelExecConfig,SgExpression*,&SgCudaKernelExecConfig::p_grid>, describe_field_t<SgCudaKernelExecConfig,SgExpression*,&SgCudaKernelExecConfig::p_blocks>, describe_field_t<SgCudaKernelExecConfig,SgExpression*,&SgCudaKernelExecConfig::p_shared>, describe_field_t<SgCudaKernelExecConfig,SgExpression*,&SgCudaKernelExecConfig::p_stream>>;
};
template <> struct node_from_variant_t<504> { using type = SgCudaKernelExecConfig; };

// Class: CudaKernelCallExp
template <> struct describe_field_t<SgCudaKernelCallExp,SgCudaKernelExecConfig*,&SgCudaKernelCallExp::p_exec_config> {
  using parent = SgCudaKernelCallExp;
  using field_type = SgCudaKernelExecConfig*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"exec_config"};
  static constexpr char const * const typestr{"SgCudaKernelExecConfig*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCudaKernelCallExp::p_exec_config};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCudaKernelCallExp, SgCudaKernelExecConfig* SgCudaKernelCallExp::*, &SgCudaKernelCallExp::p_exec_config>;
};
template <> struct describe_node_t<SgCudaKernelCallExp> {
  using node = SgCudaKernelCallExp;
  using base = SgFunctionCallExp;
  static constexpr char const * const name{"CudaKernelCallExp"};
  static constexpr unsigned long variant{505};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCudaKernelCallExp,SgCudaKernelExecConfig*,&SgCudaKernelCallExp::p_exec_config>>;
};
template <> struct node_from_variant_t<505> { using type = SgCudaKernelCallExp; };

// Class: LabelRefExp
template <> struct describe_field_t<SgLabelRefExp,SgLabelSymbol*,&SgLabelRefExp::p_symbol> {
  using parent = SgLabelRefExp;
  using field_type = SgLabelSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgLabelSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLabelRefExp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelRefExp, SgLabelSymbol* SgLabelRefExp::*, &SgLabelRefExp::p_symbol>;
};
template <> struct describe_node_t<SgLabelRefExp> {
  using node = SgLabelRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"LabelRefExp"};
  static constexpr unsigned long variant{506};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLabelRefExp,SgLabelSymbol*,&SgLabelRefExp::p_symbol>>;
};
template <> struct node_from_variant_t<506> { using type = SgLabelRefExp; };

// Class: LabelStatement
template <> struct describe_field_t<SgLabelStatement,SgName,&SgLabelStatement::p_label> {
  using parent = SgLabelStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"label"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLabelStatement::p_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelStatement, SgName SgLabelStatement::*, &SgLabelStatement::p_label>;
};
template <> struct describe_field_t<SgLabelStatement,SgScopeStatement*,&SgLabelStatement::p_scope> {
  using parent = SgLabelStatement;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLabelStatement::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelStatement, SgScopeStatement* SgLabelStatement::*, &SgLabelStatement::p_scope>;
};
template <> struct describe_field_t<SgLabelStatement,SgStatement*,&SgLabelStatement::p_statement> {
  using parent = SgLabelStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"statement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLabelStatement::p_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelStatement, SgStatement* SgLabelStatement::*, &SgLabelStatement::p_statement>;
};
template <> struct describe_field_t<SgLabelStatement,SgLabelStatement::label_type_enum,&SgLabelStatement::p_label_type> {
  using parent = SgLabelStatement;
  using field_type = SgLabelStatement::label_type_enum;
  static constexpr size_t position{3};
  static constexpr char const * const name{"label_type"};
  static constexpr char const * const typestr{"SgLabelStatement::label_type_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLabelStatement::p_label_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelStatement, SgLabelStatement::label_type_enum SgLabelStatement::*, &SgLabelStatement::p_label_type>;
};
template <> struct describe_field_t<SgLabelStatement,bool,&SgLabelStatement::p_gnu_extension_unused> {
  using parent = SgLabelStatement;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"gnu_extension_unused"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLabelStatement::p_gnu_extension_unused};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelStatement, bool SgLabelStatement::*, &SgLabelStatement::p_gnu_extension_unused>;
};
template <> struct describe_node_t<SgLabelStatement> {
  using node = SgLabelStatement;
  using base = SgStatement;
  static constexpr char const * const name{"LabelStatement"};
  static constexpr unsigned long variant{507};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLabelStatement,SgName,&SgLabelStatement::p_label>, describe_field_t<SgLabelStatement,SgScopeStatement*,&SgLabelStatement::p_scope>, describe_field_t<SgLabelStatement,SgStatement*,&SgLabelStatement::p_statement>, describe_field_t<SgLabelStatement,SgLabelStatement::label_type_enum,&SgLabelStatement::p_label_type>, describe_field_t<SgLabelStatement,bool,&SgLabelStatement::p_gnu_extension_unused>>;
};
template <> struct node_from_variant_t<507> { using type = SgLabelStatement; };

// Class: JavaLabelStatement
template <> struct describe_field_t<SgJavaLabelStatement,SgName,&SgJavaLabelStatement::p_label> {
  using parent = SgJavaLabelStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"label"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaLabelStatement::p_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaLabelStatement, SgName SgJavaLabelStatement::*, &SgJavaLabelStatement::p_label>;
};
template <> struct describe_field_t<SgJavaLabelStatement,SgStatement*,&SgJavaLabelStatement::p_statement> {
  using parent = SgJavaLabelStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"statement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaLabelStatement::p_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaLabelStatement, SgStatement* SgJavaLabelStatement::*, &SgJavaLabelStatement::p_statement>;
};
template <> struct describe_node_t<SgJavaLabelStatement> {
  using node = SgJavaLabelStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"JavaLabelStatement"};
  static constexpr unsigned long variant{508};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaLabelStatement,SgName,&SgJavaLabelStatement::p_label>, describe_field_t<SgJavaLabelStatement,SgStatement*,&SgJavaLabelStatement::p_statement>>;
};
template <> struct node_from_variant_t<508> { using type = SgJavaLabelStatement; };

// Class: LabelSymbol
template <> struct describe_field_t<SgLabelSymbol,SgLabelStatement*,&SgLabelSymbol::p_declaration> {
  using parent = SgLabelSymbol;
  using field_type = SgLabelStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgLabelStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLabelSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelSymbol, SgLabelStatement* SgLabelSymbol::*, &SgLabelSymbol::p_declaration>;
};
template <> struct describe_field_t<SgLabelSymbol,SgStatement*,&SgLabelSymbol::p_fortran_statement> {
  using parent = SgLabelSymbol;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"fortran_statement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLabelSymbol::p_fortran_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelSymbol, SgStatement* SgLabelSymbol::*, &SgLabelSymbol::p_fortran_statement>;
};
template <> struct describe_field_t<SgLabelSymbol,SgInitializedName*,&SgLabelSymbol::p_fortran_alternate_return_parameter> {
  using parent = SgLabelSymbol;
  using field_type = SgInitializedName*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"fortran_alternate_return_parameter"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLabelSymbol::p_fortran_alternate_return_parameter};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelSymbol, SgInitializedName* SgLabelSymbol::*, &SgLabelSymbol::p_fortran_alternate_return_parameter>;
};
template <> struct describe_field_t<SgLabelSymbol,int,&SgLabelSymbol::p_numeric_label_value> {
  using parent = SgLabelSymbol;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"numeric_label_value"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLabelSymbol::p_numeric_label_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelSymbol, int SgLabelSymbol::*, &SgLabelSymbol::p_numeric_label_value>;
};
template <> struct describe_field_t<SgLabelSymbol,SgLabelSymbol::label_type_enum,&SgLabelSymbol::p_label_type> {
  using parent = SgLabelSymbol;
  using field_type = SgLabelSymbol::label_type_enum;
  static constexpr size_t position{4};
  static constexpr char const * const name{"label_type"};
  static constexpr char const * const typestr{"SgLabelSymbol::label_type_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLabelSymbol::p_label_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLabelSymbol, SgLabelSymbol::label_type_enum SgLabelSymbol::*, &SgLabelSymbol::p_label_type>;
};
template <> struct describe_node_t<SgLabelSymbol> {
  using node = SgLabelSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"LabelSymbol"};
  static constexpr unsigned long variant{509};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLabelSymbol,SgLabelStatement*,&SgLabelSymbol::p_declaration>, describe_field_t<SgLabelSymbol,SgStatement*,&SgLabelSymbol::p_fortran_statement>, describe_field_t<SgLabelSymbol,SgInitializedName*,&SgLabelSymbol::p_fortran_alternate_return_parameter>, describe_field_t<SgLabelSymbol,int,&SgLabelSymbol::p_numeric_label_value>, describe_field_t<SgLabelSymbol,SgLabelSymbol::label_type_enum,&SgLabelSymbol::p_label_type>>;
};
template <> struct node_from_variant_t<509> { using type = SgLabelSymbol; };

// Class: JavaLabelSymbol
template <> struct describe_field_t<SgJavaLabelSymbol,SgJavaLabelStatement*,&SgJavaLabelSymbol::p_declaration> {
  using parent = SgJavaLabelSymbol;
  using field_type = SgJavaLabelStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgJavaLabelStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaLabelSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaLabelSymbol, SgJavaLabelStatement* SgJavaLabelSymbol::*, &SgJavaLabelSymbol::p_declaration>;
};
template <> struct describe_node_t<SgJavaLabelSymbol> {
  using node = SgJavaLabelSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"JavaLabelSymbol"};
  static constexpr unsigned long variant{510};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaLabelSymbol,SgJavaLabelStatement*,&SgJavaLabelSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<510> { using type = SgJavaLabelSymbol; };

// Class: LambdaCapture
template <> struct describe_field_t<SgLambdaCapture,SgExpression*,&SgLambdaCapture::p_capture_variable> {
  using parent = SgLambdaCapture;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"capture_variable"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLambdaCapture::p_capture_variable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaCapture, SgExpression* SgLambdaCapture::*, &SgLambdaCapture::p_capture_variable>;
};
template <> struct describe_field_t<SgLambdaCapture,SgExpression*,&SgLambdaCapture::p_source_closure_variable> {
  using parent = SgLambdaCapture;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"source_closure_variable"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLambdaCapture::p_source_closure_variable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaCapture, SgExpression* SgLambdaCapture::*, &SgLambdaCapture::p_source_closure_variable>;
};
template <> struct describe_field_t<SgLambdaCapture,SgExpression*,&SgLambdaCapture::p_closure_variable> {
  using parent = SgLambdaCapture;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"closure_variable"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLambdaCapture::p_closure_variable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaCapture, SgExpression* SgLambdaCapture::*, &SgLambdaCapture::p_closure_variable>;
};
template <> struct describe_field_t<SgLambdaCapture,bool,&SgLambdaCapture::p_capture_by_reference> {
  using parent = SgLambdaCapture;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"capture_by_reference"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLambdaCapture::p_capture_by_reference};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaCapture, bool SgLambdaCapture::*, &SgLambdaCapture::p_capture_by_reference>;
};
template <> struct describe_field_t<SgLambdaCapture,bool,&SgLambdaCapture::p_implicit> {
  using parent = SgLambdaCapture;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"implicit"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLambdaCapture::p_implicit};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaCapture, bool SgLambdaCapture::*, &SgLambdaCapture::p_implicit>;
};
template <> struct describe_field_t<SgLambdaCapture,bool,&SgLambdaCapture::p_pack_expansion> {
  using parent = SgLambdaCapture;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"pack_expansion"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLambdaCapture::p_pack_expansion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaCapture, bool SgLambdaCapture::*, &SgLambdaCapture::p_pack_expansion>;
};
template <> struct describe_node_t<SgLambdaCapture> {
  using node = SgLambdaCapture;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"LambdaCapture"};
  static constexpr unsigned long variant{511};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLambdaCapture,SgExpression*,&SgLambdaCapture::p_capture_variable>, describe_field_t<SgLambdaCapture,SgExpression*,&SgLambdaCapture::p_source_closure_variable>, describe_field_t<SgLambdaCapture,SgExpression*,&SgLambdaCapture::p_closure_variable>, describe_field_t<SgLambdaCapture,bool,&SgLambdaCapture::p_capture_by_reference>, describe_field_t<SgLambdaCapture,bool,&SgLambdaCapture::p_implicit>, describe_field_t<SgLambdaCapture,bool,&SgLambdaCapture::p_pack_expansion>>;
};
template <> struct node_from_variant_t<511> { using type = SgLambdaCapture; };

// Class: LambdaCaptureList
template <> struct describe_field_t<SgLambdaCaptureList,SgLambdaCapturePtrList,&SgLambdaCaptureList::p_capture_list> {
  using parent = SgLambdaCaptureList;
  using field_type = SgLambdaCapturePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"capture_list"};
  static constexpr char const * const typestr{"SgLambdaCapturePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLambdaCaptureList::p_capture_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaCaptureList, SgLambdaCapturePtrList SgLambdaCaptureList::*, &SgLambdaCaptureList::p_capture_list>;
};
template <> struct describe_node_t<SgLambdaCaptureList> {
  using node = SgLambdaCaptureList;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"LambdaCaptureList"};
  static constexpr unsigned long variant{512};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLambdaCaptureList,SgLambdaCapturePtrList,&SgLambdaCaptureList::p_capture_list>>;
};
template <> struct node_from_variant_t<512> { using type = SgLambdaCaptureList; };

// Class: LambdaExp
template <> struct describe_field_t<SgLambdaExp,SgLambdaCaptureList*,&SgLambdaExp::p_lambda_capture_list> {
  using parent = SgLambdaExp;
  using field_type = SgLambdaCaptureList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lambda_capture_list"};
  static constexpr char const * const typestr{"SgLambdaCaptureList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLambdaExp::p_lambda_capture_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaExp, SgLambdaCaptureList* SgLambdaExp::*, &SgLambdaExp::p_lambda_capture_list>;
};
template <> struct describe_field_t<SgLambdaExp,SgClassDeclaration*,&SgLambdaExp::p_lambda_closure_class> {
  using parent = SgLambdaExp;
  using field_type = SgClassDeclaration*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"lambda_closure_class"};
  static constexpr char const * const typestr{"SgClassDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLambdaExp::p_lambda_closure_class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaExp, SgClassDeclaration* SgLambdaExp::*, &SgLambdaExp::p_lambda_closure_class>;
};
template <> struct describe_field_t<SgLambdaExp,SgFunctionDeclaration*,&SgLambdaExp::p_lambda_function> {
  using parent = SgLambdaExp;
  using field_type = SgFunctionDeclaration*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"lambda_function"};
  static constexpr char const * const typestr{"SgFunctionDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLambdaExp::p_lambda_function};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaExp, SgFunctionDeclaration* SgLambdaExp::*, &SgLambdaExp::p_lambda_function>;
};
template <> struct describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_is_mutable> {
  using parent = SgLambdaExp;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"is_mutable"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLambdaExp::p_is_mutable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaExp, bool SgLambdaExp::*, &SgLambdaExp::p_is_mutable>;
};
template <> struct describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_capture_default> {
  using parent = SgLambdaExp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"capture_default"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLambdaExp::p_capture_default};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaExp, bool SgLambdaExp::*, &SgLambdaExp::p_capture_default>;
};
template <> struct describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_default_is_by_reference> {
  using parent = SgLambdaExp;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"default_is_by_reference"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLambdaExp::p_default_is_by_reference};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaExp, bool SgLambdaExp::*, &SgLambdaExp::p_default_is_by_reference>;
};
template <> struct describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_explicit_return_type> {
  using parent = SgLambdaExp;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"explicit_return_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLambdaExp::p_explicit_return_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaExp, bool SgLambdaExp::*, &SgLambdaExp::p_explicit_return_type>;
};
template <> struct describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_has_parameter_decl> {
  using parent = SgLambdaExp;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"has_parameter_decl"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLambdaExp::p_has_parameter_decl};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaExp, bool SgLambdaExp::*, &SgLambdaExp::p_has_parameter_decl>;
};
template <> struct describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_is_device> {
  using parent = SgLambdaExp;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"is_device"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLambdaExp::p_is_device};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaExp, bool SgLambdaExp::*, &SgLambdaExp::p_is_device>;
};
template <> struct describe_node_t<SgLambdaExp> {
  using node = SgLambdaExp;
  using base = SgExpression;
  static constexpr char const * const name{"LambdaExp"};
  static constexpr unsigned long variant{513};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLambdaExp,SgLambdaCaptureList*,&SgLambdaExp::p_lambda_capture_list>, describe_field_t<SgLambdaExp,SgClassDeclaration*,&SgLambdaExp::p_lambda_closure_class>, describe_field_t<SgLambdaExp,SgFunctionDeclaration*,&SgLambdaExp::p_lambda_function>, describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_is_mutable>, describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_capture_default>, describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_default_is_by_reference>, describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_explicit_return_type>, describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_has_parameter_decl>, describe_field_t<SgLambdaExp,bool,&SgLambdaExp::p_is_device>>;
};
template <> struct node_from_variant_t<513> { using type = SgLambdaExp; };

// Class: LambdaRefExp
template <> struct describe_field_t<SgLambdaRefExp,SgFunctionDeclaration*,&SgLambdaRefExp::p_functionDeclaration> {
  using parent = SgLambdaRefExp;
  using field_type = SgFunctionDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"functionDeclaration"};
  static constexpr char const * const typestr{"SgFunctionDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLambdaRefExp::p_functionDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLambdaRefExp, SgFunctionDeclaration* SgLambdaRefExp::*, &SgLambdaRefExp::p_functionDeclaration>;
};
template <> struct describe_node_t<SgLambdaRefExp> {
  using node = SgLambdaRefExp;
  using base = SgExpression;
  static constexpr char const * const name{"LambdaRefExp"};
  static constexpr unsigned long variant{514};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLambdaRefExp,SgFunctionDeclaration*,&SgLambdaRefExp::p_functionDeclaration>>;
};
template <> struct node_from_variant_t<514> { using type = SgLambdaRefExp; };

// Class: LeftDivideOp
template <> struct describe_node_t<SgLeftDivideOp> {
  using node = SgLeftDivideOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"LeftDivideOp"};
  static constexpr unsigned long variant{515};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<515> { using type = SgLeftDivideOp; };

// Class: LessOrEqualOp
template <> struct describe_node_t<SgLessOrEqualOp> {
  using node = SgLessOrEqualOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"LessOrEqualOp"};
  static constexpr unsigned long variant{516};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<516> { using type = SgLessOrEqualOp; };

// Class: LessThanOp
template <> struct describe_node_t<SgLessThanOp> {
  using node = SgLessThanOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"LessThanOp"};
  static constexpr unsigned long variant{517};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<517> { using type = SgLessThanOp; };

// Class: LineDirectiveStatement
template <> struct describe_node_t<SgLineDirectiveStatement> {
  using node = SgLineDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"LineDirectiveStatement"};
  static constexpr unsigned long variant{518};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<518> { using type = SgLineDirectiveStatement; };

// Class: LinemarkerDirectiveStatement
template <> struct describe_field_t<SgLinemarkerDirectiveStatement,int,&SgLinemarkerDirectiveStatement::p_linenumber> {
  using parent = SgLinemarkerDirectiveStatement;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"linenumber"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLinemarkerDirectiveStatement::p_linenumber};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLinemarkerDirectiveStatement, int SgLinemarkerDirectiveStatement::*, &SgLinemarkerDirectiveStatement::p_linenumber>;
};
template <> struct describe_field_t<SgLinemarkerDirectiveStatement,std::string,&SgLinemarkerDirectiveStatement::p_filename> {
  using parent = SgLinemarkerDirectiveStatement;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"filename"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLinemarkerDirectiveStatement::p_filename};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLinemarkerDirectiveStatement, std::string SgLinemarkerDirectiveStatement::*, &SgLinemarkerDirectiveStatement::p_filename>;
};
template <> struct describe_field_t<SgLinemarkerDirectiveStatement,SgUnsignedCharList,&SgLinemarkerDirectiveStatement::p_flaglist> {
  using parent = SgLinemarkerDirectiveStatement;
  using field_type = SgUnsignedCharList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"flaglist"};
  static constexpr char const * const typestr{"SgUnsignedCharList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLinemarkerDirectiveStatement::p_flaglist};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLinemarkerDirectiveStatement, SgUnsignedCharList SgLinemarkerDirectiveStatement::*, &SgLinemarkerDirectiveStatement::p_flaglist>;
};
template <> struct describe_node_t<SgLinemarkerDirectiveStatement> {
  using node = SgLinemarkerDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"LinemarkerDirectiveStatement"};
  static constexpr unsigned long variant{519};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLinemarkerDirectiveStatement,int,&SgLinemarkerDirectiveStatement::p_linenumber>, describe_field_t<SgLinemarkerDirectiveStatement,std::string,&SgLinemarkerDirectiveStatement::p_filename>, describe_field_t<SgLinemarkerDirectiveStatement,SgUnsignedCharList,&SgLinemarkerDirectiveStatement::p_flaglist>>;
};
template <> struct node_from_variant_t<519> { using type = SgLinemarkerDirectiveStatement; };

// Class: LinkageModifier
template <> struct describe_field_t<SgLinkageModifier,SgLinkageModifier::linkage_modifier_enum,&SgLinkageModifier::p_modifier> {
  using parent = SgLinkageModifier;
  using field_type = SgLinkageModifier::linkage_modifier_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgLinkageModifier::linkage_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLinkageModifier::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLinkageModifier, SgLinkageModifier::linkage_modifier_enum SgLinkageModifier::*, &SgLinkageModifier::p_modifier>;
};
template <> struct describe_node_t<SgLinkageModifier> {
  using node = SgLinkageModifier;
  using base = SgModifier;
  static constexpr char const * const name{"LinkageModifier"};
  static constexpr unsigned long variant{520};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLinkageModifier,SgLinkageModifier::linkage_modifier_enum,&SgLinkageModifier::p_modifier>>;
};
template <> struct node_from_variant_t<520> { using type = SgLinkageModifier; };

// Class: ListComprehension
template <> struct describe_field_t<SgListComprehension,SgExpression*,&SgListComprehension::p_element> {
  using parent = SgListComprehension;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"element"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgListComprehension::p_element};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgListComprehension, SgExpression* SgListComprehension::*, &SgListComprehension::p_element>;
};
template <> struct describe_field_t<SgListComprehension,SgExprListExp*,&SgListComprehension::p_generators> {
  using parent = SgListComprehension;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"generators"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgListComprehension::p_generators};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgListComprehension, SgExprListExp* SgListComprehension::*, &SgListComprehension::p_generators>;
};
template <> struct describe_node_t<SgListComprehension> {
  using node = SgListComprehension;
  using base = SgExpression;
  static constexpr char const * const name{"ListComprehension"};
  static constexpr unsigned long variant{521};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgListComprehension,SgExpression*,&SgListComprehension::p_element>, describe_field_t<SgListComprehension,SgExprListExp*,&SgListComprehension::p_generators>>;
};
template <> struct node_from_variant_t<521> { using type = SgListComprehension; };

// Class: ListExp
template <> struct describe_node_t<SgListExp> {
  using node = SgListExp;
  using base = SgExprListExp;
  static constexpr char const * const name{"ListExp"};
  static constexpr unsigned long variant{522};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<522> { using type = SgListExp; };

// Class: LocatedNode
template <> struct describe_field_t<SgLocatedNode,Sg_File_Info*,&SgLocatedNode::p_startOfConstruct> {
  using parent = SgLocatedNode;
  using field_type = Sg_File_Info*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"startOfConstruct"};
  static constexpr char const * const typestr{"Sg_File_Info*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLocatedNode::p_startOfConstruct};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLocatedNode, Sg_File_Info* SgLocatedNode::*, &SgLocatedNode::p_startOfConstruct>;
};
template <> struct describe_field_t<SgLocatedNode,Sg_File_Info*,&SgLocatedNode::p_endOfConstruct> {
  using parent = SgLocatedNode;
  using field_type = Sg_File_Info*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"endOfConstruct"};
  static constexpr char const * const typestr{"Sg_File_Info*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLocatedNode::p_endOfConstruct};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLocatedNode, Sg_File_Info* SgLocatedNode::*, &SgLocatedNode::p_endOfConstruct>;
};
template <> struct describe_field_t<SgLocatedNode,AttachedPreprocessingInfoType*,&SgLocatedNode::p_attachedPreprocessingInfoPtr> {
  using parent = SgLocatedNode;
  using field_type = AttachedPreprocessingInfoType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"attachedPreprocessingInfoPtr"};
  static constexpr char const * const typestr{"AttachedPreprocessingInfoType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLocatedNode::p_attachedPreprocessingInfoPtr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLocatedNode, AttachedPreprocessingInfoType* SgLocatedNode::*, &SgLocatedNode::p_attachedPreprocessingInfoPtr>;
};
template <> struct describe_field_t<SgLocatedNode,AstAttributeMechanism*,&SgLocatedNode::p_attributeMechanism> {
  using parent = SgLocatedNode;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLocatedNode::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLocatedNode, AstAttributeMechanism* SgLocatedNode::*, &SgLocatedNode::p_attributeMechanism>;
};
template <> struct describe_field_t<SgLocatedNode,bool,&SgLocatedNode::p_containsTransformationToSurroundingWhitespace> {
  using parent = SgLocatedNode;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"containsTransformationToSurroundingWhitespace"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLocatedNode::p_containsTransformationToSurroundingWhitespace};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLocatedNode, bool SgLocatedNode::*, &SgLocatedNode::p_containsTransformationToSurroundingWhitespace>;
};
template <> struct describe_node_t<SgLocatedNode> {
  using node = SgLocatedNode;
  using base = SgNode;
  static constexpr char const * const name{"LocatedNode"};
  static constexpr unsigned long variant{523};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgToken, SgLocatedNodeSupport, SgStatement, SgExpression>;
  using fields_t = mp::List<describe_field_t<SgLocatedNode,Sg_File_Info*,&SgLocatedNode::p_startOfConstruct>, describe_field_t<SgLocatedNode,Sg_File_Info*,&SgLocatedNode::p_endOfConstruct>, describe_field_t<SgLocatedNode,AttachedPreprocessingInfoType*,&SgLocatedNode::p_attachedPreprocessingInfoPtr>, describe_field_t<SgLocatedNode,AstAttributeMechanism*,&SgLocatedNode::p_attributeMechanism>, describe_field_t<SgLocatedNode,bool,&SgLocatedNode::p_containsTransformationToSurroundingWhitespace>>;
};
template <> struct node_from_variant_t<523> { using type = SgLocatedNode; };

// Class: LocatedNodeSupport
template <> struct describe_node_t<SgLocatedNodeSupport> {
  using node = SgLocatedNodeSupport;
  using base = SgLocatedNode;
  static constexpr char const * const name{"LocatedNodeSupport"};
  static constexpr unsigned long variant{524};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgCommonBlockObject, SgInitializedName, SgInterfaceBody, SgHeaderFileBody, SgRenamePair, SgJavaMemberValuePair, SgOmpClause, SgLambdaCapture, SgLambdaCaptureList, SgAdaTypeConstraint>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<524> { using type = SgLocatedNodeSupport; };

// Class: LongDoubleVal
template <> struct describe_field_t<SgLongDoubleVal,long double,&SgLongDoubleVal::p_value> {
  using parent = SgLongDoubleVal;
  using field_type = long double;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"long double"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLongDoubleVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLongDoubleVal, long double SgLongDoubleVal::*, &SgLongDoubleVal::p_value>;
};
template <> struct describe_field_t<SgLongDoubleVal,std::string,&SgLongDoubleVal::p_valueString> {
  using parent = SgLongDoubleVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLongDoubleVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLongDoubleVal, std::string SgLongDoubleVal::*, &SgLongDoubleVal::p_valueString>;
};
template <> struct describe_node_t<SgLongDoubleVal> {
  using node = SgLongDoubleVal;
  using base = SgValueExp;
  static constexpr char const * const name{"LongDoubleVal"};
  static constexpr unsigned long variant{525};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLongDoubleVal,long double,&SgLongDoubleVal::p_value>, describe_field_t<SgLongDoubleVal,std::string,&SgLongDoubleVal::p_valueString>>;
};
template <> struct node_from_variant_t<525> { using type = SgLongDoubleVal; };

// Class: LongIntVal
template <> struct describe_field_t<SgLongIntVal,long int,&SgLongIntVal::p_value> {
  using parent = SgLongIntVal;
  using field_type = long int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"long int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLongIntVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLongIntVal, long int SgLongIntVal::*, &SgLongIntVal::p_value>;
};
template <> struct describe_field_t<SgLongIntVal,std::string,&SgLongIntVal::p_valueString> {
  using parent = SgLongIntVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLongIntVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLongIntVal, std::string SgLongIntVal::*, &SgLongIntVal::p_valueString>;
};
template <> struct describe_node_t<SgLongIntVal> {
  using node = SgLongIntVal;
  using base = SgValueExp;
  static constexpr char const * const name{"LongIntVal"};
  static constexpr unsigned long variant{526};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLongIntVal,long int,&SgLongIntVal::p_value>, describe_field_t<SgLongIntVal,std::string,&SgLongIntVal::p_valueString>>;
};
template <> struct node_from_variant_t<526> { using type = SgLongIntVal; };

// Class: LongLongIntVal
template <> struct describe_field_t<SgLongLongIntVal,long long int,&SgLongLongIntVal::p_value> {
  using parent = SgLongLongIntVal;
  using field_type = long long int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"long long int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLongLongIntVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLongLongIntVal, long long int SgLongLongIntVal::*, &SgLongLongIntVal::p_value>;
};
template <> struct describe_field_t<SgLongLongIntVal,std::string,&SgLongLongIntVal::p_valueString> {
  using parent = SgLongLongIntVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgLongLongIntVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLongLongIntVal, std::string SgLongLongIntVal::*, &SgLongLongIntVal::p_valueString>;
};
template <> struct describe_node_t<SgLongLongIntVal> {
  using node = SgLongLongIntVal;
  using base = SgValueExp;
  static constexpr char const * const name{"LongLongIntVal"};
  static constexpr unsigned long variant{527};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLongLongIntVal,long long int,&SgLongLongIntVal::p_value>, describe_field_t<SgLongLongIntVal,std::string,&SgLongLongIntVal::p_valueString>>;
};
template <> struct node_from_variant_t<527> { using type = SgLongLongIntVal; };

// Class: LshiftAssignOp
template <> struct describe_node_t<SgLshiftAssignOp> {
  using node = SgLshiftAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"LshiftAssignOp"};
  static constexpr unsigned long variant{528};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<528> { using type = SgLshiftAssignOp; };

// Class: LshiftOp
template <> struct describe_node_t<SgLshiftOp> {
  using node = SgLshiftOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"LshiftOp"};
  static constexpr unsigned long variant{529};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<529> { using type = SgLshiftOp; };

// Class: MagicColonExp
template <> struct describe_node_t<SgMagicColonExp> {
  using node = SgMagicColonExp;
  using base = SgExpression;
  static constexpr char const * const name{"MagicColonExp"};
  static constexpr unsigned long variant{530};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<530> { using type = SgMagicColonExp; };

// Class: MatrixExp
template <> struct describe_node_t<SgMatrixExp> {
  using node = SgMatrixExp;
  using base = SgExprListExp;
  static constexpr char const * const name{"MatrixExp"};
  static constexpr unsigned long variant{531};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<531> { using type = SgMatrixExp; };

// Class: MatrixTransposeOp
template <> struct describe_field_t<SgMatrixTransposeOp,bool,&SgMatrixTransposeOp::p_is_conjugate> {
  using parent = SgMatrixTransposeOp;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"is_conjugate"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMatrixTransposeOp::p_is_conjugate};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMatrixTransposeOp, bool SgMatrixTransposeOp::*, &SgMatrixTransposeOp::p_is_conjugate>;
};
template <> struct describe_node_t<SgMatrixTransposeOp> {
  using node = SgMatrixTransposeOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"MatrixTransposeOp"};
  static constexpr unsigned long variant{532};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgMatrixTransposeOp,bool,&SgMatrixTransposeOp::p_is_conjugate>>;
};
template <> struct node_from_variant_t<532> { using type = SgMatrixTransposeOp; };

// Class: MatlabForStatement
template <> struct describe_field_t<SgMatlabForStatement,SgExpression*,&SgMatlabForStatement::p_index> {
  using parent = SgMatlabForStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgMatlabForStatement::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMatlabForStatement, SgExpression* SgMatlabForStatement::*, &SgMatlabForStatement::p_index>;
};
template <> struct describe_field_t<SgMatlabForStatement,SgExpression*,&SgMatlabForStatement::p_range> {
  using parent = SgMatlabForStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"range"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgMatlabForStatement::p_range};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMatlabForStatement, SgExpression* SgMatlabForStatement::*, &SgMatlabForStatement::p_range>;
};
template <> struct describe_field_t<SgMatlabForStatement,SgBasicBlock*,&SgMatlabForStatement::p_body> {
  using parent = SgMatlabForStatement;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgMatlabForStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMatlabForStatement, SgBasicBlock* SgMatlabForStatement::*, &SgMatlabForStatement::p_body>;
};
template <> struct describe_node_t<SgMatlabForStatement> {
  using node = SgMatlabForStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"MatlabForStatement"};
  static constexpr unsigned long variant{533};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgMatlabForStatement,SgExpression*,&SgMatlabForStatement::p_index>, describe_field_t<SgMatlabForStatement,SgExpression*,&SgMatlabForStatement::p_range>, describe_field_t<SgMatlabForStatement,SgBasicBlock*,&SgMatlabForStatement::p_body>>;
};
template <> struct node_from_variant_t<533> { using type = SgMatlabForStatement; };

// Class: MemberFunctionDeclaration
template <> struct describe_field_t<SgMemberFunctionDeclaration,SgCtorInitializerList*,&SgMemberFunctionDeclaration::p_CtorInitializerList> {
  using parent = SgMemberFunctionDeclaration;
  using field_type = SgCtorInitializerList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"CtorInitializerList"};
  static constexpr char const * const typestr{"SgCtorInitializerList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgMemberFunctionDeclaration::p_CtorInitializerList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionDeclaration, SgCtorInitializerList* SgMemberFunctionDeclaration::*, &SgMemberFunctionDeclaration::p_CtorInitializerList>;
};
template <> struct describe_field_t<SgMemberFunctionDeclaration,SgDeclarationStatement*,&SgMemberFunctionDeclaration::p_associatedClassDeclaration> {
  using parent = SgMemberFunctionDeclaration;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"associatedClassDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionDeclaration::p_associatedClassDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionDeclaration, SgDeclarationStatement* SgMemberFunctionDeclaration::*, &SgMemberFunctionDeclaration::p_associatedClassDeclaration>;
};
template <> struct describe_node_t<SgMemberFunctionDeclaration> {
  using node = SgMemberFunctionDeclaration;
  using base = SgFunctionDeclaration;
  static constexpr char const * const name{"MemberFunctionDeclaration"};
  static constexpr unsigned long variant{534};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateMemberFunctionDeclaration, SgTemplateInstantiationMemberFunctionDecl>;
  using fields_t = mp::List<describe_field_t<SgMemberFunctionDeclaration,SgCtorInitializerList*,&SgMemberFunctionDeclaration::p_CtorInitializerList>, describe_field_t<SgMemberFunctionDeclaration,SgDeclarationStatement*,&SgMemberFunctionDeclaration::p_associatedClassDeclaration>>;
};
template <> struct node_from_variant_t<534> { using type = SgMemberFunctionDeclaration; };

// Class: MemberFunctionRefExp
template <> struct describe_field_t<SgMemberFunctionRefExp,SgMemberFunctionSymbol*,&SgMemberFunctionRefExp::p_symbol_i> {
  using parent = SgMemberFunctionRefExp;
  using field_type = SgMemberFunctionSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol_i"};
  static constexpr char const * const typestr{"SgMemberFunctionSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionRefExp::p_symbol_i};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionRefExp, SgMemberFunctionSymbol* SgMemberFunctionRefExp::*, &SgMemberFunctionRefExp::p_symbol_i>;
};
template <> struct describe_field_t<SgMemberFunctionRefExp,int,&SgMemberFunctionRefExp::p_virtual_call> {
  using parent = SgMemberFunctionRefExp;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"virtual_call"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionRefExp::p_virtual_call};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionRefExp, int SgMemberFunctionRefExp::*, &SgMemberFunctionRefExp::p_virtual_call>;
};
template <> struct describe_field_t<SgMemberFunctionRefExp,SgFunctionType*,&SgMemberFunctionRefExp::p_function_type> {
  using parent = SgMemberFunctionRefExp;
  using field_type = SgFunctionType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"function_type"};
  static constexpr char const * const typestr{"SgFunctionType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionRefExp::p_function_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionRefExp, SgFunctionType* SgMemberFunctionRefExp::*, &SgMemberFunctionRefExp::p_function_type>;
};
template <> struct describe_field_t<SgMemberFunctionRefExp,int,&SgMemberFunctionRefExp::p_need_qualifier> {
  using parent = SgMemberFunctionRefExp;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"need_qualifier"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionRefExp::p_need_qualifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionRefExp, int SgMemberFunctionRefExp::*, &SgMemberFunctionRefExp::p_need_qualifier>;
};
template <> struct describe_field_t<SgMemberFunctionRefExp,int,&SgMemberFunctionRefExp::p_name_qualification_length> {
  using parent = SgMemberFunctionRefExp;
  using field_type = int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionRefExp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionRefExp, int SgMemberFunctionRefExp::*, &SgMemberFunctionRefExp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgMemberFunctionRefExp,bool,&SgMemberFunctionRefExp::p_type_elaboration_required> {
  using parent = SgMemberFunctionRefExp;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionRefExp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionRefExp, bool SgMemberFunctionRefExp::*, &SgMemberFunctionRefExp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgMemberFunctionRefExp,bool,&SgMemberFunctionRefExp::p_global_qualification_required> {
  using parent = SgMemberFunctionRefExp;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionRefExp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionRefExp, bool SgMemberFunctionRefExp::*, &SgMemberFunctionRefExp::p_global_qualification_required>;
};
template <> struct describe_node_t<SgMemberFunctionRefExp> {
  using node = SgMemberFunctionRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"MemberFunctionRefExp"};
  static constexpr unsigned long variant{535};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgMemberFunctionRefExp,SgMemberFunctionSymbol*,&SgMemberFunctionRefExp::p_symbol_i>, describe_field_t<SgMemberFunctionRefExp,int,&SgMemberFunctionRefExp::p_virtual_call>, describe_field_t<SgMemberFunctionRefExp,SgFunctionType*,&SgMemberFunctionRefExp::p_function_type>, describe_field_t<SgMemberFunctionRefExp,int,&SgMemberFunctionRefExp::p_need_qualifier>, describe_field_t<SgMemberFunctionRefExp,int,&SgMemberFunctionRefExp::p_name_qualification_length>, describe_field_t<SgMemberFunctionRefExp,bool,&SgMemberFunctionRefExp::p_type_elaboration_required>, describe_field_t<SgMemberFunctionRefExp,bool,&SgMemberFunctionRefExp::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<535> { using type = SgMemberFunctionRefExp; };

// Class: MemberFunctionSymbol
template <> struct describe_node_t<SgMemberFunctionSymbol> {
  using node = SgMemberFunctionSymbol;
  using base = SgFunctionSymbol;
  static constexpr char const * const name{"MemberFunctionSymbol"};
  static constexpr unsigned long variant{536};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateMemberFunctionSymbol>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<536> { using type = SgMemberFunctionSymbol; };

// Class: MemberFunctionType
template <> struct describe_field_t<SgMemberFunctionType,SgType*,&SgMemberFunctionType::p_class_type> {
  using parent = SgMemberFunctionType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"class_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionType::p_class_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionType, SgType* SgMemberFunctionType::*, &SgMemberFunctionType::p_class_type>;
};
template <> struct describe_field_t<SgMemberFunctionType,unsigned int,&SgMemberFunctionType::p_mfunc_specifier> {
  using parent = SgMemberFunctionType;
  using field_type = unsigned int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"mfunc_specifier"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMemberFunctionType::p_mfunc_specifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMemberFunctionType, unsigned int SgMemberFunctionType::*, &SgMemberFunctionType::p_mfunc_specifier>;
};
template <> struct describe_node_t<SgMemberFunctionType> {
  using node = SgMemberFunctionType;
  using base = SgFunctionType;
  static constexpr char const * const name{"MemberFunctionType"};
  static constexpr unsigned long variant{537};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgPartialFunctionType>;
  using fields_t = mp::List<describe_field_t<SgMemberFunctionType,SgType*,&SgMemberFunctionType::p_class_type>, describe_field_t<SgMemberFunctionType,unsigned int,&SgMemberFunctionType::p_mfunc_specifier>>;
};
template <> struct node_from_variant_t<537> { using type = SgMemberFunctionType; };

// Class: MembershipOp
template <> struct describe_node_t<SgMembershipOp> {
  using node = SgMembershipOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"MembershipOp"};
  static constexpr unsigned long variant{538};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<538> { using type = SgMembershipOp; };

// Class: MicrosoftAttributeDeclaration
template <> struct describe_field_t<SgMicrosoftAttributeDeclaration,SgName,&SgMicrosoftAttributeDeclaration::p_attribute_string> {
  using parent = SgMicrosoftAttributeDeclaration;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"attribute_string"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgMicrosoftAttributeDeclaration::p_attribute_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgMicrosoftAttributeDeclaration, SgName SgMicrosoftAttributeDeclaration::*, &SgMicrosoftAttributeDeclaration::p_attribute_string>;
};
template <> struct describe_node_t<SgMicrosoftAttributeDeclaration> {
  using node = SgMicrosoftAttributeDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"MicrosoftAttributeDeclaration"};
  static constexpr unsigned long variant{539};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgMicrosoftAttributeDeclaration,SgName,&SgMicrosoftAttributeDeclaration::p_attribute_string>>;
};
template <> struct node_from_variant_t<539> { using type = SgMicrosoftAttributeDeclaration; };

// Class: MinusAssignOp
template <> struct describe_node_t<SgMinusAssignOp> {
  using node = SgMinusAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"MinusAssignOp"};
  static constexpr unsigned long variant{540};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<540> { using type = SgMinusAssignOp; };

// Class: MinusMinusOp
template <> struct describe_node_t<SgMinusMinusOp> {
  using node = SgMinusMinusOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"MinusMinusOp"};
  static constexpr unsigned long variant{541};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<541> { using type = SgMinusMinusOp; };

// Class: MinusOp
template <> struct describe_node_t<SgMinusOp> {
  using node = SgMinusOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"MinusOp"};
  static constexpr unsigned long variant{542};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<542> { using type = SgMinusOp; };

// Class: ModAssignOp
template <> struct describe_node_t<SgModAssignOp> {
  using node = SgModAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"ModAssignOp"};
  static constexpr unsigned long variant{543};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<543> { using type = SgModAssignOp; };

// Class: ModOp
template <> struct describe_node_t<SgModOp> {
  using node = SgModOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"ModOp"};
  static constexpr unsigned long variant{544};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<544> { using type = SgModOp; };

// Class: Modifier
template <> struct describe_node_t<SgModifier> {
  using node = SgModifier;
  using base = SgSupport;
  static constexpr char const * const name{"Modifier"};
  static constexpr unsigned long variant{545};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgModifierNodes, SgConstVolatileModifier, SgStorageModifier, SgAccessModifier, SgFunctionModifier, SgUPC_AccessModifier, SgSpecialFunctionModifier, SgElaboratedTypeModifier, SgLinkageModifier, SgBaseClassModifier, SgStructureModifier, SgTypeModifier, SgDeclarationModifier, SgOpenclAccessModeModifier>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<545> { using type = SgModifier; };

// Class: ModifierNodes
template <> struct describe_field_t<SgModifierNodes,SgModifierTypePtrVector,&SgModifierNodes::p_nodes> {
  using parent = SgModifierNodes;
  using field_type = SgModifierTypePtrVector;
  static constexpr size_t position{0};
  static constexpr char const * const name{"nodes"};
  static constexpr char const * const typestr{"SgModifierTypePtrVector"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgModifierNodes::p_nodes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgModifierNodes, SgModifierTypePtrVector SgModifierNodes::*, &SgModifierNodes::p_nodes>;
};
template <> struct describe_field_t<SgModifierNodes,SgModifierNodes*,&SgModifierNodes::p_next> {
  using parent = SgModifierNodes;
  using field_type = SgModifierNodes*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"next"};
  static constexpr char const * const typestr{"SgModifierNodes*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgModifierNodes::p_next};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgModifierNodes, SgModifierNodes* SgModifierNodes::*, &SgModifierNodes::p_next>;
};
template <> struct describe_node_t<SgModifierNodes> {
  using node = SgModifierNodes;
  using base = SgModifier;
  static constexpr char const * const name{"ModifierNodes"};
  static constexpr unsigned long variant{546};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgModifierNodes,SgModifierTypePtrVector,&SgModifierNodes::p_nodes>, describe_field_t<SgModifierNodes,SgModifierNodes*,&SgModifierNodes::p_next>>;
};
template <> struct node_from_variant_t<546> { using type = SgModifierNodes; };

// Class: ModifierType
template <> struct describe_field_t<SgModifierType,SgType*,&SgModifierType::p_base_type> {
  using parent = SgModifierType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgModifierType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgModifierType, SgType* SgModifierType::*, &SgModifierType::p_base_type>;
};
template <> struct describe_field_t<SgModifierType,SgTypeModifier,&SgModifierType::p_typeModifier> {
  using parent = SgModifierType;
  using field_type = SgTypeModifier;
  static constexpr size_t position{1};
  static constexpr char const * const name{"typeModifier"};
  static constexpr char const * const typestr{"SgTypeModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgModifierType::p_typeModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgModifierType, SgTypeModifier SgModifierType::*, &SgModifierType::p_typeModifier>;
};
template <> struct describe_field_t<SgModifierType,char*,&SgModifierType::p_frontend_type_reference> {
  using parent = SgModifierType;
  using field_type = char*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"frontend_type_reference"};
  static constexpr char const * const typestr{"char*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgModifierType::p_frontend_type_reference};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgModifierType, char* SgModifierType::*, &SgModifierType::p_frontend_type_reference>;
};
template <> struct describe_node_t<SgModifierType> {
  using node = SgModifierType;
  using base = SgType;
  static constexpr char const * const name{"ModifierType"};
  static constexpr unsigned long variant{547};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgModifierType,SgType*,&SgModifierType::p_base_type>, describe_field_t<SgModifierType,SgTypeModifier,&SgModifierType::p_typeModifier>, describe_field_t<SgModifierType,char*,&SgModifierType::p_frontend_type_reference>>;
};
template <> struct node_from_variant_t<547> { using type = SgModifierType; };

// Class: ModuleStatement
template <> struct describe_field_t<SgModuleStatement,SgLabelRefExp*,&SgModuleStatement::p_end_numeric_label> {
  using parent = SgModuleStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgModuleStatement::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgModuleStatement, SgLabelRefExp* SgModuleStatement::*, &SgModuleStatement::p_end_numeric_label>;
};
template <> struct describe_node_t<SgModuleStatement> {
  using node = SgModuleStatement;
  using base = SgClassDeclaration;
  static constexpr char const * const name{"ModuleStatement"};
  static constexpr unsigned long variant{548};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgModuleStatement,SgLabelRefExp*,&SgModuleStatement::p_end_numeric_label>>;
};
template <> struct node_from_variant_t<548> { using type = SgModuleStatement; };

// Class: ModuleSymbol
template <> struct describe_field_t<SgModuleSymbol,SgModuleStatement*,&SgModuleSymbol::p_declaration> {
  using parent = SgModuleSymbol;
  using field_type = SgModuleStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgModuleStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgModuleSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgModuleSymbol, SgModuleStatement* SgModuleSymbol::*, &SgModuleSymbol::p_declaration>;
};
template <> struct describe_node_t<SgModuleSymbol> {
  using node = SgModuleSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"ModuleSymbol"};
  static constexpr unsigned long variant{549};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgModuleSymbol,SgModuleStatement*,&SgModuleSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<549> { using type = SgModuleSymbol; };

// Class: MultAssignOp
template <> struct describe_node_t<SgMultAssignOp> {
  using node = SgMultAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"MultAssignOp"};
  static constexpr unsigned long variant{550};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<550> { using type = SgMultAssignOp; };

// Class: MultiplyOp
template <> struct describe_node_t<SgMultiplyOp> {
  using node = SgMultiplyOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"MultiplyOp"};
  static constexpr unsigned long variant{551};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<551> { using type = SgMultiplyOp; };

// Class: Name
template <> struct describe_field_t<SgName,std::string,&SgName::p_char> {
  using parent = SgName;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"char"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgName::p_char};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgName, std::string SgName::*, &SgName::p_char>;
};
template <> struct describe_node_t<SgName> {
  using node = SgName;
  using base = SgSupport;
  static constexpr char const * const name{"Name"};
  static constexpr unsigned long variant{552};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgName,std::string,&SgName::p_char>>;
};
template <> struct node_from_variant_t<552> { using type = SgName; };

// Class: NameGroup
template <> struct describe_field_t<SgNameGroup,std::string,&SgNameGroup::p_group_name> {
  using parent = SgNameGroup;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"group_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNameGroup::p_group_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNameGroup, std::string SgNameGroup::*, &SgNameGroup::p_group_name>;
};
template <> struct describe_field_t<SgNameGroup,SgStringList,&SgNameGroup::p_name_list> {
  using parent = SgNameGroup;
  using field_type = SgStringList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"name_list"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNameGroup::p_name_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNameGroup, SgStringList SgNameGroup::*, &SgNameGroup::p_name_list>;
};
template <> struct describe_node_t<SgNameGroup> {
  using node = SgNameGroup;
  using base = SgSupport;
  static constexpr char const * const name{"NameGroup"};
  static constexpr unsigned long variant{553};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNameGroup,std::string,&SgNameGroup::p_group_name>, describe_field_t<SgNameGroup,SgStringList,&SgNameGroup::p_name_list>>;
};
template <> struct node_from_variant_t<553> { using type = SgNameGroup; };

// Class: NamedType
template <> struct describe_field_t<SgNamedType,SgDeclarationStatement*,&SgNamedType::p_declaration> {
  using parent = SgNamedType;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNamedType::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamedType, SgDeclarationStatement* SgNamedType::*, &SgNamedType::p_declaration>;
};
template <> struct describe_field_t<SgNamedType,bool,&SgNamedType::p_autonomous_declaration> {
  using parent = SgNamedType;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"autonomous_declaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamedType::p_autonomous_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamedType, bool SgNamedType::*, &SgNamedType::p_autonomous_declaration>;
};
template <> struct describe_field_t<SgNamedType,bool,&SgNamedType::p_is_from_template_parameter> {
  using parent = SgNamedType;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"is_from_template_parameter"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamedType::p_is_from_template_parameter};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamedType, bool SgNamedType::*, &SgNamedType::p_is_from_template_parameter>;
};
template <> struct describe_node_t<SgNamedType> {
  using node = SgNamedType;
  using base = SgType;
  static constexpr char const * const name{"NamedType"};
  static constexpr unsigned long variant{554};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgClassType, SgEnumType, SgTypedefType, SgNonrealType, SgJavaParameterizedType, SgJavaQualifiedType, SgJavaWildcardType, SgAdaTaskType, SgAdaProtectedType, SgAdaFormalType, SgAdaDiscriminatedType, SgScopedType>;
  using fields_t = mp::List<describe_field_t<SgNamedType,SgDeclarationStatement*,&SgNamedType::p_declaration>, describe_field_t<SgNamedType,bool,&SgNamedType::p_autonomous_declaration>, describe_field_t<SgNamedType,bool,&SgNamedType::p_is_from_template_parameter>>;
};
template <> struct node_from_variant_t<554> { using type = SgNamedType; };

// Class: NamelistStatement
template <> struct describe_field_t<SgNamelistStatement,SgNameGroupPtrList,&SgNamelistStatement::p_group_list> {
  using parent = SgNamelistStatement;
  using field_type = SgNameGroupPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"group_list"};
  static constexpr char const * const typestr{"SgNameGroupPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamelistStatement::p_group_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamelistStatement, SgNameGroupPtrList SgNamelistStatement::*, &SgNamelistStatement::p_group_list>;
};
template <> struct describe_node_t<SgNamelistStatement> {
  using node = SgNamelistStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"NamelistStatement"};
  static constexpr unsigned long variant{555};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNamelistStatement,SgNameGroupPtrList,&SgNamelistStatement::p_group_list>>;
};
template <> struct node_from_variant_t<555> { using type = SgNamelistStatement; };

// Class: NamespaceAliasDeclarationStatement
template <> struct describe_field_t<SgNamespaceAliasDeclarationStatement,SgName,&SgNamespaceAliasDeclarationStatement::p_name> {
  using parent = SgNamespaceAliasDeclarationStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceAliasDeclarationStatement::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceAliasDeclarationStatement, SgName SgNamespaceAliasDeclarationStatement::*, &SgNamespaceAliasDeclarationStatement::p_name>;
};
template <> struct describe_field_t<SgNamespaceAliasDeclarationStatement,SgNamespaceDeclarationStatement*,&SgNamespaceAliasDeclarationStatement::p_namespaceDeclaration> {
  using parent = SgNamespaceAliasDeclarationStatement;
  using field_type = SgNamespaceDeclarationStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"namespaceDeclaration"};
  static constexpr char const * const typestr{"SgNamespaceDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceAliasDeclarationStatement::p_namespaceDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceAliasDeclarationStatement, SgNamespaceDeclarationStatement* SgNamespaceAliasDeclarationStatement::*, &SgNamespaceAliasDeclarationStatement::p_namespaceDeclaration>;
};
template <> struct describe_field_t<SgNamespaceAliasDeclarationStatement,int,&SgNamespaceAliasDeclarationStatement::p_name_qualification_length> {
  using parent = SgNamespaceAliasDeclarationStatement;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceAliasDeclarationStatement::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceAliasDeclarationStatement, int SgNamespaceAliasDeclarationStatement::*, &SgNamespaceAliasDeclarationStatement::p_name_qualification_length>;
};
template <> struct describe_field_t<SgNamespaceAliasDeclarationStatement,bool,&SgNamespaceAliasDeclarationStatement::p_type_elaboration_required> {
  using parent = SgNamespaceAliasDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceAliasDeclarationStatement::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceAliasDeclarationStatement, bool SgNamespaceAliasDeclarationStatement::*, &SgNamespaceAliasDeclarationStatement::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgNamespaceAliasDeclarationStatement,bool,&SgNamespaceAliasDeclarationStatement::p_global_qualification_required> {
  using parent = SgNamespaceAliasDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceAliasDeclarationStatement::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceAliasDeclarationStatement, bool SgNamespaceAliasDeclarationStatement::*, &SgNamespaceAliasDeclarationStatement::p_global_qualification_required>;
};
template <> struct describe_field_t<SgNamespaceAliasDeclarationStatement,bool,&SgNamespaceAliasDeclarationStatement::p_is_alias_for_another_namespace_alias> {
  using parent = SgNamespaceAliasDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"is_alias_for_another_namespace_alias"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceAliasDeclarationStatement::p_is_alias_for_another_namespace_alias};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceAliasDeclarationStatement, bool SgNamespaceAliasDeclarationStatement::*, &SgNamespaceAliasDeclarationStatement::p_is_alias_for_another_namespace_alias>;
};
template <> struct describe_field_t<SgNamespaceAliasDeclarationStatement,SgNamespaceAliasDeclarationStatement*,&SgNamespaceAliasDeclarationStatement::p_namespaceAliasDeclaration> {
  using parent = SgNamespaceAliasDeclarationStatement;
  using field_type = SgNamespaceAliasDeclarationStatement*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"namespaceAliasDeclaration"};
  static constexpr char const * const typestr{"SgNamespaceAliasDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceAliasDeclarationStatement::p_namespaceAliasDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceAliasDeclarationStatement, SgNamespaceAliasDeclarationStatement* SgNamespaceAliasDeclarationStatement::*, &SgNamespaceAliasDeclarationStatement::p_namespaceAliasDeclaration>;
};
template <> struct describe_node_t<SgNamespaceAliasDeclarationStatement> {
  using node = SgNamespaceAliasDeclarationStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"NamespaceAliasDeclarationStatement"};
  static constexpr unsigned long variant{556};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNamespaceAliasDeclarationStatement,SgName,&SgNamespaceAliasDeclarationStatement::p_name>, describe_field_t<SgNamespaceAliasDeclarationStatement,SgNamespaceDeclarationStatement*,&SgNamespaceAliasDeclarationStatement::p_namespaceDeclaration>, describe_field_t<SgNamespaceAliasDeclarationStatement,int,&SgNamespaceAliasDeclarationStatement::p_name_qualification_length>, describe_field_t<SgNamespaceAliasDeclarationStatement,bool,&SgNamespaceAliasDeclarationStatement::p_type_elaboration_required>, describe_field_t<SgNamespaceAliasDeclarationStatement,bool,&SgNamespaceAliasDeclarationStatement::p_global_qualification_required>, describe_field_t<SgNamespaceAliasDeclarationStatement,bool,&SgNamespaceAliasDeclarationStatement::p_is_alias_for_another_namespace_alias>, describe_field_t<SgNamespaceAliasDeclarationStatement,SgNamespaceAliasDeclarationStatement*,&SgNamespaceAliasDeclarationStatement::p_namespaceAliasDeclaration>>;
};
template <> struct node_from_variant_t<556> { using type = SgNamespaceAliasDeclarationStatement; };

// Class: NamespaceDeclarationStatement
template <> struct describe_field_t<SgNamespaceDeclarationStatement,SgName,&SgNamespaceDeclarationStatement::p_name> {
  using parent = SgNamespaceDeclarationStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceDeclarationStatement::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDeclarationStatement, SgName SgNamespaceDeclarationStatement::*, &SgNamespaceDeclarationStatement::p_name>;
};
template <> struct describe_field_t<SgNamespaceDeclarationStatement,SgNamespaceDefinitionStatement*,&SgNamespaceDeclarationStatement::p_definition> {
  using parent = SgNamespaceDeclarationStatement;
  using field_type = SgNamespaceDefinitionStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgNamespaceDefinitionStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNamespaceDeclarationStatement::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDeclarationStatement, SgNamespaceDefinitionStatement* SgNamespaceDeclarationStatement::*, &SgNamespaceDeclarationStatement::p_definition>;
};
template <> struct describe_field_t<SgNamespaceDeclarationStatement,bool,&SgNamespaceDeclarationStatement::p_isUnnamedNamespace> {
  using parent = SgNamespaceDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"isUnnamedNamespace"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceDeclarationStatement::p_isUnnamedNamespace};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDeclarationStatement, bool SgNamespaceDeclarationStatement::*, &SgNamespaceDeclarationStatement::p_isUnnamedNamespace>;
};
template <> struct describe_field_t<SgNamespaceDeclarationStatement,bool,&SgNamespaceDeclarationStatement::p_isInlinedNamespace> {
  using parent = SgNamespaceDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"isInlinedNamespace"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceDeclarationStatement::p_isInlinedNamespace};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDeclarationStatement, bool SgNamespaceDeclarationStatement::*, &SgNamespaceDeclarationStatement::p_isInlinedNamespace>;
};
template <> struct describe_node_t<SgNamespaceDeclarationStatement> {
  using node = SgNamespaceDeclarationStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"NamespaceDeclarationStatement"};
  static constexpr unsigned long variant{557};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNamespaceDeclarationStatement,SgName,&SgNamespaceDeclarationStatement::p_name>, describe_field_t<SgNamespaceDeclarationStatement,SgNamespaceDefinitionStatement*,&SgNamespaceDeclarationStatement::p_definition>, describe_field_t<SgNamespaceDeclarationStatement,bool,&SgNamespaceDeclarationStatement::p_isUnnamedNamespace>, describe_field_t<SgNamespaceDeclarationStatement,bool,&SgNamespaceDeclarationStatement::p_isInlinedNamespace>>;
};
template <> struct node_from_variant_t<557> { using type = SgNamespaceDeclarationStatement; };

// Class: NamespaceDefinitionStatement
template <> struct describe_field_t<SgNamespaceDefinitionStatement,SgDeclarationStatementPtrList,&SgNamespaceDefinitionStatement::p_declarations> {
  using parent = SgNamespaceDefinitionStatement;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declarations"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNamespaceDefinitionStatement::p_declarations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDefinitionStatement, SgDeclarationStatementPtrList SgNamespaceDefinitionStatement::*, &SgNamespaceDefinitionStatement::p_declarations>;
};
template <> struct describe_field_t<SgNamespaceDefinitionStatement,SgNamespaceDeclarationStatement*,&SgNamespaceDefinitionStatement::p_namespaceDeclaration> {
  using parent = SgNamespaceDefinitionStatement;
  using field_type = SgNamespaceDeclarationStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"namespaceDeclaration"};
  static constexpr char const * const typestr{"SgNamespaceDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceDefinitionStatement::p_namespaceDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDefinitionStatement, SgNamespaceDeclarationStatement* SgNamespaceDefinitionStatement::*, &SgNamespaceDefinitionStatement::p_namespaceDeclaration>;
};
template <> struct describe_field_t<SgNamespaceDefinitionStatement,SgNamespaceDefinitionStatement*,&SgNamespaceDefinitionStatement::p_previousNamespaceDefinition> {
  using parent = SgNamespaceDefinitionStatement;
  using field_type = SgNamespaceDefinitionStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"previousNamespaceDefinition"};
  static constexpr char const * const typestr{"SgNamespaceDefinitionStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceDefinitionStatement::p_previousNamespaceDefinition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDefinitionStatement, SgNamespaceDefinitionStatement* SgNamespaceDefinitionStatement::*, &SgNamespaceDefinitionStatement::p_previousNamespaceDefinition>;
};
template <> struct describe_field_t<SgNamespaceDefinitionStatement,SgNamespaceDefinitionStatement*,&SgNamespaceDefinitionStatement::p_nextNamespaceDefinition> {
  using parent = SgNamespaceDefinitionStatement;
  using field_type = SgNamespaceDefinitionStatement*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"nextNamespaceDefinition"};
  static constexpr char const * const typestr{"SgNamespaceDefinitionStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceDefinitionStatement::p_nextNamespaceDefinition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDefinitionStatement, SgNamespaceDefinitionStatement* SgNamespaceDefinitionStatement::*, &SgNamespaceDefinitionStatement::p_nextNamespaceDefinition>;
};
template <> struct describe_field_t<SgNamespaceDefinitionStatement,SgNamespaceDefinitionStatement*,&SgNamespaceDefinitionStatement::p_global_definition> {
  using parent = SgNamespaceDefinitionStatement;
  using field_type = SgNamespaceDefinitionStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"global_definition"};
  static constexpr char const * const typestr{"SgNamespaceDefinitionStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceDefinitionStatement::p_global_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDefinitionStatement, SgNamespaceDefinitionStatement* SgNamespaceDefinitionStatement::*, &SgNamespaceDefinitionStatement::p_global_definition>;
};
template <> struct describe_field_t<SgNamespaceDefinitionStatement,bool,&SgNamespaceDefinitionStatement::p_isUnionOfReentrantNamespaceDefinitions> {
  using parent = SgNamespaceDefinitionStatement;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"isUnionOfReentrantNamespaceDefinitions"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceDefinitionStatement::p_isUnionOfReentrantNamespaceDefinitions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceDefinitionStatement, bool SgNamespaceDefinitionStatement::*, &SgNamespaceDefinitionStatement::p_isUnionOfReentrantNamespaceDefinitions>;
};
template <> struct describe_node_t<SgNamespaceDefinitionStatement> {
  using node = SgNamespaceDefinitionStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"NamespaceDefinitionStatement"};
  static constexpr unsigned long variant{558};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNamespaceDefinitionStatement,SgDeclarationStatementPtrList,&SgNamespaceDefinitionStatement::p_declarations>, describe_field_t<SgNamespaceDefinitionStatement,SgNamespaceDeclarationStatement*,&SgNamespaceDefinitionStatement::p_namespaceDeclaration>, describe_field_t<SgNamespaceDefinitionStatement,SgNamespaceDefinitionStatement*,&SgNamespaceDefinitionStatement::p_previousNamespaceDefinition>, describe_field_t<SgNamespaceDefinitionStatement,SgNamespaceDefinitionStatement*,&SgNamespaceDefinitionStatement::p_nextNamespaceDefinition>, describe_field_t<SgNamespaceDefinitionStatement,SgNamespaceDefinitionStatement*,&SgNamespaceDefinitionStatement::p_global_definition>, describe_field_t<SgNamespaceDefinitionStatement,bool,&SgNamespaceDefinitionStatement::p_isUnionOfReentrantNamespaceDefinitions>>;
};
template <> struct node_from_variant_t<558> { using type = SgNamespaceDefinitionStatement; };

// Class: NamespaceSymbol
template <> struct describe_field_t<SgNamespaceSymbol,SgName,&SgNamespaceSymbol::p_name> {
  using parent = SgNamespaceSymbol;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceSymbol::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceSymbol, SgName SgNamespaceSymbol::*, &SgNamespaceSymbol::p_name>;
};
template <> struct describe_field_t<SgNamespaceSymbol,SgNamespaceDeclarationStatement*,&SgNamespaceSymbol::p_declaration> {
  using parent = SgNamespaceSymbol;
  using field_type = SgNamespaceDeclarationStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgNamespaceDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNamespaceSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceSymbol, SgNamespaceDeclarationStatement* SgNamespaceSymbol::*, &SgNamespaceSymbol::p_declaration>;
};
template <> struct describe_field_t<SgNamespaceSymbol,SgNamespaceAliasDeclarationStatement*,&SgNamespaceSymbol::p_aliasDeclaration> {
  using parent = SgNamespaceSymbol;
  using field_type = SgNamespaceAliasDeclarationStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"aliasDeclaration"};
  static constexpr char const * const typestr{"SgNamespaceAliasDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNamespaceSymbol::p_aliasDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceSymbol, SgNamespaceAliasDeclarationStatement* SgNamespaceSymbol::*, &SgNamespaceSymbol::p_aliasDeclaration>;
};
template <> struct describe_field_t<SgNamespaceSymbol,bool,&SgNamespaceSymbol::p_isAlias> {
  using parent = SgNamespaceSymbol;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"isAlias"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNamespaceSymbol::p_isAlias};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNamespaceSymbol, bool SgNamespaceSymbol::*, &SgNamespaceSymbol::p_isAlias>;
};
template <> struct describe_node_t<SgNamespaceSymbol> {
  using node = SgNamespaceSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"NamespaceSymbol"};
  static constexpr unsigned long variant{559};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNamespaceSymbol,SgName,&SgNamespaceSymbol::p_name>, describe_field_t<SgNamespaceSymbol,SgNamespaceDeclarationStatement*,&SgNamespaceSymbol::p_declaration>, describe_field_t<SgNamespaceSymbol,SgNamespaceAliasDeclarationStatement*,&SgNamespaceSymbol::p_aliasDeclaration>, describe_field_t<SgNamespaceSymbol,bool,&SgNamespaceSymbol::p_isAlias>>;
};
template <> struct node_from_variant_t<559> { using type = SgNamespaceSymbol; };

// Class: NaryOp
template <> struct describe_field_t<SgNaryOp,SgExpressionPtrList,&SgNaryOp::p_operands> {
  using parent = SgNaryOp;
  using field_type = SgExpressionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operands"};
  static constexpr char const * const typestr{"SgExpressionPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNaryOp::p_operands};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNaryOp, SgExpressionPtrList SgNaryOp::*, &SgNaryOp::p_operands>;
};
template <> struct describe_field_t<SgNaryOp,VariantTList,&SgNaryOp::p_operators> {
  using parent = SgNaryOp;
  using field_type = VariantTList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operators"};
  static constexpr char const * const typestr{"VariantTList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNaryOp::p_operators};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNaryOp, VariantTList SgNaryOp::*, &SgNaryOp::p_operators>;
};
template <> struct describe_node_t<SgNaryOp> {
  using node = SgNaryOp;
  using base = SgExpression;
  static constexpr char const * const name{"NaryOp"};
  static constexpr unsigned long variant{560};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgNaryBooleanOp, SgNaryComparisonOp>;
  using fields_t = mp::List<describe_field_t<SgNaryOp,SgExpressionPtrList,&SgNaryOp::p_operands>, describe_field_t<SgNaryOp,VariantTList,&SgNaryOp::p_operators>>;
};
template <> struct node_from_variant_t<560> { using type = SgNaryOp; };

// Class: NaryBooleanOp
template <> struct describe_node_t<SgNaryBooleanOp> {
  using node = SgNaryBooleanOp;
  using base = SgNaryOp;
  static constexpr char const * const name{"NaryBooleanOp"};
  static constexpr unsigned long variant{561};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<561> { using type = SgNaryBooleanOp; };

// Class: NaryComparisonOp
template <> struct describe_node_t<SgNaryComparisonOp> {
  using node = SgNaryComparisonOp;
  using base = SgNaryOp;
  static constexpr char const * const name{"NaryComparisonOp"};
  static constexpr unsigned long variant{562};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<562> { using type = SgNaryComparisonOp; };

// Class: NewExp
template <> struct describe_field_t<SgNewExp,SgType*,&SgNewExp::p_specified_type> {
  using parent = SgNewExp;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"specified_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNewExp::p_specified_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, SgType* SgNewExp::*, &SgNewExp::p_specified_type>;
};
template <> struct describe_field_t<SgNewExp,SgExprListExp*,&SgNewExp::p_placement_args> {
  using parent = SgNewExp;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"placement_args"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNewExp::p_placement_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, SgExprListExp* SgNewExp::*, &SgNewExp::p_placement_args>;
};
template <> struct describe_field_t<SgNewExp,SgConstructorInitializer*,&SgNewExp::p_constructor_args> {
  using parent = SgNewExp;
  using field_type = SgConstructorInitializer*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"constructor_args"};
  static constexpr char const * const typestr{"SgConstructorInitializer*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNewExp::p_constructor_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, SgConstructorInitializer* SgNewExp::*, &SgNewExp::p_constructor_args>;
};
template <> struct describe_field_t<SgNewExp,SgExpression*,&SgNewExp::p_builtin_args> {
  using parent = SgNewExp;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"builtin_args"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNewExp::p_builtin_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, SgExpression* SgNewExp::*, &SgNewExp::p_builtin_args>;
};
template <> struct describe_field_t<SgNewExp,short,&SgNewExp::p_need_global_specifier> {
  using parent = SgNewExp;
  using field_type = short;
  static constexpr size_t position{4};
  static constexpr char const * const name{"need_global_specifier"};
  static constexpr char const * const typestr{"short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNewExp::p_need_global_specifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, short SgNewExp::*, &SgNewExp::p_need_global_specifier>;
};
template <> struct describe_field_t<SgNewExp,SgFunctionDeclaration*,&SgNewExp::p_newOperatorDeclaration> {
  using parent = SgNewExp;
  using field_type = SgFunctionDeclaration*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"newOperatorDeclaration"};
  static constexpr char const * const typestr{"SgFunctionDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNewExp::p_newOperatorDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, SgFunctionDeclaration* SgNewExp::*, &SgNewExp::p_newOperatorDeclaration>;
};
template <> struct describe_field_t<SgNewExp,int,&SgNewExp::p_name_qualification_length> {
  using parent = SgNewExp;
  using field_type = int;
  static constexpr size_t position{6};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNewExp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, int SgNewExp::*, &SgNewExp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgNewExp,bool,&SgNewExp::p_type_elaboration_required> {
  using parent = SgNewExp;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNewExp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, bool SgNewExp::*, &SgNewExp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgNewExp,bool,&SgNewExp::p_global_qualification_required> {
  using parent = SgNewExp;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNewExp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, bool SgNewExp::*, &SgNewExp::p_global_qualification_required>;
};
template <> struct describe_field_t<SgNewExp,int,&SgNewExp::p_name_qualification_for_pointer_to_member_class_length> {
  using parent = SgNewExp;
  using field_type = int;
  static constexpr size_t position{9};
  static constexpr char const * const name{"name_qualification_for_pointer_to_member_class_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNewExp::p_name_qualification_for_pointer_to_member_class_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, int SgNewExp::*, &SgNewExp::p_name_qualification_for_pointer_to_member_class_length>;
};
template <> struct describe_field_t<SgNewExp,bool,&SgNewExp::p_type_elaboration_for_pointer_to_member_class_required> {
  using parent = SgNewExp;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"type_elaboration_for_pointer_to_member_class_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNewExp::p_type_elaboration_for_pointer_to_member_class_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, bool SgNewExp::*, &SgNewExp::p_type_elaboration_for_pointer_to_member_class_required>;
};
template <> struct describe_field_t<SgNewExp,bool,&SgNewExp::p_global_qualification_for_pointer_to_member_class_required> {
  using parent = SgNewExp;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"global_qualification_for_pointer_to_member_class_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNewExp::p_global_qualification_for_pointer_to_member_class_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNewExp, bool SgNewExp::*, &SgNewExp::p_global_qualification_for_pointer_to_member_class_required>;
};
template <> struct describe_node_t<SgNewExp> {
  using node = SgNewExp;
  using base = SgExpression;
  static constexpr char const * const name{"NewExp"};
  static constexpr unsigned long variant{563};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNewExp,SgType*,&SgNewExp::p_specified_type>, describe_field_t<SgNewExp,SgExprListExp*,&SgNewExp::p_placement_args>, describe_field_t<SgNewExp,SgConstructorInitializer*,&SgNewExp::p_constructor_args>, describe_field_t<SgNewExp,SgExpression*,&SgNewExp::p_builtin_args>, describe_field_t<SgNewExp,short,&SgNewExp::p_need_global_specifier>, describe_field_t<SgNewExp,SgFunctionDeclaration*,&SgNewExp::p_newOperatorDeclaration>, describe_field_t<SgNewExp,int,&SgNewExp::p_name_qualification_length>, describe_field_t<SgNewExp,bool,&SgNewExp::p_type_elaboration_required>, describe_field_t<SgNewExp,bool,&SgNewExp::p_global_qualification_required>, describe_field_t<SgNewExp,int,&SgNewExp::p_name_qualification_for_pointer_to_member_class_length>, describe_field_t<SgNewExp,bool,&SgNewExp::p_type_elaboration_for_pointer_to_member_class_required>, describe_field_t<SgNewExp,bool,&SgNewExp::p_global_qualification_for_pointer_to_member_class_required>>;
};
template <> struct node_from_variant_t<563> { using type = SgNewExp; };

// Class: Node
template <> struct describe_field_t<SgNode,SgNode*,&SgNode::p_parent> {
  using parent = SgNode;
  using field_type = SgNode*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"parent"};
  static constexpr char const * const typestr{"SgNode*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNode::p_parent};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNode, SgNode* SgNode::*, &SgNode::p_parent>;
};
template <> struct describe_field_t<SgNode,bool,&SgNode::p_isModified> {
  using parent = SgNode;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"isModified"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNode::p_isModified};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNode, bool SgNode::*, &SgNode::p_isModified>;
};
template <> struct describe_field_t<SgNode,bool,&SgNode::p_containsTransformation> {
  using parent = SgNode;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"containsTransformation"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNode::p_containsTransformation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNode, bool SgNode::*, &SgNode::p_containsTransformation>;
};
template <> struct describe_field_t<SgNode,SgNode*,&SgNode::p_freepointer> {
  using parent = SgNode;
  using field_type = SgNode*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"freepointer"};
  static constexpr char const * const typestr{"SgNode*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNode::p_freepointer};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNode, SgNode* SgNode::*, &SgNode::p_freepointer>;
};
template <> struct describe_node_t<SgNode> {
  using node = SgNode;
  using base = void;
  static constexpr char const * const name{"Node"};
  static constexpr unsigned long variant{564};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgSupport, SgType, SgLocatedNode, SgSymbol, SgAsmNode>;
  using fields_t = mp::List<describe_field_t<SgNode,SgNode*,&SgNode::p_parent>, describe_field_t<SgNode,bool,&SgNode::p_isModified>, describe_field_t<SgNode,bool,&SgNode::p_containsTransformation>, describe_field_t<SgNode,SgNode*,&SgNode::p_freepointer>>;
};
template <> struct node_from_variant_t<564> { using type = SgNode; };

// Class: NoexceptOp
template <> struct describe_field_t<SgNoexceptOp,SgExpression*,&SgNoexceptOp::p_operand_expr> {
  using parent = SgNoexceptOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_expr"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNoexceptOp::p_operand_expr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNoexceptOp, SgExpression* SgNoexceptOp::*, &SgNoexceptOp::p_operand_expr>;
};
template <> struct describe_node_t<SgNoexceptOp> {
  using node = SgNoexceptOp;
  using base = SgExpression;
  static constexpr char const * const name{"NoexceptOp"};
  static constexpr unsigned long variant{565};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNoexceptOp,SgExpression*,&SgNoexceptOp::p_operand_expr>>;
};
template <> struct node_from_variant_t<565> { using type = SgNoexceptOp; };

// Class: NotEqualOp
template <> struct describe_node_t<SgNotEqualOp> {
  using node = SgNotEqualOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"NotEqualOp"};
  static constexpr unsigned long variant{566};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<566> { using type = SgNotEqualOp; };

// Class: NotOp
template <> struct describe_node_t<SgNotOp> {
  using node = SgNotOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"NotOp"};
  static constexpr unsigned long variant{567};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<567> { using type = SgNotOp; };

// Class: NonMembershipOp
template <> struct describe_node_t<SgNonMembershipOp> {
  using node = SgNonMembershipOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"NonMembershipOp"};
  static constexpr unsigned long variant{568};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<568> { using type = SgNonMembershipOp; };

// Class: NonrealDecl
template <> struct describe_field_t<SgNonrealDecl,SgName,&SgNonrealDecl::p_name> {
  using parent = SgNonrealDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, SgName SgNonrealDecl::*, &SgNonrealDecl::p_name>;
};
template <> struct describe_field_t<SgNonrealDecl,SgDeclarationScope*,&SgNonrealDecl::p_nonreal_decl_scope> {
  using parent = SgNonrealDecl;
  using field_type = SgDeclarationScope*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"nonreal_decl_scope"};
  static constexpr char const * const typestr{"SgDeclarationScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_nonreal_decl_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, SgDeclarationScope* SgNonrealDecl::*, &SgNonrealDecl::p_nonreal_decl_scope>;
};
template <> struct describe_field_t<SgNonrealDecl,SgNonrealType*,&SgNonrealDecl::p_type> {
  using parent = SgNonrealDecl;
  using field_type = SgNonrealType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgNonrealType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, SgNonrealType* SgNonrealDecl::*, &SgNonrealDecl::p_type>;
};
template <> struct describe_field_t<SgNonrealDecl,int,&SgNonrealDecl::p_template_parameter_position> {
  using parent = SgNonrealDecl;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"template_parameter_position"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_template_parameter_position};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, int SgNonrealDecl::*, &SgNonrealDecl::p_template_parameter_position>;
};
template <> struct describe_field_t<SgNonrealDecl,int,&SgNonrealDecl::p_template_parameter_depth> {
  using parent = SgNonrealDecl;
  using field_type = int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"template_parameter_depth"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_template_parameter_depth};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, int SgNonrealDecl::*, &SgNonrealDecl::p_template_parameter_depth>;
};
template <> struct describe_field_t<SgNonrealDecl,SgDeclarationStatement*,&SgNonrealDecl::p_templateDeclaration> {
  using parent = SgNonrealDecl;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"templateDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_templateDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, SgDeclarationStatement* SgNonrealDecl::*, &SgNonrealDecl::p_templateDeclaration>;
};
template <> struct describe_field_t<SgNonrealDecl,SgTemplateArgumentPtrList,&SgNonrealDecl::p_tpl_args> {
  using parent = SgNonrealDecl;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{6};
  static constexpr char const * const name{"tpl_args"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_tpl_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, SgTemplateArgumentPtrList SgNonrealDecl::*, &SgNonrealDecl::p_tpl_args>;
};
template <> struct describe_field_t<SgNonrealDecl,SgTemplateParameterPtrList,&SgNonrealDecl::p_tpl_params> {
  using parent = SgNonrealDecl;
  using field_type = SgTemplateParameterPtrList;
  static constexpr size_t position{7};
  static constexpr char const * const name{"tpl_params"};
  static constexpr char const * const typestr{"SgTemplateParameterPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_tpl_params};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, SgTemplateParameterPtrList SgNonrealDecl::*, &SgNonrealDecl::p_tpl_params>;
};
template <> struct describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_class_member> {
  using parent = SgNonrealDecl;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"is_class_member"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_is_class_member};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, bool SgNonrealDecl::*, &SgNonrealDecl::p_is_class_member>;
};
template <> struct describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_template_param> {
  using parent = SgNonrealDecl;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"is_template_param"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_is_template_param};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, bool SgNonrealDecl::*, &SgNonrealDecl::p_is_template_param>;
};
template <> struct describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_template_template_param> {
  using parent = SgNonrealDecl;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"is_template_template_param"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_is_template_template_param};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, bool SgNonrealDecl::*, &SgNonrealDecl::p_is_template_template_param>;
};
template <> struct describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_nonreal_template> {
  using parent = SgNonrealDecl;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"is_nonreal_template"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_is_nonreal_template};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, bool SgNonrealDecl::*, &SgNonrealDecl::p_is_nonreal_template>;
};
template <> struct describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_nonreal_function> {
  using parent = SgNonrealDecl;
  using field_type = bool;
  static constexpr size_t position{12};
  static constexpr char const * const name{"is_nonreal_function"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealDecl::p_is_nonreal_function};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealDecl, bool SgNonrealDecl::*, &SgNonrealDecl::p_is_nonreal_function>;
};
template <> struct describe_node_t<SgNonrealDecl> {
  using node = SgNonrealDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"NonrealDecl"};
  static constexpr unsigned long variant{569};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNonrealDecl,SgName,&SgNonrealDecl::p_name>, describe_field_t<SgNonrealDecl,SgDeclarationScope*,&SgNonrealDecl::p_nonreal_decl_scope>, describe_field_t<SgNonrealDecl,SgNonrealType*,&SgNonrealDecl::p_type>, describe_field_t<SgNonrealDecl,int,&SgNonrealDecl::p_template_parameter_position>, describe_field_t<SgNonrealDecl,int,&SgNonrealDecl::p_template_parameter_depth>, describe_field_t<SgNonrealDecl,SgDeclarationStatement*,&SgNonrealDecl::p_templateDeclaration>, describe_field_t<SgNonrealDecl,SgTemplateArgumentPtrList,&SgNonrealDecl::p_tpl_args>, describe_field_t<SgNonrealDecl,SgTemplateParameterPtrList,&SgNonrealDecl::p_tpl_params>, describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_class_member>, describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_template_param>, describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_template_template_param>, describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_nonreal_template>, describe_field_t<SgNonrealDecl,bool,&SgNonrealDecl::p_is_nonreal_function>>;
};
template <> struct node_from_variant_t<569> { using type = SgNonrealDecl; };

// Class: NonrealRefExp
template <> struct describe_field_t<SgNonrealRefExp,SgNonrealSymbol*,&SgNonrealRefExp::p_symbol> {
  using parent = SgNonrealRefExp;
  using field_type = SgNonrealSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgNonrealSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealRefExp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealRefExp, SgNonrealSymbol* SgNonrealRefExp::*, &SgNonrealRefExp::p_symbol>;
};
template <> struct describe_field_t<SgNonrealRefExp,int,&SgNonrealRefExp::p_name_qualification_length> {
  using parent = SgNonrealRefExp;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealRefExp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealRefExp, int SgNonrealRefExp::*, &SgNonrealRefExp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgNonrealRefExp,bool,&SgNonrealRefExp::p_type_elaboration_required> {
  using parent = SgNonrealRefExp;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealRefExp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealRefExp, bool SgNonrealRefExp::*, &SgNonrealRefExp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgNonrealRefExp,bool,&SgNonrealRefExp::p_global_qualification_required> {
  using parent = SgNonrealRefExp;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgNonrealRefExp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealRefExp, bool SgNonrealRefExp::*, &SgNonrealRefExp::p_global_qualification_required>;
};
template <> struct describe_node_t<SgNonrealRefExp> {
  using node = SgNonrealRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"NonrealRefExp"};
  static constexpr unsigned long variant{570};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNonrealRefExp,SgNonrealSymbol*,&SgNonrealRefExp::p_symbol>, describe_field_t<SgNonrealRefExp,int,&SgNonrealRefExp::p_name_qualification_length>, describe_field_t<SgNonrealRefExp,bool,&SgNonrealRefExp::p_type_elaboration_required>, describe_field_t<SgNonrealRefExp,bool,&SgNonrealRefExp::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<570> { using type = SgNonrealRefExp; };

// Class: NonrealSymbol
template <> struct describe_field_t<SgNonrealSymbol,SgNonrealDecl*,&SgNonrealSymbol::p_declaration> {
  using parent = SgNonrealSymbol;
  using field_type = SgNonrealDecl*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgNonrealDecl*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNonrealSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealSymbol, SgNonrealDecl* SgNonrealSymbol::*, &SgNonrealSymbol::p_declaration>;
};
template <> struct describe_node_t<SgNonrealSymbol> {
  using node = SgNonrealSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"NonrealSymbol"};
  static constexpr unsigned long variant{571};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNonrealSymbol,SgNonrealDecl*,&SgNonrealSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<571> { using type = SgNonrealSymbol; };

// Class: NonrealType
template <> struct describe_node_t<SgNonrealType> {
  using node = SgNonrealType;
  using base = SgNamedType;
  static constexpr char const * const name{"NonrealType"};
  static constexpr unsigned long variant{572};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<572> { using type = SgNonrealType; };

// Class: NonrealBaseClass
template <> struct describe_field_t<SgNonrealBaseClass,SgNonrealDecl*,&SgNonrealBaseClass::p_base_class_nonreal> {
  using parent = SgNonrealBaseClass;
  using field_type = SgNonrealDecl*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_class_nonreal"};
  static constexpr char const * const typestr{"SgNonrealDecl*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNonrealBaseClass::p_base_class_nonreal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNonrealBaseClass, SgNonrealDecl* SgNonrealBaseClass::*, &SgNonrealBaseClass::p_base_class_nonreal>;
};
template <> struct describe_node_t<SgNonrealBaseClass> {
  using node = SgNonrealBaseClass;
  using base = SgBaseClass;
  static constexpr char const * const name{"NonrealBaseClass"};
  static constexpr unsigned long variant{573};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNonrealBaseClass,SgNonrealDecl*,&SgNonrealBaseClass::p_base_class_nonreal>>;
};
template <> struct node_from_variant_t<573> { using type = SgNonrealBaseClass; };

// Class: NullExpression
template <> struct describe_node_t<SgNullExpression> {
  using node = SgNullExpression;
  using base = SgExpression;
  static constexpr char const * const name{"NullExpression"};
  static constexpr unsigned long variant{574};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<574> { using type = SgNullExpression; };

// Class: NullptrValExp
template <> struct describe_node_t<SgNullptrValExp> {
  using node = SgNullptrValExp;
  using base = SgValueExp;
  static constexpr char const * const name{"NullptrValExp"};
  static constexpr unsigned long variant{575};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<575> { using type = SgNullptrValExp; };

// Class: NullStatement
template <> struct describe_node_t<SgNullStatement> {
  using node = SgNullStatement;
  using base = SgStatement;
  static constexpr char const * const name{"NullStatement"};
  static constexpr unsigned long variant{576};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<576> { using type = SgNullStatement; };

// Class: NullifyStatement
template <> struct describe_field_t<SgNullifyStatement,SgExprListExp*,&SgNullifyStatement::p_pointer_list> {
  using parent = SgNullifyStatement;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"pointer_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgNullifyStatement::p_pointer_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgNullifyStatement, SgExprListExp* SgNullifyStatement::*, &SgNullifyStatement::p_pointer_list>;
};
template <> struct describe_node_t<SgNullifyStatement> {
  using node = SgNullifyStatement;
  using base = SgStatement;
  static constexpr char const * const name{"NullifyStatement"};
  static constexpr unsigned long variant{577};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgNullifyStatement,SgExprListExp*,&SgNullifyStatement::p_pointer_list>>;
};
template <> struct node_from_variant_t<577> { using type = SgNullifyStatement; };

// Class: OmpAtomicStatement
template <> struct describe_node_t<SgOmpAtomicStatement> {
  using node = SgOmpAtomicStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpAtomicStatement"};
  static constexpr unsigned long variant{578};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<578> { using type = SgOmpAtomicStatement; };

// Class: OmpBarrierStatement
template <> struct describe_node_t<SgOmpBarrierStatement> {
  using node = SgOmpBarrierStatement;
  using base = SgStatement;
  static constexpr char const * const name{"OmpBarrierStatement"};
  static constexpr unsigned long variant{579};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<579> { using type = SgOmpBarrierStatement; };

// Class: OmpCriticalStatement
template <> struct describe_field_t<SgOmpCriticalStatement,SgName,&SgOmpCriticalStatement::p_name> {
  using parent = SgOmpCriticalStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpCriticalStatement::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpCriticalStatement, SgName SgOmpCriticalStatement::*, &SgOmpCriticalStatement::p_name>;
};
template <> struct describe_node_t<SgOmpCriticalStatement> {
  using node = SgOmpCriticalStatement;
  using base = SgOmpBodyStatement;
  static constexpr char const * const name{"OmpCriticalStatement"};
  static constexpr unsigned long variant{580};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpCriticalStatement,SgName,&SgOmpCriticalStatement::p_name>>;
};
template <> struct node_from_variant_t<580> { using type = SgOmpCriticalStatement; };

// Class: OmpClauseBodyStatement
template <> struct describe_field_t<SgOmpClauseBodyStatement,SgOmpClausePtrList,&SgOmpClauseBodyStatement::p_clauses> {
  using parent = SgOmpClauseBodyStatement;
  using field_type = SgOmpClausePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"clauses"};
  static constexpr char const * const typestr{"SgOmpClausePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpClauseBodyStatement::p_clauses};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpClauseBodyStatement, SgOmpClausePtrList SgOmpClauseBodyStatement::*, &SgOmpClauseBodyStatement::p_clauses>;
};
template <> struct describe_node_t<SgOmpClauseBodyStatement> {
  using node = SgOmpClauseBodyStatement;
  using base = SgOmpBodyStatement;
  static constexpr char const * const name{"OmpClauseBodyStatement"};
  static constexpr unsigned long variant{581};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgOmpParallelStatement, SgOmpSingleStatement, SgOmpAtomicStatement, SgOmpTaskStatement, SgOmpForStatement, SgOmpDoStatement, SgOmpSectionsStatement, SgOmpTargetStatement, SgOmpTargetDataStatement, SgOmpSimdStatement, SgOmpForSimdStatement>;
  using fields_t = mp::List<describe_field_t<SgOmpClauseBodyStatement,SgOmpClausePtrList,&SgOmpClauseBodyStatement::p_clauses>>;
};
template <> struct node_from_variant_t<581> { using type = SgOmpClauseBodyStatement; };

// Class: OmpBodyStatement
template <> struct describe_field_t<SgOmpBodyStatement,SgStatement*,&SgOmpBodyStatement::p_body> {
  using parent = SgOmpBodyStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpBodyStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpBodyStatement, SgStatement* SgOmpBodyStatement::*, &SgOmpBodyStatement::p_body>;
};
template <> struct describe_node_t<SgOmpBodyStatement> {
  using node = SgOmpBodyStatement;
  using base = SgStatement;
  static constexpr char const * const name{"OmpBodyStatement"};
  static constexpr unsigned long variant{582};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgOmpMasterStatement, SgOmpOrderedStatement, SgOmpCriticalStatement, SgOmpSectionStatement, SgOmpWorkshareStatement, SgOmpClauseBodyStatement>;
  using fields_t = mp::List<describe_field_t<SgOmpBodyStatement,SgStatement*,&SgOmpBodyStatement::p_body>>;
};
template <> struct node_from_variant_t<582> { using type = SgOmpBodyStatement; };

// Class: OmpDoStatement
template <> struct describe_node_t<SgOmpDoStatement> {
  using node = SgOmpDoStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpDoStatement"};
  static constexpr unsigned long variant{583};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<583> { using type = SgOmpDoStatement; };

// Class: OmpFlushStatement
template <> struct describe_field_t<SgOmpFlushStatement,SgVarRefExpPtrList,&SgOmpFlushStatement::p_variables> {
  using parent = SgOmpFlushStatement;
  using field_type = SgVarRefExpPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"variables"};
  static constexpr char const * const typestr{"SgVarRefExpPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpFlushStatement::p_variables};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpFlushStatement, SgVarRefExpPtrList SgOmpFlushStatement::*, &SgOmpFlushStatement::p_variables>;
};
template <> struct describe_node_t<SgOmpFlushStatement> {
  using node = SgOmpFlushStatement;
  using base = SgStatement;
  static constexpr char const * const name{"OmpFlushStatement"};
  static constexpr unsigned long variant{584};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpFlushStatement,SgVarRefExpPtrList,&SgOmpFlushStatement::p_variables>>;
};
template <> struct node_from_variant_t<584> { using type = SgOmpFlushStatement; };

// Class: OmpDeclareSimdStatement
template <> struct describe_field_t<SgOmpDeclareSimdStatement,SgOmpClausePtrList,&SgOmpDeclareSimdStatement::p_clauses> {
  using parent = SgOmpDeclareSimdStatement;
  using field_type = SgOmpClausePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"clauses"};
  static constexpr char const * const typestr{"SgOmpClausePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpDeclareSimdStatement::p_clauses};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpDeclareSimdStatement, SgOmpClausePtrList SgOmpDeclareSimdStatement::*, &SgOmpDeclareSimdStatement::p_clauses>;
};
template <> struct describe_node_t<SgOmpDeclareSimdStatement> {
  using node = SgOmpDeclareSimdStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"OmpDeclareSimdStatement"};
  static constexpr unsigned long variant{585};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpDeclareSimdStatement,SgOmpClausePtrList,&SgOmpDeclareSimdStatement::p_clauses>>;
};
template <> struct node_from_variant_t<585> { using type = SgOmpDeclareSimdStatement; };

// Class: OmpForStatement
template <> struct describe_node_t<SgOmpForStatement> {
  using node = SgOmpForStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpForStatement"};
  static constexpr unsigned long variant{586};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<586> { using type = SgOmpForStatement; };

// Class: OmpForSimdStatement
template <> struct describe_node_t<SgOmpForSimdStatement> {
  using node = SgOmpForSimdStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpForSimdStatement"};
  static constexpr unsigned long variant{587};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<587> { using type = SgOmpForSimdStatement; };

// Class: OmpMasterStatement
template <> struct describe_node_t<SgOmpMasterStatement> {
  using node = SgOmpMasterStatement;
  using base = SgOmpBodyStatement;
  static constexpr char const * const name{"OmpMasterStatement"};
  static constexpr unsigned long variant{588};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<588> { using type = SgOmpMasterStatement; };

// Class: OmpOrderedStatement
template <> struct describe_node_t<SgOmpOrderedStatement> {
  using node = SgOmpOrderedStatement;
  using base = SgOmpBodyStatement;
  static constexpr char const * const name{"OmpOrderedStatement"};
  static constexpr unsigned long variant{589};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<589> { using type = SgOmpOrderedStatement; };

// Class: OmpParallelStatement
template <> struct describe_node_t<SgOmpParallelStatement> {
  using node = SgOmpParallelStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpParallelStatement"};
  static constexpr unsigned long variant{590};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<590> { using type = SgOmpParallelStatement; };

// Class: OmpSectionStatement
template <> struct describe_node_t<SgOmpSectionStatement> {
  using node = SgOmpSectionStatement;
  using base = SgOmpBodyStatement;
  static constexpr char const * const name{"OmpSectionStatement"};
  static constexpr unsigned long variant{591};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<591> { using type = SgOmpSectionStatement; };

// Class: OmpSectionsStatement
template <> struct describe_node_t<SgOmpSectionsStatement> {
  using node = SgOmpSectionsStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpSectionsStatement"};
  static constexpr unsigned long variant{592};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<592> { using type = SgOmpSectionsStatement; };

// Class: OmpSingleStatement
template <> struct describe_node_t<SgOmpSingleStatement> {
  using node = SgOmpSingleStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpSingleStatement"};
  static constexpr unsigned long variant{593};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<593> { using type = SgOmpSingleStatement; };

// Class: OmpTaskStatement
template <> struct describe_node_t<SgOmpTaskStatement> {
  using node = SgOmpTaskStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpTaskStatement"};
  static constexpr unsigned long variant{594};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<594> { using type = SgOmpTaskStatement; };

// Class: OmpTaskwaitStatement
template <> struct describe_node_t<SgOmpTaskwaitStatement> {
  using node = SgOmpTaskwaitStatement;
  using base = SgStatement;
  static constexpr char const * const name{"OmpTaskwaitStatement"};
  static constexpr unsigned long variant{595};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<595> { using type = SgOmpTaskwaitStatement; };

// Class: OmpThreadprivateStatement
template <> struct describe_field_t<SgOmpThreadprivateStatement,SgVarRefExpPtrList,&SgOmpThreadprivateStatement::p_variables> {
  using parent = SgOmpThreadprivateStatement;
  using field_type = SgVarRefExpPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"variables"};
  static constexpr char const * const typestr{"SgVarRefExpPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpThreadprivateStatement::p_variables};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpThreadprivateStatement, SgVarRefExpPtrList SgOmpThreadprivateStatement::*, &SgOmpThreadprivateStatement::p_variables>;
};
template <> struct describe_node_t<SgOmpThreadprivateStatement> {
  using node = SgOmpThreadprivateStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"OmpThreadprivateStatement"};
  static constexpr unsigned long variant{596};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpThreadprivateStatement,SgVarRefExpPtrList,&SgOmpThreadprivateStatement::p_variables>>;
};
template <> struct node_from_variant_t<596> { using type = SgOmpThreadprivateStatement; };

// Class: OmpWorkshareStatement
template <> struct describe_node_t<SgOmpWorkshareStatement> {
  using node = SgOmpWorkshareStatement;
  using base = SgOmpBodyStatement;
  static constexpr char const * const name{"OmpWorkshareStatement"};
  static constexpr unsigned long variant{597};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<597> { using type = SgOmpWorkshareStatement; };

// Class: OmpTargetStatement
template <> struct describe_node_t<SgOmpTargetStatement> {
  using node = SgOmpTargetStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpTargetStatement"};
  static constexpr unsigned long variant{598};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<598> { using type = SgOmpTargetStatement; };

// Class: OmpTargetDataStatement
template <> struct describe_node_t<SgOmpTargetDataStatement> {
  using node = SgOmpTargetDataStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpTargetDataStatement"};
  static constexpr unsigned long variant{599};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<599> { using type = SgOmpTargetDataStatement; };

// Class: OmpSimdStatement
template <> struct describe_node_t<SgOmpSimdStatement> {
  using node = SgOmpSimdStatement;
  using base = SgOmpClauseBodyStatement;
  static constexpr char const * const name{"OmpSimdStatement"};
  static constexpr unsigned long variant{600};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<600> { using type = SgOmpSimdStatement; };

// Class: OmpClause
template <> struct describe_node_t<SgOmpClause> {
  using node = SgOmpClause;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"OmpClause"};
  static constexpr unsigned long variant{601};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgOmpNowaitClause, SgOmpBeginClause, SgOmpEndClause, SgOmpUntiedClause, SgOmpDefaultClause, SgOmpAtomicClause, SgOmpProcBindClause, SgOmpExpressionClause, SgOmpInbranchClause, SgOmpNotinbranchClause, SgOmpVariablesClause, SgOmpScheduleClause, SgOmpMergeableClause>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<601> { using type = SgOmpClause; };

// Class: OmpBeginClause
template <> struct describe_node_t<SgOmpBeginClause> {
  using node = SgOmpBeginClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpBeginClause"};
  static constexpr unsigned long variant{602};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<602> { using type = SgOmpBeginClause; };

// Class: OmpCollapseClause
template <> struct describe_node_t<SgOmpCollapseClause> {
  using node = SgOmpCollapseClause;
  using base = SgOmpExpressionClause;
  static constexpr char const * const name{"OmpCollapseClause"};
  static constexpr unsigned long variant{603};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<603> { using type = SgOmpCollapseClause; };

// Class: OmpCopyinClause
template <> struct describe_node_t<SgOmpCopyinClause> {
  using node = SgOmpCopyinClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpCopyinClause"};
  static constexpr unsigned long variant{604};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<604> { using type = SgOmpCopyinClause; };

// Class: OmpCopyprivateClause
template <> struct describe_node_t<SgOmpCopyprivateClause> {
  using node = SgOmpCopyprivateClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpCopyprivateClause"};
  static constexpr unsigned long variant{605};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<605> { using type = SgOmpCopyprivateClause; };

// Class: OmpDefaultClause
template <> struct describe_field_t<SgOmpDefaultClause,SgOmpClause::omp_default_option_enum,&SgOmpDefaultClause::p_data_sharing> {
  using parent = SgOmpDefaultClause;
  using field_type = SgOmpClause::omp_default_option_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"data_sharing"};
  static constexpr char const * const typestr{"SgOmpClause::omp_default_option_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpDefaultClause::p_data_sharing};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpDefaultClause, SgOmpClause::omp_default_option_enum SgOmpDefaultClause::*, &SgOmpDefaultClause::p_data_sharing>;
};
template <> struct describe_node_t<SgOmpDefaultClause> {
  using node = SgOmpDefaultClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpDefaultClause"};
  static constexpr unsigned long variant{606};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpDefaultClause,SgOmpClause::omp_default_option_enum,&SgOmpDefaultClause::p_data_sharing>>;
};
template <> struct node_from_variant_t<606> { using type = SgOmpDefaultClause; };

// Class: OmpEndClause
template <> struct describe_node_t<SgOmpEndClause> {
  using node = SgOmpEndClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpEndClause"};
  static constexpr unsigned long variant{607};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<607> { using type = SgOmpEndClause; };

// Class: OmpExpressionClause
template <> struct describe_field_t<SgOmpExpressionClause,SgExpression*,&SgOmpExpressionClause::p_expression> {
  using parent = SgOmpExpressionClause;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpExpressionClause::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpExpressionClause, SgExpression* SgOmpExpressionClause::*, &SgOmpExpressionClause::p_expression>;
};
template <> struct describe_node_t<SgOmpExpressionClause> {
  using node = SgOmpExpressionClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpExpressionClause"};
  static constexpr unsigned long variant{608};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgOmpOrderedClause, SgOmpCollapseClause, SgOmpIfClause, SgOmpNumThreadsClause, SgOmpDeviceClause, SgOmpSafelenClause, SgOmpSimdlenClause, SgOmpFinalClause, SgOmpPriorityClause>;
  using fields_t = mp::List<describe_field_t<SgOmpExpressionClause,SgExpression*,&SgOmpExpressionClause::p_expression>>;
};
template <> struct node_from_variant_t<608> { using type = SgOmpExpressionClause; };

// Class: OmpFirstprivateClause
template <> struct describe_node_t<SgOmpFirstprivateClause> {
  using node = SgOmpFirstprivateClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpFirstprivateClause"};
  static constexpr unsigned long variant{609};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<609> { using type = SgOmpFirstprivateClause; };

// Class: OmpIfClause
template <> struct describe_node_t<SgOmpIfClause> {
  using node = SgOmpIfClause;
  using base = SgOmpExpressionClause;
  static constexpr char const * const name{"OmpIfClause"};
  static constexpr unsigned long variant{610};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<610> { using type = SgOmpIfClause; };

// Class: OmpFinalClause
template <> struct describe_node_t<SgOmpFinalClause> {
  using node = SgOmpFinalClause;
  using base = SgOmpExpressionClause;
  static constexpr char const * const name{"OmpFinalClause"};
  static constexpr unsigned long variant{611};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<611> { using type = SgOmpFinalClause; };

// Class: OmpPriorityClause
template <> struct describe_node_t<SgOmpPriorityClause> {
  using node = SgOmpPriorityClause;
  using base = SgOmpExpressionClause;
  static constexpr char const * const name{"OmpPriorityClause"};
  static constexpr unsigned long variant{612};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<612> { using type = SgOmpPriorityClause; };

// Class: OmpDeviceClause
template <> struct describe_node_t<SgOmpDeviceClause> {
  using node = SgOmpDeviceClause;
  using base = SgOmpExpressionClause;
  static constexpr char const * const name{"OmpDeviceClause"};
  static constexpr unsigned long variant{613};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<613> { using type = SgOmpDeviceClause; };

// Class: OmpLastprivateClause
template <> struct describe_node_t<SgOmpLastprivateClause> {
  using node = SgOmpLastprivateClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpLastprivateClause"};
  static constexpr unsigned long variant{614};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<614> { using type = SgOmpLastprivateClause; };

// Class: OmpNowaitClause
template <> struct describe_node_t<SgOmpNowaitClause> {
  using node = SgOmpNowaitClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpNowaitClause"};
  static constexpr unsigned long variant{615};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<615> { using type = SgOmpNowaitClause; };

// Class: OmpNumThreadsClause
template <> struct describe_node_t<SgOmpNumThreadsClause> {
  using node = SgOmpNumThreadsClause;
  using base = SgOmpExpressionClause;
  static constexpr char const * const name{"OmpNumThreadsClause"};
  static constexpr unsigned long variant{616};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<616> { using type = SgOmpNumThreadsClause; };

// Class: OmpOrderedClause
template <> struct describe_node_t<SgOmpOrderedClause> {
  using node = SgOmpOrderedClause;
  using base = SgOmpExpressionClause;
  static constexpr char const * const name{"OmpOrderedClause"};
  static constexpr unsigned long variant{617};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<617> { using type = SgOmpOrderedClause; };

// Class: OmpPrivateClause
template <> struct describe_node_t<SgOmpPrivateClause> {
  using node = SgOmpPrivateClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpPrivateClause"};
  static constexpr unsigned long variant{618};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<618> { using type = SgOmpPrivateClause; };

// Class: OmpReductionClause
template <> struct describe_field_t<SgOmpReductionClause,SgOmpClause::omp_reduction_operator_enum,&SgOmpReductionClause::p_operation> {
  using parent = SgOmpReductionClause;
  using field_type = SgOmpClause::omp_reduction_operator_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operation"};
  static constexpr char const * const typestr{"SgOmpClause::omp_reduction_operator_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpReductionClause::p_operation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpReductionClause, SgOmpClause::omp_reduction_operator_enum SgOmpReductionClause::*, &SgOmpReductionClause::p_operation>;
};
template <> struct describe_node_t<SgOmpReductionClause> {
  using node = SgOmpReductionClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpReductionClause"};
  static constexpr unsigned long variant{619};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpReductionClause,SgOmpClause::omp_reduction_operator_enum,&SgOmpReductionClause::p_operation>>;
};
template <> struct node_from_variant_t<619> { using type = SgOmpReductionClause; };

// Class: OmpScheduleClause
template <> struct describe_field_t<SgOmpScheduleClause,SgOmpClause::omp_schedule_kind_enum,&SgOmpScheduleClause::p_kind> {
  using parent = SgOmpScheduleClause;
  using field_type = SgOmpClause::omp_schedule_kind_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"kind"};
  static constexpr char const * const typestr{"SgOmpClause::omp_schedule_kind_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpScheduleClause::p_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpScheduleClause, SgOmpClause::omp_schedule_kind_enum SgOmpScheduleClause::*, &SgOmpScheduleClause::p_kind>;
};
template <> struct describe_field_t<SgOmpScheduleClause,SgExpression*,&SgOmpScheduleClause::p_chunk_size> {
  using parent = SgOmpScheduleClause;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"chunk_size"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpScheduleClause::p_chunk_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpScheduleClause, SgExpression* SgOmpScheduleClause::*, &SgOmpScheduleClause::p_chunk_size>;
};
template <> struct describe_node_t<SgOmpScheduleClause> {
  using node = SgOmpScheduleClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpScheduleClause"};
  static constexpr unsigned long variant{620};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpScheduleClause,SgOmpClause::omp_schedule_kind_enum,&SgOmpScheduleClause::p_kind>, describe_field_t<SgOmpScheduleClause,SgExpression*,&SgOmpScheduleClause::p_chunk_size>>;
};
template <> struct node_from_variant_t<620> { using type = SgOmpScheduleClause; };

// Class: OmpSharedClause
template <> struct describe_node_t<SgOmpSharedClause> {
  using node = SgOmpSharedClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpSharedClause"};
  static constexpr unsigned long variant{621};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<621> { using type = SgOmpSharedClause; };

// Class: OmpUntiedClause
template <> struct describe_node_t<SgOmpUntiedClause> {
  using node = SgOmpUntiedClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpUntiedClause"};
  static constexpr unsigned long variant{622};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<622> { using type = SgOmpUntiedClause; };

// Class: OmpMergeableClause
template <> struct describe_node_t<SgOmpMergeableClause> {
  using node = SgOmpMergeableClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpMergeableClause"};
  static constexpr unsigned long variant{623};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<623> { using type = SgOmpMergeableClause; };

// Class: OmpVariablesClause
template <> struct describe_field_t<SgOmpVariablesClause,SgExprListExp*,&SgOmpVariablesClause::p_variables> {
  using parent = SgOmpVariablesClause;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"variables"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpVariablesClause::p_variables};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpVariablesClause, SgExprListExp* SgOmpVariablesClause::*, &SgOmpVariablesClause::p_variables>;
};
template <> struct describe_node_t<SgOmpVariablesClause> {
  using node = SgOmpVariablesClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpVariablesClause"};
  static constexpr unsigned long variant{624};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgOmpCopyprivateClause, SgOmpPrivateClause, SgOmpFirstprivateClause, SgOmpSharedClause, SgOmpCopyinClause, SgOmpLastprivateClause, SgOmpReductionClause, SgOmpMapClause, SgOmpUniformClause, SgOmpAlignedClause, SgOmpLinearClause, SgOmpDependClause>;
  using fields_t = mp::List<describe_field_t<SgOmpVariablesClause,SgExprListExp*,&SgOmpVariablesClause::p_variables>>;
};
template <> struct node_from_variant_t<624> { using type = SgOmpVariablesClause; };

// Class: OmpMapClause
template <> struct describe_field_t<SgOmpMapClause,SgOmpClause::omp_map_operator_enum,&SgOmpMapClause::p_operation> {
  using parent = SgOmpMapClause;
  using field_type = SgOmpClause::omp_map_operator_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operation"};
  static constexpr char const * const typestr{"SgOmpClause::omp_map_operator_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpMapClause::p_operation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpMapClause, SgOmpClause::omp_map_operator_enum SgOmpMapClause::*, &SgOmpMapClause::p_operation>;
};
template <> struct describe_field_t<SgOmpMapClause,std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >,&SgOmpMapClause::p_array_dimensions> {
  using parent = SgOmpMapClause;
  using field_type = std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >;
  static constexpr size_t position{1};
  static constexpr char const * const name{"array_dimensions"};
  static constexpr char const * const typestr{"std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpMapClause::p_array_dimensions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpMapClause, std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > SgOmpMapClause::*, &SgOmpMapClause::p_array_dimensions>;
};
template <> struct describe_field_t<SgOmpMapClause,std::map<SgSymbol*,  std::vector < std::pair <SgOmpClause::omp_map_dist_data_enum, SgExpression*> > >,&SgOmpMapClause::p_dist_data_policies> {
  using parent = SgOmpMapClause;
  using field_type = std::map<SgSymbol*,  std::vector < std::pair <SgOmpClause::omp_map_dist_data_enum, SgExpression*> > >;
  static constexpr size_t position{2};
  static constexpr char const * const name{"dist_data_policies"};
  static constexpr char const * const typestr{"std::map<SgSymbol*,  std::vector < std::pair <SgOmpClause::omp_map_dist_data_enum, SgExpression*> > >"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpMapClause::p_dist_data_policies};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpMapClause, std::map<SgSymbol*,  std::vector < std::pair <SgOmpClause::omp_map_dist_data_enum, SgExpression*> > > SgOmpMapClause::*, &SgOmpMapClause::p_dist_data_policies>;
};
template <> struct describe_node_t<SgOmpMapClause> {
  using node = SgOmpMapClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpMapClause"};
  static constexpr unsigned long variant{625};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpMapClause,SgOmpClause::omp_map_operator_enum,&SgOmpMapClause::p_operation>, describe_field_t<SgOmpMapClause,std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >,&SgOmpMapClause::p_array_dimensions>, describe_field_t<SgOmpMapClause,std::map<SgSymbol*,  std::vector < std::pair <SgOmpClause::omp_map_dist_data_enum, SgExpression*> > >,&SgOmpMapClause::p_dist_data_policies>>;
};
template <> struct node_from_variant_t<625> { using type = SgOmpMapClause; };

// Class: OmpSafelenClause
template <> struct describe_node_t<SgOmpSafelenClause> {
  using node = SgOmpSafelenClause;
  using base = SgOmpExpressionClause;
  static constexpr char const * const name{"OmpSafelenClause"};
  static constexpr unsigned long variant{626};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<626> { using type = SgOmpSafelenClause; };

// Class: OmpSimdlenClause
template <> struct describe_node_t<SgOmpSimdlenClause> {
  using node = SgOmpSimdlenClause;
  using base = SgOmpExpressionClause;
  static constexpr char const * const name{"OmpSimdlenClause"};
  static constexpr unsigned long variant{627};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<627> { using type = SgOmpSimdlenClause; };

// Class: OmpLinearClause
template <> struct describe_field_t<SgOmpLinearClause,SgExpression*,&SgOmpLinearClause::p_step> {
  using parent = SgOmpLinearClause;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"step"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpLinearClause::p_step};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpLinearClause, SgExpression* SgOmpLinearClause::*, &SgOmpLinearClause::p_step>;
};
template <> struct describe_node_t<SgOmpLinearClause> {
  using node = SgOmpLinearClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpLinearClause"};
  static constexpr unsigned long variant{628};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpLinearClause,SgExpression*,&SgOmpLinearClause::p_step>>;
};
template <> struct node_from_variant_t<628> { using type = SgOmpLinearClause; };

// Class: OmpUniformClause
template <> struct describe_node_t<SgOmpUniformClause> {
  using node = SgOmpUniformClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpUniformClause"};
  static constexpr unsigned long variant{629};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<629> { using type = SgOmpUniformClause; };

// Class: OmpAlignedClause
template <> struct describe_field_t<SgOmpAlignedClause,SgExpression*,&SgOmpAlignedClause::p_alignment> {
  using parent = SgOmpAlignedClause;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"alignment"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOmpAlignedClause::p_alignment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpAlignedClause, SgExpression* SgOmpAlignedClause::*, &SgOmpAlignedClause::p_alignment>;
};
template <> struct describe_node_t<SgOmpAlignedClause> {
  using node = SgOmpAlignedClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpAlignedClause"};
  static constexpr unsigned long variant{630};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpAlignedClause,SgExpression*,&SgOmpAlignedClause::p_alignment>>;
};
template <> struct node_from_variant_t<630> { using type = SgOmpAlignedClause; };

// Class: OmpProcBindClause
template <> struct describe_field_t<SgOmpProcBindClause,SgOmpClause::omp_proc_bind_policy_enum,&SgOmpProcBindClause::p_policy> {
  using parent = SgOmpProcBindClause;
  using field_type = SgOmpClause::omp_proc_bind_policy_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"policy"};
  static constexpr char const * const typestr{"SgOmpClause::omp_proc_bind_policy_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpProcBindClause::p_policy};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpProcBindClause, SgOmpClause::omp_proc_bind_policy_enum SgOmpProcBindClause::*, &SgOmpProcBindClause::p_policy>;
};
template <> struct describe_node_t<SgOmpProcBindClause> {
  using node = SgOmpProcBindClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpProcBindClause"};
  static constexpr unsigned long variant{631};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpProcBindClause,SgOmpClause::omp_proc_bind_policy_enum,&SgOmpProcBindClause::p_policy>>;
};
template <> struct node_from_variant_t<631> { using type = SgOmpProcBindClause; };

// Class: OmpAtomicClause
template <> struct describe_field_t<SgOmpAtomicClause,SgOmpClause::omp_atomic_clause_enum,&SgOmpAtomicClause::p_atomicity> {
  using parent = SgOmpAtomicClause;
  using field_type = SgOmpClause::omp_atomic_clause_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"atomicity"};
  static constexpr char const * const typestr{"SgOmpClause::omp_atomic_clause_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpAtomicClause::p_atomicity};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpAtomicClause, SgOmpClause::omp_atomic_clause_enum SgOmpAtomicClause::*, &SgOmpAtomicClause::p_atomicity>;
};
template <> struct describe_node_t<SgOmpAtomicClause> {
  using node = SgOmpAtomicClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpAtomicClause"};
  static constexpr unsigned long variant{632};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpAtomicClause,SgOmpClause::omp_atomic_clause_enum,&SgOmpAtomicClause::p_atomicity>>;
};
template <> struct node_from_variant_t<632> { using type = SgOmpAtomicClause; };

// Class: OmpInbranchClause
template <> struct describe_node_t<SgOmpInbranchClause> {
  using node = SgOmpInbranchClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpInbranchClause"};
  static constexpr unsigned long variant{633};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<633> { using type = SgOmpInbranchClause; };

// Class: OmpNotinbranchClause
template <> struct describe_node_t<SgOmpNotinbranchClause> {
  using node = SgOmpNotinbranchClause;
  using base = SgOmpClause;
  static constexpr char const * const name{"OmpNotinbranchClause"};
  static constexpr unsigned long variant{634};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<634> { using type = SgOmpNotinbranchClause; };

// Class: OmpDependClause
template <> struct describe_field_t<SgOmpDependClause,SgOmpClause::omp_dependence_type_enum,&SgOmpDependClause::p_dependence_type> {
  using parent = SgOmpDependClause;
  using field_type = SgOmpClause::omp_dependence_type_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"dependence_type"};
  static constexpr char const * const typestr{"SgOmpClause::omp_dependence_type_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpDependClause::p_dependence_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpDependClause, SgOmpClause::omp_dependence_type_enum SgOmpDependClause::*, &SgOmpDependClause::p_dependence_type>;
};
template <> struct describe_field_t<SgOmpDependClause,std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >,&SgOmpDependClause::p_array_dimensions> {
  using parent = SgOmpDependClause;
  using field_type = std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >;
  static constexpr size_t position{1};
  static constexpr char const * const name{"array_dimensions"};
  static constexpr char const * const typestr{"std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOmpDependClause::p_array_dimensions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOmpDependClause, std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > SgOmpDependClause::*, &SgOmpDependClause::p_array_dimensions>;
};
template <> struct describe_node_t<SgOmpDependClause> {
  using node = SgOmpDependClause;
  using base = SgOmpVariablesClause;
  static constexpr char const * const name{"OmpDependClause"};
  static constexpr unsigned long variant{635};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOmpDependClause,SgOmpClause::omp_dependence_type_enum,&SgOmpDependClause::p_dependence_type>, describe_field_t<SgOmpDependClause,std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >,&SgOmpDependClause::p_array_dimensions>>;
};
template <> struct node_from_variant_t<635> { using type = SgOmpDependClause; };

// Class: OpenclAccessModeModifier
template <> struct describe_field_t<SgOpenclAccessModeModifier,SgOpenclAccessModeModifier::access_mode_modifier_enum,&SgOpenclAccessModeModifier::p_modifier> {
  using parent = SgOpenclAccessModeModifier;
  using field_type = SgOpenclAccessModeModifier::access_mode_modifier_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgOpenclAccessModeModifier::access_mode_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOpenclAccessModeModifier::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenclAccessModeModifier, SgOpenclAccessModeModifier::access_mode_modifier_enum SgOpenclAccessModeModifier::*, &SgOpenclAccessModeModifier::p_modifier>;
};
template <> struct describe_node_t<SgOpenclAccessModeModifier> {
  using node = SgOpenclAccessModeModifier;
  using base = SgModifier;
  static constexpr char const * const name{"OpenclAccessModeModifier"};
  static constexpr unsigned long variant{636};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOpenclAccessModeModifier,SgOpenclAccessModeModifier::access_mode_modifier_enum,&SgOpenclAccessModeModifier::p_modifier>>;
};
template <> struct node_from_variant_t<636> { using type = SgOpenclAccessModeModifier; };

// Class: OpenStatement
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_file> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"file"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_file>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_status> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"status"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_status};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_status>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_access> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"access"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_access};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_access>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_form> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"form"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_form};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_form>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_recl> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"recl"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_recl};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_recl>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_blank> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"blank"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_blank};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_blank>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_position> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"position"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_position};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_position>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_action> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"action"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_action};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_action>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_delim> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"delim"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_delim};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_delim>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_pad> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"pad"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_pad};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_pad>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_round> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{10};
  static constexpr char const * const name{"round"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_round};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_round>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_sign> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"sign"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_sign};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_sign>;
};
template <> struct describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_asynchronous> {
  using parent = SgOpenStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{12};
  static constexpr char const * const name{"asynchronous"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgOpenStatement::p_asynchronous};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOpenStatement, SgExpression* SgOpenStatement::*, &SgOpenStatement::p_asynchronous>;
};
template <> struct describe_node_t<SgOpenStatement> {
  using node = SgOpenStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"OpenStatement"};
  static constexpr unsigned long variant{637};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_file>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_status>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_access>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_form>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_recl>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_blank>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_position>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_action>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_delim>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_pad>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_round>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_sign>, describe_field_t<SgOpenStatement,SgExpression*,&SgOpenStatement::p_asynchronous>>;
};
template <> struct node_from_variant_t<637> { using type = SgOpenStatement; };

// Class: Options
template <> struct describe_field_t<SgOptions,std::ostream*,&SgOptions::p_default_output> {
  using parent = SgOptions;
  using field_type = std::ostream*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"default_output"};
  static constexpr char const * const typestr{"std::ostream*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOptions::p_default_output};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOptions, std::ostream* SgOptions::*, &SgOptions::p_default_output>;
};
template <> struct describe_field_t<SgOptions,std::ostream*,&SgOptions::p_debug_output> {
  using parent = SgOptions;
  using field_type = std::ostream*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"debug_output"};
  static constexpr char const * const typestr{"std::ostream*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOptions::p_debug_output};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOptions, std::ostream* SgOptions::*, &SgOptions::p_debug_output>;
};
template <> struct describe_field_t<SgOptions,std::ostream*,&SgOptions::p_error_output> {
  using parent = SgOptions;
  using field_type = std::ostream*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"error_output"};
  static constexpr char const * const typestr{"std::ostream*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOptions::p_error_output};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOptions, std::ostream* SgOptions::*, &SgOptions::p_error_output>;
};
template <> struct describe_field_t<SgOptions,std::ostream*,&SgOptions::p_logging_output> {
  using parent = SgOptions;
  using field_type = std::ostream*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"logging_output"};
  static constexpr char const * const typestr{"std::ostream*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOptions::p_logging_output};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOptions, std::ostream* SgOptions::*, &SgOptions::p_logging_output>;
};
template <> struct describe_field_t<SgOptions,int,&SgOptions::p_debug_level> {
  using parent = SgOptions;
  using field_type = int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"debug_level"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOptions::p_debug_level};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOptions, int SgOptions::*, &SgOptions::p_debug_level>;
};
template <> struct describe_field_t<SgOptions,int,&SgOptions::p_logging_level> {
  using parent = SgOptions;
  using field_type = int;
  static constexpr size_t position{5};
  static constexpr char const * const name{"logging_level"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgOptions::p_logging_level};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgOptions, int SgOptions::*, &SgOptions::p_logging_level>;
};
template <> struct describe_node_t<SgOptions> {
  using node = SgOptions;
  using base = SgSupport;
  static constexpr char const * const name{"Options"};
  static constexpr unsigned long variant{638};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgOptions,std::ostream*,&SgOptions::p_default_output>, describe_field_t<SgOptions,std::ostream*,&SgOptions::p_debug_output>, describe_field_t<SgOptions,std::ostream*,&SgOptions::p_error_output>, describe_field_t<SgOptions,std::ostream*,&SgOptions::p_logging_output>, describe_field_t<SgOptions,int,&SgOptions::p_debug_level>, describe_field_t<SgOptions,int,&SgOptions::p_logging_level>>;
};
template <> struct node_from_variant_t<638> { using type = SgOptions; };

// Class: OrOp
template <> struct describe_node_t<SgOrOp> {
  using node = SgOrOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"OrOp"};
  static constexpr unsigned long variant{639};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<639> { using type = SgOrOp; };

// Class: ParameterStatement
template <> struct describe_node_t<SgParameterStatement> {
  using node = SgParameterStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"ParameterStatement"};
  static constexpr unsigned long variant{640};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<640> { using type = SgParameterStatement; };

// Class: PartialFunctionModifierType
template <> struct describe_node_t<SgPartialFunctionModifierType> {
  using node = SgPartialFunctionModifierType;
  using base = SgPartialFunctionType;
  static constexpr char const * const name{"PartialFunctionModifierType"};
  static constexpr unsigned long variant{641};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<641> { using type = SgPartialFunctionModifierType; };

// Class: PartialFunctionType
template <> struct describe_node_t<SgPartialFunctionType> {
  using node = SgPartialFunctionType;
  using base = SgMemberFunctionType;
  static constexpr char const * const name{"PartialFunctionType"};
  static constexpr unsigned long variant{642};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgPartialFunctionModifierType>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<642> { using type = SgPartialFunctionType; };

// Class: PassStatement
template <> struct describe_node_t<SgPassStatement> {
  using node = SgPassStatement;
  using base = SgStatement;
  static constexpr char const * const name{"PassStatement"};
  static constexpr unsigned long variant{643};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<643> { using type = SgPassStatement; };

// Class: PlusAssignOp
template <> struct describe_node_t<SgPlusAssignOp> {
  using node = SgPlusAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"PlusAssignOp"};
  static constexpr unsigned long variant{644};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<644> { using type = SgPlusAssignOp; };

// Class: PlusPlusOp
template <> struct describe_node_t<SgPlusPlusOp> {
  using node = SgPlusPlusOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"PlusPlusOp"};
  static constexpr unsigned long variant{645};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<645> { using type = SgPlusPlusOp; };

// Class: PntrArrRefExp
template <> struct describe_node_t<SgPntrArrRefExp> {
  using node = SgPntrArrRefExp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"PntrArrRefExp"};
  static constexpr unsigned long variant{646};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<646> { using type = SgPntrArrRefExp; };

// Class: PointerAssignOp
template <> struct describe_node_t<SgPointerAssignOp> {
  using node = SgPointerAssignOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"PointerAssignOp"};
  static constexpr unsigned long variant{647};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<647> { using type = SgPointerAssignOp; };

// Class: PointerDerefExp
template <> struct describe_node_t<SgPointerDerefExp> {
  using node = SgPointerDerefExp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"PointerDerefExp"};
  static constexpr unsigned long variant{648};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<648> { using type = SgPointerDerefExp; };

// Class: PointerMemberType
template <> struct describe_field_t<SgPointerMemberType,SgType*,&SgPointerMemberType::p_class_type> {
  using parent = SgPointerMemberType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"class_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPointerMemberType::p_class_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPointerMemberType, SgType* SgPointerMemberType::*, &SgPointerMemberType::p_class_type>;
};
template <> struct describe_node_t<SgPointerMemberType> {
  using node = SgPointerMemberType;
  using base = SgPointerType;
  static constexpr char const * const name{"PointerMemberType"};
  static constexpr unsigned long variant{649};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgPointerMemberType,SgType*,&SgPointerMemberType::p_class_type>>;
};
template <> struct node_from_variant_t<649> { using type = SgPointerMemberType; };

// Class: PointerType
template <> struct describe_field_t<SgPointerType,SgType*,&SgPointerType::p_base_type> {
  using parent = SgPointerType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgPointerType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPointerType, SgType* SgPointerType::*, &SgPointerType::p_base_type>;
};
template <> struct describe_node_t<SgPointerType> {
  using node = SgPointerType;
  using base = SgType;
  static constexpr char const * const name{"PointerType"};
  static constexpr unsigned long variant{650};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgPointerMemberType>;
  using fields_t = mp::List<describe_field_t<SgPointerType,SgType*,&SgPointerType::p_base_type>>;
};
template <> struct node_from_variant_t<650> { using type = SgPointerType; };

// Class: PowerOp
template <> struct describe_node_t<SgPowerOp> {
  using node = SgPowerOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"PowerOp"};
  static constexpr unsigned long variant{651};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<651> { using type = SgPowerOp; };

// Class: Pragma
template <> struct describe_field_t<SgPragma,Sg_File_Info*,&SgPragma::p_startOfConstruct> {
  using parent = SgPragma;
  using field_type = Sg_File_Info*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"startOfConstruct"};
  static constexpr char const * const typestr{"Sg_File_Info*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPragma::p_startOfConstruct};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPragma, Sg_File_Info* SgPragma::*, &SgPragma::p_startOfConstruct>;
};
template <> struct describe_field_t<SgPragma,Sg_File_Info*,&SgPragma::p_endOfConstruct> {
  using parent = SgPragma;
  using field_type = Sg_File_Info*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"endOfConstruct"};
  static constexpr char const * const typestr{"Sg_File_Info*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPragma::p_endOfConstruct};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPragma, Sg_File_Info* SgPragma::*, &SgPragma::p_endOfConstruct>;
};
template <> struct describe_field_t<SgPragma,short,&SgPragma::p_printed> {
  using parent = SgPragma;
  using field_type = short;
  static constexpr size_t position{2};
  static constexpr char const * const name{"printed"};
  static constexpr char const * const typestr{"short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPragma::p_printed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPragma, short SgPragma::*, &SgPragma::p_printed>;
};
template <> struct describe_field_t<SgPragma,SgExprListExp*,&SgPragma::p_args> {
  using parent = SgPragma;
  using field_type = SgExprListExp*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"args"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPragma::p_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPragma, SgExprListExp* SgPragma::*, &SgPragma::p_args>;
};
template <> struct describe_field_t<SgPragma,SgStatement*,&SgPragma::p_associatedStatement> {
  using parent = SgPragma;
  using field_type = SgStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"associatedStatement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPragma::p_associatedStatement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPragma, SgStatement* SgPragma::*, &SgPragma::p_associatedStatement>;
};
template <> struct describe_field_t<SgPragma,AstAttributeMechanism*,&SgPragma::p_attributeMechanism> {
  using parent = SgPragma;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPragma::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPragma, AstAttributeMechanism* SgPragma::*, &SgPragma::p_attributeMechanism>;
};
template <> struct describe_node_t<SgPragma> {
  using node = SgPragma;
  using base = SgAttribute;
  static constexpr char const * const name{"Pragma"};
  static constexpr unsigned long variant{652};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgPragma,Sg_File_Info*,&SgPragma::p_startOfConstruct>, describe_field_t<SgPragma,Sg_File_Info*,&SgPragma::p_endOfConstruct>, describe_field_t<SgPragma,short,&SgPragma::p_printed>, describe_field_t<SgPragma,SgExprListExp*,&SgPragma::p_args>, describe_field_t<SgPragma,SgStatement*,&SgPragma::p_associatedStatement>, describe_field_t<SgPragma,AstAttributeMechanism*,&SgPragma::p_attributeMechanism>>;
};
template <> struct node_from_variant_t<652> { using type = SgPragma; };

// Class: PragmaDeclaration
template <> struct describe_field_t<SgPragmaDeclaration,SgPragma*,&SgPragmaDeclaration::p_pragma> {
  using parent = SgPragmaDeclaration;
  using field_type = SgPragma*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"pragma"};
  static constexpr char const * const typestr{"SgPragma*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgPragmaDeclaration::p_pragma};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPragmaDeclaration, SgPragma* SgPragmaDeclaration::*, &SgPragmaDeclaration::p_pragma>;
};
template <> struct describe_node_t<SgPragmaDeclaration> {
  using node = SgPragmaDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"PragmaDeclaration"};
  static constexpr unsigned long variant{653};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgPragmaDeclaration,SgPragma*,&SgPragmaDeclaration::p_pragma>>;
};
template <> struct node_from_variant_t<653> { using type = SgPragmaDeclaration; };

// Class: PrintStatement
template <> struct describe_field_t<SgPrintStatement,SgExpression*,&SgPrintStatement::p_format> {
  using parent = SgPrintStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"format"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgPrintStatement::p_format};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPrintStatement, SgExpression* SgPrintStatement::*, &SgPrintStatement::p_format>;
};
template <> struct describe_node_t<SgPrintStatement> {
  using node = SgPrintStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"PrintStatement"};
  static constexpr unsigned long variant{654};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgPrintStatement,SgExpression*,&SgPrintStatement::p_format>>;
};
template <> struct node_from_variant_t<654> { using type = SgPrintStatement; };

// Class: ProcedureHeaderStatement
template <> struct describe_field_t<SgProcedureHeaderStatement,SgProcedureHeaderStatement::subprogram_kind_enum,&SgProcedureHeaderStatement::p_subprogram_kind> {
  using parent = SgProcedureHeaderStatement;
  using field_type = SgProcedureHeaderStatement::subprogram_kind_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"subprogram_kind"};
  static constexpr char const * const typestr{"SgProcedureHeaderStatement::subprogram_kind_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProcedureHeaderStatement::p_subprogram_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProcedureHeaderStatement, SgProcedureHeaderStatement::subprogram_kind_enum SgProcedureHeaderStatement::*, &SgProcedureHeaderStatement::p_subprogram_kind>;
};
template <> struct describe_field_t<SgProcedureHeaderStatement,SgLabelRefExp*,&SgProcedureHeaderStatement::p_end_numeric_label> {
  using parent = SgProcedureHeaderStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProcedureHeaderStatement::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProcedureHeaderStatement, SgLabelRefExp* SgProcedureHeaderStatement::*, &SgProcedureHeaderStatement::p_end_numeric_label>;
};
template <> struct describe_field_t<SgProcedureHeaderStatement,SgInitializedName*,&SgProcedureHeaderStatement::p_result_name> {
  using parent = SgProcedureHeaderStatement;
  using field_type = SgInitializedName*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"result_name"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgProcedureHeaderStatement::p_result_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProcedureHeaderStatement, SgInitializedName* SgProcedureHeaderStatement::*, &SgProcedureHeaderStatement::p_result_name>;
};
template <> struct describe_node_t<SgProcedureHeaderStatement> {
  using node = SgProcedureHeaderStatement;
  using base = SgFunctionDeclaration;
  static constexpr char const * const name{"ProcedureHeaderStatement"};
  static constexpr unsigned long variant{655};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgProcedureHeaderStatement,SgProcedureHeaderStatement::subprogram_kind_enum,&SgProcedureHeaderStatement::p_subprogram_kind>, describe_field_t<SgProcedureHeaderStatement,SgLabelRefExp*,&SgProcedureHeaderStatement::p_end_numeric_label>, describe_field_t<SgProcedureHeaderStatement,SgInitializedName*,&SgProcedureHeaderStatement::p_result_name>>;
};
template <> struct node_from_variant_t<655> { using type = SgProcedureHeaderStatement; };

// Class: ProgramHeaderStatement
template <> struct describe_field_t<SgProgramHeaderStatement,bool,&SgProgramHeaderStatement::p_program_statement_explicit> {
  using parent = SgProgramHeaderStatement;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"program_statement_explicit"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProgramHeaderStatement::p_program_statement_explicit};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProgramHeaderStatement, bool SgProgramHeaderStatement::*, &SgProgramHeaderStatement::p_program_statement_explicit>;
};
template <> struct describe_field_t<SgProgramHeaderStatement,SgLabelRefExp*,&SgProgramHeaderStatement::p_end_numeric_label> {
  using parent = SgProgramHeaderStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProgramHeaderStatement::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProgramHeaderStatement, SgLabelRefExp* SgProgramHeaderStatement::*, &SgProgramHeaderStatement::p_end_numeric_label>;
};
template <> struct describe_node_t<SgProgramHeaderStatement> {
  using node = SgProgramHeaderStatement;
  using base = SgFunctionDeclaration;
  static constexpr char const * const name{"ProgramHeaderStatement"};
  static constexpr unsigned long variant{656};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgProgramHeaderStatement,bool,&SgProgramHeaderStatement::p_program_statement_explicit>, describe_field_t<SgProgramHeaderStatement,SgLabelRefExp*,&SgProgramHeaderStatement::p_end_numeric_label>>;
};
template <> struct node_from_variant_t<656> { using type = SgProgramHeaderStatement; };

// Class: Project
template <> struct describe_field_t<SgProject,SgFileList*,&SgProject::p_fileList_ptr> {
  using parent = SgProject;
  using field_type = SgFileList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"fileList_ptr"};
  static constexpr char const * const typestr{"SgFileList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgProject::p_fileList_ptr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgFileList* SgProject::*, &SgProject::p_fileList_ptr>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_originalCommandLineArgumentList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"originalCommandLineArgumentList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_originalCommandLineArgumentList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_originalCommandLineArgumentList>;
};
template <> struct describe_field_t<SgProject,int,&SgProject::p_frontendErrorCode> {
  using parent = SgProject;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"frontendErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_frontendErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, int SgProject::*, &SgProject::p_frontendErrorCode>;
};
template <> struct describe_field_t<SgProject,int,&SgProject::p_javacErrorCode> {
  using parent = SgProject;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"javacErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_javacErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, int SgProject::*, &SgProject::p_javacErrorCode>;
};
template <> struct describe_field_t<SgProject,int,&SgProject::p_ecjErrorCode> {
  using parent = SgProject;
  using field_type = int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"ecjErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_ecjErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, int SgProject::*, &SgProject::p_ecjErrorCode>;
};
template <> struct describe_field_t<SgProject,int,&SgProject::p_midendErrorCode> {
  using parent = SgProject;
  using field_type = int;
  static constexpr size_t position{5};
  static constexpr char const * const name{"midendErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_midendErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, int SgProject::*, &SgProject::p_midendErrorCode>;
};
template <> struct describe_field_t<SgProject,int,&SgProject::p_backendErrorCode> {
  using parent = SgProject;
  using field_type = int;
  static constexpr size_t position{6};
  static constexpr char const * const name{"backendErrorCode"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_backendErrorCode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, int SgProject::*, &SgProject::p_backendErrorCode>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_keep_going> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"keep_going"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_keep_going};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_keep_going>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_unparser__clobber_input_file> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"unparser__clobber_input_file"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_unparser__clobber_input_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_unparser__clobber_input_file>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_outputFileName> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{9};
  static constexpr char const * const name{"outputFileName"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_outputFileName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_outputFileName>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_sourceFileNameList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{10};
  static constexpr char const * const name{"sourceFileNameList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_sourceFileNameList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_sourceFileNameList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_objectFileNameList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{11};
  static constexpr char const * const name{"objectFileNameList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_objectFileNameList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_objectFileNameList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_libraryFileList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{12};
  static constexpr char const * const name{"libraryFileList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_libraryFileList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_libraryFileList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_librarySpecifierList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{13};
  static constexpr char const * const name{"librarySpecifierList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_librarySpecifierList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_librarySpecifierList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_libraryDirectorySpecifierList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{14};
  static constexpr char const * const name{"libraryDirectorySpecifierList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_libraryDirectorySpecifierList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_libraryDirectorySpecifierList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_includeDirectorySpecifierList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{15};
  static constexpr char const * const name{"includeDirectorySpecifierList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_includeDirectorySpecifierList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_includeDirectorySpecifierList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_macroSpecifierList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{16};
  static constexpr char const * const name{"macroSpecifierList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_macroSpecifierList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_macroSpecifierList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_preincludeFileList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{17};
  static constexpr char const * const name{"preincludeFileList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_preincludeFileList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_preincludeFileList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_preincludeDirectoryList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{18};
  static constexpr char const * const name{"preincludeDirectoryList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_preincludeDirectoryList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_preincludeDirectoryList>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_compileOnly> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{19};
  static constexpr char const * const name{"compileOnly"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_compileOnly};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_compileOnly>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_wave> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{20};
  static constexpr char const * const name{"wave"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_wave};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_wave>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_prelink> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{21};
  static constexpr char const * const name{"prelink"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_prelink};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_prelink>;
};
template <> struct describe_field_t<SgProject,SgProject::template_instantiation_enum,&SgProject::p_template_instantiation_mode> {
  using parent = SgProject;
  using field_type = SgProject::template_instantiation_enum;
  static constexpr size_t position{22};
  static constexpr char const * const name{"template_instantiation_mode"};
  static constexpr char const * const typestr{"SgProject::template_instantiation_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_template_instantiation_mode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgProject::template_instantiation_enum SgProject::*, &SgProject::p_template_instantiation_mode>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_ast_merge> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{23};
  static constexpr char const * const name{"ast_merge"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_ast_merge};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_ast_merge>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_projectSpecificDatabaseFile> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{24};
  static constexpr char const * const name{"projectSpecificDatabaseFile"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_projectSpecificDatabaseFile};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_projectSpecificDatabaseFile>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_C_PreprocessorOnly> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{25};
  static constexpr char const * const name{"C_PreprocessorOnly"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_C_PreprocessorOnly};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_C_PreprocessorOnly>;
};
template <> struct describe_field_t<SgProject,AstAttributeMechanism*,&SgProject::p_attributeMechanism> {
  using parent = SgProject;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{26};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, AstAttributeMechanism* SgProject::*, &SgProject::p_attributeMechanism>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_compilationPerformanceFile> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{27};
  static constexpr char const * const name{"compilationPerformanceFile"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_compilationPerformanceFile};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_compilationPerformanceFile>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_includePathList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{28};
  static constexpr char const * const name{"includePathList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_includePathList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_includePathList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_excludePathList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{29};
  static constexpr char const * const name{"excludePathList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_excludePathList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_excludePathList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_includeFileList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{30};
  static constexpr char const * const name{"includeFileList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_includeFileList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_includeFileList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_excludeFileList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{31};
  static constexpr char const * const name{"excludeFileList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_excludeFileList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_excludeFileList>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_binary_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{32};
  static constexpr char const * const name{"binary_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_binary_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_binary_only>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_dataBaseFilename> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{33};
  static constexpr char const * const name{"dataBaseFilename"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_dataBaseFilename};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_dataBaseFilename>;
};
template <> struct describe_field_t<SgProject,SgDirectoryList*,&SgProject::p_directoryList> {
  using parent = SgProject;
  using field_type = SgDirectoryList*;
  static constexpr size_t position{34};
  static constexpr char const * const name{"directoryList"};
  static constexpr char const * const typestr{"SgDirectoryList*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_directoryList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgDirectoryList* SgProject::*, &SgProject::p_directoryList>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_C_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{35};
  static constexpr char const * const name{"C_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_C_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_C_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Cxx_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{36};
  static constexpr char const * const name{"Cxx_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Cxx_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Cxx_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_C11_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{37};
  static constexpr char const * const name{"C11_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_C11_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_C11_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Cxx0x_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{38};
  static constexpr char const * const name{"Cxx0x_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Cxx0x_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Cxx0x_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Cxx11_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{39};
  static constexpr char const * const name{"Cxx11_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Cxx11_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Cxx11_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_C14_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{40};
  static constexpr char const * const name{"C14_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_C14_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_C14_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Cxx14_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{41};
  static constexpr char const * const name{"Cxx14_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Cxx14_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Cxx14_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Fortran_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{42};
  static constexpr char const * const name{"Fortran_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Fortran_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Fortran_only>;
};
template <> struct describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Fortran_ofp_jvm_options> {
  using parent = SgProject;
  using field_type = std::list<std::string>;
  static constexpr size_t position{43};
  static constexpr char const * const name{"Fortran_ofp_jvm_options"};
  static constexpr char const * const typestr{"std::list<std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Fortran_ofp_jvm_options};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::list<std::string> SgProject::*, &SgProject::p_Fortran_ofp_jvm_options>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Java_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{44};
  static constexpr char const * const name{"Java_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Java_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Jvm_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{45};
  static constexpr char const * const name{"Jvm_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Jvm_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Jvm_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Jovial_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{46};
  static constexpr char const * const name{"Jovial_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Jovial_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Jovial_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Ada_only> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{47};
  static constexpr char const * const name{"Ada_only"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Ada_only};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Ada_only>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_openmp_linking> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{48};
  static constexpr char const * const name{"openmp_linking"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_openmp_linking};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_openmp_linking>;
};
template <> struct describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Java_ecj_jvm_options> {
  using parent = SgProject;
  using field_type = std::list<std::string>;
  static constexpr size_t position{49};
  static constexpr char const * const name{"Java_ecj_jvm_options"};
  static constexpr char const * const typestr{"std::list<std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_ecj_jvm_options};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::list<std::string> SgProject::*, &SgProject::p_Java_ecj_jvm_options>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Java_batch_mode> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{50};
  static constexpr char const * const name{"Java_batch_mode"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_batch_mode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Java_batch_mode>;
};
template <> struct describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Java_classpath> {
  using parent = SgProject;
  using field_type = std::list<std::string>;
  static constexpr size_t position{51};
  static constexpr char const * const name{"Java_classpath"};
  static constexpr char const * const typestr{"std::list<std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_classpath};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::list<std::string> SgProject::*, &SgProject::p_Java_classpath>;
};
template <> struct describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Java_sourcepath> {
  using parent = SgProject;
  using field_type = std::list<std::string>;
  static constexpr size_t position{52};
  static constexpr char const * const name{"Java_sourcepath"};
  static constexpr char const * const typestr{"std::list<std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_sourcepath};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::list<std::string> SgProject::*, &SgProject::p_Java_sourcepath>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_Java_destdir> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{53};
  static constexpr char const * const name{"Java_destdir"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_destdir};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_Java_destdir>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_Java_source_destdir> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{54};
  static constexpr char const * const name{"Java_source_destdir"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_source_destdir};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_Java_source_destdir>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_Java_s> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{55};
  static constexpr char const * const name{"Java_s"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_s};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_Java_s>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_Java_source> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{56};
  static constexpr char const * const name{"Java_source"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_source};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_Java_source>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_Java_target> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{57};
  static constexpr char const * const name{"Java_target"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_target};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_Java_target>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_Java_encoding> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{58};
  static constexpr char const * const name{"Java_encoding"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_encoding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_Java_encoding>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_Java_g> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{59};
  static constexpr char const * const name{"Java_g"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_g};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_Java_g>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Java_nowarn> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{60};
  static constexpr char const * const name{"Java_nowarn"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_nowarn};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Java_nowarn>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Java_verbose> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{61};
  static constexpr char const * const name{"Java_verbose"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_verbose};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Java_verbose>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_Java_deprecation> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{62};
  static constexpr char const * const name{"Java_deprecation"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_deprecation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_Java_deprecation>;
};
template <> struct describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Java_bootclasspath> {
  using parent = SgProject;
  using field_type = std::list<std::string>;
  static constexpr size_t position{63};
  static constexpr char const * const name{"Java_bootclasspath"};
  static constexpr char const * const typestr{"std::list<std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_Java_bootclasspath};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::list<std::string> SgProject::*, &SgProject::p_Java_bootclasspath>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_addCppDirectivesToAST> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{64};
  static constexpr char const * const name{"addCppDirectivesToAST"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_addCppDirectivesToAST};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_addCppDirectivesToAST>;
};
template <> struct describe_field_t<SgProject,std::map<std::string, std::set<PreprocessingInfo*> >,&SgProject::p_includingPreprocessingInfosMap> {
  using parent = SgProject;
  using field_type = std::map<std::string, std::set<PreprocessingInfo*> >;
  static constexpr size_t position{65};
  static constexpr char const * const name{"includingPreprocessingInfosMap"};
  static constexpr char const * const typestr{"std::map<std::string, std::set<PreprocessingInfo*> >"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_includingPreprocessingInfosMap};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::map<std::string, std::set<PreprocessingInfo*> > SgProject::*, &SgProject::p_includingPreprocessingInfosMap>;
};
template <> struct describe_field_t<SgProject,std::list<std::string>,&SgProject::p_quotedIncludesSearchPaths> {
  using parent = SgProject;
  using field_type = std::list<std::string>;
  static constexpr size_t position{66};
  static constexpr char const * const name{"quotedIncludesSearchPaths"};
  static constexpr char const * const typestr{"std::list<std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_quotedIncludesSearchPaths};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::list<std::string> SgProject::*, &SgProject::p_quotedIncludesSearchPaths>;
};
template <> struct describe_field_t<SgProject,std::list<std::string>,&SgProject::p_bracketedIncludesSearchPaths> {
  using parent = SgProject;
  using field_type = std::list<std::string>;
  static constexpr size_t position{67};
  static constexpr char const * const name{"bracketedIncludesSearchPaths"};
  static constexpr char const * const typestr{"std::list<std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_bracketedIncludesSearchPaths};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::list<std::string> SgProject::*, &SgProject::p_bracketedIncludesSearchPaths>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_unparseHeaderFilesRootFolder> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{68};
  static constexpr char const * const name{"unparseHeaderFilesRootFolder"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_unparseHeaderFilesRootFolder};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_unparseHeaderFilesRootFolder>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_frontendConstantFolding> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{69};
  static constexpr char const * const name{"frontendConstantFolding"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_frontendConstantFolding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_frontendConstantFolding>;
};
template <> struct describe_field_t<SgProject,SgGlobal*,&SgProject::p_globalScopeAcrossFiles> {
  using parent = SgProject;
  using field_type = SgGlobal*;
  static constexpr size_t position{70};
  static constexpr char const * const name{"globalScopeAcrossFiles"};
  static constexpr char const * const typestr{"SgGlobal*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_globalScopeAcrossFiles};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgGlobal* SgProject::*, &SgProject::p_globalScopeAcrossFiles>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_unparse_in_same_directory_as_input_file> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{71};
  static constexpr char const * const name{"unparse_in_same_directory_as_input_file"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_unparse_in_same_directory_as_input_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_unparse_in_same_directory_as_input_file>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_stop_after_compilation_do_not_assemble_file> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{72};
  static constexpr char const * const name{"stop_after_compilation_do_not_assemble_file"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_stop_after_compilation_do_not_assemble_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_stop_after_compilation_do_not_assemble_file>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_gnuOptionForUndefinedSymbol> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{73};
  static constexpr char const * const name{"gnuOptionForUndefinedSymbol"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_gnuOptionForUndefinedSymbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_gnuOptionForUndefinedSymbol>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_mode_32_bit> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{74};
  static constexpr char const * const name{"mode_32_bit"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_mode_32_bit};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_mode_32_bit>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_noclobber_output_file> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{75};
  static constexpr char const * const name{"noclobber_output_file"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_noclobber_output_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_noclobber_output_file>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_noclobber_if_different_output_file> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{76};
  static constexpr char const * const name{"noclobber_if_different_output_file"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_noclobber_if_different_output_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_noclobber_if_different_output_file>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_suppressConstantFoldingPostProcessing> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{77};
  static constexpr char const * const name{"suppressConstantFoldingPostProcessing"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_suppressConstantFoldingPostProcessing};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_suppressConstantFoldingPostProcessing>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_suppressNameQualificationAcrossWholeTranslationUnit> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{78};
  static constexpr char const * const name{"suppressNameQualificationAcrossWholeTranslationUnit"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_suppressNameQualificationAcrossWholeTranslationUnit};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_suppressNameQualificationAcrossWholeTranslationUnit>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_appendPID> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{79};
  static constexpr char const * const name{"appendPID"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_appendPID};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_appendPID>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_reportOnHeaderFileUnparsing> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{80};
  static constexpr char const * const name{"reportOnHeaderFileUnparsing"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_reportOnHeaderFileUnparsing};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_reportOnHeaderFileUnparsing>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_applicationRootDirectory> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{81};
  static constexpr char const * const name{"applicationRootDirectory"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_applicationRootDirectory};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_applicationRootDirectory>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_usingApplicationRootDirectory> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{82};
  static constexpr char const * const name{"usingApplicationRootDirectory"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_usingApplicationRootDirectory};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_usingApplicationRootDirectory>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_usingDeferredTransformations> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{83};
  static constexpr char const * const name{"usingDeferredTransformations"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_usingDeferredTransformations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_usingDeferredTransformations>;
};
template <> struct describe_field_t<SgProject,std::string,&SgProject::p_astfile_out> {
  using parent = SgProject;
  using field_type = std::string;
  static constexpr size_t position{84};
  static constexpr char const * const name{"astfile_out"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_astfile_out};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::string SgProject::*, &SgProject::p_astfile_out>;
};
template <> struct describe_field_t<SgProject,std::list<std::string>,&SgProject::p_astfiles_in> {
  using parent = SgProject;
  using field_type = std::list<std::string>;
  static constexpr size_t position{85};
  static constexpr char const * const name{"astfiles_in"};
  static constexpr char const * const typestr{"std::list<std::string>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_astfiles_in};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, std::list<std::string> SgProject::*, &SgProject::p_astfiles_in>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_extraIncludeDirectorySpecifierBeforeList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{86};
  static constexpr char const * const name{"extraIncludeDirectorySpecifierBeforeList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_extraIncludeDirectorySpecifierBeforeList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_extraIncludeDirectorySpecifierBeforeList>;
};
template <> struct describe_field_t<SgProject,SgStringList,&SgProject::p_extraIncludeDirectorySpecifierAfterList> {
  using parent = SgProject;
  using field_type = SgStringList;
  static constexpr size_t position{87};
  static constexpr char const * const name{"extraIncludeDirectorySpecifierAfterList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_extraIncludeDirectorySpecifierAfterList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, SgStringList SgProject::*, &SgProject::p_extraIncludeDirectorySpecifierAfterList>;
};
template <> struct describe_field_t<SgProject,bool,&SgProject::p_skip_post_processing> {
  using parent = SgProject;
  using field_type = bool;
  static constexpr size_t position{88};
  static constexpr char const * const name{"skip_post_processing"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProject::p_skip_post_processing};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProject, bool SgProject::*, &SgProject::p_skip_post_processing>;
};
template <> struct describe_node_t<SgProject> {
  using node = SgProject;
  using base = SgSupport;
  static constexpr char const * const name{"Project"};
  static constexpr unsigned long variant{657};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgProject,SgFileList*,&SgProject::p_fileList_ptr>, describe_field_t<SgProject,SgStringList,&SgProject::p_originalCommandLineArgumentList>, describe_field_t<SgProject,int,&SgProject::p_frontendErrorCode>, describe_field_t<SgProject,int,&SgProject::p_javacErrorCode>, describe_field_t<SgProject,int,&SgProject::p_ecjErrorCode>, describe_field_t<SgProject,int,&SgProject::p_midendErrorCode>, describe_field_t<SgProject,int,&SgProject::p_backendErrorCode>, describe_field_t<SgProject,bool,&SgProject::p_keep_going>, describe_field_t<SgProject,bool,&SgProject::p_unparser__clobber_input_file>, describe_field_t<SgProject,std::string,&SgProject::p_outputFileName>, describe_field_t<SgProject,SgStringList,&SgProject::p_sourceFileNameList>, describe_field_t<SgProject,SgStringList,&SgProject::p_objectFileNameList>, describe_field_t<SgProject,SgStringList,&SgProject::p_libraryFileList>, describe_field_t<SgProject,SgStringList,&SgProject::p_librarySpecifierList>, describe_field_t<SgProject,SgStringList,&SgProject::p_libraryDirectorySpecifierList>, describe_field_t<SgProject,SgStringList,&SgProject::p_includeDirectorySpecifierList>, describe_field_t<SgProject,SgStringList,&SgProject::p_macroSpecifierList>, describe_field_t<SgProject,SgStringList,&SgProject::p_preincludeFileList>, describe_field_t<SgProject,SgStringList,&SgProject::p_preincludeDirectoryList>, describe_field_t<SgProject,bool,&SgProject::p_compileOnly>, describe_field_t<SgProject,bool,&SgProject::p_wave>, describe_field_t<SgProject,bool,&SgProject::p_prelink>, describe_field_t<SgProject,SgProject::template_instantiation_enum,&SgProject::p_template_instantiation_mode>, describe_field_t<SgProject,bool,&SgProject::p_ast_merge>, describe_field_t<SgProject,std::string,&SgProject::p_projectSpecificDatabaseFile>, describe_field_t<SgProject,bool,&SgProject::p_C_PreprocessorOnly>, describe_field_t<SgProject,AstAttributeMechanism*,&SgProject::p_attributeMechanism>, describe_field_t<SgProject,std::string,&SgProject::p_compilationPerformanceFile>, describe_field_t<SgProject,SgStringList,&SgProject::p_includePathList>, describe_field_t<SgProject,SgStringList,&SgProject::p_excludePathList>, describe_field_t<SgProject,SgStringList,&SgProject::p_includeFileList>, describe_field_t<SgProject,SgStringList,&SgProject::p_excludeFileList>, describe_field_t<SgProject,bool,&SgProject::p_binary_only>, describe_field_t<SgProject,std::string,&SgProject::p_dataBaseFilename>, describe_field_t<SgProject,SgDirectoryList*,&SgProject::p_directoryList>, describe_field_t<SgProject,bool,&SgProject::p_C_only>, describe_field_t<SgProject,bool,&SgProject::p_Cxx_only>, describe_field_t<SgProject,bool,&SgProject::p_C11_only>, describe_field_t<SgProject,bool,&SgProject::p_Cxx0x_only>, describe_field_t<SgProject,bool,&SgProject::p_Cxx11_only>, describe_field_t<SgProject,bool,&SgProject::p_C14_only>, describe_field_t<SgProject,bool,&SgProject::p_Cxx14_only>, describe_field_t<SgProject,bool,&SgProject::p_Fortran_only>, describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Fortran_ofp_jvm_options>, describe_field_t<SgProject,bool,&SgProject::p_Java_only>, describe_field_t<SgProject,bool,&SgProject::p_Jvm_only>, describe_field_t<SgProject,bool,&SgProject::p_Jovial_only>, describe_field_t<SgProject,bool,&SgProject::p_Ada_only>, describe_field_t<SgProject,bool,&SgProject::p_openmp_linking>, describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Java_ecj_jvm_options>, describe_field_t<SgProject,bool,&SgProject::p_Java_batch_mode>, describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Java_classpath>, describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Java_sourcepath>, describe_field_t<SgProject,std::string,&SgProject::p_Java_destdir>, describe_field_t<SgProject,std::string,&SgProject::p_Java_source_destdir>, describe_field_t<SgProject,std::string,&SgProject::p_Java_s>, describe_field_t<SgProject,std::string,&SgProject::p_Java_source>, describe_field_t<SgProject,std::string,&SgProject::p_Java_target>, describe_field_t<SgProject,std::string,&SgProject::p_Java_encoding>, describe_field_t<SgProject,std::string,&SgProject::p_Java_g>, describe_field_t<SgProject,bool,&SgProject::p_Java_nowarn>, describe_field_t<SgProject,bool,&SgProject::p_Java_verbose>, describe_field_t<SgProject,bool,&SgProject::p_Java_deprecation>, describe_field_t<SgProject,std::list<std::string>,&SgProject::p_Java_bootclasspath>, describe_field_t<SgProject,bool,&SgProject::p_addCppDirectivesToAST>, describe_field_t<SgProject,std::map<std::string, std::set<PreprocessingInfo*> >,&SgProject::p_includingPreprocessingInfosMap>, describe_field_t<SgProject,std::list<std::string>,&SgProject::p_quotedIncludesSearchPaths>, describe_field_t<SgProject,std::list<std::string>,&SgProject::p_bracketedIncludesSearchPaths>, describe_field_t<SgProject,std::string,&SgProject::p_unparseHeaderFilesRootFolder>, describe_field_t<SgProject,bool,&SgProject::p_frontendConstantFolding>, describe_field_t<SgProject,SgGlobal*,&SgProject::p_globalScopeAcrossFiles>, describe_field_t<SgProject,bool,&SgProject::p_unparse_in_same_directory_as_input_file>, describe_field_t<SgProject,bool,&SgProject::p_stop_after_compilation_do_not_assemble_file>, describe_field_t<SgProject,std::string,&SgProject::p_gnuOptionForUndefinedSymbol>, describe_field_t<SgProject,bool,&SgProject::p_mode_32_bit>, describe_field_t<SgProject,bool,&SgProject::p_noclobber_output_file>, describe_field_t<SgProject,bool,&SgProject::p_noclobber_if_different_output_file>, describe_field_t<SgProject,bool,&SgProject::p_suppressConstantFoldingPostProcessing>, describe_field_t<SgProject,bool,&SgProject::p_suppressNameQualificationAcrossWholeTranslationUnit>, describe_field_t<SgProject,bool,&SgProject::p_appendPID>, describe_field_t<SgProject,bool,&SgProject::p_reportOnHeaderFileUnparsing>, describe_field_t<SgProject,std::string,&SgProject::p_applicationRootDirectory>, describe_field_t<SgProject,bool,&SgProject::p_usingApplicationRootDirectory>, describe_field_t<SgProject,bool,&SgProject::p_usingDeferredTransformations>, describe_field_t<SgProject,std::string,&SgProject::p_astfile_out>, describe_field_t<SgProject,std::list<std::string>,&SgProject::p_astfiles_in>, describe_field_t<SgProject,SgStringList,&SgProject::p_extraIncludeDirectorySpecifierBeforeList>, describe_field_t<SgProject,SgStringList,&SgProject::p_extraIncludeDirectorySpecifierAfterList>, describe_field_t<SgProject,bool,&SgProject::p_skip_post_processing>>;
};
template <> struct node_from_variant_t<657> { using type = SgProject; };

// Class: PseudoDestructorRefExp
template <> struct describe_field_t<SgPseudoDestructorRefExp,SgType*,&SgPseudoDestructorRefExp::p_object_type> {
  using parent = SgPseudoDestructorRefExp;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"object_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPseudoDestructorRefExp::p_object_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPseudoDestructorRefExp, SgType* SgPseudoDestructorRefExp::*, &SgPseudoDestructorRefExp::p_object_type>;
};
template <> struct describe_field_t<SgPseudoDestructorRefExp,SgType*,&SgPseudoDestructorRefExp::p_expression_type> {
  using parent = SgPseudoDestructorRefExp;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPseudoDestructorRefExp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPseudoDestructorRefExp, SgType* SgPseudoDestructorRefExp::*, &SgPseudoDestructorRefExp::p_expression_type>;
};
template <> struct describe_field_t<SgPseudoDestructorRefExp,int,&SgPseudoDestructorRefExp::p_name_qualification_length> {
  using parent = SgPseudoDestructorRefExp;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPseudoDestructorRefExp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPseudoDestructorRefExp, int SgPseudoDestructorRefExp::*, &SgPseudoDestructorRefExp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgPseudoDestructorRefExp,bool,&SgPseudoDestructorRefExp::p_type_elaboration_required> {
  using parent = SgPseudoDestructorRefExp;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPseudoDestructorRefExp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPseudoDestructorRefExp, bool SgPseudoDestructorRefExp::*, &SgPseudoDestructorRefExp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgPseudoDestructorRefExp,bool,&SgPseudoDestructorRefExp::p_global_qualification_required> {
  using parent = SgPseudoDestructorRefExp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgPseudoDestructorRefExp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPseudoDestructorRefExp, bool SgPseudoDestructorRefExp::*, &SgPseudoDestructorRefExp::p_global_qualification_required>;
};
template <> struct describe_node_t<SgPseudoDestructorRefExp> {
  using node = SgPseudoDestructorRefExp;
  using base = SgExpression;
  static constexpr char const * const name{"PseudoDestructorRefExp"};
  static constexpr unsigned long variant{658};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgPseudoDestructorRefExp,SgType*,&SgPseudoDestructorRefExp::p_object_type>, describe_field_t<SgPseudoDestructorRefExp,SgType*,&SgPseudoDestructorRefExp::p_expression_type>, describe_field_t<SgPseudoDestructorRefExp,int,&SgPseudoDestructorRefExp::p_name_qualification_length>, describe_field_t<SgPseudoDestructorRefExp,bool,&SgPseudoDestructorRefExp::p_type_elaboration_required>, describe_field_t<SgPseudoDestructorRefExp,bool,&SgPseudoDestructorRefExp::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<658> { using type = SgPseudoDestructorRefExp; };

// Class: PythonGlobalStmt
template <> struct describe_field_t<SgPythonGlobalStmt,SgInitializedNamePtrList,&SgPythonGlobalStmt::p_names> {
  using parent = SgPythonGlobalStmt;
  using field_type = SgInitializedNamePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"names"};
  static constexpr char const * const typestr{"SgInitializedNamePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgPythonGlobalStmt::p_names};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPythonGlobalStmt, SgInitializedNamePtrList SgPythonGlobalStmt::*, &SgPythonGlobalStmt::p_names>;
};
template <> struct describe_node_t<SgPythonGlobalStmt> {
  using node = SgPythonGlobalStmt;
  using base = SgStatement;
  static constexpr char const * const name{"PythonGlobalStmt"};
  static constexpr unsigned long variant{659};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgPythonGlobalStmt,SgInitializedNamePtrList,&SgPythonGlobalStmt::p_names>>;
};
template <> struct node_from_variant_t<659> { using type = SgPythonGlobalStmt; };

// Class: PythonPrintStmt
template <> struct describe_field_t<SgPythonPrintStmt,SgExpression*,&SgPythonPrintStmt::p_destination> {
  using parent = SgPythonPrintStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"destination"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgPythonPrintStmt::p_destination};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPythonPrintStmt, SgExpression* SgPythonPrintStmt::*, &SgPythonPrintStmt::p_destination>;
};
template <> struct describe_field_t<SgPythonPrintStmt,SgExprListExp*,&SgPythonPrintStmt::p_values> {
  using parent = SgPythonPrintStmt;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"values"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgPythonPrintStmt::p_values};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgPythonPrintStmt, SgExprListExp* SgPythonPrintStmt::*, &SgPythonPrintStmt::p_values>;
};
template <> struct describe_node_t<SgPythonPrintStmt> {
  using node = SgPythonPrintStmt;
  using base = SgStatement;
  static constexpr char const * const name{"PythonPrintStmt"};
  static constexpr unsigned long variant{660};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgPythonPrintStmt,SgExpression*,&SgPythonPrintStmt::p_destination>, describe_field_t<SgPythonPrintStmt,SgExprListExp*,&SgPythonPrintStmt::p_values>>;
};
template <> struct node_from_variant_t<660> { using type = SgPythonPrintStmt; };

// Class: QualifiedName
template <> struct describe_field_t<SgQualifiedName,SgScopeStatement*,&SgQualifiedName::p_scope> {
  using parent = SgQualifiedName;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgQualifiedName::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgQualifiedName, SgScopeStatement* SgQualifiedName::*, &SgQualifiedName::p_scope>;
};
template <> struct describe_node_t<SgQualifiedName> {
  using node = SgQualifiedName;
  using base = SgSupport;
  static constexpr char const * const name{"QualifiedName"};
  static constexpr unsigned long variant{661};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgQualifiedName,SgScopeStatement*,&SgQualifiedName::p_scope>>;
};
template <> struct node_from_variant_t<661> { using type = SgQualifiedName; };

// Class: QualifiedNameType
template <> struct describe_field_t<SgQualifiedNameType,SgType*,&SgQualifiedNameType::p_base_type> {
  using parent = SgQualifiedNameType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgQualifiedNameType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgQualifiedNameType, SgType* SgQualifiedNameType::*, &SgQualifiedNameType::p_base_type>;
};
template <> struct describe_field_t<SgQualifiedNameType,SgQualifiedNamePtrList,&SgQualifiedNameType::p_qualifiedNameList> {
  using parent = SgQualifiedNameType;
  using field_type = SgQualifiedNamePtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"qualifiedNameList"};
  static constexpr char const * const typestr{"SgQualifiedNamePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgQualifiedNameType::p_qualifiedNameList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgQualifiedNameType, SgQualifiedNamePtrList SgQualifiedNameType::*, &SgQualifiedNameType::p_qualifiedNameList>;
};
template <> struct describe_node_t<SgQualifiedNameType> {
  using node = SgQualifiedNameType;
  using base = SgType;
  static constexpr char const * const name{"QualifiedNameType"};
  static constexpr unsigned long variant{662};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgQualifiedNameType,SgType*,&SgQualifiedNameType::p_base_type>, describe_field_t<SgQualifiedNameType,SgQualifiedNamePtrList,&SgQualifiedNameType::p_qualifiedNameList>>;
};
template <> struct node_from_variant_t<662> { using type = SgQualifiedNameType; };

// Class: RangeExp
template <> struct describe_field_t<SgRangeExp,SgExpression*,&SgRangeExp::p_start> {
  using parent = SgRangeExp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"start"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeExp::p_start};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeExp, SgExpression* SgRangeExp::*, &SgRangeExp::p_start>;
};
template <> struct describe_field_t<SgRangeExp,SgExpression*,&SgRangeExp::p_end> {
  using parent = SgRangeExp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"end"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeExp::p_end};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeExp, SgExpression* SgRangeExp::*, &SgRangeExp::p_end>;
};
template <> struct describe_field_t<SgRangeExp,SgExpression*,&SgRangeExp::p_stride> {
  using parent = SgRangeExp;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"stride"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeExp::p_stride};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeExp, SgExpression* SgRangeExp::*, &SgRangeExp::p_stride>;
};
template <> struct describe_node_t<SgRangeExp> {
  using node = SgRangeExp;
  using base = SgExpression;
  static constexpr char const * const name{"RangeExp"};
  static constexpr unsigned long variant{663};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgRangeExp,SgExpression*,&SgRangeExp::p_start>, describe_field_t<SgRangeExp,SgExpression*,&SgRangeExp::p_end>, describe_field_t<SgRangeExp,SgExpression*,&SgRangeExp::p_stride>>;
};
template <> struct node_from_variant_t<663> { using type = SgRangeExp; };

// Class: RangeBasedForStatement
template <> struct describe_field_t<SgRangeBasedForStatement,SgVariableDeclaration*,&SgRangeBasedForStatement::p_iterator_declaration> {
  using parent = SgRangeBasedForStatement;
  using field_type = SgVariableDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"iterator_declaration"};
  static constexpr char const * const typestr{"SgVariableDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeBasedForStatement::p_iterator_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeBasedForStatement, SgVariableDeclaration* SgRangeBasedForStatement::*, &SgRangeBasedForStatement::p_iterator_declaration>;
};
template <> struct describe_field_t<SgRangeBasedForStatement,SgVariableDeclaration*,&SgRangeBasedForStatement::p_range_declaration> {
  using parent = SgRangeBasedForStatement;
  using field_type = SgVariableDeclaration*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"range_declaration"};
  static constexpr char const * const typestr{"SgVariableDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeBasedForStatement::p_range_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeBasedForStatement, SgVariableDeclaration* SgRangeBasedForStatement::*, &SgRangeBasedForStatement::p_range_declaration>;
};
template <> struct describe_field_t<SgRangeBasedForStatement,SgVariableDeclaration*,&SgRangeBasedForStatement::p_begin_declaration> {
  using parent = SgRangeBasedForStatement;
  using field_type = SgVariableDeclaration*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"begin_declaration"};
  static constexpr char const * const typestr{"SgVariableDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeBasedForStatement::p_begin_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeBasedForStatement, SgVariableDeclaration* SgRangeBasedForStatement::*, &SgRangeBasedForStatement::p_begin_declaration>;
};
template <> struct describe_field_t<SgRangeBasedForStatement,SgVariableDeclaration*,&SgRangeBasedForStatement::p_end_declaration> {
  using parent = SgRangeBasedForStatement;
  using field_type = SgVariableDeclaration*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"end_declaration"};
  static constexpr char const * const typestr{"SgVariableDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeBasedForStatement::p_end_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeBasedForStatement, SgVariableDeclaration* SgRangeBasedForStatement::*, &SgRangeBasedForStatement::p_end_declaration>;
};
template <> struct describe_field_t<SgRangeBasedForStatement,SgExpression*,&SgRangeBasedForStatement::p_not_equal_expression> {
  using parent = SgRangeBasedForStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"not_equal_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeBasedForStatement::p_not_equal_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeBasedForStatement, SgExpression* SgRangeBasedForStatement::*, &SgRangeBasedForStatement::p_not_equal_expression>;
};
template <> struct describe_field_t<SgRangeBasedForStatement,SgExpression*,&SgRangeBasedForStatement::p_increment_expression> {
  using parent = SgRangeBasedForStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"increment_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeBasedForStatement::p_increment_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeBasedForStatement, SgExpression* SgRangeBasedForStatement::*, &SgRangeBasedForStatement::p_increment_expression>;
};
template <> struct describe_field_t<SgRangeBasedForStatement,SgStatement*,&SgRangeBasedForStatement::p_loop_body> {
  using parent = SgRangeBasedForStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"loop_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRangeBasedForStatement::p_loop_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeBasedForStatement, SgStatement* SgRangeBasedForStatement::*, &SgRangeBasedForStatement::p_loop_body>;
};
template <> struct describe_node_t<SgRangeBasedForStatement> {
  using node = SgRangeBasedForStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"RangeBasedForStatement"};
  static constexpr unsigned long variant{664};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgRangeBasedForStatement,SgVariableDeclaration*,&SgRangeBasedForStatement::p_iterator_declaration>, describe_field_t<SgRangeBasedForStatement,SgVariableDeclaration*,&SgRangeBasedForStatement::p_range_declaration>, describe_field_t<SgRangeBasedForStatement,SgVariableDeclaration*,&SgRangeBasedForStatement::p_begin_declaration>, describe_field_t<SgRangeBasedForStatement,SgVariableDeclaration*,&SgRangeBasedForStatement::p_end_declaration>, describe_field_t<SgRangeBasedForStatement,SgExpression*,&SgRangeBasedForStatement::p_not_equal_expression>, describe_field_t<SgRangeBasedForStatement,SgExpression*,&SgRangeBasedForStatement::p_increment_expression>, describe_field_t<SgRangeBasedForStatement,SgStatement*,&SgRangeBasedForStatement::p_loop_body>>;
};
template <> struct node_from_variant_t<664> { using type = SgRangeBasedForStatement; };

// Class: ReadStatement
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_format> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"format"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_format};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_format>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_namelist> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"namelist"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_namelist};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_namelist>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_advance> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"advance"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_advance};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_advance>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_asynchronous> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"asynchronous"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_asynchronous};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_asynchronous>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_blank> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"blank"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_blank};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_blank>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_decimal> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"decimal"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_decimal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_decimal>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_delim> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"delim"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_delim};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_delim>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_end> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"end"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_end};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_end>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_eor> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"eor"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_eor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_eor>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_id> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"id"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_id};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_id>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_pad> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{10};
  static constexpr char const * const name{"pad"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_pad};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_pad>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_pos> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"pos"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_pos};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_pos>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_rec> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{12};
  static constexpr char const * const name{"rec"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_rec};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_rec>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_round> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"round"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_round};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_round>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_sign> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{14};
  static constexpr char const * const name{"sign"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_sign};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_sign>;
};
template <> struct describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_size> {
  using parent = SgReadStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{15};
  static constexpr char const * const name{"size"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReadStatement::p_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReadStatement, SgExpression* SgReadStatement::*, &SgReadStatement::p_size>;
};
template <> struct describe_node_t<SgReadStatement> {
  using node = SgReadStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"ReadStatement"};
  static constexpr unsigned long variant{665};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_format>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_namelist>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_advance>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_asynchronous>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_blank>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_decimal>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_delim>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_end>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_eor>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_id>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_pad>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_pos>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_rec>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_round>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_sign>, describe_field_t<SgReadStatement,SgExpression*,&SgReadStatement::p_size>>;
};
template <> struct node_from_variant_t<665> { using type = SgReadStatement; };

// Class: RealPartOp
template <> struct describe_node_t<SgRealPartOp> {
  using node = SgRealPartOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"RealPartOp"};
  static constexpr unsigned long variant{666};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<666> { using type = SgRealPartOp; };

// Class: RefExp
template <> struct describe_field_t<SgRefExp,SgType*,&SgRefExp::p_type_name> {
  using parent = SgRefExp;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"type_name"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgRefExp::p_type_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRefExp, SgType* SgRefExp::*, &SgRefExp::p_type_name>;
};
template <> struct describe_node_t<SgRefExp> {
  using node = SgRefExp;
  using base = SgExpression;
  static constexpr char const * const name{"RefExp"};
  static constexpr unsigned long variant{667};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgRefExp,SgType*,&SgRefExp::p_type_name>>;
};
template <> struct node_from_variant_t<667> { using type = SgRefExp; };

// Class: ReferenceType
template <> struct describe_field_t<SgReferenceType,SgType*,&SgReferenceType::p_base_type> {
  using parent = SgReferenceType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgReferenceType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReferenceType, SgType* SgReferenceType::*, &SgReferenceType::p_base_type>;
};
template <> struct describe_node_t<SgReferenceType> {
  using node = SgReferenceType;
  using base = SgType;
  static constexpr char const * const name{"ReferenceType"};
  static constexpr unsigned long variant{668};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgReferenceType,SgType*,&SgReferenceType::p_base_type>>;
};
template <> struct node_from_variant_t<668> { using type = SgReferenceType; };

// Class: RemOp
template <> struct describe_node_t<SgRemOp> {
  using node = SgRemOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"RemOp"};
  static constexpr unsigned long variant{669};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<669> { using type = SgRemOp; };

// Class: RenamePair
template <> struct describe_field_t<SgRenamePair,SgName,&SgRenamePair::p_local_name> {
  using parent = SgRenamePair;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"local_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgRenamePair::p_local_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRenamePair, SgName SgRenamePair::*, &SgRenamePair::p_local_name>;
};
template <> struct describe_field_t<SgRenamePair,SgName,&SgRenamePair::p_use_name> {
  using parent = SgRenamePair;
  using field_type = SgName;
  static constexpr size_t position{1};
  static constexpr char const * const name{"use_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgRenamePair::p_use_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRenamePair, SgName SgRenamePair::*, &SgRenamePair::p_use_name>;
};
template <> struct describe_node_t<SgRenamePair> {
  using node = SgRenamePair;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"RenamePair"};
  static constexpr unsigned long variant{670};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgRenamePair,SgName,&SgRenamePair::p_local_name>, describe_field_t<SgRenamePair,SgName,&SgRenamePair::p_use_name>>;
};
template <> struct node_from_variant_t<670> { using type = SgRenamePair; };

// Class: RenameSymbol
template <> struct describe_field_t<SgRenameSymbol,SgSymbol*,&SgRenameSymbol::p_original_symbol> {
  using parent = SgRenameSymbol;
  using field_type = SgSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"original_symbol"};
  static constexpr char const * const typestr{"SgSymbol*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgRenameSymbol::p_original_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRenameSymbol, SgSymbol* SgRenameSymbol::*, &SgRenameSymbol::p_original_symbol>;
};
template <> struct describe_field_t<SgRenameSymbol,SgName,&SgRenameSymbol::p_new_name> {
  using parent = SgRenameSymbol;
  using field_type = SgName;
  static constexpr size_t position{1};
  static constexpr char const * const name{"new_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgRenameSymbol::p_new_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRenameSymbol, SgName SgRenameSymbol::*, &SgRenameSymbol::p_new_name>;
};
template <> struct describe_node_t<SgRenameSymbol> {
  using node = SgRenameSymbol;
  using base = SgFunctionSymbol;
  static constexpr char const * const name{"RenameSymbol"};
  static constexpr unsigned long variant{671};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgRenameSymbol,SgSymbol*,&SgRenameSymbol::p_original_symbol>, describe_field_t<SgRenameSymbol,SgName,&SgRenameSymbol::p_new_name>>;
};
template <> struct node_from_variant_t<671> { using type = SgRenameSymbol; };

// Class: ReplicationOp
template <> struct describe_node_t<SgReplicationOp> {
  using node = SgReplicationOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"ReplicationOp"};
  static constexpr unsigned long variant{672};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<672> { using type = SgReplicationOp; };

// Class: ReturnStmt
template <> struct describe_field_t<SgReturnStmt,SgExpression*,&SgReturnStmt::p_expression> {
  using parent = SgReturnStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgReturnStmt::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgReturnStmt, SgExpression* SgReturnStmt::*, &SgReturnStmt::p_expression>;
};
template <> struct describe_node_t<SgReturnStmt> {
  using node = SgReturnStmt;
  using base = SgStatement;
  static constexpr char const * const name{"ReturnStmt"};
  static constexpr unsigned long variant{673};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgReturnStmt,SgExpression*,&SgReturnStmt::p_expression>>;
};
template <> struct node_from_variant_t<673> { using type = SgReturnStmt; };

// Class: RewindStatement
template <> struct describe_node_t<SgRewindStatement> {
  using node = SgRewindStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"RewindStatement"};
  static constexpr unsigned long variant{674};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<674> { using type = SgRewindStatement; };

// Class: RshiftAssignOp
template <> struct describe_node_t<SgRshiftAssignOp> {
  using node = SgRshiftAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"RshiftAssignOp"};
  static constexpr unsigned long variant{675};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<675> { using type = SgRshiftAssignOp; };

// Class: RshiftOp
template <> struct describe_node_t<SgRshiftOp> {
  using node = SgRshiftOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"RshiftOp"};
  static constexpr unsigned long variant{676};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<676> { using type = SgRshiftOp; };

// Class: RvalueReferenceType
template <> struct describe_field_t<SgRvalueReferenceType,SgType*,&SgRvalueReferenceType::p_base_type> {
  using parent = SgRvalueReferenceType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgRvalueReferenceType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRvalueReferenceType, SgType* SgRvalueReferenceType::*, &SgRvalueReferenceType::p_base_type>;
};
template <> struct describe_node_t<SgRvalueReferenceType> {
  using node = SgRvalueReferenceType;
  using base = SgType;
  static constexpr char const * const name{"RvalueReferenceType"};
  static constexpr unsigned long variant{677};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgRvalueReferenceType,SgType*,&SgRvalueReferenceType::p_base_type>>;
};
template <> struct node_from_variant_t<677> { using type = SgRvalueReferenceType; };

// Class: JavaUnsignedRshiftAssignOp
template <> struct describe_node_t<SgJavaUnsignedRshiftAssignOp> {
  using node = SgJavaUnsignedRshiftAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"JavaUnsignedRshiftAssignOp"};
  static constexpr unsigned long variant{678};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<678> { using type = SgJavaUnsignedRshiftAssignOp; };

// Class: JavaUnsignedRshiftOp
template <> struct describe_node_t<SgJavaUnsignedRshiftOp> {
  using node = SgJavaUnsignedRshiftOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"JavaUnsignedRshiftOp"};
  static constexpr unsigned long variant{679};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<679> { using type = SgJavaUnsignedRshiftOp; };

// Class: ScopeOp
template <> struct describe_node_t<SgScopeOp> {
  using node = SgScopeOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"ScopeOp"};
  static constexpr unsigned long variant{680};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<680> { using type = SgScopeOp; };

// Class: ScopeStatement
template <> struct describe_field_t<SgScopeStatement,SgSymbolTable*,&SgScopeStatement::p_symbol_table> {
  using parent = SgScopeStatement;
  using field_type = SgSymbolTable*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol_table"};
  static constexpr char const * const typestr{"SgSymbolTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgScopeStatement::p_symbol_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgScopeStatement, SgSymbolTable* SgScopeStatement::*, &SgScopeStatement::p_symbol_table>;
};
template <> struct describe_field_t<SgScopeStatement,SgTypeTable*,&SgScopeStatement::p_type_table> {
  using parent = SgScopeStatement;
  using field_type = SgTypeTable*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"type_table"};
  static constexpr char const * const typestr{"SgTypeTable*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgScopeStatement::p_type_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgScopeStatement, SgTypeTable* SgScopeStatement::*, &SgScopeStatement::p_type_table>;
};
template <> struct describe_field_t<SgScopeStatement,std::set<SgSymbol*>,&SgScopeStatement::p_type_elaboration_list> {
  using parent = SgScopeStatement;
  using field_type = std::set<SgSymbol*>;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type_elaboration_list"};
  static constexpr char const * const typestr{"std::set<SgSymbol*>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgScopeStatement::p_type_elaboration_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgScopeStatement, std::set<SgSymbol*> SgScopeStatement::*, &SgScopeStatement::p_type_elaboration_list>;
};
template <> struct describe_field_t<SgScopeStatement,std::set<SgSymbol*>,&SgScopeStatement::p_hidden_type_list> {
  using parent = SgScopeStatement;
  using field_type = std::set<SgSymbol*>;
  static constexpr size_t position{3};
  static constexpr char const * const name{"hidden_type_list"};
  static constexpr char const * const typestr{"std::set<SgSymbol*>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgScopeStatement::p_hidden_type_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgScopeStatement, std::set<SgSymbol*> SgScopeStatement::*, &SgScopeStatement::p_hidden_type_list>;
};
template <> struct describe_field_t<SgScopeStatement,std::set<SgSymbol*>,&SgScopeStatement::p_hidden_declaration_list> {
  using parent = SgScopeStatement;
  using field_type = std::set<SgSymbol*>;
  static constexpr size_t position{4};
  static constexpr char const * const name{"hidden_declaration_list"};
  static constexpr char const * const typestr{"std::set<SgSymbol*>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgScopeStatement::p_hidden_declaration_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgScopeStatement, std::set<SgSymbol*> SgScopeStatement::*, &SgScopeStatement::p_hidden_declaration_list>;
};
template <> struct describe_field_t<SgScopeStatement,SgPragma*,&SgScopeStatement::p_pragma> {
  using parent = SgScopeStatement;
  using field_type = SgPragma*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"pragma"};
  static constexpr char const * const typestr{"SgPragma*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgScopeStatement::p_pragma};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgScopeStatement, SgPragma* SgScopeStatement::*, &SgScopeStatement::p_pragma>;
};
template <> struct describe_node_t<SgScopeStatement> {
  using node = SgScopeStatement;
  using base = SgStatement;
  static constexpr char const * const name{"ScopeStatement"};
  static constexpr unsigned long variant{681};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgGlobal, SgBasicBlock, SgIfStmt, SgForStatement, SgFunctionDefinition, SgClassDefinition, SgWhileStmt, SgDoWhileStmt, SgSwitchStatement, SgCatchOptionStmt, SgNamespaceDefinitionStatement, SgBlockDataStatement, SgAssociateStatement, SgFortranDo, SgForAllStatement, SgUpcForAllStatement, SgCAFWithTeamStatement, SgJavaForEachStatement, SgJavaLabelStatement, SgMatlabForStatement, SgFunctionParameterScope, SgDeclarationScope, SgRangeBasedForStatement, SgJovialForThenStatement, SgAdaAcceptStmt, SgAdaPackageSpec, SgAdaPackageBody, SgAdaTaskSpec, SgAdaTaskBody, SgAdaProtectedBody, SgAdaProtectedSpec, SgAdaGenericDefn>;
  using fields_t = mp::List<describe_field_t<SgScopeStatement,SgSymbolTable*,&SgScopeStatement::p_symbol_table>, describe_field_t<SgScopeStatement,SgTypeTable*,&SgScopeStatement::p_type_table>, describe_field_t<SgScopeStatement,std::set<SgSymbol*>,&SgScopeStatement::p_type_elaboration_list>, describe_field_t<SgScopeStatement,std::set<SgSymbol*>,&SgScopeStatement::p_hidden_type_list>, describe_field_t<SgScopeStatement,std::set<SgSymbol*>,&SgScopeStatement::p_hidden_declaration_list>, describe_field_t<SgScopeStatement,SgPragma*,&SgScopeStatement::p_pragma>>;
};
template <> struct node_from_variant_t<681> { using type = SgScopeStatement; };

// Class: SequenceStatement
template <> struct describe_node_t<SgSequenceStatement> {
  using node = SgSequenceStatement;
  using base = SgStatement;
  static constexpr char const * const name{"SequenceStatement"};
  static constexpr unsigned long variant{682};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<682> { using type = SgSequenceStatement; };

// Class: SetComprehension
template <> struct describe_field_t<SgSetComprehension,SgExpression*,&SgSetComprehension::p_element> {
  using parent = SgSetComprehension;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"element"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSetComprehension::p_element};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSetComprehension, SgExpression* SgSetComprehension::*, &SgSetComprehension::p_element>;
};
template <> struct describe_field_t<SgSetComprehension,SgExprListExp*,&SgSetComprehension::p_generators> {
  using parent = SgSetComprehension;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"generators"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSetComprehension::p_generators};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSetComprehension, SgExprListExp* SgSetComprehension::*, &SgSetComprehension::p_generators>;
};
template <> struct describe_node_t<SgSetComprehension> {
  using node = SgSetComprehension;
  using base = SgExpression;
  static constexpr char const * const name{"SetComprehension"};
  static constexpr unsigned long variant{683};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSetComprehension,SgExpression*,&SgSetComprehension::p_element>, describe_field_t<SgSetComprehension,SgExprListExp*,&SgSetComprehension::p_generators>>;
};
template <> struct node_from_variant_t<683> { using type = SgSetComprehension; };

// Class: ShortVal
template <> struct describe_field_t<SgShortVal,short,&SgShortVal::p_value> {
  using parent = SgShortVal;
  using field_type = short;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgShortVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgShortVal, short SgShortVal::*, &SgShortVal::p_value>;
};
template <> struct describe_field_t<SgShortVal,std::string,&SgShortVal::p_valueString> {
  using parent = SgShortVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgShortVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgShortVal, std::string SgShortVal::*, &SgShortVal::p_valueString>;
};
template <> struct describe_node_t<SgShortVal> {
  using node = SgShortVal;
  using base = SgValueExp;
  static constexpr char const * const name{"ShortVal"};
  static constexpr unsigned long variant{684};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgShortVal,short,&SgShortVal::p_value>, describe_field_t<SgShortVal,std::string,&SgShortVal::p_valueString>>;
};
template <> struct node_from_variant_t<684> { using type = SgShortVal; };

// Class: SizeOfOp
template <> struct describe_field_t<SgSizeOfOp,SgExpression*,&SgSizeOfOp::p_operand_expr> {
  using parent = SgSizeOfOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_expr"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_operand_expr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, SgExpression* SgSizeOfOp::*, &SgSizeOfOp::p_operand_expr>;
};
template <> struct describe_field_t<SgSizeOfOp,SgType*,&SgSizeOfOp::p_operand_type> {
  using parent = SgSizeOfOp;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operand_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_operand_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, SgType* SgSizeOfOp::*, &SgSizeOfOp::p_operand_type>;
};
template <> struct describe_field_t<SgSizeOfOp,SgType*,&SgSizeOfOp::p_expression_type> {
  using parent = SgSizeOfOp;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, SgType* SgSizeOfOp::*, &SgSizeOfOp::p_expression_type>;
};
template <> struct describe_field_t<SgSizeOfOp,int,&SgSizeOfOp::p_name_qualification_length> {
  using parent = SgSizeOfOp;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, int SgSizeOfOp::*, &SgSizeOfOp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_type_elaboration_required> {
  using parent = SgSizeOfOp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, bool SgSizeOfOp::*, &SgSizeOfOp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_global_qualification_required> {
  using parent = SgSizeOfOp;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, bool SgSizeOfOp::*, &SgSizeOfOp::p_global_qualification_required>;
};
template <> struct describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_sizeOfContainsBaseTypeDefiningDeclaration> {
  using parent = SgSizeOfOp;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"sizeOfContainsBaseTypeDefiningDeclaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_sizeOfContainsBaseTypeDefiningDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, bool SgSizeOfOp::*, &SgSizeOfOp::p_sizeOfContainsBaseTypeDefiningDeclaration>;
};
template <> struct describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_is_objectless_nonstatic_data_member_reference> {
  using parent = SgSizeOfOp;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"is_objectless_nonstatic_data_member_reference"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_is_objectless_nonstatic_data_member_reference};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, bool SgSizeOfOp::*, &SgSizeOfOp::p_is_objectless_nonstatic_data_member_reference>;
};
template <> struct describe_field_t<SgSizeOfOp,int,&SgSizeOfOp::p_name_qualification_for_pointer_to_member_class_length> {
  using parent = SgSizeOfOp;
  using field_type = int;
  static constexpr size_t position{8};
  static constexpr char const * const name{"name_qualification_for_pointer_to_member_class_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_name_qualification_for_pointer_to_member_class_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, int SgSizeOfOp::*, &SgSizeOfOp::p_name_qualification_for_pointer_to_member_class_length>;
};
template <> struct describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_type_elaboration_for_pointer_to_member_class_required> {
  using parent = SgSizeOfOp;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"type_elaboration_for_pointer_to_member_class_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_type_elaboration_for_pointer_to_member_class_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, bool SgSizeOfOp::*, &SgSizeOfOp::p_type_elaboration_for_pointer_to_member_class_required>;
};
template <> struct describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_global_qualification_for_pointer_to_member_class_required> {
  using parent = SgSizeOfOp;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"global_qualification_for_pointer_to_member_class_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSizeOfOp::p_global_qualification_for_pointer_to_member_class_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSizeOfOp, bool SgSizeOfOp::*, &SgSizeOfOp::p_global_qualification_for_pointer_to_member_class_required>;
};
template <> struct describe_node_t<SgSizeOfOp> {
  using node = SgSizeOfOp;
  using base = SgExpression;
  static constexpr char const * const name{"SizeOfOp"};
  static constexpr unsigned long variant{685};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSizeOfOp,SgExpression*,&SgSizeOfOp::p_operand_expr>, describe_field_t<SgSizeOfOp,SgType*,&SgSizeOfOp::p_operand_type>, describe_field_t<SgSizeOfOp,SgType*,&SgSizeOfOp::p_expression_type>, describe_field_t<SgSizeOfOp,int,&SgSizeOfOp::p_name_qualification_length>, describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_type_elaboration_required>, describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_global_qualification_required>, describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_sizeOfContainsBaseTypeDefiningDeclaration>, describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_is_objectless_nonstatic_data_member_reference>, describe_field_t<SgSizeOfOp,int,&SgSizeOfOp::p_name_qualification_for_pointer_to_member_class_length>, describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_type_elaboration_for_pointer_to_member_class_required>, describe_field_t<SgSizeOfOp,bool,&SgSizeOfOp::p_global_qualification_for_pointer_to_member_class_required>>;
};
template <> struct node_from_variant_t<685> { using type = SgSizeOfOp; };

// Class: AlignOfOp
template <> struct describe_field_t<SgAlignOfOp,SgExpression*,&SgAlignOfOp::p_operand_expr> {
  using parent = SgAlignOfOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_expr"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAlignOfOp::p_operand_expr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAlignOfOp, SgExpression* SgAlignOfOp::*, &SgAlignOfOp::p_operand_expr>;
};
template <> struct describe_field_t<SgAlignOfOp,SgType*,&SgAlignOfOp::p_operand_type> {
  using parent = SgAlignOfOp;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operand_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAlignOfOp::p_operand_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAlignOfOp, SgType* SgAlignOfOp::*, &SgAlignOfOp::p_operand_type>;
};
template <> struct describe_field_t<SgAlignOfOp,SgType*,&SgAlignOfOp::p_expression_type> {
  using parent = SgAlignOfOp;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAlignOfOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAlignOfOp, SgType* SgAlignOfOp::*, &SgAlignOfOp::p_expression_type>;
};
template <> struct describe_field_t<SgAlignOfOp,int,&SgAlignOfOp::p_name_qualification_length> {
  using parent = SgAlignOfOp;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAlignOfOp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAlignOfOp, int SgAlignOfOp::*, &SgAlignOfOp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgAlignOfOp,bool,&SgAlignOfOp::p_type_elaboration_required> {
  using parent = SgAlignOfOp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAlignOfOp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAlignOfOp, bool SgAlignOfOp::*, &SgAlignOfOp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgAlignOfOp,bool,&SgAlignOfOp::p_global_qualification_required> {
  using parent = SgAlignOfOp;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAlignOfOp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAlignOfOp, bool SgAlignOfOp::*, &SgAlignOfOp::p_global_qualification_required>;
};
template <> struct describe_field_t<SgAlignOfOp,bool,&SgAlignOfOp::p_alignOfContainsBaseTypeDefiningDeclaration> {
  using parent = SgAlignOfOp;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"alignOfContainsBaseTypeDefiningDeclaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAlignOfOp::p_alignOfContainsBaseTypeDefiningDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAlignOfOp, bool SgAlignOfOp::*, &SgAlignOfOp::p_alignOfContainsBaseTypeDefiningDeclaration>;
};
template <> struct describe_node_t<SgAlignOfOp> {
  using node = SgAlignOfOp;
  using base = SgExpression;
  static constexpr char const * const name{"AlignOfOp"};
  static constexpr unsigned long variant{686};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAlignOfOp,SgExpression*,&SgAlignOfOp::p_operand_expr>, describe_field_t<SgAlignOfOp,SgType*,&SgAlignOfOp::p_operand_type>, describe_field_t<SgAlignOfOp,SgType*,&SgAlignOfOp::p_expression_type>, describe_field_t<SgAlignOfOp,int,&SgAlignOfOp::p_name_qualification_length>, describe_field_t<SgAlignOfOp,bool,&SgAlignOfOp::p_type_elaboration_required>, describe_field_t<SgAlignOfOp,bool,&SgAlignOfOp::p_global_qualification_required>, describe_field_t<SgAlignOfOp,bool,&SgAlignOfOp::p_alignOfContainsBaseTypeDefiningDeclaration>>;
};
template <> struct node_from_variant_t<686> { using type = SgAlignOfOp; };

// Class: JavaInstanceOfOp
template <> struct describe_field_t<SgJavaInstanceOfOp,SgExpression*,&SgJavaInstanceOfOp::p_operand_expr> {
  using parent = SgJavaInstanceOfOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_expr"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaInstanceOfOp::p_operand_expr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaInstanceOfOp, SgExpression* SgJavaInstanceOfOp::*, &SgJavaInstanceOfOp::p_operand_expr>;
};
template <> struct describe_field_t<SgJavaInstanceOfOp,SgType*,&SgJavaInstanceOfOp::p_operand_type> {
  using parent = SgJavaInstanceOfOp;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operand_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaInstanceOfOp::p_operand_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaInstanceOfOp, SgType* SgJavaInstanceOfOp::*, &SgJavaInstanceOfOp::p_operand_type>;
};
template <> struct describe_field_t<SgJavaInstanceOfOp,SgType*,&SgJavaInstanceOfOp::p_expression_type> {
  using parent = SgJavaInstanceOfOp;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaInstanceOfOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaInstanceOfOp, SgType* SgJavaInstanceOfOp::*, &SgJavaInstanceOfOp::p_expression_type>;
};
template <> struct describe_node_t<SgJavaInstanceOfOp> {
  using node = SgJavaInstanceOfOp;
  using base = SgExpression;
  static constexpr char const * const name{"JavaInstanceOfOp"};
  static constexpr unsigned long variant{687};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaInstanceOfOp,SgExpression*,&SgJavaInstanceOfOp::p_operand_expr>, describe_field_t<SgJavaInstanceOfOp,SgType*,&SgJavaInstanceOfOp::p_operand_type>, describe_field_t<SgJavaInstanceOfOp,SgType*,&SgJavaInstanceOfOp::p_expression_type>>;
};
template <> struct node_from_variant_t<687> { using type = SgJavaInstanceOfOp; };

// Class: SourceFile
template <> struct describe_field_t<SgSourceFile,SgGlobal*,&SgSourceFile::p_globalScope> {
  using parent = SgSourceFile;
  using field_type = SgGlobal*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"globalScope"};
  static constexpr char const * const typestr{"SgGlobal*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSourceFile::p_globalScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgGlobal* SgSourceFile::*, &SgSourceFile::p_globalScope>;
};
template <> struct describe_field_t<SgSourceFile,SgModuleStatementPtrList,&SgSourceFile::p_module_list> {
  using parent = SgSourceFile;
  using field_type = SgModuleStatementPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"module_list"};
  static constexpr char const * const typestr{"SgModuleStatementPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_module_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgModuleStatementPtrList SgSourceFile::*, &SgSourceFile::p_module_list>;
};
template <> struct describe_field_t<SgSourceFile,SgTokenPtrList,&SgSourceFile::p_token_list> {
  using parent = SgSourceFile;
  using field_type = SgTokenPtrList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"token_list"};
  static constexpr char const * const typestr{"SgTokenPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_token_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgTokenPtrList SgSourceFile::*, &SgSourceFile::p_token_list>;
};
template <> struct describe_field_t<SgSourceFile,SgGlobal*,&SgSourceFile::p_temp_holding_scope> {
  using parent = SgSourceFile;
  using field_type = SgGlobal*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"temp_holding_scope"};
  static constexpr char const * const typestr{"SgGlobal*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_temp_holding_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgGlobal* SgSourceFile::*, &SgSourceFile::p_temp_holding_scope>;
};
template <> struct describe_field_t<SgSourceFile,SgJavaPackageStatement *,&SgSourceFile::p_package> {
  using parent = SgSourceFile;
  using field_type = SgJavaPackageStatement *;
  static constexpr size_t position{4};
  static constexpr char const * const name{"package"};
  static constexpr char const * const typestr{"SgJavaPackageStatement *"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSourceFile::p_package};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgJavaPackageStatement * SgSourceFile::*, &SgSourceFile::p_package>;
};
template <> struct describe_field_t<SgSourceFile,SgJavaImportStatementList*,&SgSourceFile::p_import_list> {
  using parent = SgSourceFile;
  using field_type = SgJavaImportStatementList*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"import_list"};
  static constexpr char const * const typestr{"SgJavaImportStatementList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSourceFile::p_import_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgJavaImportStatementList* SgSourceFile::*, &SgSourceFile::p_import_list>;
};
template <> struct describe_field_t<SgSourceFile,SgJavaClassDeclarationList*,&SgSourceFile::p_class_list> {
  using parent = SgSourceFile;
  using field_type = SgJavaClassDeclarationList*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"class_list"};
  static constexpr char const * const typestr{"SgJavaClassDeclarationList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSourceFile::p_class_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgJavaClassDeclarationList* SgSourceFile::*, &SgSourceFile::p_class_list>;
};
template <> struct describe_field_t<SgSourceFile,bool,&SgSourceFile::p_isHeaderFile> {
  using parent = SgSourceFile;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"isHeaderFile"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_isHeaderFile};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, bool SgSourceFile::*, &SgSourceFile::p_isHeaderFile>;
};
template <> struct describe_field_t<SgSourceFile,bool,&SgSourceFile::p_isHeaderFileIncludedMoreThanOnce> {
  using parent = SgSourceFile;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"isHeaderFileIncludedMoreThanOnce"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_isHeaderFileIncludedMoreThanOnce};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, bool SgSourceFile::*, &SgSourceFile::p_isHeaderFileIncludedMoreThanOnce>;
};
template <> struct describe_field_t<SgSourceFile,SgHeaderFileReport*,&SgSourceFile::p_headerFileReport> {
  using parent = SgSourceFile;
  using field_type = SgHeaderFileReport*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"headerFileReport"};
  static constexpr char const * const typestr{"SgHeaderFileReport*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_headerFileReport};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgHeaderFileReport* SgSourceFile::*, &SgSourceFile::p_headerFileReport>;
};
template <> struct describe_field_t<SgSourceFile,SgStringList,&SgSourceFile::p_extraIncludeDirectorySpecifierBeforeList> {
  using parent = SgSourceFile;
  using field_type = SgStringList;
  static constexpr size_t position{10};
  static constexpr char const * const name{"extraIncludeDirectorySpecifierBeforeList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_extraIncludeDirectorySpecifierBeforeList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgStringList SgSourceFile::*, &SgSourceFile::p_extraIncludeDirectorySpecifierBeforeList>;
};
template <> struct describe_field_t<SgSourceFile,SgStringList,&SgSourceFile::p_extraIncludeDirectorySpecifierAfterList> {
  using parent = SgSourceFile;
  using field_type = SgStringList;
  static constexpr size_t position{11};
  static constexpr char const * const name{"extraIncludeDirectorySpecifierAfterList"};
  static constexpr char const * const typestr{"SgStringList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_extraIncludeDirectorySpecifierAfterList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgStringList SgSourceFile::*, &SgSourceFile::p_extraIncludeDirectorySpecifierAfterList>;
};
template <> struct describe_field_t<SgSourceFile,SgIncludeFile*,&SgSourceFile::p_associated_include_file> {
  using parent = SgSourceFile;
  using field_type = SgIncludeFile*;
  static constexpr size_t position{12};
  static constexpr char const * const name{"associated_include_file"};
  static constexpr char const * const typestr{"SgIncludeFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_associated_include_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgIncludeFile* SgSourceFile::*, &SgSourceFile::p_associated_include_file>;
};
template <> struct describe_field_t<SgSourceFile,bool,&SgSourceFile::p_processedToIncludeCppDirectivesAndComments> {
  using parent = SgSourceFile;
  using field_type = bool;
  static constexpr size_t position{13};
  static constexpr char const * const name{"processedToIncludeCppDirectivesAndComments"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_processedToIncludeCppDirectivesAndComments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, bool SgSourceFile::*, &SgSourceFile::p_processedToIncludeCppDirectivesAndComments>;
};
template <> struct describe_field_t<SgSourceFile,SgNodePtrList,&SgSourceFile::p_extra_nodes_for_namequal_init> {
  using parent = SgSourceFile;
  using field_type = SgNodePtrList;
  static constexpr size_t position{14};
  static constexpr char const * const name{"extra_nodes_for_namequal_init"};
  static constexpr char const * const typestr{"SgNodePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_extra_nodes_for_namequal_init};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgNodePtrList SgSourceFile::*, &SgSourceFile::p_extra_nodes_for_namequal_init>;
};
template <> struct describe_field_t<SgSourceFile,bool,&SgSourceFile::p_isDynamicLibrary> {
  using parent = SgSourceFile;
  using field_type = bool;
  static constexpr size_t position{15};
  static constexpr char const * const name{"isDynamicLibrary"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_isDynamicLibrary};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, bool SgSourceFile::*, &SgSourceFile::p_isDynamicLibrary>;
};
template <> struct describe_field_t<SgSourceFile,SgStatement*,&SgSourceFile::p_firstStatement> {
  using parent = SgSourceFile;
  using field_type = SgStatement*;
  static constexpr size_t position{16};
  static constexpr char const * const name{"firstStatement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_firstStatement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgStatement* SgSourceFile::*, &SgSourceFile::p_firstStatement>;
};
template <> struct describe_field_t<SgSourceFile,SgStatement*,&SgSourceFile::p_lastStatement> {
  using parent = SgSourceFile;
  using field_type = SgStatement*;
  static constexpr size_t position{17};
  static constexpr char const * const name{"lastStatement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSourceFile::p_lastStatement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSourceFile, SgStatement* SgSourceFile::*, &SgSourceFile::p_lastStatement>;
};
template <> struct describe_node_t<SgSourceFile> {
  using node = SgSourceFile;
  using base = SgFile;
  static constexpr char const * const name{"SourceFile"};
  static constexpr unsigned long variant{688};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSourceFile,SgGlobal*,&SgSourceFile::p_globalScope>, describe_field_t<SgSourceFile,SgModuleStatementPtrList,&SgSourceFile::p_module_list>, describe_field_t<SgSourceFile,SgTokenPtrList,&SgSourceFile::p_token_list>, describe_field_t<SgSourceFile,SgGlobal*,&SgSourceFile::p_temp_holding_scope>, describe_field_t<SgSourceFile,SgJavaPackageStatement *,&SgSourceFile::p_package>, describe_field_t<SgSourceFile,SgJavaImportStatementList*,&SgSourceFile::p_import_list>, describe_field_t<SgSourceFile,SgJavaClassDeclarationList*,&SgSourceFile::p_class_list>, describe_field_t<SgSourceFile,bool,&SgSourceFile::p_isHeaderFile>, describe_field_t<SgSourceFile,bool,&SgSourceFile::p_isHeaderFileIncludedMoreThanOnce>, describe_field_t<SgSourceFile,SgHeaderFileReport*,&SgSourceFile::p_headerFileReport>, describe_field_t<SgSourceFile,SgStringList,&SgSourceFile::p_extraIncludeDirectorySpecifierBeforeList>, describe_field_t<SgSourceFile,SgStringList,&SgSourceFile::p_extraIncludeDirectorySpecifierAfterList>, describe_field_t<SgSourceFile,SgIncludeFile*,&SgSourceFile::p_associated_include_file>, describe_field_t<SgSourceFile,bool,&SgSourceFile::p_processedToIncludeCppDirectivesAndComments>, describe_field_t<SgSourceFile,SgNodePtrList,&SgSourceFile::p_extra_nodes_for_namequal_init>, describe_field_t<SgSourceFile,bool,&SgSourceFile::p_isDynamicLibrary>, describe_field_t<SgSourceFile,SgStatement*,&SgSourceFile::p_firstStatement>, describe_field_t<SgSourceFile,SgStatement*,&SgSourceFile::p_lastStatement>>;
};
template <> struct node_from_variant_t<688> { using type = SgSourceFile; };

// Class: SpaceshipOp
template <> struct describe_node_t<SgSpaceshipOp> {
  using node = SgSpaceshipOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"SpaceshipOp"};
  static constexpr unsigned long variant{689};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<689> { using type = SgSpaceshipOp; };

// Class: SpawnStmt
template <> struct describe_field_t<SgSpawnStmt,SgFunctionCallExp*,&SgSpawnStmt::p_the_func> {
  using parent = SgSpawnStmt;
  using field_type = SgFunctionCallExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"the_func"};
  static constexpr char const * const typestr{"SgFunctionCallExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSpawnStmt::p_the_func};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSpawnStmt, SgFunctionCallExp* SgSpawnStmt::*, &SgSpawnStmt::p_the_func>;
};
template <> struct describe_node_t<SgSpawnStmt> {
  using node = SgSpawnStmt;
  using base = SgStatement;
  static constexpr char const * const name{"SpawnStmt"};
  static constexpr unsigned long variant{690};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSpawnStmt,SgFunctionCallExp*,&SgSpawnStmt::p_the_func>>;
};
template <> struct node_from_variant_t<690> { using type = SgSpawnStmt; };

// Class: SyncAllStatement
template <> struct describe_node_t<SgSyncAllStatement> {
  using node = SgSyncAllStatement;
  using base = SgImageControlStatement;
  static constexpr char const * const name{"SyncAllStatement"};
  static constexpr unsigned long variant{691};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<691> { using type = SgSyncAllStatement; };

// Class: SyncImagesStatement
template <> struct describe_field_t<SgSyncImagesStatement,SgExpression*,&SgSyncImagesStatement::p_image_set> {
  using parent = SgSyncImagesStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"image_set"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSyncImagesStatement::p_image_set};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSyncImagesStatement, SgExpression* SgSyncImagesStatement::*, &SgSyncImagesStatement::p_image_set>;
};
template <> struct describe_node_t<SgSyncImagesStatement> {
  using node = SgSyncImagesStatement;
  using base = SgImageControlStatement;
  static constexpr char const * const name{"SyncImagesStatement"};
  static constexpr unsigned long variant{692};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSyncImagesStatement,SgExpression*,&SgSyncImagesStatement::p_image_set>>;
};
template <> struct node_from_variant_t<692> { using type = SgSyncImagesStatement; };

// Class: SyncMemoryStatement
template <> struct describe_node_t<SgSyncMemoryStatement> {
  using node = SgSyncMemoryStatement;
  using base = SgImageControlStatement;
  static constexpr char const * const name{"SyncMemoryStatement"};
  static constexpr unsigned long variant{693};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<693> { using type = SgSyncMemoryStatement; };

// Class: SyncTeamStatement
template <> struct describe_field_t<SgSyncTeamStatement,SgExpression*,&SgSyncTeamStatement::p_team_value> {
  using parent = SgSyncTeamStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"team_value"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSyncTeamStatement::p_team_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSyncTeamStatement, SgExpression* SgSyncTeamStatement::*, &SgSyncTeamStatement::p_team_value>;
};
template <> struct describe_node_t<SgSyncTeamStatement> {
  using node = SgSyncTeamStatement;
  using base = SgImageControlStatement;
  static constexpr char const * const name{"SyncTeamStatement"};
  static constexpr unsigned long variant{694};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSyncTeamStatement,SgExpression*,&SgSyncTeamStatement::p_team_value>>;
};
template <> struct node_from_variant_t<694> { using type = SgSyncTeamStatement; };

// Class: LockStatement
template <> struct describe_field_t<SgLockStatement,SgExpression*,&SgLockStatement::p_lock_variable> {
  using parent = SgLockStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lock_variable"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgLockStatement::p_lock_variable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgLockStatement, SgExpression* SgLockStatement::*, &SgLockStatement::p_lock_variable>;
};
template <> struct describe_node_t<SgLockStatement> {
  using node = SgLockStatement;
  using base = SgImageControlStatement;
  static constexpr char const * const name{"LockStatement"};
  static constexpr unsigned long variant{695};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgLockStatement,SgExpression*,&SgLockStatement::p_lock_variable>>;
};
template <> struct node_from_variant_t<695> { using type = SgLockStatement; };

// Class: UnlockStatement
template <> struct describe_field_t<SgUnlockStatement,SgExpression*,&SgUnlockStatement::p_lock_variable> {
  using parent = SgUnlockStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lock_variable"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUnlockStatement::p_lock_variable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnlockStatement, SgExpression* SgUnlockStatement::*, &SgUnlockStatement::p_lock_variable>;
};
template <> struct describe_node_t<SgUnlockStatement> {
  using node = SgUnlockStatement;
  using base = SgImageControlStatement;
  static constexpr char const * const name{"UnlockStatement"};
  static constexpr unsigned long variant{696};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUnlockStatement,SgExpression*,&SgUnlockStatement::p_lock_variable>>;
};
template <> struct node_from_variant_t<696> { using type = SgUnlockStatement; };

// Class: JavaThrowStatement
template <> struct describe_field_t<SgJavaThrowStatement,SgThrowOp*,&SgJavaThrowStatement::p_throwOp> {
  using parent = SgJavaThrowStatement;
  using field_type = SgThrowOp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"throwOp"};
  static constexpr char const * const typestr{"SgThrowOp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaThrowStatement::p_throwOp};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaThrowStatement, SgThrowOp* SgJavaThrowStatement::*, &SgJavaThrowStatement::p_throwOp>;
};
template <> struct describe_node_t<SgJavaThrowStatement> {
  using node = SgJavaThrowStatement;
  using base = SgStatement;
  static constexpr char const * const name{"JavaThrowStatement"};
  static constexpr unsigned long variant{697};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaThrowStatement,SgThrowOp*,&SgJavaThrowStatement::p_throwOp>>;
};
template <> struct node_from_variant_t<697> { using type = SgJavaThrowStatement; };

// Class: JavaForEachStatement
template <> struct describe_field_t<SgJavaForEachStatement,SgVariableDeclaration*,&SgJavaForEachStatement::p_element> {
  using parent = SgJavaForEachStatement;
  using field_type = SgVariableDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"element"};
  static constexpr char const * const typestr{"SgVariableDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaForEachStatement::p_element};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaForEachStatement, SgVariableDeclaration* SgJavaForEachStatement::*, &SgJavaForEachStatement::p_element>;
};
template <> struct describe_field_t<SgJavaForEachStatement,SgExpression*,&SgJavaForEachStatement::p_collection> {
  using parent = SgJavaForEachStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"collection"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaForEachStatement::p_collection};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaForEachStatement, SgExpression* SgJavaForEachStatement::*, &SgJavaForEachStatement::p_collection>;
};
template <> struct describe_field_t<SgJavaForEachStatement,SgStatement*,&SgJavaForEachStatement::p_loop_body> {
  using parent = SgJavaForEachStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"loop_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaForEachStatement::p_loop_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaForEachStatement, SgStatement* SgJavaForEachStatement::*, &SgJavaForEachStatement::p_loop_body>;
};
template <> struct describe_node_t<SgJavaForEachStatement> {
  using node = SgJavaForEachStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"JavaForEachStatement"};
  static constexpr unsigned long variant{698};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaForEachStatement,SgVariableDeclaration*,&SgJavaForEachStatement::p_element>, describe_field_t<SgJavaForEachStatement,SgExpression*,&SgJavaForEachStatement::p_collection>, describe_field_t<SgJavaForEachStatement,SgStatement*,&SgJavaForEachStatement::p_loop_body>>;
};
template <> struct node_from_variant_t<698> { using type = SgJavaForEachStatement; };

// Class: JavaSynchronizedStatement
template <> struct describe_field_t<SgJavaSynchronizedStatement,SgExpression*,&SgJavaSynchronizedStatement::p_expression> {
  using parent = SgJavaSynchronizedStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaSynchronizedStatement::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaSynchronizedStatement, SgExpression* SgJavaSynchronizedStatement::*, &SgJavaSynchronizedStatement::p_expression>;
};
template <> struct describe_field_t<SgJavaSynchronizedStatement,SgStatement*,&SgJavaSynchronizedStatement::p_body> {
  using parent = SgJavaSynchronizedStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaSynchronizedStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaSynchronizedStatement, SgStatement* SgJavaSynchronizedStatement::*, &SgJavaSynchronizedStatement::p_body>;
};
template <> struct describe_node_t<SgJavaSynchronizedStatement> {
  using node = SgJavaSynchronizedStatement;
  using base = SgStatement;
  static constexpr char const * const name{"JavaSynchronizedStatement"};
  static constexpr unsigned long variant{699};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaSynchronizedStatement,SgExpression*,&SgJavaSynchronizedStatement::p_expression>, describe_field_t<SgJavaSynchronizedStatement,SgStatement*,&SgJavaSynchronizedStatement::p_body>>;
};
template <> struct node_from_variant_t<699> { using type = SgJavaSynchronizedStatement; };

// Class: JavaParameterizedType
template <> struct describe_field_t<SgJavaParameterizedType,SgNamedType*,&SgJavaParameterizedType::p_raw_type> {
  using parent = SgJavaParameterizedType;
  using field_type = SgNamedType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"raw_type"};
  static constexpr char const * const typestr{"SgNamedType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaParameterizedType::p_raw_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaParameterizedType, SgNamedType* SgJavaParameterizedType::*, &SgJavaParameterizedType::p_raw_type>;
};
template <> struct describe_field_t<SgJavaParameterizedType,SgTemplateParameterList*,&SgJavaParameterizedType::p_type_list> {
  using parent = SgJavaParameterizedType;
  using field_type = SgTemplateParameterList*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"type_list"};
  static constexpr char const * const typestr{"SgTemplateParameterList*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaParameterizedType::p_type_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaParameterizedType, SgTemplateParameterList* SgJavaParameterizedType::*, &SgJavaParameterizedType::p_type_list>;
};
template <> struct describe_node_t<SgJavaParameterizedType> {
  using node = SgJavaParameterizedType;
  using base = SgNamedType;
  static constexpr char const * const name{"JavaParameterizedType"};
  static constexpr unsigned long variant{700};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaParameterizedType,SgNamedType*,&SgJavaParameterizedType::p_raw_type>, describe_field_t<SgJavaParameterizedType,SgTemplateParameterList*,&SgJavaParameterizedType::p_type_list>>;
};
template <> struct node_from_variant_t<700> { using type = SgJavaParameterizedType; };

// Class: JavaWildcardType
template <> struct describe_field_t<SgJavaWildcardType,SgType*,&SgJavaWildcardType::p_bound_type> {
  using parent = SgJavaWildcardType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"bound_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaWildcardType::p_bound_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaWildcardType, SgType* SgJavaWildcardType::*, &SgJavaWildcardType::p_bound_type>;
};
template <> struct describe_field_t<SgJavaWildcardType,bool,&SgJavaWildcardType::p_is_unbound> {
  using parent = SgJavaWildcardType;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"is_unbound"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaWildcardType::p_is_unbound};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaWildcardType, bool SgJavaWildcardType::*, &SgJavaWildcardType::p_is_unbound>;
};
template <> struct describe_field_t<SgJavaWildcardType,bool,&SgJavaWildcardType::p_has_extends> {
  using parent = SgJavaWildcardType;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"has_extends"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaWildcardType::p_has_extends};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaWildcardType, bool SgJavaWildcardType::*, &SgJavaWildcardType::p_has_extends>;
};
template <> struct describe_field_t<SgJavaWildcardType,bool,&SgJavaWildcardType::p_has_super> {
  using parent = SgJavaWildcardType;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"has_super"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaWildcardType::p_has_super};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaWildcardType, bool SgJavaWildcardType::*, &SgJavaWildcardType::p_has_super>;
};
template <> struct describe_node_t<SgJavaWildcardType> {
  using node = SgJavaWildcardType;
  using base = SgNamedType;
  static constexpr char const * const name{"JavaWildcardType"};
  static constexpr unsigned long variant{701};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaWildcardType,SgType*,&SgJavaWildcardType::p_bound_type>, describe_field_t<SgJavaWildcardType,bool,&SgJavaWildcardType::p_is_unbound>, describe_field_t<SgJavaWildcardType,bool,&SgJavaWildcardType::p_has_extends>, describe_field_t<SgJavaWildcardType,bool,&SgJavaWildcardType::p_has_super>>;
};
template <> struct node_from_variant_t<701> { using type = SgJavaWildcardType; };

// Class: ProcessControlStatement
template <> struct describe_field_t<SgProcessControlStatement,SgProcessControlStatement::control_enum,&SgProcessControlStatement::p_control_kind> {
  using parent = SgProcessControlStatement;
  using field_type = SgProcessControlStatement::control_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"control_kind"};
  static constexpr char const * const typestr{"SgProcessControlStatement::control_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgProcessControlStatement::p_control_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProcessControlStatement, SgProcessControlStatement::control_enum SgProcessControlStatement::*, &SgProcessControlStatement::p_control_kind>;
};
template <> struct describe_field_t<SgProcessControlStatement,SgExpression*,&SgProcessControlStatement::p_code> {
  using parent = SgProcessControlStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"code"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgProcessControlStatement::p_code};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProcessControlStatement, SgExpression* SgProcessControlStatement::*, &SgProcessControlStatement::p_code>;
};
template <> struct describe_field_t<SgProcessControlStatement,SgExpression*,&SgProcessControlStatement::p_quiet> {
  using parent = SgProcessControlStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"quiet"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgProcessControlStatement::p_quiet};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgProcessControlStatement, SgExpression* SgProcessControlStatement::*, &SgProcessControlStatement::p_quiet>;
};
template <> struct describe_node_t<SgProcessControlStatement> {
  using node = SgProcessControlStatement;
  using base = SgStatement;
  static constexpr char const * const name{"ProcessControlStatement"};
  static constexpr unsigned long variant{702};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgProcessControlStatement,SgProcessControlStatement::control_enum,&SgProcessControlStatement::p_control_kind>, describe_field_t<SgProcessControlStatement,SgExpression*,&SgProcessControlStatement::p_code>, describe_field_t<SgProcessControlStatement,SgExpression*,&SgProcessControlStatement::p_quiet>>;
};
template <> struct node_from_variant_t<702> { using type = SgProcessControlStatement; };

// Class: SpecialFunctionModifier
template <> struct describe_field_t<SgSpecialFunctionModifier,SgBitVector,&SgSpecialFunctionModifier::p_modifierVector> {
  using parent = SgSpecialFunctionModifier;
  using field_type = SgBitVector;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifierVector"};
  static constexpr char const * const typestr{"SgBitVector"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSpecialFunctionModifier::p_modifierVector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSpecialFunctionModifier, SgBitVector SgSpecialFunctionModifier::*, &SgSpecialFunctionModifier::p_modifierVector>;
};
template <> struct describe_node_t<SgSpecialFunctionModifier> {
  using node = SgSpecialFunctionModifier;
  using base = SgModifier;
  static constexpr char const * const name{"SpecialFunctionModifier"};
  static constexpr unsigned long variant{703};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSpecialFunctionModifier,SgBitVector,&SgSpecialFunctionModifier::p_modifierVector>>;
};
template <> struct node_from_variant_t<703> { using type = SgSpecialFunctionModifier; };

// Class: Statement
template <> struct describe_field_t<SgStatement,SgLabelRefExp*,&SgStatement::p_numeric_label> {
  using parent = SgStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStatement::p_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStatement, SgLabelRefExp* SgStatement::*, &SgStatement::p_numeric_label>;
};
template <> struct describe_field_t<SgStatement,int,&SgStatement::p_source_sequence_value> {
  using parent = SgStatement;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"source_sequence_value"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStatement::p_source_sequence_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStatement, int SgStatement::*, &SgStatement::p_source_sequence_value>;
};
template <> struct describe_node_t<SgStatement> {
  using node = SgStatement;
  using base = SgLocatedNode;
  static constexpr char const * const name{"Statement"};
  static constexpr unsigned long variant{704};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgScopeStatement, SgFunctionTypeTable, SgDeclarationStatement, SgExprStatement, SgLabelStatement, SgCaseOptionStmt, SgTryStmt, SgDefaultOptionStmt, SgBreakStmt, SgContinueStmt, SgReturnStmt, SgGotoStatement, SgSpawnStmt, SgNullStatement, SgVariantStatement, SgForInitStatement, SgCatchStatementSeq, SgProcessControlStatement, SgIOStatement, SgFortranContinueStmt, SgWhereStatement, SgElseWhereStatement, SgNullifyStatement, SgArithmeticIfStatement, SgAssignStatement, SgComputedGotoStatement, SgAssignedGotoStatement, SgAllocateStatement, SgDeallocateStatement, SgUpcNotifyStatement, SgUpcWaitStatement, SgUpcBarrierStatement, SgUpcFenceStatement, SgOmpBarrierStatement, SgOmpTaskwaitStatement, SgOmpFlushStatement, SgOmpBodyStatement, SgSequenceStatement, SgWithStatement, SgPythonPrintStmt, SgPassStatement, SgAssertStmt, SgExecStatement, SgPythonGlobalStmt, SgJavaThrowStatement, SgJavaSynchronizedStatement, SgAsyncStmt, SgFinishStmt, SgAtStmt, SgAtomicStmt, SgWhenStmt, SgImageControlStatement, SgAdaExitStmt, SgAdaDelayStmt, SgAdaLoopStmt, SgAdaSelectStmt, SgAdaSelectAlternativeStmt, SgAdaTerminateStmt, SgAdaUnscopedBlock, SgAdaVariantWhenStmt>;
  using fields_t = mp::List<describe_field_t<SgStatement,SgLabelRefExp*,&SgStatement::p_numeric_label>, describe_field_t<SgStatement,int,&SgStatement::p_source_sequence_value>>;
};
template <> struct node_from_variant_t<704> { using type = SgStatement; };

// Class: StaticAssertionDeclaration
template <> struct describe_field_t<SgStaticAssertionDeclaration,SgExpression*,&SgStaticAssertionDeclaration::p_condition> {
  using parent = SgStaticAssertionDeclaration;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"condition"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgStaticAssertionDeclaration::p_condition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStaticAssertionDeclaration, SgExpression* SgStaticAssertionDeclaration::*, &SgStaticAssertionDeclaration::p_condition>;
};
template <> struct describe_field_t<SgStaticAssertionDeclaration,SgName,&SgStaticAssertionDeclaration::p_string_literal> {
  using parent = SgStaticAssertionDeclaration;
  using field_type = SgName;
  static constexpr size_t position{1};
  static constexpr char const * const name{"string_literal"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStaticAssertionDeclaration::p_string_literal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStaticAssertionDeclaration, SgName SgStaticAssertionDeclaration::*, &SgStaticAssertionDeclaration::p_string_literal>;
};
template <> struct describe_node_t<SgStaticAssertionDeclaration> {
  using node = SgStaticAssertionDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"StaticAssertionDeclaration"};
  static constexpr unsigned long variant{705};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgStaticAssertionDeclaration,SgExpression*,&SgStaticAssertionDeclaration::p_condition>, describe_field_t<SgStaticAssertionDeclaration,SgName,&SgStaticAssertionDeclaration::p_string_literal>>;
};
template <> struct node_from_variant_t<705> { using type = SgStaticAssertionDeclaration; };

// Class: StmtDeclarationStatement
template <> struct describe_field_t<SgStmtDeclarationStatement,SgStatement*,&SgStmtDeclarationStatement::p_statement> {
  using parent = SgStmtDeclarationStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"statement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgStmtDeclarationStatement::p_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStmtDeclarationStatement, SgStatement* SgStmtDeclarationStatement::*, &SgStmtDeclarationStatement::p_statement>;
};
template <> struct describe_node_t<SgStmtDeclarationStatement> {
  using node = SgStmtDeclarationStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"StmtDeclarationStatement"};
  static constexpr unsigned long variant{706};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgStmtDeclarationStatement,SgStatement*,&SgStmtDeclarationStatement::p_statement>>;
};
template <> struct node_from_variant_t<706> { using type = SgStmtDeclarationStatement; };

// Class: StatementExpression
template <> struct describe_field_t<SgStatementExpression,SgStatement*,&SgStatementExpression::p_statement> {
  using parent = SgStatementExpression;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"statement"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgStatementExpression::p_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStatementExpression, SgStatement* SgStatementExpression::*, &SgStatementExpression::p_statement>;
};
template <> struct describe_node_t<SgStatementExpression> {
  using node = SgStatementExpression;
  using base = SgExpression;
  static constexpr char const * const name{"StatementExpression"};
  static constexpr unsigned long variant{707};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgStatementExpression,SgStatement*,&SgStatementExpression::p_statement>>;
};
template <> struct node_from_variant_t<707> { using type = SgStatementExpression; };

// Class: StatementFunctionStatement
template <> struct describe_field_t<SgStatementFunctionStatement,SgFunctionDeclaration*,&SgStatementFunctionStatement::p_function> {
  using parent = SgStatementFunctionStatement;
  using field_type = SgFunctionDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"function"};
  static constexpr char const * const typestr{"SgFunctionDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgStatementFunctionStatement::p_function};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStatementFunctionStatement, SgFunctionDeclaration* SgStatementFunctionStatement::*, &SgStatementFunctionStatement::p_function>;
};
template <> struct describe_field_t<SgStatementFunctionStatement,SgExpression*,&SgStatementFunctionStatement::p_expression> {
  using parent = SgStatementFunctionStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgStatementFunctionStatement::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStatementFunctionStatement, SgExpression* SgStatementFunctionStatement::*, &SgStatementFunctionStatement::p_expression>;
};
template <> struct describe_node_t<SgStatementFunctionStatement> {
  using node = SgStatementFunctionStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"StatementFunctionStatement"};
  static constexpr unsigned long variant{708};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgStatementFunctionStatement,SgFunctionDeclaration*,&SgStatementFunctionStatement::p_function>, describe_field_t<SgStatementFunctionStatement,SgExpression*,&SgStatementFunctionStatement::p_expression>>;
};
template <> struct node_from_variant_t<708> { using type = SgStatementFunctionStatement; };

// Class: StorageModifier
template <> struct describe_field_t<SgStorageModifier,SgStorageModifier::storage_modifier_enum,&SgStorageModifier::p_modifier> {
  using parent = SgStorageModifier;
  using field_type = SgStorageModifier::storage_modifier_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgStorageModifier::storage_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStorageModifier::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStorageModifier, SgStorageModifier::storage_modifier_enum SgStorageModifier::*, &SgStorageModifier::p_modifier>;
};
template <> struct describe_field_t<SgStorageModifier,bool,&SgStorageModifier::p_thread_local_storage> {
  using parent = SgStorageModifier;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"thread_local_storage"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStorageModifier::p_thread_local_storage};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStorageModifier, bool SgStorageModifier::*, &SgStorageModifier::p_thread_local_storage>;
};
template <> struct describe_node_t<SgStorageModifier> {
  using node = SgStorageModifier;
  using base = SgModifier;
  static constexpr char const * const name{"StorageModifier"};
  static constexpr unsigned long variant{709};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgStorageModifier,SgStorageModifier::storage_modifier_enum,&SgStorageModifier::p_modifier>, describe_field_t<SgStorageModifier,bool,&SgStorageModifier::p_thread_local_storage>>;
};
template <> struct node_from_variant_t<709> { using type = SgStorageModifier; };

// Class: StringConversion
template <> struct describe_field_t<SgStringConversion,SgExpression*,&SgStringConversion::p_expression> {
  using parent = SgStringConversion;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgStringConversion::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStringConversion, SgExpression* SgStringConversion::*, &SgStringConversion::p_expression>;
};
template <> struct describe_node_t<SgStringConversion> {
  using node = SgStringConversion;
  using base = SgExpression;
  static constexpr char const * const name{"StringConversion"};
  static constexpr unsigned long variant{710};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgStringConversion,SgExpression*,&SgStringConversion::p_expression>>;
};
template <> struct node_from_variant_t<710> { using type = SgStringConversion; };

// Class: StringKeyedBidirectionalGraph
template <> struct describe_node_t<SgStringKeyedBidirectionalGraph> {
  using node = SgStringKeyedBidirectionalGraph;
  using base = SgBidirectionalGraph;
  static constexpr char const * const name{"StringKeyedBidirectionalGraph"};
  static constexpr unsigned long variant{711};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<711> { using type = SgStringKeyedBidirectionalGraph; };

// Class: StringVal
template <> struct describe_field_t<SgStringVal,std::string,&SgStringVal::p_value> {
  using parent = SgStringVal;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStringVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStringVal, std::string SgStringVal::*, &SgStringVal::p_value>;
};
template <> struct describe_field_t<SgStringVal,bool,&SgStringVal::p_wcharString> {
  using parent = SgStringVal;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"wcharString"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStringVal::p_wcharString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStringVal, bool SgStringVal::*, &SgStringVal::p_wcharString>;
};
template <> struct describe_field_t<SgStringVal,char,&SgStringVal::p_stringDelimiter> {
  using parent = SgStringVal;
  using field_type = char;
  static constexpr size_t position{2};
  static constexpr char const * const name{"stringDelimiter"};
  static constexpr char const * const typestr{"char"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStringVal::p_stringDelimiter};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStringVal, char SgStringVal::*, &SgStringVal::p_stringDelimiter>;
};
template <> struct describe_field_t<SgStringVal,bool,&SgStringVal::p_is16bitString> {
  using parent = SgStringVal;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"is16bitString"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStringVal::p_is16bitString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStringVal, bool SgStringVal::*, &SgStringVal::p_is16bitString>;
};
template <> struct describe_field_t<SgStringVal,bool,&SgStringVal::p_is32bitString> {
  using parent = SgStringVal;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"is32bitString"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStringVal::p_is32bitString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStringVal, bool SgStringVal::*, &SgStringVal::p_is32bitString>;
};
template <> struct describe_field_t<SgStringVal,bool,&SgStringVal::p_isRawString> {
  using parent = SgStringVal;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"isRawString"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStringVal::p_isRawString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStringVal, bool SgStringVal::*, &SgStringVal::p_isRawString>;
};
template <> struct describe_field_t<SgStringVal,std::string,&SgStringVal::p_raw_string_value> {
  using parent = SgStringVal;
  using field_type = std::string;
  static constexpr size_t position{6};
  static constexpr char const * const name{"raw_string_value"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStringVal::p_raw_string_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStringVal, std::string SgStringVal::*, &SgStringVal::p_raw_string_value>;
};
template <> struct describe_node_t<SgStringVal> {
  using node = SgStringVal;
  using base = SgValueExp;
  static constexpr char const * const name{"StringVal"};
  static constexpr unsigned long variant{712};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgStringVal,std::string,&SgStringVal::p_value>, describe_field_t<SgStringVal,bool,&SgStringVal::p_wcharString>, describe_field_t<SgStringVal,char,&SgStringVal::p_stringDelimiter>, describe_field_t<SgStringVal,bool,&SgStringVal::p_is16bitString>, describe_field_t<SgStringVal,bool,&SgStringVal::p_is32bitString>, describe_field_t<SgStringVal,bool,&SgStringVal::p_isRawString>, describe_field_t<SgStringVal,std::string,&SgStringVal::p_raw_string_value>>;
};
template <> struct node_from_variant_t<712> { using type = SgStringVal; };

// Class: StructureModifier
template <> struct describe_field_t<SgStructureModifier,SgStructureModifier::jovial_structure_modifier_enum,&SgStructureModifier::p_modifier> {
  using parent = SgStructureModifier;
  using field_type = SgStructureModifier::jovial_structure_modifier_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgStructureModifier::jovial_structure_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStructureModifier::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStructureModifier, SgStructureModifier::jovial_structure_modifier_enum SgStructureModifier::*, &SgStructureModifier::p_modifier>;
};
template <> struct describe_field_t<SgStructureModifier,int,&SgStructureModifier::p_bits_per_entry> {
  using parent = SgStructureModifier;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"bits_per_entry"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgStructureModifier::p_bits_per_entry};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgStructureModifier, int SgStructureModifier::*, &SgStructureModifier::p_bits_per_entry>;
};
template <> struct describe_node_t<SgStructureModifier> {
  using node = SgStructureModifier;
  using base = SgModifier;
  static constexpr char const * const name{"StructureModifier"};
  static constexpr unsigned long variant{713};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgStructureModifier,SgStructureModifier::jovial_structure_modifier_enum,&SgStructureModifier::p_modifier>, describe_field_t<SgStructureModifier,int,&SgStructureModifier::p_bits_per_entry>>;
};
template <> struct node_from_variant_t<713> { using type = SgStructureModifier; };

// Class: SubscriptExpression
template <> struct describe_field_t<SgSubscriptExpression,SgExpression*,&SgSubscriptExpression::p_lowerBound> {
  using parent = SgSubscriptExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lowerBound"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSubscriptExpression::p_lowerBound};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSubscriptExpression, SgExpression* SgSubscriptExpression::*, &SgSubscriptExpression::p_lowerBound>;
};
template <> struct describe_field_t<SgSubscriptExpression,SgExpression*,&SgSubscriptExpression::p_upperBound> {
  using parent = SgSubscriptExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"upperBound"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSubscriptExpression::p_upperBound};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSubscriptExpression, SgExpression* SgSubscriptExpression::*, &SgSubscriptExpression::p_upperBound>;
};
template <> struct describe_field_t<SgSubscriptExpression,SgExpression*,&SgSubscriptExpression::p_stride> {
  using parent = SgSubscriptExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"stride"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSubscriptExpression::p_stride};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSubscriptExpression, SgExpression* SgSubscriptExpression::*, &SgSubscriptExpression::p_stride>;
};
template <> struct describe_node_t<SgSubscriptExpression> {
  using node = SgSubscriptExpression;
  using base = SgExpression;
  static constexpr char const * const name{"SubscriptExpression"};
  static constexpr unsigned long variant{714};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSubscriptExpression,SgExpression*,&SgSubscriptExpression::p_lowerBound>, describe_field_t<SgSubscriptExpression,SgExpression*,&SgSubscriptExpression::p_upperBound>, describe_field_t<SgSubscriptExpression,SgExpression*,&SgSubscriptExpression::p_stride>>;
};
template <> struct node_from_variant_t<714> { using type = SgSubscriptExpression; };

// Class: SubtractOp
template <> struct describe_node_t<SgSubtractOp> {
  using node = SgSubtractOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"SubtractOp"};
  static constexpr unsigned long variant{715};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<715> { using type = SgSubtractOp; };

// Class: Support
template <> struct describe_node_t<SgSupport> {
  using node = SgSupport;
  using base = SgNode;
  static constexpr char const * const name{"Support"};
  static constexpr unsigned long variant{716};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgModifier, SgName, SgSymbolTable, SgAttribute, Sg_File_Info, SgFile, SgProject, SgOptions, SgUnparse_Info, SgBaseClass, SgTypedefSeq, SgTemplateParameter, SgTemplateArgument, SgDirectory, SgFileList, SgDirectoryList, SgFunctionParameterTypeList, SgQualifiedName, SgTemplateArgumentList, SgTemplateParameterList, SgGraph, SgGraphNode, SgGraphEdge, SgGraphNodeList, SgGraphEdgeList, SgTypeTable, SgNameGroup, SgDimensionObject, SgFormatItem, SgFormatItemList, SgDataStatementGroup, SgDataStatementObject, SgIncludeFile, SgDataStatementValue, SgJavaImportStatementList, SgJavaClassDeclarationList, SgHeaderFileReport>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<716> { using type = SgSupport; };

// Class: SwitchStatement
template <> struct describe_field_t<SgSwitchStatement,SgStatement*,&SgSwitchStatement::p_item_selector> {
  using parent = SgSwitchStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"item_selector"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSwitchStatement::p_item_selector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSwitchStatement, SgStatement* SgSwitchStatement::*, &SgSwitchStatement::p_item_selector>;
};
template <> struct describe_field_t<SgSwitchStatement,SgStatement*,&SgSwitchStatement::p_body> {
  using parent = SgSwitchStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgSwitchStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSwitchStatement, SgStatement* SgSwitchStatement::*, &SgSwitchStatement::p_body>;
};
template <> struct describe_field_t<SgSwitchStatement,SgLabelRefExp*,&SgSwitchStatement::p_end_numeric_label> {
  using parent = SgSwitchStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSwitchStatement::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSwitchStatement, SgLabelRefExp* SgSwitchStatement::*, &SgSwitchStatement::p_end_numeric_label>;
};
template <> struct describe_field_t<SgSwitchStatement,std::string,&SgSwitchStatement::p_string_label> {
  using parent = SgSwitchStatement;
  using field_type = std::string;
  static constexpr size_t position{3};
  static constexpr char const * const name{"string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSwitchStatement::p_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSwitchStatement, std::string SgSwitchStatement::*, &SgSwitchStatement::p_string_label>;
};
template <> struct describe_node_t<SgSwitchStatement> {
  using node = SgSwitchStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"SwitchStatement"};
  static constexpr unsigned long variant{717};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSwitchStatement,SgStatement*,&SgSwitchStatement::p_item_selector>, describe_field_t<SgSwitchStatement,SgStatement*,&SgSwitchStatement::p_body>, describe_field_t<SgSwitchStatement,SgLabelRefExp*,&SgSwitchStatement::p_end_numeric_label>, describe_field_t<SgSwitchStatement,std::string,&SgSwitchStatement::p_string_label>>;
};
template <> struct node_from_variant_t<717> { using type = SgSwitchStatement; };

// Class: Symbol
template <> struct describe_field_t<SgSymbol,AstAttributeMechanism*,&SgSymbol::p_attributeMechanism> {
  using parent = SgSymbol;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSymbol::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSymbol, AstAttributeMechanism* SgSymbol::*, &SgSymbol::p_attributeMechanism>;
};
template <> struct describe_node_t<SgSymbol> {
  using node = SgSymbol;
  using base = SgNode;
  static constexpr char const * const name{"Symbol"};
  static constexpr unsigned long variant{718};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgVariableSymbol, SgNonrealSymbol, SgFunctionSymbol, SgFunctionTypeSymbol, SgTemplateSymbol, SgEnumFieldSymbol, SgTypeSymbol, SgLabelSymbol, SgDefaultSymbol, SgNamespaceSymbol, SgIntrinsicSymbol, SgModuleSymbol, SgInterfaceSymbol, SgCommonSymbol, SgAliasSymbol, SgAsmBinaryAddressSymbol, SgAsmBinaryDataSymbol, SgJavaLabelSymbol, SgAdaPackageSymbol, SgAdaTaskSymbol, SgAdaProtectedSymbol, SgAdaRenamingSymbol, SgAdaGenericSymbol, SgAdaGenericInstanceSymbol, SgAdaFormalPackageSymbol>;
  using fields_t = mp::List<describe_field_t<SgSymbol,AstAttributeMechanism*,&SgSymbol::p_attributeMechanism>>;
};
template <> struct node_from_variant_t<718> { using type = SgSymbol; };

// Class: SymbolTable
template <> struct describe_field_t<SgSymbolTable,SgSymbolTable::hash_iterator,&SgSymbolTable::p_iterator> {
  using parent = SgSymbolTable;
  using field_type = SgSymbolTable::hash_iterator;
  static constexpr size_t position{0};
  static constexpr char const * const name{"iterator"};
  static constexpr char const * const typestr{"SgSymbolTable::hash_iterator"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSymbolTable::p_iterator};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSymbolTable, SgSymbolTable::hash_iterator SgSymbolTable::*, &SgSymbolTable::p_iterator>;
};
template <> struct describe_field_t<SgSymbolTable,SgName,&SgSymbolTable::p_name> {
  using parent = SgSymbolTable;
  using field_type = SgName;
  static constexpr size_t position{1};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSymbolTable::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSymbolTable, SgName SgSymbolTable::*, &SgSymbolTable::p_name>;
};
template <> struct describe_field_t<SgSymbolTable,bool,&SgSymbolTable::p_no_name> {
  using parent = SgSymbolTable;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"no_name"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSymbolTable::p_no_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSymbolTable, bool SgSymbolTable::*, &SgSymbolTable::p_no_name>;
};
template <> struct describe_field_t<SgSymbolTable, rose_hash_multimap*,&SgSymbolTable::p_table> {
  using parent = SgSymbolTable;
  using field_type =  rose_hash_multimap*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"table"};
  static constexpr char const * const typestr{" rose_hash_multimap*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSymbolTable::p_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSymbolTable,  rose_hash_multimap* SgSymbolTable::*, &SgSymbolTable::p_table>;
};
template <> struct describe_field_t<SgSymbolTable,SgNodeSet,&SgSymbolTable::p_symbolSet> {
  using parent = SgSymbolTable;
  using field_type = SgNodeSet;
  static constexpr size_t position{4};
  static constexpr char const * const name{"symbolSet"};
  static constexpr char const * const typestr{"SgNodeSet"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSymbolTable::p_symbolSet};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSymbolTable, SgNodeSet SgSymbolTable::*, &SgSymbolTable::p_symbolSet>;
};
template <> struct describe_field_t<SgSymbolTable,bool,&SgSymbolTable::p_case_insensitive> {
  using parent = SgSymbolTable;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"case_insensitive"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSymbolTable::p_case_insensitive};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSymbolTable, bool SgSymbolTable::*, &SgSymbolTable::p_case_insensitive>;
};
template <> struct describe_node_t<SgSymbolTable> {
  using node = SgSymbolTable;
  using base = SgSupport;
  static constexpr char const * const name{"SymbolTable"};
  static constexpr unsigned long variant{719};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSymbolTable,SgSymbolTable::hash_iterator,&SgSymbolTable::p_iterator>, describe_field_t<SgSymbolTable,SgName,&SgSymbolTable::p_name>, describe_field_t<SgSymbolTable,bool,&SgSymbolTable::p_no_name>, describe_field_t<SgSymbolTable, rose_hash_multimap*,&SgSymbolTable::p_table>, describe_field_t<SgSymbolTable,SgNodeSet,&SgSymbolTable::p_symbolSet>, describe_field_t<SgSymbolTable,bool,&SgSymbolTable::p_case_insensitive>>;
};
template <> struct node_from_variant_t<719> { using type = SgSymbolTable; };

// Class: TemplateArgument
template <> struct describe_field_t<SgTemplateArgument,SgTemplateArgument::template_argument_enum,&SgTemplateArgument::p_argumentType> {
  using parent = SgTemplateArgument;
  using field_type = SgTemplateArgument::template_argument_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"argumentType"};
  static constexpr char const * const typestr{"SgTemplateArgument::template_argument_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_argumentType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, SgTemplateArgument::template_argument_enum SgTemplateArgument::*, &SgTemplateArgument::p_argumentType>;
};
template <> struct describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_isArrayBoundUnknownType> {
  using parent = SgTemplateArgument;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"isArrayBoundUnknownType"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_isArrayBoundUnknownType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, bool SgTemplateArgument::*, &SgTemplateArgument::p_isArrayBoundUnknownType>;
};
template <> struct describe_field_t<SgTemplateArgument,SgType*,&SgTemplateArgument::p_type> {
  using parent = SgTemplateArgument;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, SgType* SgTemplateArgument::*, &SgTemplateArgument::p_type>;
};
template <> struct describe_field_t<SgTemplateArgument,SgType*,&SgTemplateArgument::p_unparsable_type_alias> {
  using parent = SgTemplateArgument;
  using field_type = SgType*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"unparsable_type_alias"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_unparsable_type_alias};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, SgType* SgTemplateArgument::*, &SgTemplateArgument::p_unparsable_type_alias>;
};
template <> struct describe_field_t<SgTemplateArgument,SgExpression*,&SgTemplateArgument::p_expression> {
  using parent = SgTemplateArgument;
  using field_type = SgExpression*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, SgExpression* SgTemplateArgument::*, &SgTemplateArgument::p_expression>;
};
template <> struct describe_field_t<SgTemplateArgument,SgDeclarationStatement*,&SgTemplateArgument::p_templateDeclaration> {
  using parent = SgTemplateArgument;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"templateDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_templateDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, SgDeclarationStatement* SgTemplateArgument::*, &SgTemplateArgument::p_templateDeclaration>;
};
template <> struct describe_field_t<SgTemplateArgument,SgInitializedName*,&SgTemplateArgument::p_initializedName> {
  using parent = SgTemplateArgument;
  using field_type = SgInitializedName*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"initializedName"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_initializedName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, SgInitializedName* SgTemplateArgument::*, &SgTemplateArgument::p_initializedName>;
};
template <> struct describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_explicitlySpecified> {
  using parent = SgTemplateArgument;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"explicitlySpecified"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_explicitlySpecified};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, bool SgTemplateArgument::*, &SgTemplateArgument::p_explicitlySpecified>;
};
template <> struct describe_field_t<SgTemplateArgument,int,&SgTemplateArgument::p_name_qualification_length> {
  using parent = SgTemplateArgument;
  using field_type = int;
  static constexpr size_t position{8};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, int SgTemplateArgument::*, &SgTemplateArgument::p_name_qualification_length>;
};
template <> struct describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_type_elaboration_required> {
  using parent = SgTemplateArgument;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, bool SgTemplateArgument::*, &SgTemplateArgument::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_global_qualification_required> {
  using parent = SgTemplateArgument;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, bool SgTemplateArgument::*, &SgTemplateArgument::p_global_qualification_required>;
};
template <> struct describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_requiresGlobalNameQualificationOnType> {
  using parent = SgTemplateArgument;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"requiresGlobalNameQualificationOnType"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_requiresGlobalNameQualificationOnType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, bool SgTemplateArgument::*, &SgTemplateArgument::p_requiresGlobalNameQualificationOnType>;
};
template <> struct describe_field_t<SgTemplateArgument,int,&SgTemplateArgument::p_name_qualification_length_for_type> {
  using parent = SgTemplateArgument;
  using field_type = int;
  static constexpr size_t position{12};
  static constexpr char const * const name{"name_qualification_length_for_type"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_name_qualification_length_for_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, int SgTemplateArgument::*, &SgTemplateArgument::p_name_qualification_length_for_type>;
};
template <> struct describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_type_elaboration_required_for_type> {
  using parent = SgTemplateArgument;
  using field_type = bool;
  static constexpr size_t position{13};
  static constexpr char const * const name{"type_elaboration_required_for_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_type_elaboration_required_for_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, bool SgTemplateArgument::*, &SgTemplateArgument::p_type_elaboration_required_for_type>;
};
template <> struct describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_global_qualification_required_for_type> {
  using parent = SgTemplateArgument;
  using field_type = bool;
  static constexpr size_t position{14};
  static constexpr char const * const name{"global_qualification_required_for_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_global_qualification_required_for_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, bool SgTemplateArgument::*, &SgTemplateArgument::p_global_qualification_required_for_type>;
};
template <> struct describe_field_t<SgTemplateArgument,SgTemplateArgument*,&SgTemplateArgument::p_previous_instance> {
  using parent = SgTemplateArgument;
  using field_type = SgTemplateArgument*;
  static constexpr size_t position{15};
  static constexpr char const * const name{"previous_instance"};
  static constexpr char const * const typestr{"SgTemplateArgument*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_previous_instance};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, SgTemplateArgument* SgTemplateArgument::*, &SgTemplateArgument::p_previous_instance>;
};
template <> struct describe_field_t<SgTemplateArgument,SgTemplateArgument*,&SgTemplateArgument::p_next_instance> {
  using parent = SgTemplateArgument;
  using field_type = SgTemplateArgument*;
  static constexpr size_t position{16};
  static constexpr char const * const name{"next_instance"};
  static constexpr char const * const typestr{"SgTemplateArgument*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_next_instance};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, SgTemplateArgument* SgTemplateArgument::*, &SgTemplateArgument::p_next_instance>;
};
template <> struct describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_is_pack_element> {
  using parent = SgTemplateArgument;
  using field_type = bool;
  static constexpr size_t position{17};
  static constexpr char const * const name{"is_pack_element"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateArgument::p_is_pack_element};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgument, bool SgTemplateArgument::*, &SgTemplateArgument::p_is_pack_element>;
};
template <> struct describe_node_t<SgTemplateArgument> {
  using node = SgTemplateArgument;
  using base = SgSupport;
  static constexpr char const * const name{"TemplateArgument"};
  static constexpr unsigned long variant{720};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateArgument,SgTemplateArgument::template_argument_enum,&SgTemplateArgument::p_argumentType>, describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_isArrayBoundUnknownType>, describe_field_t<SgTemplateArgument,SgType*,&SgTemplateArgument::p_type>, describe_field_t<SgTemplateArgument,SgType*,&SgTemplateArgument::p_unparsable_type_alias>, describe_field_t<SgTemplateArgument,SgExpression*,&SgTemplateArgument::p_expression>, describe_field_t<SgTemplateArgument,SgDeclarationStatement*,&SgTemplateArgument::p_templateDeclaration>, describe_field_t<SgTemplateArgument,SgInitializedName*,&SgTemplateArgument::p_initializedName>, describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_explicitlySpecified>, describe_field_t<SgTemplateArgument,int,&SgTemplateArgument::p_name_qualification_length>, describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_type_elaboration_required>, describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_global_qualification_required>, describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_requiresGlobalNameQualificationOnType>, describe_field_t<SgTemplateArgument,int,&SgTemplateArgument::p_name_qualification_length_for_type>, describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_type_elaboration_required_for_type>, describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_global_qualification_required_for_type>, describe_field_t<SgTemplateArgument,SgTemplateArgument*,&SgTemplateArgument::p_previous_instance>, describe_field_t<SgTemplateArgument,SgTemplateArgument*,&SgTemplateArgument::p_next_instance>, describe_field_t<SgTemplateArgument,bool,&SgTemplateArgument::p_is_pack_element>>;
};
template <> struct node_from_variant_t<720> { using type = SgTemplateArgument; };

// Class: TemplateArgumentList
template <> struct describe_field_t<SgTemplateArgumentList,SgTemplateArgumentPtrList,&SgTemplateArgumentList::p_args> {
  using parent = SgTemplateArgumentList;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"args"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateArgumentList::p_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateArgumentList, SgTemplateArgumentPtrList SgTemplateArgumentList::*, &SgTemplateArgumentList::p_args>;
};
template <> struct describe_node_t<SgTemplateArgumentList> {
  using node = SgTemplateArgumentList;
  using base = SgSupport;
  static constexpr char const * const name{"TemplateArgumentList"};
  static constexpr unsigned long variant{721};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateArgumentList,SgTemplateArgumentPtrList,&SgTemplateArgumentList::p_args>>;
};
template <> struct node_from_variant_t<721> { using type = SgTemplateArgumentList; };

// Class: TemplateDeclaration
template <> struct describe_field_t<SgTemplateDeclaration,SgName,&SgTemplateDeclaration::p_name> {
  using parent = SgTemplateDeclaration;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateDeclaration::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateDeclaration, SgName SgTemplateDeclaration::*, &SgTemplateDeclaration::p_name>;
};
template <> struct describe_field_t<SgTemplateDeclaration,SgName,&SgTemplateDeclaration::p_string> {
  using parent = SgTemplateDeclaration;
  using field_type = SgName;
  static constexpr size_t position{1};
  static constexpr char const * const name{"string"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateDeclaration::p_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateDeclaration, SgName SgTemplateDeclaration::*, &SgTemplateDeclaration::p_string>;
};
template <> struct describe_field_t<SgTemplateDeclaration,SgTemplateDeclaration::template_type_enum,&SgTemplateDeclaration::p_template_kind> {
  using parent = SgTemplateDeclaration;
  using field_type = SgTemplateDeclaration::template_type_enum;
  static constexpr size_t position{2};
  static constexpr char const * const name{"template_kind"};
  static constexpr char const * const typestr{"SgTemplateDeclaration::template_type_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateDeclaration::p_template_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateDeclaration, SgTemplateDeclaration::template_type_enum SgTemplateDeclaration::*, &SgTemplateDeclaration::p_template_kind>;
};
template <> struct describe_field_t<SgTemplateDeclaration,SgTemplateParameterPtrList,&SgTemplateDeclaration::p_templateParameters> {
  using parent = SgTemplateDeclaration;
  using field_type = SgTemplateParameterPtrList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"templateParameters"};
  static constexpr char const * const typestr{"SgTemplateParameterPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateDeclaration::p_templateParameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateDeclaration, SgTemplateParameterPtrList SgTemplateDeclaration::*, &SgTemplateDeclaration::p_templateParameters>;
};
template <> struct describe_field_t<SgTemplateDeclaration,SgScopeStatement*,&SgTemplateDeclaration::p_scope> {
  using parent = SgTemplateDeclaration;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateDeclaration::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateDeclaration, SgScopeStatement* SgTemplateDeclaration::*, &SgTemplateDeclaration::p_scope>;
};
template <> struct describe_field_t<SgTemplateDeclaration,SgDeclarationScope*,&SgTemplateDeclaration::p_nonreal_decl_scope> {
  using parent = SgTemplateDeclaration;
  using field_type = SgDeclarationScope*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"nonreal_decl_scope"};
  static constexpr char const * const typestr{"SgDeclarationScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateDeclaration::p_nonreal_decl_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateDeclaration, SgDeclarationScope* SgTemplateDeclaration::*, &SgTemplateDeclaration::p_nonreal_decl_scope>;
};
template <> struct describe_node_t<SgTemplateDeclaration> {
  using node = SgTemplateDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"TemplateDeclaration"};
  static constexpr unsigned long variant{722};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateDeclaration,SgName,&SgTemplateDeclaration::p_name>, describe_field_t<SgTemplateDeclaration,SgName,&SgTemplateDeclaration::p_string>, describe_field_t<SgTemplateDeclaration,SgTemplateDeclaration::template_type_enum,&SgTemplateDeclaration::p_template_kind>, describe_field_t<SgTemplateDeclaration,SgTemplateParameterPtrList,&SgTemplateDeclaration::p_templateParameters>, describe_field_t<SgTemplateDeclaration,SgScopeStatement*,&SgTemplateDeclaration::p_scope>, describe_field_t<SgTemplateDeclaration,SgDeclarationScope*,&SgTemplateDeclaration::p_nonreal_decl_scope>>;
};
template <> struct node_from_variant_t<722> { using type = SgTemplateDeclaration; };

// Class: TemplateClassDeclaration
template <> struct describe_field_t<SgTemplateClassDeclaration,SgTemplateParameterPtrList,&SgTemplateClassDeclaration::p_templateParameters> {
  using parent = SgTemplateClassDeclaration;
  using field_type = SgTemplateParameterPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateParameters"};
  static constexpr char const * const typestr{"SgTemplateParameterPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateClassDeclaration::p_templateParameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateClassDeclaration, SgTemplateParameterPtrList SgTemplateClassDeclaration::*, &SgTemplateClassDeclaration::p_templateParameters>;
};
template <> struct describe_field_t<SgTemplateClassDeclaration,SgTemplateArgumentPtrList,&SgTemplateClassDeclaration::p_templateSpecializationArguments> {
  using parent = SgTemplateClassDeclaration;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateSpecializationArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateClassDeclaration::p_templateSpecializationArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateClassDeclaration, SgTemplateArgumentPtrList SgTemplateClassDeclaration::*, &SgTemplateClassDeclaration::p_templateSpecializationArguments>;
};
template <> struct describe_field_t<SgTemplateClassDeclaration,SgName,&SgTemplateClassDeclaration::p_string> {
  using parent = SgTemplateClassDeclaration;
  using field_type = SgName;
  static constexpr size_t position{2};
  static constexpr char const * const name{"string"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateClassDeclaration::p_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateClassDeclaration, SgName SgTemplateClassDeclaration::*, &SgTemplateClassDeclaration::p_string>;
};
template <> struct describe_field_t<SgTemplateClassDeclaration,SgName,&SgTemplateClassDeclaration::p_templateName> {
  using parent = SgTemplateClassDeclaration;
  using field_type = SgName;
  static constexpr size_t position{3};
  static constexpr char const * const name{"templateName"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateClassDeclaration::p_templateName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateClassDeclaration, SgName SgTemplateClassDeclaration::*, &SgTemplateClassDeclaration::p_templateName>;
};
template <> struct describe_field_t<SgTemplateClassDeclaration,SgDeclarationScope*,&SgTemplateClassDeclaration::p_nonreal_decl_scope> {
  using parent = SgTemplateClassDeclaration;
  using field_type = SgDeclarationScope*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"nonreal_decl_scope"};
  static constexpr char const * const typestr{"SgDeclarationScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateClassDeclaration::p_nonreal_decl_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateClassDeclaration, SgDeclarationScope* SgTemplateClassDeclaration::*, &SgTemplateClassDeclaration::p_nonreal_decl_scope>;
};
template <> struct describe_node_t<SgTemplateClassDeclaration> {
  using node = SgTemplateClassDeclaration;
  using base = SgClassDeclaration;
  static constexpr char const * const name{"TemplateClassDeclaration"};
  static constexpr unsigned long variant{723};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateClassDeclaration,SgTemplateParameterPtrList,&SgTemplateClassDeclaration::p_templateParameters>, describe_field_t<SgTemplateClassDeclaration,SgTemplateArgumentPtrList,&SgTemplateClassDeclaration::p_templateSpecializationArguments>, describe_field_t<SgTemplateClassDeclaration,SgName,&SgTemplateClassDeclaration::p_string>, describe_field_t<SgTemplateClassDeclaration,SgName,&SgTemplateClassDeclaration::p_templateName>, describe_field_t<SgTemplateClassDeclaration,SgDeclarationScope*,&SgTemplateClassDeclaration::p_nonreal_decl_scope>>;
};
template <> struct node_from_variant_t<723> { using type = SgTemplateClassDeclaration; };

// Class: TemplateClassSymbol
template <> struct describe_node_t<SgTemplateClassSymbol> {
  using node = SgTemplateClassSymbol;
  using base = SgClassSymbol;
  static constexpr char const * const name{"TemplateClassSymbol"};
  static constexpr unsigned long variant{724};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<724> { using type = SgTemplateClassSymbol; };

// Class: TemplateFunctionDeclaration
template <> struct describe_field_t<SgTemplateFunctionDeclaration,SgTemplateParameterPtrList,&SgTemplateFunctionDeclaration::p_templateParameters> {
  using parent = SgTemplateFunctionDeclaration;
  using field_type = SgTemplateParameterPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateParameters"};
  static constexpr char const * const typestr{"SgTemplateParameterPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateFunctionDeclaration::p_templateParameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateFunctionDeclaration, SgTemplateParameterPtrList SgTemplateFunctionDeclaration::*, &SgTemplateFunctionDeclaration::p_templateParameters>;
};
template <> struct describe_field_t<SgTemplateFunctionDeclaration,SgTemplateArgumentPtrList,&SgTemplateFunctionDeclaration::p_templateSpecializationArguments> {
  using parent = SgTemplateFunctionDeclaration;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateSpecializationArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateFunctionDeclaration::p_templateSpecializationArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateFunctionDeclaration, SgTemplateArgumentPtrList SgTemplateFunctionDeclaration::*, &SgTemplateFunctionDeclaration::p_templateSpecializationArguments>;
};
template <> struct describe_field_t<SgTemplateFunctionDeclaration,SgName,&SgTemplateFunctionDeclaration::p_string> {
  using parent = SgTemplateFunctionDeclaration;
  using field_type = SgName;
  static constexpr size_t position{2};
  static constexpr char const * const name{"string"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateFunctionDeclaration::p_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateFunctionDeclaration, SgName SgTemplateFunctionDeclaration::*, &SgTemplateFunctionDeclaration::p_string>;
};
template <> struct describe_field_t<SgTemplateFunctionDeclaration,bool,&SgTemplateFunctionDeclaration::p_string_represents_function_body> {
  using parent = SgTemplateFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"string_represents_function_body"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateFunctionDeclaration::p_string_represents_function_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateFunctionDeclaration, bool SgTemplateFunctionDeclaration::*, &SgTemplateFunctionDeclaration::p_string_represents_function_body>;
};
template <> struct describe_field_t<SgTemplateFunctionDeclaration,SgDeclarationScope*,&SgTemplateFunctionDeclaration::p_nonreal_decl_scope> {
  using parent = SgTemplateFunctionDeclaration;
  using field_type = SgDeclarationScope*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"nonreal_decl_scope"};
  static constexpr char const * const typestr{"SgDeclarationScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateFunctionDeclaration::p_nonreal_decl_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateFunctionDeclaration, SgDeclarationScope* SgTemplateFunctionDeclaration::*, &SgTemplateFunctionDeclaration::p_nonreal_decl_scope>;
};
template <> struct describe_node_t<SgTemplateFunctionDeclaration> {
  using node = SgTemplateFunctionDeclaration;
  using base = SgFunctionDeclaration;
  static constexpr char const * const name{"TemplateFunctionDeclaration"};
  static constexpr unsigned long variant{725};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateFunctionDeclaration,SgTemplateParameterPtrList,&SgTemplateFunctionDeclaration::p_templateParameters>, describe_field_t<SgTemplateFunctionDeclaration,SgTemplateArgumentPtrList,&SgTemplateFunctionDeclaration::p_templateSpecializationArguments>, describe_field_t<SgTemplateFunctionDeclaration,SgName,&SgTemplateFunctionDeclaration::p_string>, describe_field_t<SgTemplateFunctionDeclaration,bool,&SgTemplateFunctionDeclaration::p_string_represents_function_body>, describe_field_t<SgTemplateFunctionDeclaration,SgDeclarationScope*,&SgTemplateFunctionDeclaration::p_nonreal_decl_scope>>;
};
template <> struct node_from_variant_t<725> { using type = SgTemplateFunctionDeclaration; };

// Class: TemplateFunctionRefExp
template <> struct describe_field_t<SgTemplateFunctionRefExp,SgTemplateFunctionSymbol*,&SgTemplateFunctionRefExp::p_symbol_i> {
  using parent = SgTemplateFunctionRefExp;
  using field_type = SgTemplateFunctionSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol_i"};
  static constexpr char const * const typestr{"SgTemplateFunctionSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateFunctionRefExp::p_symbol_i};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateFunctionRefExp, SgTemplateFunctionSymbol* SgTemplateFunctionRefExp::*, &SgTemplateFunctionRefExp::p_symbol_i>;
};
template <> struct describe_field_t<SgTemplateFunctionRefExp,int,&SgTemplateFunctionRefExp::p_name_qualification_length> {
  using parent = SgTemplateFunctionRefExp;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateFunctionRefExp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateFunctionRefExp, int SgTemplateFunctionRefExp::*, &SgTemplateFunctionRefExp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgTemplateFunctionRefExp,bool,&SgTemplateFunctionRefExp::p_type_elaboration_required> {
  using parent = SgTemplateFunctionRefExp;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateFunctionRefExp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateFunctionRefExp, bool SgTemplateFunctionRefExp::*, &SgTemplateFunctionRefExp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgTemplateFunctionRefExp,bool,&SgTemplateFunctionRefExp::p_global_qualification_required> {
  using parent = SgTemplateFunctionRefExp;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateFunctionRefExp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateFunctionRefExp, bool SgTemplateFunctionRefExp::*, &SgTemplateFunctionRefExp::p_global_qualification_required>;
};
template <> struct describe_node_t<SgTemplateFunctionRefExp> {
  using node = SgTemplateFunctionRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"TemplateFunctionRefExp"};
  static constexpr unsigned long variant{726};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateFunctionRefExp,SgTemplateFunctionSymbol*,&SgTemplateFunctionRefExp::p_symbol_i>, describe_field_t<SgTemplateFunctionRefExp,int,&SgTemplateFunctionRefExp::p_name_qualification_length>, describe_field_t<SgTemplateFunctionRefExp,bool,&SgTemplateFunctionRefExp::p_type_elaboration_required>, describe_field_t<SgTemplateFunctionRefExp,bool,&SgTemplateFunctionRefExp::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<726> { using type = SgTemplateFunctionRefExp; };

// Class: TemplateFunctionSymbol
template <> struct describe_node_t<SgTemplateFunctionSymbol> {
  using node = SgTemplateFunctionSymbol;
  using base = SgFunctionSymbol;
  static constexpr char const * const name{"TemplateFunctionSymbol"};
  static constexpr unsigned long variant{727};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<727> { using type = SgTemplateFunctionSymbol; };

// Class: TemplateMemberFunctionDeclaration
template <> struct describe_field_t<SgTemplateMemberFunctionDeclaration,SgTemplateParameterPtrList,&SgTemplateMemberFunctionDeclaration::p_templateParameters> {
  using parent = SgTemplateMemberFunctionDeclaration;
  using field_type = SgTemplateParameterPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateParameters"};
  static constexpr char const * const typestr{"SgTemplateParameterPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionDeclaration::p_templateParameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionDeclaration, SgTemplateParameterPtrList SgTemplateMemberFunctionDeclaration::*, &SgTemplateMemberFunctionDeclaration::p_templateParameters>;
};
template <> struct describe_field_t<SgTemplateMemberFunctionDeclaration,SgTemplateArgumentPtrList,&SgTemplateMemberFunctionDeclaration::p_templateSpecializationArguments> {
  using parent = SgTemplateMemberFunctionDeclaration;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateSpecializationArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionDeclaration::p_templateSpecializationArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionDeclaration, SgTemplateArgumentPtrList SgTemplateMemberFunctionDeclaration::*, &SgTemplateMemberFunctionDeclaration::p_templateSpecializationArguments>;
};
template <> struct describe_field_t<SgTemplateMemberFunctionDeclaration,SgName,&SgTemplateMemberFunctionDeclaration::p_string> {
  using parent = SgTemplateMemberFunctionDeclaration;
  using field_type = SgName;
  static constexpr size_t position{2};
  static constexpr char const * const name{"string"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionDeclaration::p_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionDeclaration, SgName SgTemplateMemberFunctionDeclaration::*, &SgTemplateMemberFunctionDeclaration::p_string>;
};
template <> struct describe_field_t<SgTemplateMemberFunctionDeclaration,bool,&SgTemplateMemberFunctionDeclaration::p_string_represents_function_body> {
  using parent = SgTemplateMemberFunctionDeclaration;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"string_represents_function_body"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionDeclaration::p_string_represents_function_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionDeclaration, bool SgTemplateMemberFunctionDeclaration::*, &SgTemplateMemberFunctionDeclaration::p_string_represents_function_body>;
};
template <> struct describe_field_t<SgTemplateMemberFunctionDeclaration,SgDeclarationScope*,&SgTemplateMemberFunctionDeclaration::p_nonreal_decl_scope> {
  using parent = SgTemplateMemberFunctionDeclaration;
  using field_type = SgDeclarationScope*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"nonreal_decl_scope"};
  static constexpr char const * const typestr{"SgDeclarationScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionDeclaration::p_nonreal_decl_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionDeclaration, SgDeclarationScope* SgTemplateMemberFunctionDeclaration::*, &SgTemplateMemberFunctionDeclaration::p_nonreal_decl_scope>;
};
template <> struct describe_node_t<SgTemplateMemberFunctionDeclaration> {
  using node = SgTemplateMemberFunctionDeclaration;
  using base = SgMemberFunctionDeclaration;
  static constexpr char const * const name{"TemplateMemberFunctionDeclaration"};
  static constexpr unsigned long variant{728};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateMemberFunctionDeclaration,SgTemplateParameterPtrList,&SgTemplateMemberFunctionDeclaration::p_templateParameters>, describe_field_t<SgTemplateMemberFunctionDeclaration,SgTemplateArgumentPtrList,&SgTemplateMemberFunctionDeclaration::p_templateSpecializationArguments>, describe_field_t<SgTemplateMemberFunctionDeclaration,SgName,&SgTemplateMemberFunctionDeclaration::p_string>, describe_field_t<SgTemplateMemberFunctionDeclaration,bool,&SgTemplateMemberFunctionDeclaration::p_string_represents_function_body>, describe_field_t<SgTemplateMemberFunctionDeclaration,SgDeclarationScope*,&SgTemplateMemberFunctionDeclaration::p_nonreal_decl_scope>>;
};
template <> struct node_from_variant_t<728> { using type = SgTemplateMemberFunctionDeclaration; };

// Class: TemplateMemberFunctionRefExp
template <> struct describe_field_t<SgTemplateMemberFunctionRefExp,SgTemplateMemberFunctionSymbol*,&SgTemplateMemberFunctionRefExp::p_symbol_i> {
  using parent = SgTemplateMemberFunctionRefExp;
  using field_type = SgTemplateMemberFunctionSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol_i"};
  static constexpr char const * const typestr{"SgTemplateMemberFunctionSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionRefExp::p_symbol_i};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionRefExp, SgTemplateMemberFunctionSymbol* SgTemplateMemberFunctionRefExp::*, &SgTemplateMemberFunctionRefExp::p_symbol_i>;
};
template <> struct describe_field_t<SgTemplateMemberFunctionRefExp,int,&SgTemplateMemberFunctionRefExp::p_virtual_call> {
  using parent = SgTemplateMemberFunctionRefExp;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"virtual_call"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionRefExp::p_virtual_call};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionRefExp, int SgTemplateMemberFunctionRefExp::*, &SgTemplateMemberFunctionRefExp::p_virtual_call>;
};
template <> struct describe_field_t<SgTemplateMemberFunctionRefExp,int,&SgTemplateMemberFunctionRefExp::p_need_qualifier> {
  using parent = SgTemplateMemberFunctionRefExp;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"need_qualifier"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionRefExp::p_need_qualifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionRefExp, int SgTemplateMemberFunctionRefExp::*, &SgTemplateMemberFunctionRefExp::p_need_qualifier>;
};
template <> struct describe_field_t<SgTemplateMemberFunctionRefExp,int,&SgTemplateMemberFunctionRefExp::p_name_qualification_length> {
  using parent = SgTemplateMemberFunctionRefExp;
  using field_type = int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionRefExp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionRefExp, int SgTemplateMemberFunctionRefExp::*, &SgTemplateMemberFunctionRefExp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgTemplateMemberFunctionRefExp,bool,&SgTemplateMemberFunctionRefExp::p_type_elaboration_required> {
  using parent = SgTemplateMemberFunctionRefExp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionRefExp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionRefExp, bool SgTemplateMemberFunctionRefExp::*, &SgTemplateMemberFunctionRefExp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgTemplateMemberFunctionRefExp,bool,&SgTemplateMemberFunctionRefExp::p_global_qualification_required> {
  using parent = SgTemplateMemberFunctionRefExp;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateMemberFunctionRefExp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateMemberFunctionRefExp, bool SgTemplateMemberFunctionRefExp::*, &SgTemplateMemberFunctionRefExp::p_global_qualification_required>;
};
template <> struct describe_node_t<SgTemplateMemberFunctionRefExp> {
  using node = SgTemplateMemberFunctionRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"TemplateMemberFunctionRefExp"};
  static constexpr unsigned long variant{729};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateMemberFunctionRefExp,SgTemplateMemberFunctionSymbol*,&SgTemplateMemberFunctionRefExp::p_symbol_i>, describe_field_t<SgTemplateMemberFunctionRefExp,int,&SgTemplateMemberFunctionRefExp::p_virtual_call>, describe_field_t<SgTemplateMemberFunctionRefExp,int,&SgTemplateMemberFunctionRefExp::p_need_qualifier>, describe_field_t<SgTemplateMemberFunctionRefExp,int,&SgTemplateMemberFunctionRefExp::p_name_qualification_length>, describe_field_t<SgTemplateMemberFunctionRefExp,bool,&SgTemplateMemberFunctionRefExp::p_type_elaboration_required>, describe_field_t<SgTemplateMemberFunctionRefExp,bool,&SgTemplateMemberFunctionRefExp::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<729> { using type = SgTemplateMemberFunctionRefExp; };

// Class: TemplateMemberFunctionSymbol
template <> struct describe_node_t<SgTemplateMemberFunctionSymbol> {
  using node = SgTemplateMemberFunctionSymbol;
  using base = SgMemberFunctionSymbol;
  static constexpr char const * const name{"TemplateMemberFunctionSymbol"};
  static constexpr unsigned long variant{730};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<730> { using type = SgTemplateMemberFunctionSymbol; };

// Class: TemplateTypedefDeclaration
template <> struct describe_field_t<SgTemplateTypedefDeclaration,SgTemplateParameterPtrList,&SgTemplateTypedefDeclaration::p_templateParameters> {
  using parent = SgTemplateTypedefDeclaration;
  using field_type = SgTemplateParameterPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateParameters"};
  static constexpr char const * const typestr{"SgTemplateParameterPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateTypedefDeclaration::p_templateParameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateTypedefDeclaration, SgTemplateParameterPtrList SgTemplateTypedefDeclaration::*, &SgTemplateTypedefDeclaration::p_templateParameters>;
};
template <> struct describe_field_t<SgTemplateTypedefDeclaration,SgTemplateArgumentPtrList,&SgTemplateTypedefDeclaration::p_templateSpecializationArguments> {
  using parent = SgTemplateTypedefDeclaration;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateSpecializationArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateTypedefDeclaration::p_templateSpecializationArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateTypedefDeclaration, SgTemplateArgumentPtrList SgTemplateTypedefDeclaration::*, &SgTemplateTypedefDeclaration::p_templateSpecializationArguments>;
};
template <> struct describe_field_t<SgTemplateTypedefDeclaration,SgName,&SgTemplateTypedefDeclaration::p_string> {
  using parent = SgTemplateTypedefDeclaration;
  using field_type = SgName;
  static constexpr size_t position{2};
  static constexpr char const * const name{"string"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateTypedefDeclaration::p_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateTypedefDeclaration, SgName SgTemplateTypedefDeclaration::*, &SgTemplateTypedefDeclaration::p_string>;
};
template <> struct describe_field_t<SgTemplateTypedefDeclaration,SgDeclarationScope*,&SgTemplateTypedefDeclaration::p_nonreal_decl_scope> {
  using parent = SgTemplateTypedefDeclaration;
  using field_type = SgDeclarationScope*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"nonreal_decl_scope"};
  static constexpr char const * const typestr{"SgDeclarationScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateTypedefDeclaration::p_nonreal_decl_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateTypedefDeclaration, SgDeclarationScope* SgTemplateTypedefDeclaration::*, &SgTemplateTypedefDeclaration::p_nonreal_decl_scope>;
};
template <> struct describe_node_t<SgTemplateTypedefDeclaration> {
  using node = SgTemplateTypedefDeclaration;
  using base = SgTypedefDeclaration;
  static constexpr char const * const name{"TemplateTypedefDeclaration"};
  static constexpr unsigned long variant{731};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateTypedefDeclaration,SgTemplateParameterPtrList,&SgTemplateTypedefDeclaration::p_templateParameters>, describe_field_t<SgTemplateTypedefDeclaration,SgTemplateArgumentPtrList,&SgTemplateTypedefDeclaration::p_templateSpecializationArguments>, describe_field_t<SgTemplateTypedefDeclaration,SgName,&SgTemplateTypedefDeclaration::p_string>, describe_field_t<SgTemplateTypedefDeclaration,SgDeclarationScope*,&SgTemplateTypedefDeclaration::p_nonreal_decl_scope>>;
};
template <> struct node_from_variant_t<731> { using type = SgTemplateTypedefDeclaration; };

// Class: TemplateTypedefSymbol
template <> struct describe_node_t<SgTemplateTypedefSymbol> {
  using node = SgTemplateTypedefSymbol;
  using base = SgTypedefSymbol;
  static constexpr char const * const name{"TemplateTypedefSymbol"};
  static constexpr unsigned long variant{732};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<732> { using type = SgTemplateTypedefSymbol; };

// Class: TemplateVariableDeclaration
template <> struct describe_field_t<SgTemplateVariableDeclaration,SgTemplateParameterPtrList,&SgTemplateVariableDeclaration::p_templateParameters> {
  using parent = SgTemplateVariableDeclaration;
  using field_type = SgTemplateParameterPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateParameters"};
  static constexpr char const * const typestr{"SgTemplateParameterPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateVariableDeclaration::p_templateParameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateVariableDeclaration, SgTemplateParameterPtrList SgTemplateVariableDeclaration::*, &SgTemplateVariableDeclaration::p_templateParameters>;
};
template <> struct describe_field_t<SgTemplateVariableDeclaration,SgTemplateArgumentPtrList,&SgTemplateVariableDeclaration::p_templateSpecializationArguments> {
  using parent = SgTemplateVariableDeclaration;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateSpecializationArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateVariableDeclaration::p_templateSpecializationArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateVariableDeclaration, SgTemplateArgumentPtrList SgTemplateVariableDeclaration::*, &SgTemplateVariableDeclaration::p_templateSpecializationArguments>;
};
template <> struct describe_field_t<SgTemplateVariableDeclaration,SgName,&SgTemplateVariableDeclaration::p_string> {
  using parent = SgTemplateVariableDeclaration;
  using field_type = SgName;
  static constexpr size_t position{2};
  static constexpr char const * const name{"string"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateVariableDeclaration::p_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateVariableDeclaration, SgName SgTemplateVariableDeclaration::*, &SgTemplateVariableDeclaration::p_string>;
};
template <> struct describe_field_t<SgTemplateVariableDeclaration,SgDeclarationScope*,&SgTemplateVariableDeclaration::p_nonreal_decl_scope> {
  using parent = SgTemplateVariableDeclaration;
  using field_type = SgDeclarationScope*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"nonreal_decl_scope"};
  static constexpr char const * const typestr{"SgDeclarationScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateVariableDeclaration::p_nonreal_decl_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateVariableDeclaration, SgDeclarationScope* SgTemplateVariableDeclaration::*, &SgTemplateVariableDeclaration::p_nonreal_decl_scope>;
};
template <> struct describe_node_t<SgTemplateVariableDeclaration> {
  using node = SgTemplateVariableDeclaration;
  using base = SgVariableDeclaration;
  static constexpr char const * const name{"TemplateVariableDeclaration"};
  static constexpr unsigned long variant{733};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateVariableDeclaration,SgTemplateParameterPtrList,&SgTemplateVariableDeclaration::p_templateParameters>, describe_field_t<SgTemplateVariableDeclaration,SgTemplateArgumentPtrList,&SgTemplateVariableDeclaration::p_templateSpecializationArguments>, describe_field_t<SgTemplateVariableDeclaration,SgName,&SgTemplateVariableDeclaration::p_string>, describe_field_t<SgTemplateVariableDeclaration,SgDeclarationScope*,&SgTemplateVariableDeclaration::p_nonreal_decl_scope>>;
};
template <> struct node_from_variant_t<733> { using type = SgTemplateVariableDeclaration; };

// Class: TemplateVariableSymbol
template <> struct describe_node_t<SgTemplateVariableSymbol> {
  using node = SgTemplateVariableSymbol;
  using base = SgVariableSymbol;
  static constexpr char const * const name{"TemplateVariableSymbol"};
  static constexpr unsigned long variant{734};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<734> { using type = SgTemplateVariableSymbol; };

// Class: TemplateClassDefinition
template <> struct describe_node_t<SgTemplateClassDefinition> {
  using node = SgTemplateClassDefinition;
  using base = SgClassDefinition;
  static constexpr char const * const name{"TemplateClassDefinition"};
  static constexpr unsigned long variant{735};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<735> { using type = SgTemplateClassDefinition; };

// Class: TemplateFunctionDefinition
template <> struct describe_node_t<SgTemplateFunctionDefinition> {
  using node = SgTemplateFunctionDefinition;
  using base = SgFunctionDefinition;
  static constexpr char const * const name{"TemplateFunctionDefinition"};
  static constexpr unsigned long variant{736};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<736> { using type = SgTemplateFunctionDefinition; };

// Class: TemplateInstantiationDecl
template <> struct describe_field_t<SgTemplateInstantiationDecl,SgName,&SgTemplateInstantiationDecl::p_templateName> {
  using parent = SgTemplateInstantiationDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateName"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationDecl::p_templateName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationDecl, SgName SgTemplateInstantiationDecl::*, &SgTemplateInstantiationDecl::p_templateName>;
};
template <> struct describe_field_t<SgTemplateInstantiationDecl,SgName,&SgTemplateInstantiationDecl::p_templateHeader> {
  using parent = SgTemplateInstantiationDecl;
  using field_type = SgName;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateHeader"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationDecl::p_templateHeader};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationDecl, SgName SgTemplateInstantiationDecl::*, &SgTemplateInstantiationDecl::p_templateHeader>;
};
template <> struct describe_field_t<SgTemplateInstantiationDecl,SgTemplateClassDeclaration*,&SgTemplateInstantiationDecl::p_templateDeclaration> {
  using parent = SgTemplateInstantiationDecl;
  using field_type = SgTemplateClassDeclaration*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"templateDeclaration"};
  static constexpr char const * const typestr{"SgTemplateClassDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationDecl::p_templateDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationDecl, SgTemplateClassDeclaration* SgTemplateInstantiationDecl::*, &SgTemplateInstantiationDecl::p_templateDeclaration>;
};
template <> struct describe_field_t<SgTemplateInstantiationDecl,SgTemplateArgumentPtrList,&SgTemplateInstantiationDecl::p_templateArguments> {
  using parent = SgTemplateInstantiationDecl;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"templateArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationDecl::p_templateArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationDecl, SgTemplateArgumentPtrList SgTemplateInstantiationDecl::*, &SgTemplateInstantiationDecl::p_templateArguments>;
};
template <> struct describe_field_t<SgTemplateInstantiationDecl,bool,&SgTemplateInstantiationDecl::p_nameResetFromMangledForm> {
  using parent = SgTemplateInstantiationDecl;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"nameResetFromMangledForm"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationDecl::p_nameResetFromMangledForm};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationDecl, bool SgTemplateInstantiationDecl::*, &SgTemplateInstantiationDecl::p_nameResetFromMangledForm>;
};
template <> struct describe_node_t<SgTemplateInstantiationDecl> {
  using node = SgTemplateInstantiationDecl;
  using base = SgClassDeclaration;
  static constexpr char const * const name{"TemplateInstantiationDecl"};
  static constexpr unsigned long variant{737};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateInstantiationDecl,SgName,&SgTemplateInstantiationDecl::p_templateName>, describe_field_t<SgTemplateInstantiationDecl,SgName,&SgTemplateInstantiationDecl::p_templateHeader>, describe_field_t<SgTemplateInstantiationDecl,SgTemplateClassDeclaration*,&SgTemplateInstantiationDecl::p_templateDeclaration>, describe_field_t<SgTemplateInstantiationDecl,SgTemplateArgumentPtrList,&SgTemplateInstantiationDecl::p_templateArguments>, describe_field_t<SgTemplateInstantiationDecl,bool,&SgTemplateInstantiationDecl::p_nameResetFromMangledForm>>;
};
template <> struct node_from_variant_t<737> { using type = SgTemplateInstantiationDecl; };

// Class: TemplateInstantiationDefn
template <> struct describe_node_t<SgTemplateInstantiationDefn> {
  using node = SgTemplateInstantiationDefn;
  using base = SgClassDefinition;
  static constexpr char const * const name{"TemplateInstantiationDefn"};
  static constexpr unsigned long variant{738};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<738> { using type = SgTemplateInstantiationDefn; };

// Class: TemplateInstantiationDirectiveStatement
template <> struct describe_field_t<SgTemplateInstantiationDirectiveStatement,SgDeclarationStatement*,&SgTemplateInstantiationDirectiveStatement::p_declaration> {
  using parent = SgTemplateInstantiationDirectiveStatement;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationDirectiveStatement::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationDirectiveStatement, SgDeclarationStatement* SgTemplateInstantiationDirectiveStatement::*, &SgTemplateInstantiationDirectiveStatement::p_declaration>;
};
template <> struct describe_field_t<SgTemplateInstantiationDirectiveStatement,bool,&SgTemplateInstantiationDirectiveStatement::p_do_not_instantiate> {
  using parent = SgTemplateInstantiationDirectiveStatement;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"do_not_instantiate"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationDirectiveStatement::p_do_not_instantiate};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationDirectiveStatement, bool SgTemplateInstantiationDirectiveStatement::*, &SgTemplateInstantiationDirectiveStatement::p_do_not_instantiate>;
};
template <> struct describe_node_t<SgTemplateInstantiationDirectiveStatement> {
  using node = SgTemplateInstantiationDirectiveStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"TemplateInstantiationDirectiveStatement"};
  static constexpr unsigned long variant{739};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateInstantiationDirectiveStatement,SgDeclarationStatement*,&SgTemplateInstantiationDirectiveStatement::p_declaration>, describe_field_t<SgTemplateInstantiationDirectiveStatement,bool,&SgTemplateInstantiationDirectiveStatement::p_do_not_instantiate>>;
};
template <> struct node_from_variant_t<739> { using type = SgTemplateInstantiationDirectiveStatement; };

// Class: TemplateInstantiationFunctionDecl
template <> struct describe_field_t<SgTemplateInstantiationFunctionDecl,SgName,&SgTemplateInstantiationFunctionDecl::p_templateName> {
  using parent = SgTemplateInstantiationFunctionDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateName"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationFunctionDecl::p_templateName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationFunctionDecl, SgName SgTemplateInstantiationFunctionDecl::*, &SgTemplateInstantiationFunctionDecl::p_templateName>;
};
template <> struct describe_field_t<SgTemplateInstantiationFunctionDecl,SgTemplateFunctionDeclaration*,&SgTemplateInstantiationFunctionDecl::p_templateDeclaration> {
  using parent = SgTemplateInstantiationFunctionDecl;
  using field_type = SgTemplateFunctionDeclaration*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateDeclaration"};
  static constexpr char const * const typestr{"SgTemplateFunctionDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationFunctionDecl::p_templateDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationFunctionDecl, SgTemplateFunctionDeclaration* SgTemplateInstantiationFunctionDecl::*, &SgTemplateInstantiationFunctionDecl::p_templateDeclaration>;
};
template <> struct describe_field_t<SgTemplateInstantiationFunctionDecl,SgTemplateArgumentPtrList,&SgTemplateInstantiationFunctionDecl::p_templateArguments> {
  using parent = SgTemplateInstantiationFunctionDecl;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"templateArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationFunctionDecl::p_templateArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationFunctionDecl, SgTemplateArgumentPtrList SgTemplateInstantiationFunctionDecl::*, &SgTemplateInstantiationFunctionDecl::p_templateArguments>;
};
template <> struct describe_field_t<SgTemplateInstantiationFunctionDecl,bool,&SgTemplateInstantiationFunctionDecl::p_nameResetFromMangledForm> {
  using parent = SgTemplateInstantiationFunctionDecl;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"nameResetFromMangledForm"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationFunctionDecl::p_nameResetFromMangledForm};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationFunctionDecl, bool SgTemplateInstantiationFunctionDecl::*, &SgTemplateInstantiationFunctionDecl::p_nameResetFromMangledForm>;
};
template <> struct describe_field_t<SgTemplateInstantiationFunctionDecl,bool,&SgTemplateInstantiationFunctionDecl::p_template_argument_list_is_explicit> {
  using parent = SgTemplateInstantiationFunctionDecl;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"template_argument_list_is_explicit"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationFunctionDecl::p_template_argument_list_is_explicit};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationFunctionDecl, bool SgTemplateInstantiationFunctionDecl::*, &SgTemplateInstantiationFunctionDecl::p_template_argument_list_is_explicit>;
};
template <> struct describe_node_t<SgTemplateInstantiationFunctionDecl> {
  using node = SgTemplateInstantiationFunctionDecl;
  using base = SgFunctionDeclaration;
  static constexpr char const * const name{"TemplateInstantiationFunctionDecl"};
  static constexpr unsigned long variant{740};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateInstantiationFunctionDecl,SgName,&SgTemplateInstantiationFunctionDecl::p_templateName>, describe_field_t<SgTemplateInstantiationFunctionDecl,SgTemplateFunctionDeclaration*,&SgTemplateInstantiationFunctionDecl::p_templateDeclaration>, describe_field_t<SgTemplateInstantiationFunctionDecl,SgTemplateArgumentPtrList,&SgTemplateInstantiationFunctionDecl::p_templateArguments>, describe_field_t<SgTemplateInstantiationFunctionDecl,bool,&SgTemplateInstantiationFunctionDecl::p_nameResetFromMangledForm>, describe_field_t<SgTemplateInstantiationFunctionDecl,bool,&SgTemplateInstantiationFunctionDecl::p_template_argument_list_is_explicit>>;
};
template <> struct node_from_variant_t<740> { using type = SgTemplateInstantiationFunctionDecl; };

// Class: TemplateInstantiationMemberFunctionDecl
template <> struct describe_field_t<SgTemplateInstantiationMemberFunctionDecl,SgName,&SgTemplateInstantiationMemberFunctionDecl::p_templateName> {
  using parent = SgTemplateInstantiationMemberFunctionDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateName"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationMemberFunctionDecl::p_templateName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationMemberFunctionDecl, SgName SgTemplateInstantiationMemberFunctionDecl::*, &SgTemplateInstantiationMemberFunctionDecl::p_templateName>;
};
template <> struct describe_field_t<SgTemplateInstantiationMemberFunctionDecl,SgTemplateMemberFunctionDeclaration*,&SgTemplateInstantiationMemberFunctionDecl::p_templateDeclaration> {
  using parent = SgTemplateInstantiationMemberFunctionDecl;
  using field_type = SgTemplateMemberFunctionDeclaration*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateDeclaration"};
  static constexpr char const * const typestr{"SgTemplateMemberFunctionDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationMemberFunctionDecl::p_templateDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationMemberFunctionDecl, SgTemplateMemberFunctionDeclaration* SgTemplateInstantiationMemberFunctionDecl::*, &SgTemplateInstantiationMemberFunctionDecl::p_templateDeclaration>;
};
template <> struct describe_field_t<SgTemplateInstantiationMemberFunctionDecl,SgTemplateArgumentPtrList,&SgTemplateInstantiationMemberFunctionDecl::p_templateArguments> {
  using parent = SgTemplateInstantiationMemberFunctionDecl;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{2};
  static constexpr char const * const name{"templateArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationMemberFunctionDecl::p_templateArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationMemberFunctionDecl, SgTemplateArgumentPtrList SgTemplateInstantiationMemberFunctionDecl::*, &SgTemplateInstantiationMemberFunctionDecl::p_templateArguments>;
};
template <> struct describe_field_t<SgTemplateInstantiationMemberFunctionDecl,bool,&SgTemplateInstantiationMemberFunctionDecl::p_nameResetFromMangledForm> {
  using parent = SgTemplateInstantiationMemberFunctionDecl;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"nameResetFromMangledForm"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationMemberFunctionDecl::p_nameResetFromMangledForm};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationMemberFunctionDecl, bool SgTemplateInstantiationMemberFunctionDecl::*, &SgTemplateInstantiationMemberFunctionDecl::p_nameResetFromMangledForm>;
};
template <> struct describe_field_t<SgTemplateInstantiationMemberFunctionDecl,bool,&SgTemplateInstantiationMemberFunctionDecl::p_template_argument_list_is_explicit> {
  using parent = SgTemplateInstantiationMemberFunctionDecl;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"template_argument_list_is_explicit"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationMemberFunctionDecl::p_template_argument_list_is_explicit};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationMemberFunctionDecl, bool SgTemplateInstantiationMemberFunctionDecl::*, &SgTemplateInstantiationMemberFunctionDecl::p_template_argument_list_is_explicit>;
};
template <> struct describe_node_t<SgTemplateInstantiationMemberFunctionDecl> {
  using node = SgTemplateInstantiationMemberFunctionDecl;
  using base = SgMemberFunctionDeclaration;
  static constexpr char const * const name{"TemplateInstantiationMemberFunctionDecl"};
  static constexpr unsigned long variant{741};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateInstantiationMemberFunctionDecl,SgName,&SgTemplateInstantiationMemberFunctionDecl::p_templateName>, describe_field_t<SgTemplateInstantiationMemberFunctionDecl,SgTemplateMemberFunctionDeclaration*,&SgTemplateInstantiationMemberFunctionDecl::p_templateDeclaration>, describe_field_t<SgTemplateInstantiationMemberFunctionDecl,SgTemplateArgumentPtrList,&SgTemplateInstantiationMemberFunctionDecl::p_templateArguments>, describe_field_t<SgTemplateInstantiationMemberFunctionDecl,bool,&SgTemplateInstantiationMemberFunctionDecl::p_nameResetFromMangledForm>, describe_field_t<SgTemplateInstantiationMemberFunctionDecl,bool,&SgTemplateInstantiationMemberFunctionDecl::p_template_argument_list_is_explicit>>;
};
template <> struct node_from_variant_t<741> { using type = SgTemplateInstantiationMemberFunctionDecl; };

// Class: TemplateInstantiationTypedefDeclaration
template <> struct describe_field_t<SgTemplateInstantiationTypedefDeclaration,SgName,&SgTemplateInstantiationTypedefDeclaration::p_templateName> {
  using parent = SgTemplateInstantiationTypedefDeclaration;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateName"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationTypedefDeclaration::p_templateName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationTypedefDeclaration, SgName SgTemplateInstantiationTypedefDeclaration::*, &SgTemplateInstantiationTypedefDeclaration::p_templateName>;
};
template <> struct describe_field_t<SgTemplateInstantiationTypedefDeclaration,SgName,&SgTemplateInstantiationTypedefDeclaration::p_templateHeader> {
  using parent = SgTemplateInstantiationTypedefDeclaration;
  using field_type = SgName;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateHeader"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationTypedefDeclaration::p_templateHeader};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationTypedefDeclaration, SgName SgTemplateInstantiationTypedefDeclaration::*, &SgTemplateInstantiationTypedefDeclaration::p_templateHeader>;
};
template <> struct describe_field_t<SgTemplateInstantiationTypedefDeclaration,SgTemplateTypedefDeclaration*,&SgTemplateInstantiationTypedefDeclaration::p_templateDeclaration> {
  using parent = SgTemplateInstantiationTypedefDeclaration;
  using field_type = SgTemplateTypedefDeclaration*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"templateDeclaration"};
  static constexpr char const * const typestr{"SgTemplateTypedefDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationTypedefDeclaration::p_templateDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationTypedefDeclaration, SgTemplateTypedefDeclaration* SgTemplateInstantiationTypedefDeclaration::*, &SgTemplateInstantiationTypedefDeclaration::p_templateDeclaration>;
};
template <> struct describe_field_t<SgTemplateInstantiationTypedefDeclaration,SgTemplateArgumentPtrList,&SgTemplateInstantiationTypedefDeclaration::p_templateArguments> {
  using parent = SgTemplateInstantiationTypedefDeclaration;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"templateArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationTypedefDeclaration::p_templateArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationTypedefDeclaration, SgTemplateArgumentPtrList SgTemplateInstantiationTypedefDeclaration::*, &SgTemplateInstantiationTypedefDeclaration::p_templateArguments>;
};
template <> struct describe_field_t<SgTemplateInstantiationTypedefDeclaration,bool,&SgTemplateInstantiationTypedefDeclaration::p_nameResetFromMangledForm> {
  using parent = SgTemplateInstantiationTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"nameResetFromMangledForm"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateInstantiationTypedefDeclaration::p_nameResetFromMangledForm};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateInstantiationTypedefDeclaration, bool SgTemplateInstantiationTypedefDeclaration::*, &SgTemplateInstantiationTypedefDeclaration::p_nameResetFromMangledForm>;
};
template <> struct describe_node_t<SgTemplateInstantiationTypedefDeclaration> {
  using node = SgTemplateInstantiationTypedefDeclaration;
  using base = SgTypedefDeclaration;
  static constexpr char const * const name{"TemplateInstantiationTypedefDeclaration"};
  static constexpr unsigned long variant{742};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateInstantiationTypedefDeclaration,SgName,&SgTemplateInstantiationTypedefDeclaration::p_templateName>, describe_field_t<SgTemplateInstantiationTypedefDeclaration,SgName,&SgTemplateInstantiationTypedefDeclaration::p_templateHeader>, describe_field_t<SgTemplateInstantiationTypedefDeclaration,SgTemplateTypedefDeclaration*,&SgTemplateInstantiationTypedefDeclaration::p_templateDeclaration>, describe_field_t<SgTemplateInstantiationTypedefDeclaration,SgTemplateArgumentPtrList,&SgTemplateInstantiationTypedefDeclaration::p_templateArguments>, describe_field_t<SgTemplateInstantiationTypedefDeclaration,bool,&SgTemplateInstantiationTypedefDeclaration::p_nameResetFromMangledForm>>;
};
template <> struct node_from_variant_t<742> { using type = SgTemplateInstantiationTypedefDeclaration; };

// Class: TemplateParameter
template <> struct describe_field_t<SgTemplateParameter,SgTemplateParameter::template_parameter_enum,&SgTemplateParameter::p_parameterType> {
  using parent = SgTemplateParameter;
  using field_type = SgTemplateParameter::template_parameter_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"parameterType"};
  static constexpr char const * const typestr{"SgTemplateParameter::template_parameter_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateParameter::p_parameterType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameter, SgTemplateParameter::template_parameter_enum SgTemplateParameter::*, &SgTemplateParameter::p_parameterType>;
};
template <> struct describe_field_t<SgTemplateParameter,SgType*,&SgTemplateParameter::p_type> {
  using parent = SgTemplateParameter;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateParameter::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameter, SgType* SgTemplateParameter::*, &SgTemplateParameter::p_type>;
};
template <> struct describe_field_t<SgTemplateParameter,SgType*,&SgTemplateParameter::p_defaultTypeParameter> {
  using parent = SgTemplateParameter;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"defaultTypeParameter"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateParameter::p_defaultTypeParameter};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameter, SgType* SgTemplateParameter::*, &SgTemplateParameter::p_defaultTypeParameter>;
};
template <> struct describe_field_t<SgTemplateParameter,SgExpression*,&SgTemplateParameter::p_expression> {
  using parent = SgTemplateParameter;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateParameter::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameter, SgExpression* SgTemplateParameter::*, &SgTemplateParameter::p_expression>;
};
template <> struct describe_field_t<SgTemplateParameter,SgExpression*,&SgTemplateParameter::p_defaultExpressionParameter> {
  using parent = SgTemplateParameter;
  using field_type = SgExpression*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"defaultExpressionParameter"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateParameter::p_defaultExpressionParameter};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameter, SgExpression* SgTemplateParameter::*, &SgTemplateParameter::p_defaultExpressionParameter>;
};
template <> struct describe_field_t<SgTemplateParameter,SgDeclarationStatement*,&SgTemplateParameter::p_templateDeclaration> {
  using parent = SgTemplateParameter;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"templateDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateParameter::p_templateDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameter, SgDeclarationStatement* SgTemplateParameter::*, &SgTemplateParameter::p_templateDeclaration>;
};
template <> struct describe_field_t<SgTemplateParameter,SgDeclarationStatement*,&SgTemplateParameter::p_defaultTemplateDeclarationParameter> {
  using parent = SgTemplateParameter;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"defaultTemplateDeclarationParameter"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateParameter::p_defaultTemplateDeclarationParameter};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameter, SgDeclarationStatement* SgTemplateParameter::*, &SgTemplateParameter::p_defaultTemplateDeclarationParameter>;
};
template <> struct describe_field_t<SgTemplateParameter,SgInitializedName*,&SgTemplateParameter::p_initializedName> {
  using parent = SgTemplateParameter;
  using field_type = SgInitializedName*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"initializedName"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateParameter::p_initializedName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameter, SgInitializedName* SgTemplateParameter::*, &SgTemplateParameter::p_initializedName>;
};
template <> struct describe_node_t<SgTemplateParameter> {
  using node = SgTemplateParameter;
  using base = SgSupport;
  static constexpr char const * const name{"TemplateParameter"};
  static constexpr unsigned long variant{743};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateParameter,SgTemplateParameter::template_parameter_enum,&SgTemplateParameter::p_parameterType>, describe_field_t<SgTemplateParameter,SgType*,&SgTemplateParameter::p_type>, describe_field_t<SgTemplateParameter,SgType*,&SgTemplateParameter::p_defaultTypeParameter>, describe_field_t<SgTemplateParameter,SgExpression*,&SgTemplateParameter::p_expression>, describe_field_t<SgTemplateParameter,SgExpression*,&SgTemplateParameter::p_defaultExpressionParameter>, describe_field_t<SgTemplateParameter,SgDeclarationStatement*,&SgTemplateParameter::p_templateDeclaration>, describe_field_t<SgTemplateParameter,SgDeclarationStatement*,&SgTemplateParameter::p_defaultTemplateDeclarationParameter>, describe_field_t<SgTemplateParameter,SgInitializedName*,&SgTemplateParameter::p_initializedName>>;
};
template <> struct node_from_variant_t<743> { using type = SgTemplateParameter; };

// Class: TemplateParameterVal
template <> struct describe_field_t<SgTemplateParameterVal,int,&SgTemplateParameterVal::p_template_parameter_position> {
  using parent = SgTemplateParameterVal;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"template_parameter_position"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateParameterVal::p_template_parameter_position};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameterVal, int SgTemplateParameterVal::*, &SgTemplateParameterVal::p_template_parameter_position>;
};
template <> struct describe_field_t<SgTemplateParameterVal,std::string,&SgTemplateParameterVal::p_valueString> {
  using parent = SgTemplateParameterVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateParameterVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameterVal, std::string SgTemplateParameterVal::*, &SgTemplateParameterVal::p_valueString>;
};
template <> struct describe_field_t<SgTemplateParameterVal,SgType*,&SgTemplateParameterVal::p_valueType> {
  using parent = SgTemplateParameterVal;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"valueType"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateParameterVal::p_valueType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameterVal, SgType* SgTemplateParameterVal::*, &SgTemplateParameterVal::p_valueType>;
};
template <> struct describe_node_t<SgTemplateParameterVal> {
  using node = SgTemplateParameterVal;
  using base = SgValueExp;
  static constexpr char const * const name{"TemplateParameterVal"};
  static constexpr unsigned long variant{744};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateParameterVal,int,&SgTemplateParameterVal::p_template_parameter_position>, describe_field_t<SgTemplateParameterVal,std::string,&SgTemplateParameterVal::p_valueString>, describe_field_t<SgTemplateParameterVal,SgType*,&SgTemplateParameterVal::p_valueType>>;
};
template <> struct node_from_variant_t<744> { using type = SgTemplateParameterVal; };

// Class: TemplateParameterList
template <> struct describe_field_t<SgTemplateParameterList,SgTemplateParameterPtrList,&SgTemplateParameterList::p_args> {
  using parent = SgTemplateParameterList;
  using field_type = SgTemplateParameterPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"args"};
  static constexpr char const * const typestr{"SgTemplateParameterPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateParameterList::p_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateParameterList, SgTemplateParameterPtrList SgTemplateParameterList::*, &SgTemplateParameterList::p_args>;
};
template <> struct describe_node_t<SgTemplateParameterList> {
  using node = SgTemplateParameterList;
  using base = SgSupport;
  static constexpr char const * const name{"TemplateParameterList"};
  static constexpr unsigned long variant{745};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateParameterList,SgTemplateParameterPtrList,&SgTemplateParameterList::p_args>>;
};
template <> struct node_from_variant_t<745> { using type = SgTemplateParameterList; };

// Class: TemplateSymbol
template <> struct describe_field_t<SgTemplateSymbol,SgTemplateDeclaration*,&SgTemplateSymbol::p_declaration> {
  using parent = SgTemplateSymbol;
  using field_type = SgTemplateDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgTemplateDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateSymbol, SgTemplateDeclaration* SgTemplateSymbol::*, &SgTemplateSymbol::p_declaration>;
};
template <> struct describe_node_t<SgTemplateSymbol> {
  using node = SgTemplateSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"TemplateSymbol"};
  static constexpr unsigned long variant{746};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateSymbol,SgTemplateDeclaration*,&SgTemplateSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<746> { using type = SgTemplateSymbol; };

// Class: TemplateType
template <> struct describe_field_t<SgTemplateType,SgName,&SgTemplateType::p_name> {
  using parent = SgTemplateType;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateType::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateType, SgName SgTemplateType::*, &SgTemplateType::p_name>;
};
template <> struct describe_field_t<SgTemplateType,int,&SgTemplateType::p_template_parameter_position> {
  using parent = SgTemplateType;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"template_parameter_position"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateType::p_template_parameter_position};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateType, int SgTemplateType::*, &SgTemplateType::p_template_parameter_position>;
};
template <> struct describe_field_t<SgTemplateType,int,&SgTemplateType::p_template_parameter_depth> {
  using parent = SgTemplateType;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"template_parameter_depth"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateType::p_template_parameter_depth};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateType, int SgTemplateType::*, &SgTemplateType::p_template_parameter_depth>;
};
template <> struct describe_field_t<SgTemplateType,SgType *,&SgTemplateType::p_class_type> {
  using parent = SgTemplateType;
  using field_type = SgType *;
  static constexpr size_t position{3};
  static constexpr char const * const name{"class_type"};
  static constexpr char const * const typestr{"SgType *"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateType::p_class_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateType, SgType * SgTemplateType::*, &SgTemplateType::p_class_type>;
};
template <> struct describe_field_t<SgTemplateType,SgType *,&SgTemplateType::p_parent_class_type> {
  using parent = SgTemplateType;
  using field_type = SgType *;
  static constexpr size_t position{4};
  static constexpr char const * const name{"parent_class_type"};
  static constexpr char const * const typestr{"SgType *"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateType::p_parent_class_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateType, SgType * SgTemplateType::*, &SgTemplateType::p_parent_class_type>;
};
template <> struct describe_field_t<SgTemplateType,SgTemplateParameter *,&SgTemplateType::p_template_parameter> {
  using parent = SgTemplateType;
  using field_type = SgTemplateParameter *;
  static constexpr size_t position{5};
  static constexpr char const * const name{"template_parameter"};
  static constexpr char const * const typestr{"SgTemplateParameter *"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTemplateType::p_template_parameter};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateType, SgTemplateParameter * SgTemplateType::*, &SgTemplateType::p_template_parameter>;
};
template <> struct describe_field_t<SgTemplateType,SgTemplateArgumentPtrList,&SgTemplateType::p_tpl_args> {
  using parent = SgTemplateType;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{6};
  static constexpr char const * const name{"tpl_args"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateType::p_tpl_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateType, SgTemplateArgumentPtrList SgTemplateType::*, &SgTemplateType::p_tpl_args>;
};
template <> struct describe_field_t<SgTemplateType,SgTemplateArgumentPtrList,&SgTemplateType::p_part_spec_tpl_args> {
  using parent = SgTemplateType;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{7};
  static constexpr char const * const name{"part_spec_tpl_args"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateType::p_part_spec_tpl_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateType, SgTemplateArgumentPtrList SgTemplateType::*, &SgTemplateType::p_part_spec_tpl_args>;
};
template <> struct describe_field_t<SgTemplateType,bool,&SgTemplateType::p_packed> {
  using parent = SgTemplateType;
  using field_type = bool;
  static constexpr size_t position{8};
  static constexpr char const * const name{"packed"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateType::p_packed};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateType, bool SgTemplateType::*, &SgTemplateType::p_packed>;
};
template <> struct describe_node_t<SgTemplateType> {
  using node = SgTemplateType;
  using base = SgType;
  static constexpr char const * const name{"TemplateType"};
  static constexpr unsigned long variant{747};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateType,SgName,&SgTemplateType::p_name>, describe_field_t<SgTemplateType,int,&SgTemplateType::p_template_parameter_position>, describe_field_t<SgTemplateType,int,&SgTemplateType::p_template_parameter_depth>, describe_field_t<SgTemplateType,SgType *,&SgTemplateType::p_class_type>, describe_field_t<SgTemplateType,SgType *,&SgTemplateType::p_parent_class_type>, describe_field_t<SgTemplateType,SgTemplateParameter *,&SgTemplateType::p_template_parameter>, describe_field_t<SgTemplateType,SgTemplateArgumentPtrList,&SgTemplateType::p_tpl_args>, describe_field_t<SgTemplateType,SgTemplateArgumentPtrList,&SgTemplateType::p_part_spec_tpl_args>, describe_field_t<SgTemplateType,bool,&SgTemplateType::p_packed>>;
};
template <> struct node_from_variant_t<747> { using type = SgTemplateType; };

// Class: ThisExp
template <> struct describe_field_t<SgThisExp,SgClassSymbol*,&SgThisExp::p_class_symbol> {
  using parent = SgThisExp;
  using field_type = SgClassSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"class_symbol"};
  static constexpr char const * const typestr{"SgClassSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgThisExp::p_class_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgThisExp, SgClassSymbol* SgThisExp::*, &SgThisExp::p_class_symbol>;
};
template <> struct describe_field_t<SgThisExp,SgNonrealSymbol*,&SgThisExp::p_nonreal_symbol> {
  using parent = SgThisExp;
  using field_type = SgNonrealSymbol*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"nonreal_symbol"};
  static constexpr char const * const typestr{"SgNonrealSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgThisExp::p_nonreal_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgThisExp, SgNonrealSymbol* SgThisExp::*, &SgThisExp::p_nonreal_symbol>;
};
template <> struct describe_field_t<SgThisExp,int,&SgThisExp::p_pobj_this> {
  using parent = SgThisExp;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"pobj_this"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgThisExp::p_pobj_this};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgThisExp, int SgThisExp::*, &SgThisExp::p_pobj_this>;
};
template <> struct describe_node_t<SgThisExp> {
  using node = SgThisExp;
  using base = SgExpression;
  static constexpr char const * const name{"ThisExp"};
  static constexpr unsigned long variant{748};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgThisExp,SgClassSymbol*,&SgThisExp::p_class_symbol>, describe_field_t<SgThisExp,SgNonrealSymbol*,&SgThisExp::p_nonreal_symbol>, describe_field_t<SgThisExp,int,&SgThisExp::p_pobj_this>>;
};
template <> struct node_from_variant_t<748> { using type = SgThisExp; };

// Class: TypeTraitBuiltinOperator
template <> struct describe_field_t<SgTypeTraitBuiltinOperator,SgName,&SgTypeTraitBuiltinOperator::p_name> {
  using parent = SgTypeTraitBuiltinOperator;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeTraitBuiltinOperator::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeTraitBuiltinOperator, SgName SgTypeTraitBuiltinOperator::*, &SgTypeTraitBuiltinOperator::p_name>;
};
template <> struct describe_field_t<SgTypeTraitBuiltinOperator,SgNodePtrList,&SgTypeTraitBuiltinOperator::p_args> {
  using parent = SgTypeTraitBuiltinOperator;
  using field_type = SgNodePtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"args"};
  static constexpr char const * const typestr{"SgNodePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeTraitBuiltinOperator::p_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeTraitBuiltinOperator, SgNodePtrList SgTypeTraitBuiltinOperator::*, &SgTypeTraitBuiltinOperator::p_args>;
};
template <> struct describe_node_t<SgTypeTraitBuiltinOperator> {
  using node = SgTypeTraitBuiltinOperator;
  using base = SgExpression;
  static constexpr char const * const name{"TypeTraitBuiltinOperator"};
  static constexpr unsigned long variant{749};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeTraitBuiltinOperator,SgName,&SgTypeTraitBuiltinOperator::p_name>, describe_field_t<SgTypeTraitBuiltinOperator,SgNodePtrList,&SgTypeTraitBuiltinOperator::p_args>>;
};
template <> struct node_from_variant_t<749> { using type = SgTypeTraitBuiltinOperator; };

// Class: SuperExp
template <> struct describe_field_t<SgSuperExp,SgClassSymbol*,&SgSuperExp::p_class_symbol> {
  using parent = SgSuperExp;
  using field_type = SgClassSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"class_symbol"};
  static constexpr char const * const typestr{"SgClassSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSuperExp::p_class_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSuperExp, SgClassSymbol* SgSuperExp::*, &SgSuperExp::p_class_symbol>;
};
template <> struct describe_field_t<SgSuperExp,int,&SgSuperExp::p_pobj_super> {
  using parent = SgSuperExp;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"pobj_super"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSuperExp::p_pobj_super};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSuperExp, int SgSuperExp::*, &SgSuperExp::p_pobj_super>;
};
template <> struct describe_node_t<SgSuperExp> {
  using node = SgSuperExp;
  using base = SgExpression;
  static constexpr char const * const name{"SuperExp"};
  static constexpr unsigned long variant{750};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSuperExp,SgClassSymbol*,&SgSuperExp::p_class_symbol>, describe_field_t<SgSuperExp,int,&SgSuperExp::p_pobj_super>>;
};
template <> struct node_from_variant_t<750> { using type = SgSuperExp; };

// Class: ThrowOp
template <> struct describe_field_t<SgThrowOp,SgThrowOp::e_throw_kind,&SgThrowOp::p_throwKind> {
  using parent = SgThrowOp;
  using field_type = SgThrowOp::e_throw_kind;
  static constexpr size_t position{0};
  static constexpr char const * const name{"throwKind"};
  static constexpr char const * const typestr{"SgThrowOp::e_throw_kind"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgThrowOp::p_throwKind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgThrowOp, SgThrowOp::e_throw_kind SgThrowOp::*, &SgThrowOp::p_throwKind>;
};
template <> struct describe_node_t<SgThrowOp> {
  using node = SgThrowOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"ThrowOp"};
  static constexpr unsigned long variant{751};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgThrowOp,SgThrowOp::e_throw_kind,&SgThrowOp::p_throwKind>>;
};
template <> struct node_from_variant_t<751> { using type = SgThrowOp; };

// Class: Token
template <> struct describe_field_t<SgToken,std::string,&SgToken::p_lexeme_string> {
  using parent = SgToken;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lexeme_string"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgToken::p_lexeme_string};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgToken, std::string SgToken::*, &SgToken::p_lexeme_string>;
};
template <> struct describe_field_t<SgToken,unsigned int,&SgToken::p_classification_code> {
  using parent = SgToken;
  using field_type = unsigned int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"classification_code"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgToken::p_classification_code};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgToken, unsigned int SgToken::*, &SgToken::p_classification_code>;
};
template <> struct describe_node_t<SgToken> {
  using node = SgToken;
  using base = SgLocatedNode;
  static constexpr char const * const name{"Token"};
  static constexpr unsigned long variant{752};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgToken,std::string,&SgToken::p_lexeme_string>, describe_field_t<SgToken,unsigned int,&SgToken::p_classification_code>>;
};
template <> struct node_from_variant_t<752> { using type = SgToken; };

// Class: TryStmt
template <> struct describe_field_t<SgTryStmt,SgStatement*,&SgTryStmt::p_body> {
  using parent = SgTryStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTryStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTryStmt, SgStatement* SgTryStmt::*, &SgTryStmt::p_body>;
};
template <> struct describe_field_t<SgTryStmt,SgCatchStatementSeq*,&SgTryStmt::p_catch_statement_seq_root> {
  using parent = SgTryStmt;
  using field_type = SgCatchStatementSeq*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"catch_statement_seq_root"};
  static constexpr char const * const typestr{"SgCatchStatementSeq*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTryStmt::p_catch_statement_seq_root};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTryStmt, SgCatchStatementSeq* SgTryStmt::*, &SgTryStmt::p_catch_statement_seq_root>;
};
template <> struct describe_field_t<SgTryStmt,SgStatement*,&SgTryStmt::p_else_body> {
  using parent = SgTryStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"else_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTryStmt::p_else_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTryStmt, SgStatement* SgTryStmt::*, &SgTryStmt::p_else_body>;
};
template <> struct describe_field_t<SgTryStmt,SgStatement*,&SgTryStmt::p_finally_body> {
  using parent = SgTryStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"finally_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTryStmt::p_finally_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTryStmt, SgStatement* SgTryStmt::*, &SgTryStmt::p_finally_body>;
};
template <> struct describe_node_t<SgTryStmt> {
  using node = SgTryStmt;
  using base = SgStatement;
  static constexpr char const * const name{"TryStmt"};
  static constexpr unsigned long variant{753};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTryStmt,SgStatement*,&SgTryStmt::p_body>, describe_field_t<SgTryStmt,SgCatchStatementSeq*,&SgTryStmt::p_catch_statement_seq_root>, describe_field_t<SgTryStmt,SgStatement*,&SgTryStmt::p_else_body>, describe_field_t<SgTryStmt,SgStatement*,&SgTryStmt::p_finally_body>>;
};
template <> struct node_from_variant_t<753> { using type = SgTryStmt; };

// Class: TupleExp
template <> struct describe_node_t<SgTupleExp> {
  using node = SgTupleExp;
  using base = SgExprListExp;
  static constexpr char const * const name{"TupleExp"};
  static constexpr unsigned long variant{754};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<754> { using type = SgTupleExp; };

// Class: Type
template <> struct describe_field_t<SgType,bool,&SgType::p_isCoArray> {
  using parent = SgType;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"isCoArray"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_isCoArray};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, bool SgType::*, &SgType::p_isCoArray>;
};
template <> struct describe_field_t<SgType,int,&SgType::p_substitutedForTemplateParam> {
  using parent = SgType;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"substitutedForTemplateParam"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_substitutedForTemplateParam};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, int SgType::*, &SgType::p_substitutedForTemplateParam>;
};
template <> struct describe_field_t<SgType,SgReferenceType*,&SgType::p_ref_to> {
  using parent = SgType;
  using field_type = SgReferenceType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"ref_to"};
  static constexpr char const * const typestr{"SgReferenceType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_ref_to};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, SgReferenceType* SgType::*, &SgType::p_ref_to>;
};
template <> struct describe_field_t<SgType,SgPointerType*,&SgType::p_ptr_to> {
  using parent = SgType;
  using field_type = SgPointerType*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"ptr_to"};
  static constexpr char const * const typestr{"SgPointerType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_ptr_to};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, SgPointerType* SgType::*, &SgType::p_ptr_to>;
};
template <> struct describe_field_t<SgType,SgModifierNodes*,&SgType::p_modifiers> {
  using parent = SgType;
  using field_type = SgModifierNodes*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"modifiers"};
  static constexpr char const * const typestr{"SgModifierNodes*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_modifiers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, SgModifierNodes* SgType::*, &SgType::p_modifiers>;
};
template <> struct describe_field_t<SgType,SgTypedefSeq*,&SgType::p_typedefs> {
  using parent = SgType;
  using field_type = SgTypedefSeq*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"typedefs"};
  static constexpr char const * const typestr{"SgTypedefSeq*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_typedefs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, SgTypedefSeq* SgType::*, &SgType::p_typedefs>;
};
template <> struct describe_field_t<SgType,SgRvalueReferenceType*,&SgType::p_rvalue_ref_to> {
  using parent = SgType;
  using field_type = SgRvalueReferenceType*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"rvalue_ref_to"};
  static constexpr char const * const typestr{"SgRvalueReferenceType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_rvalue_ref_to};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, SgRvalueReferenceType* SgType::*, &SgType::p_rvalue_ref_to>;
};
template <> struct describe_field_t<SgType,SgDeclType*,&SgType::p_decltype_ref_to> {
  using parent = SgType;
  using field_type = SgDeclType*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"decltype_ref_to"};
  static constexpr char const * const typestr{"SgDeclType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_decltype_ref_to};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, SgDeclType* SgType::*, &SgType::p_decltype_ref_to>;
};
template <> struct describe_field_t<SgType,SgTypeOfType*,&SgType::p_typeof_ref_to> {
  using parent = SgType;
  using field_type = SgTypeOfType*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"typeof_ref_to"};
  static constexpr char const * const typestr{"SgTypeOfType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_typeof_ref_to};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, SgTypeOfType* SgType::*, &SgType::p_typeof_ref_to>;
};
template <> struct describe_field_t<SgType,SgExpression*,&SgType::p_type_kind> {
  using parent = SgType;
  using field_type = SgExpression*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"type_kind"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgType::p_type_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, SgExpression* SgType::*, &SgType::p_type_kind>;
};
template <> struct describe_field_t<SgType,bool,&SgType::p_hasTypeKindStar> {
  using parent = SgType;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"hasTypeKindStar"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_hasTypeKindStar};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, bool SgType::*, &SgType::p_hasTypeKindStar>;
};
template <> struct describe_field_t<SgType,AstAttributeMechanism*,&SgType::p_attributeMechanism> {
  using parent = SgType;
  using field_type = AstAttributeMechanism*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"attributeMechanism"};
  static constexpr char const * const typestr{"AstAttributeMechanism*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgType::p_attributeMechanism};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgType, AstAttributeMechanism* SgType::*, &SgType::p_attributeMechanism>;
};
template <> struct describe_node_t<SgType> {
  using node = SgType;
  using base = SgNode;
  static constexpr char const * const name{"Type"};
  static constexpr unsigned long variant{755};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgTypeUnknown, SgTypeChar, SgTypeSignedChar, SgTypeUnsignedChar, SgTypeShort, SgTypeSignedShort, SgTypeUnsignedShort, SgTypeInt, SgTypeSignedInt, SgTypeUnsignedInt, SgTypeLong, SgTypeSignedLong, SgTypeUnsignedLong, SgTypeVoid, SgTypeGlobalVoid, SgTypeWchar, SgTypeFloat, SgTypeDouble, SgTypeLongLong, SgTypeSignedLongLong, SgTypeUnsignedLongLong, SgTypeSigned128bitInteger, SgTypeUnsigned128bitInteger, SgTypeFloat80, SgTypeLongDouble, SgTypeString, SgTypeBool, SgPointerType, SgReferenceType, SgNamedType, SgModifierType, SgFunctionType, SgArrayType, SgTypeEllipse, SgTemplateType, SgQualifiedNameType, SgTypeComplex, SgTypeImaginary, SgTypeDefault, SgTypeCAFTeam, SgTypeCrayPointer, SgTypeLabel, SgJavaUnionType, SgRvalueReferenceType, SgTypeNullptr, SgDeclType, SgTypeOfType, SgTypeMatrix, SgTypeTuple, SgTypeChar16, SgTypeChar32, SgTypeFloat128, SgTypeFixed, SgAutoType, SgAdaAccessType, SgAdaSubtype, SgAdaDiscreteType, SgAdaModularType, SgAdaDerivedType, SgAdaSubroutineType, SgJovialBitType, SgRangeType>;
  using fields_t = mp::List<describe_field_t<SgType,bool,&SgType::p_isCoArray>, describe_field_t<SgType,int,&SgType::p_substitutedForTemplateParam>, describe_field_t<SgType,SgReferenceType*,&SgType::p_ref_to>, describe_field_t<SgType,SgPointerType*,&SgType::p_ptr_to>, describe_field_t<SgType,SgModifierNodes*,&SgType::p_modifiers>, describe_field_t<SgType,SgTypedefSeq*,&SgType::p_typedefs>, describe_field_t<SgType,SgRvalueReferenceType*,&SgType::p_rvalue_ref_to>, describe_field_t<SgType,SgDeclType*,&SgType::p_decltype_ref_to>, describe_field_t<SgType,SgTypeOfType*,&SgType::p_typeof_ref_to>, describe_field_t<SgType,SgExpression*,&SgType::p_type_kind>, describe_field_t<SgType,bool,&SgType::p_hasTypeKindStar>, describe_field_t<SgType,AstAttributeMechanism*,&SgType::p_attributeMechanism>>;
};
template <> struct node_from_variant_t<755> { using type = SgType; };

// Class: TypeBool
template <> struct describe_node_t<SgTypeBool> {
  using node = SgTypeBool;
  using base = SgType;
  static constexpr char const * const name{"TypeBool"};
  static constexpr unsigned long variant{756};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<756> { using type = SgTypeBool; };

// Class: TypeChar
template <> struct describe_node_t<SgTypeChar> {
  using node = SgTypeChar;
  using base = SgType;
  static constexpr char const * const name{"TypeChar"};
  static constexpr unsigned long variant{757};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<757> { using type = SgTypeChar; };

// Class: TypeChar16
template <> struct describe_node_t<SgTypeChar16> {
  using node = SgTypeChar16;
  using base = SgType;
  static constexpr char const * const name{"TypeChar16"};
  static constexpr unsigned long variant{758};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<758> { using type = SgTypeChar16; };

// Class: TypeChar32
template <> struct describe_node_t<SgTypeChar32> {
  using node = SgTypeChar32;
  using base = SgType;
  static constexpr char const * const name{"TypeChar32"};
  static constexpr unsigned long variant{759};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<759> { using type = SgTypeChar32; };

// Class: TypeComplex
template <> struct describe_field_t<SgTypeComplex,SgType*,&SgTypeComplex::p_base_type> {
  using parent = SgTypeComplex;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeComplex::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeComplex, SgType* SgTypeComplex::*, &SgTypeComplex::p_base_type>;
};
template <> struct describe_node_t<SgTypeComplex> {
  using node = SgTypeComplex;
  using base = SgType;
  static constexpr char const * const name{"TypeComplex"};
  static constexpr unsigned long variant{760};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeComplex,SgType*,&SgTypeComplex::p_base_type>>;
};
template <> struct node_from_variant_t<760> { using type = SgTypeComplex; };

// Class: TypeDefault
template <> struct describe_field_t<SgTypeDefault,SgName,&SgTypeDefault::p_name> {
  using parent = SgTypeDefault;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeDefault::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeDefault, SgName SgTypeDefault::*, &SgTypeDefault::p_name>;
};
template <> struct describe_node_t<SgTypeDefault> {
  using node = SgTypeDefault;
  using base = SgType;
  static constexpr char const * const name{"TypeDefault"};
  static constexpr unsigned long variant{761};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeDefault,SgName,&SgTypeDefault::p_name>>;
};
template <> struct node_from_variant_t<761> { using type = SgTypeDefault; };

// Class: TypeExpression
template <> struct describe_field_t<SgTypeExpression,SgType*,&SgTypeExpression::p_type> {
  using parent = SgTypeExpression;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeExpression::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeExpression, SgType* SgTypeExpression::*, &SgTypeExpression::p_type>;
};
template <> struct describe_node_t<SgTypeExpression> {
  using node = SgTypeExpression;
  using base = SgExpression;
  static constexpr char const * const name{"TypeExpression"};
  static constexpr unsigned long variant{762};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeExpression,SgType*,&SgTypeExpression::p_type>>;
};
template <> struct node_from_variant_t<762> { using type = SgTypeExpression; };

// Class: TypeLabel
template <> struct describe_field_t<SgTypeLabel,SgName,&SgTypeLabel::p_name> {
  using parent = SgTypeLabel;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeLabel::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeLabel, SgName SgTypeLabel::*, &SgTypeLabel::p_name>;
};
template <> struct describe_node_t<SgTypeLabel> {
  using node = SgTypeLabel;
  using base = SgType;
  static constexpr char const * const name{"TypeLabel"};
  static constexpr unsigned long variant{763};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeLabel,SgName,&SgTypeLabel::p_name>>;
};
template <> struct node_from_variant_t<763> { using type = SgTypeLabel; };

// Class: TypeDouble
template <> struct describe_node_t<SgTypeDouble> {
  using node = SgTypeDouble;
  using base = SgType;
  static constexpr char const * const name{"TypeDouble"};
  static constexpr unsigned long variant{764};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<764> { using type = SgTypeDouble; };

// Class: TypeEllipse
template <> struct describe_node_t<SgTypeEllipse> {
  using node = SgTypeEllipse;
  using base = SgType;
  static constexpr char const * const name{"TypeEllipse"};
  static constexpr unsigned long variant{765};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<765> { using type = SgTypeEllipse; };

// Class: TypeFixed
template <> struct describe_field_t<SgTypeFixed,SgExpression*,&SgTypeFixed::p_scale> {
  using parent = SgTypeFixed;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"scale"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTypeFixed::p_scale};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeFixed, SgExpression* SgTypeFixed::*, &SgTypeFixed::p_scale>;
};
template <> struct describe_field_t<SgTypeFixed,SgExpression*,&SgTypeFixed::p_fraction> {
  using parent = SgTypeFixed;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"fraction"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTypeFixed::p_fraction};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeFixed, SgExpression* SgTypeFixed::*, &SgTypeFixed::p_fraction>;
};
template <> struct describe_node_t<SgTypeFixed> {
  using node = SgTypeFixed;
  using base = SgType;
  static constexpr char const * const name{"TypeFixed"};
  static constexpr unsigned long variant{766};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeFixed,SgExpression*,&SgTypeFixed::p_scale>, describe_field_t<SgTypeFixed,SgExpression*,&SgTypeFixed::p_fraction>>;
};
template <> struct node_from_variant_t<766> { using type = SgTypeFixed; };

// Class: TypeFloat
template <> struct describe_node_t<SgTypeFloat> {
  using node = SgTypeFloat;
  using base = SgType;
  static constexpr char const * const name{"TypeFloat"};
  static constexpr unsigned long variant{767};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<767> { using type = SgTypeFloat; };

// Class: TypeFloat128
template <> struct describe_node_t<SgTypeFloat128> {
  using node = SgTypeFloat128;
  using base = SgType;
  static constexpr char const * const name{"TypeFloat128"};
  static constexpr unsigned long variant{768};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<768> { using type = SgTypeFloat128; };

// Class: TypeFloat80
template <> struct describe_node_t<SgTypeFloat80> {
  using node = SgTypeFloat80;
  using base = SgType;
  static constexpr char const * const name{"TypeFloat80"};
  static constexpr unsigned long variant{769};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<769> { using type = SgTypeFloat80; };

// Class: TypeGlobalVoid
template <> struct describe_node_t<SgTypeGlobalVoid> {
  using node = SgTypeGlobalVoid;
  using base = SgType;
  static constexpr char const * const name{"TypeGlobalVoid"};
  static constexpr unsigned long variant{770};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<770> { using type = SgTypeGlobalVoid; };

// Class: TypeIdOp
template <> struct describe_field_t<SgTypeIdOp,SgExpression*,&SgTypeIdOp::p_operand_expr> {
  using parent = SgTypeIdOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_expr"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTypeIdOp::p_operand_expr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeIdOp, SgExpression* SgTypeIdOp::*, &SgTypeIdOp::p_operand_expr>;
};
template <> struct describe_field_t<SgTypeIdOp,SgType*,&SgTypeIdOp::p_operand_type> {
  using parent = SgTypeIdOp;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operand_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeIdOp::p_operand_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeIdOp, SgType* SgTypeIdOp::*, &SgTypeIdOp::p_operand_type>;
};
template <> struct describe_field_t<SgTypeIdOp,int,&SgTypeIdOp::p_name_qualification_length> {
  using parent = SgTypeIdOp;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeIdOp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeIdOp, int SgTypeIdOp::*, &SgTypeIdOp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgTypeIdOp,bool,&SgTypeIdOp::p_type_elaboration_required> {
  using parent = SgTypeIdOp;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeIdOp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeIdOp, bool SgTypeIdOp::*, &SgTypeIdOp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgTypeIdOp,bool,&SgTypeIdOp::p_global_qualification_required> {
  using parent = SgTypeIdOp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeIdOp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeIdOp, bool SgTypeIdOp::*, &SgTypeIdOp::p_global_qualification_required>;
};
template <> struct describe_field_t<SgTypeIdOp,int,&SgTypeIdOp::p_name_qualification_for_pointer_to_member_class_length> {
  using parent = SgTypeIdOp;
  using field_type = int;
  static constexpr size_t position{5};
  static constexpr char const * const name{"name_qualification_for_pointer_to_member_class_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeIdOp::p_name_qualification_for_pointer_to_member_class_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeIdOp, int SgTypeIdOp::*, &SgTypeIdOp::p_name_qualification_for_pointer_to_member_class_length>;
};
template <> struct describe_field_t<SgTypeIdOp,bool,&SgTypeIdOp::p_type_elaboration_for_pointer_to_member_class_required> {
  using parent = SgTypeIdOp;
  using field_type = bool;
  static constexpr size_t position{6};
  static constexpr char const * const name{"type_elaboration_for_pointer_to_member_class_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeIdOp::p_type_elaboration_for_pointer_to_member_class_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeIdOp, bool SgTypeIdOp::*, &SgTypeIdOp::p_type_elaboration_for_pointer_to_member_class_required>;
};
template <> struct describe_field_t<SgTypeIdOp,bool,&SgTypeIdOp::p_global_qualification_for_pointer_to_member_class_required> {
  using parent = SgTypeIdOp;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"global_qualification_for_pointer_to_member_class_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeIdOp::p_global_qualification_for_pointer_to_member_class_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeIdOp, bool SgTypeIdOp::*, &SgTypeIdOp::p_global_qualification_for_pointer_to_member_class_required>;
};
template <> struct describe_node_t<SgTypeIdOp> {
  using node = SgTypeIdOp;
  using base = SgExpression;
  static constexpr char const * const name{"TypeIdOp"};
  static constexpr unsigned long variant{771};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeIdOp,SgExpression*,&SgTypeIdOp::p_operand_expr>, describe_field_t<SgTypeIdOp,SgType*,&SgTypeIdOp::p_operand_type>, describe_field_t<SgTypeIdOp,int,&SgTypeIdOp::p_name_qualification_length>, describe_field_t<SgTypeIdOp,bool,&SgTypeIdOp::p_type_elaboration_required>, describe_field_t<SgTypeIdOp,bool,&SgTypeIdOp::p_global_qualification_required>, describe_field_t<SgTypeIdOp,int,&SgTypeIdOp::p_name_qualification_for_pointer_to_member_class_length>, describe_field_t<SgTypeIdOp,bool,&SgTypeIdOp::p_type_elaboration_for_pointer_to_member_class_required>, describe_field_t<SgTypeIdOp,bool,&SgTypeIdOp::p_global_qualification_for_pointer_to_member_class_required>>;
};
template <> struct node_from_variant_t<771> { using type = SgTypeIdOp; };

// Class: TypeImaginary
template <> struct describe_field_t<SgTypeImaginary,SgType*,&SgTypeImaginary::p_base_type> {
  using parent = SgTypeImaginary;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeImaginary::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeImaginary, SgType* SgTypeImaginary::*, &SgTypeImaginary::p_base_type>;
};
template <> struct describe_node_t<SgTypeImaginary> {
  using node = SgTypeImaginary;
  using base = SgType;
  static constexpr char const * const name{"TypeImaginary"};
  static constexpr unsigned long variant{772};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeImaginary,SgType*,&SgTypeImaginary::p_base_type>>;
};
template <> struct node_from_variant_t<772> { using type = SgTypeImaginary; };

// Class: TypeInt
template <> struct describe_field_t<SgTypeInt,int,&SgTypeInt::p_field_size> {
  using parent = SgTypeInt;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"field_size"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeInt::p_field_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeInt, int SgTypeInt::*, &SgTypeInt::p_field_size>;
};
template <> struct describe_node_t<SgTypeInt> {
  using node = SgTypeInt;
  using base = SgType;
  static constexpr char const * const name{"TypeInt"};
  static constexpr unsigned long variant{773};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeInt,int,&SgTypeInt::p_field_size>>;
};
template <> struct node_from_variant_t<773> { using type = SgTypeInt; };

// Class: TypeLong
template <> struct describe_node_t<SgTypeLong> {
  using node = SgTypeLong;
  using base = SgType;
  static constexpr char const * const name{"TypeLong"};
  static constexpr unsigned long variant{774};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<774> { using type = SgTypeLong; };

// Class: TypeLongDouble
template <> struct describe_node_t<SgTypeLongDouble> {
  using node = SgTypeLongDouble;
  using base = SgType;
  static constexpr char const * const name{"TypeLongDouble"};
  static constexpr unsigned long variant{775};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<775> { using type = SgTypeLongDouble; };

// Class: TypeLongLong
template <> struct describe_node_t<SgTypeLongLong> {
  using node = SgTypeLongLong;
  using base = SgType;
  static constexpr char const * const name{"TypeLongLong"};
  static constexpr unsigned long variant{776};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<776> { using type = SgTypeLongLong; };

// Class: TypeModifier
template <> struct describe_field_t<SgTypeModifier,SgBitVector,&SgTypeModifier::p_modifierVector> {
  using parent = SgTypeModifier;
  using field_type = SgBitVector;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifierVector"};
  static constexpr char const * const typestr{"SgBitVector"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_modifierVector};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, SgBitVector SgTypeModifier::*, &SgTypeModifier::p_modifierVector>;
};
template <> struct describe_field_t<SgTypeModifier,SgUPC_AccessModifier,&SgTypeModifier::p_upcModifier> {
  using parent = SgTypeModifier;
  using field_type = SgUPC_AccessModifier;
  static constexpr size_t position{1};
  static constexpr char const * const name{"upcModifier"};
  static constexpr char const * const typestr{"SgUPC_AccessModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_upcModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, SgUPC_AccessModifier SgTypeModifier::*, &SgTypeModifier::p_upcModifier>;
};
template <> struct describe_field_t<SgTypeModifier,SgStructureModifier,&SgTypeModifier::p_structureModifier> {
  using parent = SgTypeModifier;
  using field_type = SgStructureModifier;
  static constexpr size_t position{2};
  static constexpr char const * const name{"structureModifier"};
  static constexpr char const * const typestr{"SgStructureModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_structureModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, SgStructureModifier SgTypeModifier::*, &SgTypeModifier::p_structureModifier>;
};
template <> struct describe_field_t<SgTypeModifier,SgConstVolatileModifier,&SgTypeModifier::p_constVolatileModifier> {
  using parent = SgTypeModifier;
  using field_type = SgConstVolatileModifier;
  static constexpr size_t position{3};
  static constexpr char const * const name{"constVolatileModifier"};
  static constexpr char const * const typestr{"SgConstVolatileModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_constVolatileModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, SgConstVolatileModifier SgTypeModifier::*, &SgTypeModifier::p_constVolatileModifier>;
};
template <> struct describe_field_t<SgTypeModifier,SgElaboratedTypeModifier,&SgTypeModifier::p_elaboratedTypeModifier> {
  using parent = SgTypeModifier;
  using field_type = SgElaboratedTypeModifier;
  static constexpr size_t position{4};
  static constexpr char const * const name{"elaboratedTypeModifier"};
  static constexpr char const * const typestr{"SgElaboratedTypeModifier"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_elaboratedTypeModifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, SgElaboratedTypeModifier SgTypeModifier::*, &SgTypeModifier::p_elaboratedTypeModifier>;
};
template <> struct describe_field_t<SgTypeModifier,SgTypeModifier::gnu_extension_machine_mode_enum,&SgTypeModifier::p_gnu_extension_machine_mode> {
  using parent = SgTypeModifier;
  using field_type = SgTypeModifier::gnu_extension_machine_mode_enum;
  static constexpr size_t position{5};
  static constexpr char const * const name{"gnu_extension_machine_mode"};
  static constexpr char const * const typestr{"SgTypeModifier::gnu_extension_machine_mode_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_gnu_extension_machine_mode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, SgTypeModifier::gnu_extension_machine_mode_enum SgTypeModifier::*, &SgTypeModifier::p_gnu_extension_machine_mode>;
};
template <> struct describe_field_t<SgTypeModifier,int,&SgTypeModifier::p_gnu_attribute_alignment> {
  using parent = SgTypeModifier;
  using field_type = int;
  static constexpr size_t position{6};
  static constexpr char const * const name{"gnu_attribute_alignment"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_gnu_attribute_alignment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, int SgTypeModifier::*, &SgTypeModifier::p_gnu_attribute_alignment>;
};
template <> struct describe_field_t<SgTypeModifier,long,&SgTypeModifier::p_gnu_attribute_sentinel> {
  using parent = SgTypeModifier;
  using field_type = long;
  static constexpr size_t position{7};
  static constexpr char const * const name{"gnu_attribute_sentinel"};
  static constexpr char const * const typestr{"long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_gnu_attribute_sentinel};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, long SgTypeModifier::*, &SgTypeModifier::p_gnu_attribute_sentinel>;
};
template <> struct describe_field_t<SgTypeModifier,unsigned,&SgTypeModifier::p_address_space_value> {
  using parent = SgTypeModifier;
  using field_type = unsigned;
  static constexpr size_t position{8};
  static constexpr char const * const name{"address_space_value"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_address_space_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, unsigned SgTypeModifier::*, &SgTypeModifier::p_address_space_value>;
};
template <> struct describe_field_t<SgTypeModifier,unsigned,&SgTypeModifier::p_vector_size> {
  using parent = SgTypeModifier;
  using field_type = unsigned;
  static constexpr size_t position{9};
  static constexpr char const * const name{"vector_size"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeModifier::p_vector_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeModifier, unsigned SgTypeModifier::*, &SgTypeModifier::p_vector_size>;
};
template <> struct describe_node_t<SgTypeModifier> {
  using node = SgTypeModifier;
  using base = SgModifier;
  static constexpr char const * const name{"TypeModifier"};
  static constexpr unsigned long variant{777};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeModifier,SgBitVector,&SgTypeModifier::p_modifierVector>, describe_field_t<SgTypeModifier,SgUPC_AccessModifier,&SgTypeModifier::p_upcModifier>, describe_field_t<SgTypeModifier,SgStructureModifier,&SgTypeModifier::p_structureModifier>, describe_field_t<SgTypeModifier,SgConstVolatileModifier,&SgTypeModifier::p_constVolatileModifier>, describe_field_t<SgTypeModifier,SgElaboratedTypeModifier,&SgTypeModifier::p_elaboratedTypeModifier>, describe_field_t<SgTypeModifier,SgTypeModifier::gnu_extension_machine_mode_enum,&SgTypeModifier::p_gnu_extension_machine_mode>, describe_field_t<SgTypeModifier,int,&SgTypeModifier::p_gnu_attribute_alignment>, describe_field_t<SgTypeModifier,long,&SgTypeModifier::p_gnu_attribute_sentinel>, describe_field_t<SgTypeModifier,unsigned,&SgTypeModifier::p_address_space_value>, describe_field_t<SgTypeModifier,unsigned,&SgTypeModifier::p_vector_size>>;
};
template <> struct node_from_variant_t<777> { using type = SgTypeModifier; };

// Class: TypeMatrix
template <> struct describe_field_t<SgTypeMatrix,SgType*,&SgTypeMatrix::p_base_type> {
  using parent = SgTypeMatrix;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeMatrix::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeMatrix, SgType* SgTypeMatrix::*, &SgTypeMatrix::p_base_type>;
};
template <> struct describe_node_t<SgTypeMatrix> {
  using node = SgTypeMatrix;
  using base = SgType;
  static constexpr char const * const name{"TypeMatrix"};
  static constexpr unsigned long variant{778};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeMatrix,SgType*,&SgTypeMatrix::p_base_type>>;
};
template <> struct node_from_variant_t<778> { using type = SgTypeMatrix; };

// Class: TypeTuple
template <> struct describe_field_t<SgTypeTuple,SgTypePtrList,&SgTypeTuple::p_types> {
  using parent = SgTypeTuple;
  using field_type = SgTypePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"types"};
  static constexpr char const * const typestr{"SgTypePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeTuple::p_types};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeTuple, SgTypePtrList SgTypeTuple::*, &SgTypeTuple::p_types>;
};
template <> struct describe_node_t<SgTypeTuple> {
  using node = SgTypeTuple;
  using base = SgType;
  static constexpr char const * const name{"TypeTuple"};
  static constexpr unsigned long variant{779};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeTuple,SgTypePtrList,&SgTypeTuple::p_types>>;
};
template <> struct node_from_variant_t<779> { using type = SgTypeTuple; };

// Class: TypeNullptr
template <> struct describe_node_t<SgTypeNullptr> {
  using node = SgTypeNullptr;
  using base = SgType;
  static constexpr char const * const name{"TypeNullptr"};
  static constexpr unsigned long variant{780};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<780> { using type = SgTypeNullptr; };

// Class: TypeOfType
template <> struct describe_field_t<SgTypeOfType,SgExpression*,&SgTypeOfType::p_base_expression> {
  using parent = SgTypeOfType;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeOfType::p_base_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeOfType, SgExpression* SgTypeOfType::*, &SgTypeOfType::p_base_expression>;
};
template <> struct describe_field_t<SgTypeOfType,SgType*,&SgTypeOfType::p_base_type> {
  using parent = SgTypeOfType;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeOfType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeOfType, SgType* SgTypeOfType::*, &SgTypeOfType::p_base_type>;
};
template <> struct describe_node_t<SgTypeOfType> {
  using node = SgTypeOfType;
  using base = SgType;
  static constexpr char const * const name{"TypeOfType"};
  static constexpr unsigned long variant{781};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeOfType,SgExpression*,&SgTypeOfType::p_base_expression>, describe_field_t<SgTypeOfType,SgType*,&SgTypeOfType::p_base_type>>;
};
template <> struct node_from_variant_t<781> { using type = SgTypeOfType; };

// Class: TypeShort
template <> struct describe_node_t<SgTypeShort> {
  using node = SgTypeShort;
  using base = SgType;
  static constexpr char const * const name{"TypeShort"};
  static constexpr unsigned long variant{782};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<782> { using type = SgTypeShort; };

// Class: TypeSigned128bitInteger
template <> struct describe_node_t<SgTypeSigned128bitInteger> {
  using node = SgTypeSigned128bitInteger;
  using base = SgType;
  static constexpr char const * const name{"TypeSigned128bitInteger"};
  static constexpr unsigned long variant{783};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<783> { using type = SgTypeSigned128bitInteger; };

// Class: TypeSignedChar
template <> struct describe_node_t<SgTypeSignedChar> {
  using node = SgTypeSignedChar;
  using base = SgType;
  static constexpr char const * const name{"TypeSignedChar"};
  static constexpr unsigned long variant{784};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<784> { using type = SgTypeSignedChar; };

// Class: TypeSignedInt
template <> struct describe_node_t<SgTypeSignedInt> {
  using node = SgTypeSignedInt;
  using base = SgType;
  static constexpr char const * const name{"TypeSignedInt"};
  static constexpr unsigned long variant{785};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<785> { using type = SgTypeSignedInt; };

// Class: TypeSignedLong
template <> struct describe_node_t<SgTypeSignedLong> {
  using node = SgTypeSignedLong;
  using base = SgType;
  static constexpr char const * const name{"TypeSignedLong"};
  static constexpr unsigned long variant{786};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<786> { using type = SgTypeSignedLong; };

// Class: TypeSignedLongLong
template <> struct describe_node_t<SgTypeSignedLongLong> {
  using node = SgTypeSignedLongLong;
  using base = SgType;
  static constexpr char const * const name{"TypeSignedLongLong"};
  static constexpr unsigned long variant{787};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<787> { using type = SgTypeSignedLongLong; };

// Class: TypeSignedShort
template <> struct describe_node_t<SgTypeSignedShort> {
  using node = SgTypeSignedShort;
  using base = SgType;
  static constexpr char const * const name{"TypeSignedShort"};
  static constexpr unsigned long variant{788};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<788> { using type = SgTypeSignedShort; };

// Class: TypeString
template <> struct describe_field_t<SgTypeString,SgExpression*,&SgTypeString::p_lengthExpression> {
  using parent = SgTypeString;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lengthExpression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTypeString::p_lengthExpression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeString, SgExpression* SgTypeString::*, &SgTypeString::p_lengthExpression>;
};
template <> struct describe_node_t<SgTypeString> {
  using node = SgTypeString;
  using base = SgType;
  static constexpr char const * const name{"TypeString"};
  static constexpr unsigned long variant{789};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeString,SgExpression*,&SgTypeString::p_lengthExpression>>;
};
template <> struct node_from_variant_t<789> { using type = SgTypeString; };

// Class: TypeUnknown
template <> struct describe_field_t<SgTypeUnknown,std::string,&SgTypeUnknown::p_type_name> {
  using parent = SgTypeUnknown;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"type_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeUnknown::p_type_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeUnknown, std::string SgTypeUnknown::*, &SgTypeUnknown::p_type_name>;
};
template <> struct describe_field_t<SgTypeUnknown,bool,&SgTypeUnknown::p_has_type_name> {
  using parent = SgTypeUnknown;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"has_type_name"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeUnknown::p_has_type_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeUnknown, bool SgTypeUnknown::*, &SgTypeUnknown::p_has_type_name>;
};
template <> struct describe_node_t<SgTypeUnknown> {
  using node = SgTypeUnknown;
  using base = SgType;
  static constexpr char const * const name{"TypeUnknown"};
  static constexpr unsigned long variant{790};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeUnknown,std::string,&SgTypeUnknown::p_type_name>, describe_field_t<SgTypeUnknown,bool,&SgTypeUnknown::p_has_type_name>>;
};
template <> struct node_from_variant_t<790> { using type = SgTypeUnknown; };

// Class: TypeUnsigned128bitInteger
template <> struct describe_node_t<SgTypeUnsigned128bitInteger> {
  using node = SgTypeUnsigned128bitInteger;
  using base = SgType;
  static constexpr char const * const name{"TypeUnsigned128bitInteger"};
  static constexpr unsigned long variant{791};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<791> { using type = SgTypeUnsigned128bitInteger; };

// Class: TypeUnsignedChar
template <> struct describe_node_t<SgTypeUnsignedChar> {
  using node = SgTypeUnsignedChar;
  using base = SgType;
  static constexpr char const * const name{"TypeUnsignedChar"};
  static constexpr unsigned long variant{792};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<792> { using type = SgTypeUnsignedChar; };

// Class: TypeUnsignedInt
template <> struct describe_node_t<SgTypeUnsignedInt> {
  using node = SgTypeUnsignedInt;
  using base = SgType;
  static constexpr char const * const name{"TypeUnsignedInt"};
  static constexpr unsigned long variant{793};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<793> { using type = SgTypeUnsignedInt; };

// Class: TypeUnsignedLong
template <> struct describe_node_t<SgTypeUnsignedLong> {
  using node = SgTypeUnsignedLong;
  using base = SgType;
  static constexpr char const * const name{"TypeUnsignedLong"};
  static constexpr unsigned long variant{794};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<794> { using type = SgTypeUnsignedLong; };

// Class: TypeUnsignedLongLong
template <> struct describe_node_t<SgTypeUnsignedLongLong> {
  using node = SgTypeUnsignedLongLong;
  using base = SgType;
  static constexpr char const * const name{"TypeUnsignedLongLong"};
  static constexpr unsigned long variant{795};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<795> { using type = SgTypeUnsignedLongLong; };

// Class: TypeUnsignedShort
template <> struct describe_node_t<SgTypeUnsignedShort> {
  using node = SgTypeUnsignedShort;
  using base = SgType;
  static constexpr char const * const name{"TypeUnsignedShort"};
  static constexpr unsigned long variant{796};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<796> { using type = SgTypeUnsignedShort; };

// Class: TypeVoid
template <> struct describe_node_t<SgTypeVoid> {
  using node = SgTypeVoid;
  using base = SgType;
  static constexpr char const * const name{"TypeVoid"};
  static constexpr unsigned long variant{797};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<797> { using type = SgTypeVoid; };

// Class: TypeWchar
template <> struct describe_node_t<SgTypeWchar> {
  using node = SgTypeWchar;
  using base = SgType;
  static constexpr char const * const name{"TypeWchar"};
  static constexpr unsigned long variant{798};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<798> { using type = SgTypeWchar; };

// Class: TypedefDeclaration
template <> struct describe_field_t<SgTypedefDeclaration,SgName,&SgTypedefDeclaration::p_name> {
  using parent = SgTypedefDeclaration;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, SgName SgTypedefDeclaration::*, &SgTypedefDeclaration::p_name>;
};
template <> struct describe_field_t<SgTypedefDeclaration,SgType*,&SgTypedefDeclaration::p_base_type> {
  using parent = SgTypedefDeclaration;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, SgType* SgTypedefDeclaration::*, &SgTypedefDeclaration::p_base_type>;
};
template <> struct describe_field_t<SgTypedefDeclaration,SgTypedefType*,&SgTypedefDeclaration::p_type> {
  using parent = SgTypedefDeclaration;
  using field_type = SgTypedefType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgTypedefType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, SgTypedefType* SgTypedefDeclaration::*, &SgTypedefDeclaration::p_type>;
};
template <> struct describe_field_t<SgTypedefDeclaration,SgDeclarationStatement*,&SgTypedefDeclaration::p_declaration> {
  using parent = SgTypedefDeclaration;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, SgDeclarationStatement* SgTypedefDeclaration::*, &SgTypedefDeclaration::p_declaration>;
};
template <> struct describe_field_t<SgTypedefDeclaration,SgSymbol*,&SgTypedefDeclaration::p_parent_scope> {
  using parent = SgTypedefDeclaration;
  using field_type = SgSymbol*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"parent_scope"};
  static constexpr char const * const typestr{"SgSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_parent_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, SgSymbol* SgTypedefDeclaration::*, &SgTypedefDeclaration::p_parent_scope>;
};
template <> struct describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_typedefBaseTypeContainsDefiningDeclaration> {
  using parent = SgTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"typedefBaseTypeContainsDefiningDeclaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_typedefBaseTypeContainsDefiningDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, bool SgTypedefDeclaration::*, &SgTypedefDeclaration::p_typedefBaseTypeContainsDefiningDeclaration>;
};
template <> struct describe_field_t<SgTypedefDeclaration,SgScopeStatement*,&SgTypedefDeclaration::p_scope> {
  using parent = SgTypedefDeclaration;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, SgScopeStatement* SgTypedefDeclaration::*, &SgTypedefDeclaration::p_scope>;
};
template <> struct describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_requiresGlobalNameQualificationOnType> {
  using parent = SgTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"requiresGlobalNameQualificationOnType"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_requiresGlobalNameQualificationOnType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, bool SgTypedefDeclaration::*, &SgTypedefDeclaration::p_requiresGlobalNameQualificationOnType>;
};
template <> struct describe_field_t<SgTypedefDeclaration,int,&SgTypedefDeclaration::p_name_qualification_length_for_base_type> {
  using parent = SgTypedefDeclaration;
  using field_type = int;
  static constexpr size_t position{8};
  static constexpr char const * const name{"name_qualification_length_for_base_type"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_name_qualification_length_for_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, int SgTypedefDeclaration::*, &SgTypedefDeclaration::p_name_qualification_length_for_base_type>;
};
template <> struct describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_type_elaboration_required_for_base_type> {
  using parent = SgTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"type_elaboration_required_for_base_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_type_elaboration_required_for_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, bool SgTypedefDeclaration::*, &SgTypedefDeclaration::p_type_elaboration_required_for_base_type>;
};
template <> struct describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_global_qualification_required_for_base_type> {
  using parent = SgTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"global_qualification_required_for_base_type"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_global_qualification_required_for_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, bool SgTypedefDeclaration::*, &SgTypedefDeclaration::p_global_qualification_required_for_base_type>;
};
template <> struct describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_isAutonomousDeclaration> {
  using parent = SgTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"isAutonomousDeclaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_isAutonomousDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, bool SgTypedefDeclaration::*, &SgTypedefDeclaration::p_isAutonomousDeclaration>;
};
template <> struct describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_isAssociatedWithDeclarationList> {
  using parent = SgTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{12};
  static constexpr char const * const name{"isAssociatedWithDeclarationList"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_isAssociatedWithDeclarationList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, bool SgTypedefDeclaration::*, &SgTypedefDeclaration::p_isAssociatedWithDeclarationList>;
};
template <> struct describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_isFirstDeclarationOfDeclarationList> {
  using parent = SgTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{13};
  static constexpr char const * const name{"isFirstDeclarationOfDeclarationList"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_isFirstDeclarationOfDeclarationList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, bool SgTypedefDeclaration::*, &SgTypedefDeclaration::p_isFirstDeclarationOfDeclarationList>;
};
template <> struct describe_field_t<SgTypedefDeclaration,int,&SgTypedefDeclaration::p_name_qualification_length> {
  using parent = SgTypedefDeclaration;
  using field_type = int;
  static constexpr size_t position{14};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, int SgTypedefDeclaration::*, &SgTypedefDeclaration::p_name_qualification_length>;
};
template <> struct describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_type_elaboration_required> {
  using parent = SgTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{15};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, bool SgTypedefDeclaration::*, &SgTypedefDeclaration::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_global_qualification_required> {
  using parent = SgTypedefDeclaration;
  using field_type = bool;
  static constexpr size_t position{16};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefDeclaration::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefDeclaration, bool SgTypedefDeclaration::*, &SgTypedefDeclaration::p_global_qualification_required>;
};
template <> struct describe_node_t<SgTypedefDeclaration> {
  using node = SgTypedefDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"TypedefDeclaration"};
  static constexpr unsigned long variant{799};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateTypedefDeclaration, SgTemplateInstantiationTypedefDeclaration>;
  using fields_t = mp::List<describe_field_t<SgTypedefDeclaration,SgName,&SgTypedefDeclaration::p_name>, describe_field_t<SgTypedefDeclaration,SgType*,&SgTypedefDeclaration::p_base_type>, describe_field_t<SgTypedefDeclaration,SgTypedefType*,&SgTypedefDeclaration::p_type>, describe_field_t<SgTypedefDeclaration,SgDeclarationStatement*,&SgTypedefDeclaration::p_declaration>, describe_field_t<SgTypedefDeclaration,SgSymbol*,&SgTypedefDeclaration::p_parent_scope>, describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_typedefBaseTypeContainsDefiningDeclaration>, describe_field_t<SgTypedefDeclaration,SgScopeStatement*,&SgTypedefDeclaration::p_scope>, describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_requiresGlobalNameQualificationOnType>, describe_field_t<SgTypedefDeclaration,int,&SgTypedefDeclaration::p_name_qualification_length_for_base_type>, describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_type_elaboration_required_for_base_type>, describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_global_qualification_required_for_base_type>, describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_isAutonomousDeclaration>, describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_isAssociatedWithDeclarationList>, describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_isFirstDeclarationOfDeclarationList>, describe_field_t<SgTypedefDeclaration,int,&SgTypedefDeclaration::p_name_qualification_length>, describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_type_elaboration_required>, describe_field_t<SgTypedefDeclaration,bool,&SgTypedefDeclaration::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<799> { using type = SgTypedefDeclaration; };

// Class: TypedefSeq
template <> struct describe_field_t<SgTypedefSeq,SgTypePtrList,&SgTypedefSeq::p_typedefs> {
  using parent = SgTypedefSeq;
  using field_type = SgTypePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"typedefs"};
  static constexpr char const * const typestr{"SgTypePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefSeq::p_typedefs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefSeq, SgTypePtrList SgTypedefSeq::*, &SgTypedefSeq::p_typedefs>;
};
template <> struct describe_node_t<SgTypedefSeq> {
  using node = SgTypedefSeq;
  using base = SgSupport;
  static constexpr char const * const name{"TypedefSeq"};
  static constexpr unsigned long variant{800};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypedefSeq,SgTypePtrList,&SgTypedefSeq::p_typedefs>>;
};
template <> struct node_from_variant_t<800> { using type = SgTypedefSeq; };

// Class: TypedefSymbol
template <> struct describe_field_t<SgTypedefSymbol,SgTypedefDeclaration*,&SgTypedefSymbol::p_declaration> {
  using parent = SgTypedefSymbol;
  using field_type = SgTypedefDeclaration*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgTypedefDeclaration*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgTypedefSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefSymbol, SgTypedefDeclaration* SgTypedefSymbol::*, &SgTypedefSymbol::p_declaration>;
};
template <> struct describe_node_t<SgTypedefSymbol> {
  using node = SgTypedefSymbol;
  using base = SgTypeSymbol;
  static constexpr char const * const name{"TypedefSymbol"};
  static constexpr unsigned long variant{801};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateTypedefSymbol>;
  using fields_t = mp::List<describe_field_t<SgTypedefSymbol,SgTypedefDeclaration*,&SgTypedefSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<801> { using type = SgTypedefSymbol; };

// Class: TypedefType
template <> struct describe_field_t<SgTypedefType,SgSymbol*,&SgTypedefType::p_parent_scope> {
  using parent = SgTypedefType;
  using field_type = SgSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"parent_scope"};
  static constexpr char const * const typestr{"SgSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypedefType::p_parent_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypedefType, SgSymbol* SgTypedefType::*, &SgTypedefType::p_parent_scope>;
};
template <> struct describe_node_t<SgTypedefType> {
  using node = SgTypedefType;
  using base = SgNamedType;
  static constexpr char const * const name{"TypedefType"};
  static constexpr unsigned long variant{802};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypedefType,SgSymbol*,&SgTypedefType::p_parent_scope>>;
};
template <> struct node_from_variant_t<802> { using type = SgTypedefType; };

// Class: UPC_AccessModifier
template <> struct describe_field_t<SgUPC_AccessModifier,SgUPC_AccessModifier::upc_access_modifier_enum,&SgUPC_AccessModifier::p_modifier> {
  using parent = SgUPC_AccessModifier;
  using field_type = SgUPC_AccessModifier::upc_access_modifier_enum;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modifier"};
  static constexpr char const * const typestr{"SgUPC_AccessModifier::upc_access_modifier_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUPC_AccessModifier::p_modifier};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUPC_AccessModifier, SgUPC_AccessModifier::upc_access_modifier_enum SgUPC_AccessModifier::*, &SgUPC_AccessModifier::p_modifier>;
};
template <> struct describe_field_t<SgUPC_AccessModifier,bool,&SgUPC_AccessModifier::p_isShared> {
  using parent = SgUPC_AccessModifier;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"isShared"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUPC_AccessModifier::p_isShared};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUPC_AccessModifier, bool SgUPC_AccessModifier::*, &SgUPC_AccessModifier::p_isShared>;
};
template <> struct describe_field_t<SgUPC_AccessModifier,long,&SgUPC_AccessModifier::p_layout> {
  using parent = SgUPC_AccessModifier;
  using field_type = long;
  static constexpr size_t position{2};
  static constexpr char const * const name{"layout"};
  static constexpr char const * const typestr{"long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUPC_AccessModifier::p_layout};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUPC_AccessModifier, long SgUPC_AccessModifier::*, &SgUPC_AccessModifier::p_layout>;
};
template <> struct describe_node_t<SgUPC_AccessModifier> {
  using node = SgUPC_AccessModifier;
  using base = SgModifier;
  static constexpr char const * const name{"UPC_AccessModifier"};
  static constexpr unsigned long variant{803};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUPC_AccessModifier,SgUPC_AccessModifier::upc_access_modifier_enum,&SgUPC_AccessModifier::p_modifier>, describe_field_t<SgUPC_AccessModifier,bool,&SgUPC_AccessModifier::p_isShared>, describe_field_t<SgUPC_AccessModifier,long,&SgUPC_AccessModifier::p_layout>>;
};
template <> struct node_from_variant_t<803> { using type = SgUPC_AccessModifier; };

// Class: UnaryAddOp
template <> struct describe_node_t<SgUnaryAddOp> {
  using node = SgUnaryAddOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"UnaryAddOp"};
  static constexpr unsigned long variant{804};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<804> { using type = SgUnaryAddOp; };

// Class: UnaryOp
template <> struct describe_field_t<SgUnaryOp,SgExpression*,&SgUnaryOp::p_operand_i> {
  using parent = SgUnaryOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_i"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUnaryOp::p_operand_i};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnaryOp, SgExpression* SgUnaryOp::*, &SgUnaryOp::p_operand_i>;
};
template <> struct describe_field_t<SgUnaryOp,SgType*,&SgUnaryOp::p_expression_type> {
  using parent = SgUnaryOp;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnaryOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnaryOp, SgType* SgUnaryOp::*, &SgUnaryOp::p_expression_type>;
};
template <> struct describe_field_t<SgUnaryOp,SgUnaryOp::Sgop_mode,&SgUnaryOp::p_mode> {
  using parent = SgUnaryOp;
  using field_type = SgUnaryOp::Sgop_mode;
  static constexpr size_t position{2};
  static constexpr char const * const name{"mode"};
  static constexpr char const * const typestr{"SgUnaryOp::Sgop_mode"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnaryOp::p_mode};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnaryOp, SgUnaryOp::Sgop_mode SgUnaryOp::*, &SgUnaryOp::p_mode>;
};
template <> struct describe_node_t<SgUnaryOp> {
  using node = SgUnaryOp;
  using base = SgExpression;
  static constexpr char const * const name{"UnaryOp"};
  static constexpr unsigned long variant{805};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgExpressionRoot, SgMinusOp, SgUnaryAddOp, SgNotOp, SgPointerDerefExp, SgAddressOfOp, SgMinusMinusOp, SgPlusPlusOp, SgBitComplementOp, SgCastExp, SgThrowOp, SgRealPartOp, SgImagPartOp, SgConjugateOp, SgUserDefinedUnaryOp, SgMatrixTransposeOp, SgAbsOp>;
  using fields_t = mp::List<describe_field_t<SgUnaryOp,SgExpression*,&SgUnaryOp::p_operand_i>, describe_field_t<SgUnaryOp,SgType*,&SgUnaryOp::p_expression_type>, describe_field_t<SgUnaryOp,SgUnaryOp::Sgop_mode,&SgUnaryOp::p_mode>>;
};
template <> struct node_from_variant_t<805> { using type = SgUnaryOp; };

// Class: UndefDirectiveStatement
template <> struct describe_node_t<SgUndefDirectiveStatement> {
  using node = SgUndefDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"UndefDirectiveStatement"};
  static constexpr unsigned long variant{806};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<806> { using type = SgUndefDirectiveStatement; };

// Class: UndirectedGraphEdge
template <> struct describe_node_t<SgUndirectedGraphEdge> {
  using node = SgUndirectedGraphEdge;
  using base = SgGraphEdge;
  static constexpr char const * const name{"UndirectedGraphEdge"};
  static constexpr unsigned long variant{807};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<807> { using type = SgUndirectedGraphEdge; };

// Class: UnknownArrayOrFunctionReference
template <> struct describe_field_t<SgUnknownArrayOrFunctionReference,std::string,&SgUnknownArrayOrFunctionReference::p_name> {
  using parent = SgUnknownArrayOrFunctionReference;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnknownArrayOrFunctionReference::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnknownArrayOrFunctionReference, std::string SgUnknownArrayOrFunctionReference::*, &SgUnknownArrayOrFunctionReference::p_name>;
};
template <> struct describe_field_t<SgUnknownArrayOrFunctionReference,SgExpression*,&SgUnknownArrayOrFunctionReference::p_named_reference> {
  using parent = SgUnknownArrayOrFunctionReference;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"named_reference"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUnknownArrayOrFunctionReference::p_named_reference};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnknownArrayOrFunctionReference, SgExpression* SgUnknownArrayOrFunctionReference::*, &SgUnknownArrayOrFunctionReference::p_named_reference>;
};
template <> struct describe_field_t<SgUnknownArrayOrFunctionReference,SgExprListExp*,&SgUnknownArrayOrFunctionReference::p_expression_list> {
  using parent = SgUnknownArrayOrFunctionReference;
  using field_type = SgExprListExp*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_list"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUnknownArrayOrFunctionReference::p_expression_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnknownArrayOrFunctionReference, SgExprListExp* SgUnknownArrayOrFunctionReference::*, &SgUnknownArrayOrFunctionReference::p_expression_list>;
};
template <> struct describe_node_t<SgUnknownArrayOrFunctionReference> {
  using node = SgUnknownArrayOrFunctionReference;
  using base = SgExpression;
  static constexpr char const * const name{"UnknownArrayOrFunctionReference"};
  static constexpr unsigned long variant{808};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUnknownArrayOrFunctionReference,std::string,&SgUnknownArrayOrFunctionReference::p_name>, describe_field_t<SgUnknownArrayOrFunctionReference,SgExpression*,&SgUnknownArrayOrFunctionReference::p_named_reference>, describe_field_t<SgUnknownArrayOrFunctionReference,SgExprListExp*,&SgUnknownArrayOrFunctionReference::p_expression_list>>;
};
template <> struct node_from_variant_t<808> { using type = SgUnknownArrayOrFunctionReference; };

// Class: UnknownFile
template <> struct describe_field_t<SgUnknownFile,SgGlobal*,&SgUnknownFile::p_globalScope> {
  using parent = SgUnknownFile;
  using field_type = SgGlobal*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"globalScope"};
  static constexpr char const * const typestr{"SgGlobal*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUnknownFile::p_globalScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnknownFile, SgGlobal* SgUnknownFile::*, &SgUnknownFile::p_globalScope>;
};
template <> struct describe_node_t<SgUnknownFile> {
  using node = SgUnknownFile;
  using base = SgFile;
  static constexpr char const * const name{"UnknownFile"};
  static constexpr unsigned long variant{809};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUnknownFile,SgGlobal*,&SgUnknownFile::p_globalScope>>;
};
template <> struct node_from_variant_t<809> { using type = SgUnknownFile; };

// Class: Unparse_Info
template <> struct describe_field_t<SgUnparse_Info,SgBitVector,&SgUnparse_Info::p_unparse_attribute> {
  using parent = SgUnparse_Info;
  using field_type = SgBitVector;
  static constexpr size_t position{0};
  static constexpr char const * const name{"unparse_attribute"};
  static constexpr char const * const typestr{"SgBitVector"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_unparse_attribute};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgBitVector SgUnparse_Info::*, &SgUnparse_Info::p_unparse_attribute>;
};
template <> struct describe_field_t<SgUnparse_Info,int,&SgUnparse_Info::p_access_attribute> {
  using parent = SgUnparse_Info;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"access_attribute"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_access_attribute};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, int SgUnparse_Info::*, &SgUnparse_Info::p_access_attribute>;
};
template <> struct describe_field_t<SgUnparse_Info,int,&SgUnparse_Info::p_nested_expression> {
  using parent = SgUnparse_Info;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"nested_expression"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_nested_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, int SgUnparse_Info::*, &SgUnparse_Info::p_nested_expression>;
};
template <> struct describe_field_t<SgUnparse_Info,std::string,&SgUnparse_Info::p_operator_name> {
  using parent = SgUnparse_Info;
  using field_type = std::string;
  static constexpr size_t position{3};
  static constexpr char const * const name{"operator_name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_operator_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, std::string SgUnparse_Info::*, &SgUnparse_Info::p_operator_name>;
};
template <> struct describe_field_t<SgUnparse_Info,SgName,&SgUnparse_Info::p_var_name> {
  using parent = SgUnparse_Info;
  using field_type = SgName;
  static constexpr size_t position{4};
  static constexpr char const * const name{"var_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_var_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgName SgUnparse_Info::*, &SgUnparse_Info::p_var_name>;
};
template <> struct describe_field_t<SgUnparse_Info,SgDeclarationStatement*,&SgUnparse_Info::p_declstatement_ptr> {
  using parent = SgUnparse_Info;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"declstatement_ptr"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_declstatement_ptr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgDeclarationStatement* SgUnparse_Info::*, &SgUnparse_Info::p_declstatement_ptr>;
};
template <> struct describe_field_t<SgUnparse_Info,SgDeclarationStatement*,&SgUnparse_Info::p_declaration_of_context> {
  using parent = SgUnparse_Info;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"declaration_of_context"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_declaration_of_context};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgDeclarationStatement* SgUnparse_Info::*, &SgUnparse_Info::p_declaration_of_context>;
};
template <> struct describe_field_t<SgUnparse_Info,SgNamedType*,&SgUnparse_Info::p_current_context> {
  using parent = SgUnparse_Info;
  using field_type = SgNamedType*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"current_context"};
  static constexpr char const * const typestr{"SgNamedType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_current_context};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgNamedType* SgUnparse_Info::*, &SgUnparse_Info::p_current_context>;
};
template <> struct describe_field_t<SgUnparse_Info,SgName,&SgUnparse_Info::p_array_index_list> {
  using parent = SgUnparse_Info;
  using field_type = SgName;
  static constexpr size_t position{8};
  static constexpr char const * const name{"array_index_list"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_array_index_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgName SgUnparse_Info::*, &SgUnparse_Info::p_array_index_list>;
};
template <> struct describe_field_t<SgUnparse_Info,SgNamespaceDeclarationStatement*,&SgUnparse_Info::p_current_namespace> {
  using parent = SgUnparse_Info;
  using field_type = SgNamespaceDeclarationStatement*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"current_namespace"};
  static constexpr char const * const typestr{"SgNamespaceDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_current_namespace};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgNamespaceDeclarationStatement* SgUnparse_Info::*, &SgUnparse_Info::p_current_namespace>;
};
template <> struct describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_outputCodeGenerationFormatDelimiters> {
  using parent = SgUnparse_Info;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"outputCodeGenerationFormatDelimiters"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_outputCodeGenerationFormatDelimiters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, bool SgUnparse_Info::*, &SgUnparse_Info::p_outputCodeGenerationFormatDelimiters>;
};
template <> struct describe_field_t<SgUnparse_Info,SgQualifiedNamePtrList,&SgUnparse_Info::p_qualifiedNameList> {
  using parent = SgUnparse_Info;
  using field_type = SgQualifiedNamePtrList;
  static constexpr size_t position{11};
  static constexpr char const * const name{"qualifiedNameList"};
  static constexpr char const * const typestr{"SgQualifiedNamePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_qualifiedNameList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgQualifiedNamePtrList SgUnparse_Info::*, &SgUnparse_Info::p_qualifiedNameList>;
};
template <> struct describe_field_t<SgUnparse_Info,SgFunctionCallExp*,&SgUnparse_Info::p_current_function_call> {
  using parent = SgUnparse_Info;
  using field_type = SgFunctionCallExp*;
  static constexpr size_t position{12};
  static constexpr char const * const name{"current_function_call"};
  static constexpr char const * const typestr{"SgFunctionCallExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_current_function_call};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgFunctionCallExp* SgUnparse_Info::*, &SgUnparse_Info::p_current_function_call>;
};
template <> struct describe_field_t<SgUnparse_Info,SgScopeStatement*,&SgUnparse_Info::p_current_scope> {
  using parent = SgUnparse_Info;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"current_scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_current_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgScopeStatement* SgUnparse_Info::*, &SgUnparse_Info::p_current_scope>;
};
template <> struct describe_field_t<SgUnparse_Info,SgNode*,&SgUnparse_Info::p_reference_node_for_qualification> {
  using parent = SgUnparse_Info;
  using field_type = SgNode*;
  static constexpr size_t position{14};
  static constexpr char const * const name{"reference_node_for_qualification"};
  static constexpr char const * const typestr{"SgNode*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_reference_node_for_qualification};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgNode* SgUnparse_Info::*, &SgUnparse_Info::p_reference_node_for_qualification>;
};
template <> struct describe_field_t<SgUnparse_Info,int,&SgUnparse_Info::p_name_qualification_length> {
  using parent = SgUnparse_Info;
  using field_type = int;
  static constexpr size_t position{15};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, int SgUnparse_Info::*, &SgUnparse_Info::p_name_qualification_length>;
};
template <> struct describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_type_elaboration_required> {
  using parent = SgUnparse_Info;
  using field_type = bool;
  static constexpr size_t position{16};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, bool SgUnparse_Info::*, &SgUnparse_Info::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_global_qualification_required> {
  using parent = SgUnparse_Info;
  using field_type = bool;
  static constexpr size_t position{17};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, bool SgUnparse_Info::*, &SgUnparse_Info::p_global_qualification_required>;
};
template <> struct describe_field_t<SgUnparse_Info,int,&SgUnparse_Info::p_nestingLevel> {
  using parent = SgUnparse_Info;
  using field_type = int;
  static constexpr size_t position{18};
  static constexpr char const * const name{"nestingLevel"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_nestingLevel};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, int SgUnparse_Info::*, &SgUnparse_Info::p_nestingLevel>;
};
template <> struct describe_field_t<SgUnparse_Info,SgFile::languageOption_enum,&SgUnparse_Info::p_language> {
  using parent = SgUnparse_Info;
  using field_type = SgFile::languageOption_enum;
  static constexpr size_t position{19};
  static constexpr char const * const name{"language"};
  static constexpr char const * const typestr{"SgFile::languageOption_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_language};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgFile::languageOption_enum SgUnparse_Info::*, &SgUnparse_Info::p_language>;
};
template <> struct describe_field_t<SgUnparse_Info,SgSourceFile*,&SgUnparse_Info::p_current_source_file> {
  using parent = SgUnparse_Info;
  using field_type = SgSourceFile*;
  static constexpr size_t position{20};
  static constexpr char const * const name{"current_source_file"};
  static constexpr char const * const typestr{"SgSourceFile*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_current_source_file};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgSourceFile* SgUnparse_Info::*, &SgUnparse_Info::p_current_source_file>;
};
template <> struct describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_use_generated_name_for_template_arguments> {
  using parent = SgUnparse_Info;
  using field_type = bool;
  static constexpr size_t position{21};
  static constexpr char const * const name{"use_generated_name_for_template_arguments"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_use_generated_name_for_template_arguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, bool SgUnparse_Info::*, &SgUnparse_Info::p_use_generated_name_for_template_arguments>;
};
template <> struct describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_user_defined_literal> {
  using parent = SgUnparse_Info;
  using field_type = bool;
  static constexpr size_t position{22};
  static constexpr char const * const name{"user_defined_literal"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_user_defined_literal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, bool SgUnparse_Info::*, &SgUnparse_Info::p_user_defined_literal>;
};
template <> struct describe_field_t<SgUnparse_Info,SgDeclarationStatement*,&SgUnparse_Info::p_declstatement_associated_with_type> {
  using parent = SgUnparse_Info;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{23};
  static constexpr char const * const name{"declstatement_associated_with_type"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_declstatement_associated_with_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, SgDeclarationStatement* SgUnparse_Info::*, &SgUnparse_Info::p_declstatement_associated_with_type>;
};
template <> struct describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_context_for_added_parentheses> {
  using parent = SgUnparse_Info;
  using field_type = bool;
  static constexpr size_t position{24};
  static constexpr char const * const name{"context_for_added_parentheses"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnparse_Info::p_context_for_added_parentheses};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnparse_Info, bool SgUnparse_Info::*, &SgUnparse_Info::p_context_for_added_parentheses>;
};
template <> struct describe_node_t<SgUnparse_Info> {
  using node = SgUnparse_Info;
  using base = SgSupport;
  static constexpr char const * const name{"Unparse_Info"};
  static constexpr unsigned long variant{811};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUnparse_Info,SgBitVector,&SgUnparse_Info::p_unparse_attribute>, describe_field_t<SgUnparse_Info,int,&SgUnparse_Info::p_access_attribute>, describe_field_t<SgUnparse_Info,int,&SgUnparse_Info::p_nested_expression>, describe_field_t<SgUnparse_Info,std::string,&SgUnparse_Info::p_operator_name>, describe_field_t<SgUnparse_Info,SgName,&SgUnparse_Info::p_var_name>, describe_field_t<SgUnparse_Info,SgDeclarationStatement*,&SgUnparse_Info::p_declstatement_ptr>, describe_field_t<SgUnparse_Info,SgDeclarationStatement*,&SgUnparse_Info::p_declaration_of_context>, describe_field_t<SgUnparse_Info,SgNamedType*,&SgUnparse_Info::p_current_context>, describe_field_t<SgUnparse_Info,SgName,&SgUnparse_Info::p_array_index_list>, describe_field_t<SgUnparse_Info,SgNamespaceDeclarationStatement*,&SgUnparse_Info::p_current_namespace>, describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_outputCodeGenerationFormatDelimiters>, describe_field_t<SgUnparse_Info,SgQualifiedNamePtrList,&SgUnparse_Info::p_qualifiedNameList>, describe_field_t<SgUnparse_Info,SgFunctionCallExp*,&SgUnparse_Info::p_current_function_call>, describe_field_t<SgUnparse_Info,SgScopeStatement*,&SgUnparse_Info::p_current_scope>, describe_field_t<SgUnparse_Info,SgNode*,&SgUnparse_Info::p_reference_node_for_qualification>, describe_field_t<SgUnparse_Info,int,&SgUnparse_Info::p_name_qualification_length>, describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_type_elaboration_required>, describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_global_qualification_required>, describe_field_t<SgUnparse_Info,int,&SgUnparse_Info::p_nestingLevel>, describe_field_t<SgUnparse_Info,SgFile::languageOption_enum,&SgUnparse_Info::p_language>, describe_field_t<SgUnparse_Info,SgSourceFile*,&SgUnparse_Info::p_current_source_file>, describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_use_generated_name_for_template_arguments>, describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_user_defined_literal>, describe_field_t<SgUnparse_Info,SgDeclarationStatement*,&SgUnparse_Info::p_declstatement_associated_with_type>, describe_field_t<SgUnparse_Info,bool,&SgUnparse_Info::p_context_for_added_parentheses>>;
};
template <> struct node_from_variant_t<811> { using type = SgUnparse_Info; };

// Class: UnsignedCharVal
template <> struct describe_field_t<SgUnsignedCharVal,unsigned char,&SgUnsignedCharVal::p_value> {
  using parent = SgUnsignedCharVal;
  using field_type = unsigned char;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"unsigned char"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedCharVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedCharVal, unsigned char SgUnsignedCharVal::*, &SgUnsignedCharVal::p_value>;
};
template <> struct describe_field_t<SgUnsignedCharVal,std::string,&SgUnsignedCharVal::p_valueString> {
  using parent = SgUnsignedCharVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedCharVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedCharVal, std::string SgUnsignedCharVal::*, &SgUnsignedCharVal::p_valueString>;
};
template <> struct describe_node_t<SgUnsignedCharVal> {
  using node = SgUnsignedCharVal;
  using base = SgValueExp;
  static constexpr char const * const name{"UnsignedCharVal"};
  static constexpr unsigned long variant{812};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUnsignedCharVal,unsigned char,&SgUnsignedCharVal::p_value>, describe_field_t<SgUnsignedCharVal,std::string,&SgUnsignedCharVal::p_valueString>>;
};
template <> struct node_from_variant_t<812> { using type = SgUnsignedCharVal; };

// Class: UnsignedIntVal
template <> struct describe_field_t<SgUnsignedIntVal,unsigned int,&SgUnsignedIntVal::p_value> {
  using parent = SgUnsignedIntVal;
  using field_type = unsigned int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedIntVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedIntVal, unsigned int SgUnsignedIntVal::*, &SgUnsignedIntVal::p_value>;
};
template <> struct describe_field_t<SgUnsignedIntVal,std::string,&SgUnsignedIntVal::p_valueString> {
  using parent = SgUnsignedIntVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedIntVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedIntVal, std::string SgUnsignedIntVal::*, &SgUnsignedIntVal::p_valueString>;
};
template <> struct describe_node_t<SgUnsignedIntVal> {
  using node = SgUnsignedIntVal;
  using base = SgValueExp;
  static constexpr char const * const name{"UnsignedIntVal"};
  static constexpr unsigned long variant{813};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUnsignedIntVal,unsigned int,&SgUnsignedIntVal::p_value>, describe_field_t<SgUnsignedIntVal,std::string,&SgUnsignedIntVal::p_valueString>>;
};
template <> struct node_from_variant_t<813> { using type = SgUnsignedIntVal; };

// Class: UnsignedLongLongIntVal
template <> struct describe_field_t<SgUnsignedLongLongIntVal,unsigned long long int,&SgUnsignedLongLongIntVal::p_value> {
  using parent = SgUnsignedLongLongIntVal;
  using field_type = unsigned long long int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"unsigned long long int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedLongLongIntVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedLongLongIntVal, unsigned long long int SgUnsignedLongLongIntVal::*, &SgUnsignedLongLongIntVal::p_value>;
};
template <> struct describe_field_t<SgUnsignedLongLongIntVal,std::string,&SgUnsignedLongLongIntVal::p_valueString> {
  using parent = SgUnsignedLongLongIntVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedLongLongIntVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedLongLongIntVal, std::string SgUnsignedLongLongIntVal::*, &SgUnsignedLongLongIntVal::p_valueString>;
};
template <> struct describe_node_t<SgUnsignedLongLongIntVal> {
  using node = SgUnsignedLongLongIntVal;
  using base = SgValueExp;
  static constexpr char const * const name{"UnsignedLongLongIntVal"};
  static constexpr unsigned long variant{814};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUnsignedLongLongIntVal,unsigned long long int,&SgUnsignedLongLongIntVal::p_value>, describe_field_t<SgUnsignedLongLongIntVal,std::string,&SgUnsignedLongLongIntVal::p_valueString>>;
};
template <> struct node_from_variant_t<814> { using type = SgUnsignedLongLongIntVal; };

// Class: UnsignedLongVal
template <> struct describe_field_t<SgUnsignedLongVal,unsigned long,&SgUnsignedLongVal::p_value> {
  using parent = SgUnsignedLongVal;
  using field_type = unsigned long;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedLongVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedLongVal, unsigned long SgUnsignedLongVal::*, &SgUnsignedLongVal::p_value>;
};
template <> struct describe_field_t<SgUnsignedLongVal,std::string,&SgUnsignedLongVal::p_valueString> {
  using parent = SgUnsignedLongVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedLongVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedLongVal, std::string SgUnsignedLongVal::*, &SgUnsignedLongVal::p_valueString>;
};
template <> struct describe_node_t<SgUnsignedLongVal> {
  using node = SgUnsignedLongVal;
  using base = SgValueExp;
  static constexpr char const * const name{"UnsignedLongVal"};
  static constexpr unsigned long variant{815};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUnsignedLongVal,unsigned long,&SgUnsignedLongVal::p_value>, describe_field_t<SgUnsignedLongVal,std::string,&SgUnsignedLongVal::p_valueString>>;
};
template <> struct node_from_variant_t<815> { using type = SgUnsignedLongVal; };

// Class: UnsignedShortVal
template <> struct describe_field_t<SgUnsignedShortVal,unsigned short,&SgUnsignedShortVal::p_value> {
  using parent = SgUnsignedShortVal;
  using field_type = unsigned short;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"unsigned short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedShortVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedShortVal, unsigned short SgUnsignedShortVal::*, &SgUnsignedShortVal::p_value>;
};
template <> struct describe_field_t<SgUnsignedShortVal,std::string,&SgUnsignedShortVal::p_valueString> {
  using parent = SgUnsignedShortVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUnsignedShortVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUnsignedShortVal, std::string SgUnsignedShortVal::*, &SgUnsignedShortVal::p_valueString>;
};
template <> struct describe_node_t<SgUnsignedShortVal> {
  using node = SgUnsignedShortVal;
  using base = SgValueExp;
  static constexpr char const * const name{"UnsignedShortVal"};
  static constexpr unsigned long variant{816};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUnsignedShortVal,unsigned short,&SgUnsignedShortVal::p_value>, describe_field_t<SgUnsignedShortVal,std::string,&SgUnsignedShortVal::p_valueString>>;
};
template <> struct node_from_variant_t<816> { using type = SgUnsignedShortVal; };

// Class: UpcBarrierStatement
template <> struct describe_field_t<SgUpcBarrierStatement,SgExpression*,&SgUpcBarrierStatement::p_barrier_expression> {
  using parent = SgUpcBarrierStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"barrier_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcBarrierStatement::p_barrier_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcBarrierStatement, SgExpression* SgUpcBarrierStatement::*, &SgUpcBarrierStatement::p_barrier_expression>;
};
template <> struct describe_node_t<SgUpcBarrierStatement> {
  using node = SgUpcBarrierStatement;
  using base = SgStatement;
  static constexpr char const * const name{"UpcBarrierStatement"};
  static constexpr unsigned long variant{817};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUpcBarrierStatement,SgExpression*,&SgUpcBarrierStatement::p_barrier_expression>>;
};
template <> struct node_from_variant_t<817> { using type = SgUpcBarrierStatement; };

// Class: UpcBlocksizeofExpression
template <> struct describe_field_t<SgUpcBlocksizeofExpression,SgExpression*,&SgUpcBlocksizeofExpression::p_expression> {
  using parent = SgUpcBlocksizeofExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcBlocksizeofExpression::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcBlocksizeofExpression, SgExpression* SgUpcBlocksizeofExpression::*, &SgUpcBlocksizeofExpression::p_expression>;
};
template <> struct describe_field_t<SgUpcBlocksizeofExpression,SgType*,&SgUpcBlocksizeofExpression::p_operand_type> {
  using parent = SgUpcBlocksizeofExpression;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operand_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcBlocksizeofExpression::p_operand_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcBlocksizeofExpression, SgType* SgUpcBlocksizeofExpression::*, &SgUpcBlocksizeofExpression::p_operand_type>;
};
template <> struct describe_field_t<SgUpcBlocksizeofExpression,SgType*,&SgUpcBlocksizeofExpression::p_expression_type> {
  using parent = SgUpcBlocksizeofExpression;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcBlocksizeofExpression::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcBlocksizeofExpression, SgType* SgUpcBlocksizeofExpression::*, &SgUpcBlocksizeofExpression::p_expression_type>;
};
template <> struct describe_node_t<SgUpcBlocksizeofExpression> {
  using node = SgUpcBlocksizeofExpression;
  using base = SgExpression;
  static constexpr char const * const name{"UpcBlocksizeofExpression"};
  static constexpr unsigned long variant{818};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUpcBlocksizeofExpression,SgExpression*,&SgUpcBlocksizeofExpression::p_expression>, describe_field_t<SgUpcBlocksizeofExpression,SgType*,&SgUpcBlocksizeofExpression::p_operand_type>, describe_field_t<SgUpcBlocksizeofExpression,SgType*,&SgUpcBlocksizeofExpression::p_expression_type>>;
};
template <> struct node_from_variant_t<818> { using type = SgUpcBlocksizeofExpression; };

// Class: UpcElemsizeofExpression
template <> struct describe_field_t<SgUpcElemsizeofExpression,SgExpression*,&SgUpcElemsizeofExpression::p_expression> {
  using parent = SgUpcElemsizeofExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcElemsizeofExpression::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcElemsizeofExpression, SgExpression* SgUpcElemsizeofExpression::*, &SgUpcElemsizeofExpression::p_expression>;
};
template <> struct describe_field_t<SgUpcElemsizeofExpression,SgType*,&SgUpcElemsizeofExpression::p_operand_type> {
  using parent = SgUpcElemsizeofExpression;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operand_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcElemsizeofExpression::p_operand_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcElemsizeofExpression, SgType* SgUpcElemsizeofExpression::*, &SgUpcElemsizeofExpression::p_operand_type>;
};
template <> struct describe_field_t<SgUpcElemsizeofExpression,SgType*,&SgUpcElemsizeofExpression::p_expression_type> {
  using parent = SgUpcElemsizeofExpression;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcElemsizeofExpression::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcElemsizeofExpression, SgType* SgUpcElemsizeofExpression::*, &SgUpcElemsizeofExpression::p_expression_type>;
};
template <> struct describe_node_t<SgUpcElemsizeofExpression> {
  using node = SgUpcElemsizeofExpression;
  using base = SgExpression;
  static constexpr char const * const name{"UpcElemsizeofExpression"};
  static constexpr unsigned long variant{819};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUpcElemsizeofExpression,SgExpression*,&SgUpcElemsizeofExpression::p_expression>, describe_field_t<SgUpcElemsizeofExpression,SgType*,&SgUpcElemsizeofExpression::p_operand_type>, describe_field_t<SgUpcElemsizeofExpression,SgType*,&SgUpcElemsizeofExpression::p_expression_type>>;
};
template <> struct node_from_variant_t<819> { using type = SgUpcElemsizeofExpression; };

// Class: UpcFenceStatement
template <> struct describe_node_t<SgUpcFenceStatement> {
  using node = SgUpcFenceStatement;
  using base = SgStatement;
  static constexpr char const * const name{"UpcFenceStatement"};
  static constexpr unsigned long variant{820};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<820> { using type = SgUpcFenceStatement; };

// Class: UpcForAllStatement
template <> struct describe_field_t<SgUpcForAllStatement,SgForInitStatement*,&SgUpcForAllStatement::p_for_init_stmt> {
  using parent = SgUpcForAllStatement;
  using field_type = SgForInitStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"for_init_stmt"};
  static constexpr char const * const typestr{"SgForInitStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcForAllStatement::p_for_init_stmt};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcForAllStatement, SgForInitStatement* SgUpcForAllStatement::*, &SgUpcForAllStatement::p_for_init_stmt>;
};
template <> struct describe_field_t<SgUpcForAllStatement,SgStatement*,&SgUpcForAllStatement::p_test> {
  using parent = SgUpcForAllStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"test"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcForAllStatement::p_test};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcForAllStatement, SgStatement* SgUpcForAllStatement::*, &SgUpcForAllStatement::p_test>;
};
template <> struct describe_field_t<SgUpcForAllStatement,SgExpression*,&SgUpcForAllStatement::p_increment> {
  using parent = SgUpcForAllStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"increment"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcForAllStatement::p_increment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcForAllStatement, SgExpression* SgUpcForAllStatement::*, &SgUpcForAllStatement::p_increment>;
};
template <> struct describe_field_t<SgUpcForAllStatement,SgExpression*,&SgUpcForAllStatement::p_affinity> {
  using parent = SgUpcForAllStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"affinity"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcForAllStatement::p_affinity};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcForAllStatement, SgExpression* SgUpcForAllStatement::*, &SgUpcForAllStatement::p_affinity>;
};
template <> struct describe_field_t<SgUpcForAllStatement,SgStatement*,&SgUpcForAllStatement::p_loop_body> {
  using parent = SgUpcForAllStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"loop_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcForAllStatement::p_loop_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcForAllStatement, SgStatement* SgUpcForAllStatement::*, &SgUpcForAllStatement::p_loop_body>;
};
template <> struct describe_node_t<SgUpcForAllStatement> {
  using node = SgUpcForAllStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"UpcForAllStatement"};
  static constexpr unsigned long variant{821};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUpcForAllStatement,SgForInitStatement*,&SgUpcForAllStatement::p_for_init_stmt>, describe_field_t<SgUpcForAllStatement,SgStatement*,&SgUpcForAllStatement::p_test>, describe_field_t<SgUpcForAllStatement,SgExpression*,&SgUpcForAllStatement::p_increment>, describe_field_t<SgUpcForAllStatement,SgExpression*,&SgUpcForAllStatement::p_affinity>, describe_field_t<SgUpcForAllStatement,SgStatement*,&SgUpcForAllStatement::p_loop_body>>;
};
template <> struct node_from_variant_t<821> { using type = SgUpcForAllStatement; };

// Class: UpcLocalsizeofExpression
template <> struct describe_field_t<SgUpcLocalsizeofExpression,SgExpression*,&SgUpcLocalsizeofExpression::p_expression> {
  using parent = SgUpcLocalsizeofExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcLocalsizeofExpression::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcLocalsizeofExpression, SgExpression* SgUpcLocalsizeofExpression::*, &SgUpcLocalsizeofExpression::p_expression>;
};
template <> struct describe_field_t<SgUpcLocalsizeofExpression,SgType*,&SgUpcLocalsizeofExpression::p_operand_type> {
  using parent = SgUpcLocalsizeofExpression;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"operand_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcLocalsizeofExpression::p_operand_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcLocalsizeofExpression, SgType* SgUpcLocalsizeofExpression::*, &SgUpcLocalsizeofExpression::p_operand_type>;
};
template <> struct describe_field_t<SgUpcLocalsizeofExpression,SgType*,&SgUpcLocalsizeofExpression::p_expression_type> {
  using parent = SgUpcLocalsizeofExpression;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcLocalsizeofExpression::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcLocalsizeofExpression, SgType* SgUpcLocalsizeofExpression::*, &SgUpcLocalsizeofExpression::p_expression_type>;
};
template <> struct describe_node_t<SgUpcLocalsizeofExpression> {
  using node = SgUpcLocalsizeofExpression;
  using base = SgExpression;
  static constexpr char const * const name{"UpcLocalsizeofExpression"};
  static constexpr unsigned long variant{822};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUpcLocalsizeofExpression,SgExpression*,&SgUpcLocalsizeofExpression::p_expression>, describe_field_t<SgUpcLocalsizeofExpression,SgType*,&SgUpcLocalsizeofExpression::p_operand_type>, describe_field_t<SgUpcLocalsizeofExpression,SgType*,&SgUpcLocalsizeofExpression::p_expression_type>>;
};
template <> struct node_from_variant_t<822> { using type = SgUpcLocalsizeofExpression; };

// Class: UpcMythread
template <> struct describe_field_t<SgUpcMythread,int,&SgUpcMythread::p_value> {
  using parent = SgUpcMythread;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcMythread::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcMythread, int SgUpcMythread::*, &SgUpcMythread::p_value>;
};
template <> struct describe_field_t<SgUpcMythread,std::string,&SgUpcMythread::p_valueString> {
  using parent = SgUpcMythread;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcMythread::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcMythread, std::string SgUpcMythread::*, &SgUpcMythread::p_valueString>;
};
template <> struct describe_node_t<SgUpcMythread> {
  using node = SgUpcMythread;
  using base = SgValueExp;
  static constexpr char const * const name{"UpcMythread"};
  static constexpr unsigned long variant{823};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUpcMythread,int,&SgUpcMythread::p_value>, describe_field_t<SgUpcMythread,std::string,&SgUpcMythread::p_valueString>>;
};
template <> struct node_from_variant_t<823> { using type = SgUpcMythread; };

// Class: UpcNotifyStatement
template <> struct describe_field_t<SgUpcNotifyStatement,SgExpression*,&SgUpcNotifyStatement::p_notify_expression> {
  using parent = SgUpcNotifyStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"notify_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcNotifyStatement::p_notify_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcNotifyStatement, SgExpression* SgUpcNotifyStatement::*, &SgUpcNotifyStatement::p_notify_expression>;
};
template <> struct describe_node_t<SgUpcNotifyStatement> {
  using node = SgUpcNotifyStatement;
  using base = SgStatement;
  static constexpr char const * const name{"UpcNotifyStatement"};
  static constexpr unsigned long variant{824};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUpcNotifyStatement,SgExpression*,&SgUpcNotifyStatement::p_notify_expression>>;
};
template <> struct node_from_variant_t<824> { using type = SgUpcNotifyStatement; };

// Class: UpcThreads
template <> struct describe_field_t<SgUpcThreads,int,&SgUpcThreads::p_value> {
  using parent = SgUpcThreads;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcThreads::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcThreads, int SgUpcThreads::*, &SgUpcThreads::p_value>;
};
template <> struct describe_field_t<SgUpcThreads,std::string,&SgUpcThreads::p_valueString> {
  using parent = SgUpcThreads;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUpcThreads::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcThreads, std::string SgUpcThreads::*, &SgUpcThreads::p_valueString>;
};
template <> struct describe_node_t<SgUpcThreads> {
  using node = SgUpcThreads;
  using base = SgValueExp;
  static constexpr char const * const name{"UpcThreads"};
  static constexpr unsigned long variant{825};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUpcThreads,int,&SgUpcThreads::p_value>, describe_field_t<SgUpcThreads,std::string,&SgUpcThreads::p_valueString>>;
};
template <> struct node_from_variant_t<825> { using type = SgUpcThreads; };

// Class: UpcWaitStatement
template <> struct describe_field_t<SgUpcWaitStatement,SgExpression*,&SgUpcWaitStatement::p_wait_expression> {
  using parent = SgUpcWaitStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"wait_expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUpcWaitStatement::p_wait_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUpcWaitStatement, SgExpression* SgUpcWaitStatement::*, &SgUpcWaitStatement::p_wait_expression>;
};
template <> struct describe_node_t<SgUpcWaitStatement> {
  using node = SgUpcWaitStatement;
  using base = SgStatement;
  static constexpr char const * const name{"UpcWaitStatement"};
  static constexpr unsigned long variant{826};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUpcWaitStatement,SgExpression*,&SgUpcWaitStatement::p_wait_expression>>;
};
template <> struct node_from_variant_t<826> { using type = SgUpcWaitStatement; };

// Class: UseStatement
template <> struct describe_field_t<SgUseStatement,SgName,&SgUseStatement::p_name> {
  using parent = SgUseStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUseStatement::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUseStatement, SgName SgUseStatement::*, &SgUseStatement::p_name>;
};
template <> struct describe_field_t<SgUseStatement,bool,&SgUseStatement::p_only_option> {
  using parent = SgUseStatement;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"only_option"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUseStatement::p_only_option};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUseStatement, bool SgUseStatement::*, &SgUseStatement::p_only_option>;
};
template <> struct describe_field_t<SgUseStatement,std::string,&SgUseStatement::p_module_nature> {
  using parent = SgUseStatement;
  using field_type = std::string;
  static constexpr size_t position{2};
  static constexpr char const * const name{"module_nature"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUseStatement::p_module_nature};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUseStatement, std::string SgUseStatement::*, &SgUseStatement::p_module_nature>;
};
template <> struct describe_field_t<SgUseStatement,SgRenamePairPtrList,&SgUseStatement::p_rename_list> {
  using parent = SgUseStatement;
  using field_type = SgRenamePairPtrList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"rename_list"};
  static constexpr char const * const typestr{"SgRenamePairPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgUseStatement::p_rename_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUseStatement, SgRenamePairPtrList SgUseStatement::*, &SgUseStatement::p_rename_list>;
};
template <> struct describe_field_t<SgUseStatement,SgModuleStatement*,&SgUseStatement::p_module> {
  using parent = SgUseStatement;
  using field_type = SgModuleStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"module"};
  static constexpr char const * const typestr{"SgModuleStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUseStatement::p_module};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUseStatement, SgModuleStatement* SgUseStatement::*, &SgUseStatement::p_module>;
};
template <> struct describe_node_t<SgUseStatement> {
  using node = SgUseStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"UseStatement"};
  static constexpr unsigned long variant{827};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUseStatement,SgName,&SgUseStatement::p_name>, describe_field_t<SgUseStatement,bool,&SgUseStatement::p_only_option>, describe_field_t<SgUseStatement,std::string,&SgUseStatement::p_module_nature>, describe_field_t<SgUseStatement,SgRenamePairPtrList,&SgUseStatement::p_rename_list>, describe_field_t<SgUseStatement,SgModuleStatement*,&SgUseStatement::p_module>>;
};
template <> struct node_from_variant_t<827> { using type = SgUseStatement; };

// Class: UserDefinedBinaryOp
template <> struct describe_field_t<SgUserDefinedBinaryOp,SgName,&SgUserDefinedBinaryOp::p_operator_name> {
  using parent = SgUserDefinedBinaryOp;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operator_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUserDefinedBinaryOp::p_operator_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUserDefinedBinaryOp, SgName SgUserDefinedBinaryOp::*, &SgUserDefinedBinaryOp::p_operator_name>;
};
template <> struct describe_field_t<SgUserDefinedBinaryOp,SgFunctionSymbol*,&SgUserDefinedBinaryOp::p_symbol> {
  using parent = SgUserDefinedBinaryOp;
  using field_type = SgFunctionSymbol*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgFunctionSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUserDefinedBinaryOp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUserDefinedBinaryOp, SgFunctionSymbol* SgUserDefinedBinaryOp::*, &SgUserDefinedBinaryOp::p_symbol>;
};
template <> struct describe_node_t<SgUserDefinedBinaryOp> {
  using node = SgUserDefinedBinaryOp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"UserDefinedBinaryOp"};
  static constexpr unsigned long variant{828};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUserDefinedBinaryOp,SgName,&SgUserDefinedBinaryOp::p_operator_name>, describe_field_t<SgUserDefinedBinaryOp,SgFunctionSymbol*,&SgUserDefinedBinaryOp::p_symbol>>;
};
template <> struct node_from_variant_t<828> { using type = SgUserDefinedBinaryOp; };

// Class: UserDefinedUnaryOp
template <> struct describe_field_t<SgUserDefinedUnaryOp,SgName,&SgUserDefinedUnaryOp::p_operator_name> {
  using parent = SgUserDefinedUnaryOp;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operator_name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUserDefinedUnaryOp::p_operator_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUserDefinedUnaryOp, SgName SgUserDefinedUnaryOp::*, &SgUserDefinedUnaryOp::p_operator_name>;
};
template <> struct describe_field_t<SgUserDefinedUnaryOp,SgFunctionSymbol*,&SgUserDefinedUnaryOp::p_symbol> {
  using parent = SgUserDefinedUnaryOp;
  using field_type = SgFunctionSymbol*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgFunctionSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUserDefinedUnaryOp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUserDefinedUnaryOp, SgFunctionSymbol* SgUserDefinedUnaryOp::*, &SgUserDefinedUnaryOp::p_symbol>;
};
template <> struct describe_node_t<SgUserDefinedUnaryOp> {
  using node = SgUserDefinedUnaryOp;
  using base = SgUnaryOp;
  static constexpr char const * const name{"UserDefinedUnaryOp"};
  static constexpr unsigned long variant{829};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUserDefinedUnaryOp,SgName,&SgUserDefinedUnaryOp::p_operator_name>, describe_field_t<SgUserDefinedUnaryOp,SgFunctionSymbol*,&SgUserDefinedUnaryOp::p_symbol>>;
};
template <> struct node_from_variant_t<829> { using type = SgUserDefinedUnaryOp; };

// Class: UsingDeclarationStatement
template <> struct describe_field_t<SgUsingDeclarationStatement,SgDeclarationStatement*,&SgUsingDeclarationStatement::p_declaration> {
  using parent = SgUsingDeclarationStatement;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDeclarationStatement::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDeclarationStatement, SgDeclarationStatement* SgUsingDeclarationStatement::*, &SgUsingDeclarationStatement::p_declaration>;
};
template <> struct describe_field_t<SgUsingDeclarationStatement,SgInitializedName*,&SgUsingDeclarationStatement::p_initializedName> {
  using parent = SgUsingDeclarationStatement;
  using field_type = SgInitializedName*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"initializedName"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDeclarationStatement::p_initializedName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDeclarationStatement, SgInitializedName* SgUsingDeclarationStatement::*, &SgUsingDeclarationStatement::p_initializedName>;
};
template <> struct describe_field_t<SgUsingDeclarationStatement,int,&SgUsingDeclarationStatement::p_name_qualification_length> {
  using parent = SgUsingDeclarationStatement;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDeclarationStatement::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDeclarationStatement, int SgUsingDeclarationStatement::*, &SgUsingDeclarationStatement::p_name_qualification_length>;
};
template <> struct describe_field_t<SgUsingDeclarationStatement,bool,&SgUsingDeclarationStatement::p_type_elaboration_required> {
  using parent = SgUsingDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDeclarationStatement::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDeclarationStatement, bool SgUsingDeclarationStatement::*, &SgUsingDeclarationStatement::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgUsingDeclarationStatement,bool,&SgUsingDeclarationStatement::p_global_qualification_required> {
  using parent = SgUsingDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDeclarationStatement::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDeclarationStatement, bool SgUsingDeclarationStatement::*, &SgUsingDeclarationStatement::p_global_qualification_required>;
};
template <> struct describe_field_t<SgUsingDeclarationStatement,bool,&SgUsingDeclarationStatement::p_is_inheriting_constructor> {
  using parent = SgUsingDeclarationStatement;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"is_inheriting_constructor"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDeclarationStatement::p_is_inheriting_constructor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDeclarationStatement, bool SgUsingDeclarationStatement::*, &SgUsingDeclarationStatement::p_is_inheriting_constructor>;
};
template <> struct describe_field_t<SgUsingDeclarationStatement,SgName,&SgUsingDeclarationStatement::p_adaTypeAttribute> {
  using parent = SgUsingDeclarationStatement;
  using field_type = SgName;
  static constexpr size_t position{6};
  static constexpr char const * const name{"adaTypeAttribute"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDeclarationStatement::p_adaTypeAttribute};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDeclarationStatement, SgName SgUsingDeclarationStatement::*, &SgUsingDeclarationStatement::p_adaTypeAttribute>;
};
template <> struct describe_node_t<SgUsingDeclarationStatement> {
  using node = SgUsingDeclarationStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"UsingDeclarationStatement"};
  static constexpr unsigned long variant{830};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUsingDeclarationStatement,SgDeclarationStatement*,&SgUsingDeclarationStatement::p_declaration>, describe_field_t<SgUsingDeclarationStatement,SgInitializedName*,&SgUsingDeclarationStatement::p_initializedName>, describe_field_t<SgUsingDeclarationStatement,int,&SgUsingDeclarationStatement::p_name_qualification_length>, describe_field_t<SgUsingDeclarationStatement,bool,&SgUsingDeclarationStatement::p_type_elaboration_required>, describe_field_t<SgUsingDeclarationStatement,bool,&SgUsingDeclarationStatement::p_global_qualification_required>, describe_field_t<SgUsingDeclarationStatement,bool,&SgUsingDeclarationStatement::p_is_inheriting_constructor>, describe_field_t<SgUsingDeclarationStatement,SgName,&SgUsingDeclarationStatement::p_adaTypeAttribute>>;
};
template <> struct node_from_variant_t<830> { using type = SgUsingDeclarationStatement; };

// Class: UsingDirectiveStatement
template <> struct describe_field_t<SgUsingDirectiveStatement,SgNamespaceDeclarationStatement*,&SgUsingDirectiveStatement::p_namespaceDeclaration> {
  using parent = SgUsingDirectiveStatement;
  using field_type = SgNamespaceDeclarationStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"namespaceDeclaration"};
  static constexpr char const * const typestr{"SgNamespaceDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDirectiveStatement::p_namespaceDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDirectiveStatement, SgNamespaceDeclarationStatement* SgUsingDirectiveStatement::*, &SgUsingDirectiveStatement::p_namespaceDeclaration>;
};
template <> struct describe_field_t<SgUsingDirectiveStatement,int,&SgUsingDirectiveStatement::p_name_qualification_length> {
  using parent = SgUsingDirectiveStatement;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDirectiveStatement::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDirectiveStatement, int SgUsingDirectiveStatement::*, &SgUsingDirectiveStatement::p_name_qualification_length>;
};
template <> struct describe_field_t<SgUsingDirectiveStatement,bool,&SgUsingDirectiveStatement::p_type_elaboration_required> {
  using parent = SgUsingDirectiveStatement;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDirectiveStatement::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDirectiveStatement, bool SgUsingDirectiveStatement::*, &SgUsingDirectiveStatement::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgUsingDirectiveStatement,bool,&SgUsingDirectiveStatement::p_global_qualification_required> {
  using parent = SgUsingDirectiveStatement;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgUsingDirectiveStatement::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgUsingDirectiveStatement, bool SgUsingDirectiveStatement::*, &SgUsingDirectiveStatement::p_global_qualification_required>;
};
template <> struct describe_node_t<SgUsingDirectiveStatement> {
  using node = SgUsingDirectiveStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"UsingDirectiveStatement"};
  static constexpr unsigned long variant{831};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgUsingDirectiveStatement,SgNamespaceDeclarationStatement*,&SgUsingDirectiveStatement::p_namespaceDeclaration>, describe_field_t<SgUsingDirectiveStatement,int,&SgUsingDirectiveStatement::p_name_qualification_length>, describe_field_t<SgUsingDirectiveStatement,bool,&SgUsingDirectiveStatement::p_type_elaboration_required>, describe_field_t<SgUsingDirectiveStatement,bool,&SgUsingDirectiveStatement::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<831> { using type = SgUsingDirectiveStatement; };

// Class: ValueExp
template <> struct describe_field_t<SgValueExp,SgExpression*,&SgValueExp::p_originalExpressionTree> {
  using parent = SgValueExp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"originalExpressionTree"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgValueExp::p_originalExpressionTree};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgValueExp, SgExpression* SgValueExp::*, &SgValueExp::p_originalExpressionTree>;
};
template <> struct describe_node_t<SgValueExp> {
  using node = SgValueExp;
  using base = SgExpression;
  static constexpr char const * const name{"ValueExp"};
  static constexpr unsigned long variant{832};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgBoolValExp, SgStringVal, SgShortVal, SgCharVal, SgUnsignedCharVal, SgWcharVal, SgUnsignedShortVal, SgIntVal, SgEnumVal, SgUnsignedIntVal, SgLongIntVal, SgLongLongIntVal, SgUnsignedLongLongIntVal, SgUnsignedLongVal, SgFloatVal, SgDoubleVal, SgLongDoubleVal, SgComplexVal, SgUpcThreads, SgUpcMythread, SgTemplateParameterVal, SgNullptrValExp, SgChar16Val, SgChar32Val, SgFloat80Val, SgFloat128Val, SgVoidVal, SgAdaFloatVal, SgSignedCharVal, SgJovialBitVal>;
  using fields_t = mp::List<describe_field_t<SgValueExp,SgExpression*,&SgValueExp::p_originalExpressionTree>>;
};
template <> struct node_from_variant_t<832> { using type = SgValueExp; };

// Class: VarArgCopyOp
template <> struct describe_field_t<SgVarArgCopyOp,SgExpression*,&SgVarArgCopyOp::p_lhs_operand> {
  using parent = SgVarArgCopyOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lhs_operand"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVarArgCopyOp::p_lhs_operand};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgCopyOp, SgExpression* SgVarArgCopyOp::*, &SgVarArgCopyOp::p_lhs_operand>;
};
template <> struct describe_field_t<SgVarArgCopyOp,SgExpression*,&SgVarArgCopyOp::p_rhs_operand> {
  using parent = SgVarArgCopyOp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"rhs_operand"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVarArgCopyOp::p_rhs_operand};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgCopyOp, SgExpression* SgVarArgCopyOp::*, &SgVarArgCopyOp::p_rhs_operand>;
};
template <> struct describe_field_t<SgVarArgCopyOp,SgType*,&SgVarArgCopyOp::p_expression_type> {
  using parent = SgVarArgCopyOp;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarArgCopyOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgCopyOp, SgType* SgVarArgCopyOp::*, &SgVarArgCopyOp::p_expression_type>;
};
template <> struct describe_node_t<SgVarArgCopyOp> {
  using node = SgVarArgCopyOp;
  using base = SgExpression;
  static constexpr char const * const name{"VarArgCopyOp"};
  static constexpr unsigned long variant{833};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgVarArgCopyOp,SgExpression*,&SgVarArgCopyOp::p_lhs_operand>, describe_field_t<SgVarArgCopyOp,SgExpression*,&SgVarArgCopyOp::p_rhs_operand>, describe_field_t<SgVarArgCopyOp,SgType*,&SgVarArgCopyOp::p_expression_type>>;
};
template <> struct node_from_variant_t<833> { using type = SgVarArgCopyOp; };

// Class: VarArgEndOp
template <> struct describe_field_t<SgVarArgEndOp,SgExpression*,&SgVarArgEndOp::p_operand_expr> {
  using parent = SgVarArgEndOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_expr"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVarArgEndOp::p_operand_expr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgEndOp, SgExpression* SgVarArgEndOp::*, &SgVarArgEndOp::p_operand_expr>;
};
template <> struct describe_field_t<SgVarArgEndOp,SgType*,&SgVarArgEndOp::p_expression_type> {
  using parent = SgVarArgEndOp;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarArgEndOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgEndOp, SgType* SgVarArgEndOp::*, &SgVarArgEndOp::p_expression_type>;
};
template <> struct describe_node_t<SgVarArgEndOp> {
  using node = SgVarArgEndOp;
  using base = SgExpression;
  static constexpr char const * const name{"VarArgEndOp"};
  static constexpr unsigned long variant{834};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgVarArgEndOp,SgExpression*,&SgVarArgEndOp::p_operand_expr>, describe_field_t<SgVarArgEndOp,SgType*,&SgVarArgEndOp::p_expression_type>>;
};
template <> struct node_from_variant_t<834> { using type = SgVarArgEndOp; };

// Class: VarArgOp
template <> struct describe_field_t<SgVarArgOp,SgExpression*,&SgVarArgOp::p_operand_expr> {
  using parent = SgVarArgOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_expr"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVarArgOp::p_operand_expr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgOp, SgExpression* SgVarArgOp::*, &SgVarArgOp::p_operand_expr>;
};
template <> struct describe_field_t<SgVarArgOp,SgType*,&SgVarArgOp::p_expression_type> {
  using parent = SgVarArgOp;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarArgOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgOp, SgType* SgVarArgOp::*, &SgVarArgOp::p_expression_type>;
};
template <> struct describe_node_t<SgVarArgOp> {
  using node = SgVarArgOp;
  using base = SgExpression;
  static constexpr char const * const name{"VarArgOp"};
  static constexpr unsigned long variant{835};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgVarArgOp,SgExpression*,&SgVarArgOp::p_operand_expr>, describe_field_t<SgVarArgOp,SgType*,&SgVarArgOp::p_expression_type>>;
};
template <> struct node_from_variant_t<835> { using type = SgVarArgOp; };

// Class: VarArgStartOneOperandOp
template <> struct describe_field_t<SgVarArgStartOneOperandOp,SgExpression*,&SgVarArgStartOneOperandOp::p_operand_expr> {
  using parent = SgVarArgStartOneOperandOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"operand_expr"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVarArgStartOneOperandOp::p_operand_expr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgStartOneOperandOp, SgExpression* SgVarArgStartOneOperandOp::*, &SgVarArgStartOneOperandOp::p_operand_expr>;
};
template <> struct describe_field_t<SgVarArgStartOneOperandOp,SgType*,&SgVarArgStartOneOperandOp::p_expression_type> {
  using parent = SgVarArgStartOneOperandOp;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarArgStartOneOperandOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgStartOneOperandOp, SgType* SgVarArgStartOneOperandOp::*, &SgVarArgStartOneOperandOp::p_expression_type>;
};
template <> struct describe_node_t<SgVarArgStartOneOperandOp> {
  using node = SgVarArgStartOneOperandOp;
  using base = SgExpression;
  static constexpr char const * const name{"VarArgStartOneOperandOp"};
  static constexpr unsigned long variant{836};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgVarArgStartOneOperandOp,SgExpression*,&SgVarArgStartOneOperandOp::p_operand_expr>, describe_field_t<SgVarArgStartOneOperandOp,SgType*,&SgVarArgStartOneOperandOp::p_expression_type>>;
};
template <> struct node_from_variant_t<836> { using type = SgVarArgStartOneOperandOp; };

// Class: VarArgStartOp
template <> struct describe_field_t<SgVarArgStartOp,SgExpression*,&SgVarArgStartOp::p_lhs_operand> {
  using parent = SgVarArgStartOp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lhs_operand"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVarArgStartOp::p_lhs_operand};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgStartOp, SgExpression* SgVarArgStartOp::*, &SgVarArgStartOp::p_lhs_operand>;
};
template <> struct describe_field_t<SgVarArgStartOp,SgExpression*,&SgVarArgStartOp::p_rhs_operand> {
  using parent = SgVarArgStartOp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"rhs_operand"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVarArgStartOp::p_rhs_operand};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgStartOp, SgExpression* SgVarArgStartOp::*, &SgVarArgStartOp::p_rhs_operand>;
};
template <> struct describe_field_t<SgVarArgStartOp,SgType*,&SgVarArgStartOp::p_expression_type> {
  using parent = SgVarArgStartOp;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarArgStartOp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarArgStartOp, SgType* SgVarArgStartOp::*, &SgVarArgStartOp::p_expression_type>;
};
template <> struct describe_node_t<SgVarArgStartOp> {
  using node = SgVarArgStartOp;
  using base = SgExpression;
  static constexpr char const * const name{"VarArgStartOp"};
  static constexpr unsigned long variant{837};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgVarArgStartOp,SgExpression*,&SgVarArgStartOp::p_lhs_operand>, describe_field_t<SgVarArgStartOp,SgExpression*,&SgVarArgStartOp::p_rhs_operand>, describe_field_t<SgVarArgStartOp,SgType*,&SgVarArgStartOp::p_expression_type>>;
};
template <> struct node_from_variant_t<837> { using type = SgVarArgStartOp; };

// Class: VarRefExp
template <> struct describe_field_t<SgVarRefExp,SgVariableSymbol*,&SgVarRefExp::p_symbol> {
  using parent = SgVarRefExp;
  using field_type = SgVariableSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgVariableSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarRefExp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarRefExp, SgVariableSymbol* SgVarRefExp::*, &SgVarRefExp::p_symbol>;
};
template <> struct describe_field_t<SgVarRefExp,SgExpression*,&SgVarRefExp::p_originalExpressionTree> {
  using parent = SgVarRefExp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"originalExpressionTree"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarRefExp::p_originalExpressionTree};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarRefExp, SgExpression* SgVarRefExp::*, &SgVarRefExp::p_originalExpressionTree>;
};
template <> struct describe_field_t<SgVarRefExp,int,&SgVarRefExp::p_name_qualification_length> {
  using parent = SgVarRefExp;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarRefExp::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarRefExp, int SgVarRefExp::*, &SgVarRefExp::p_name_qualification_length>;
};
template <> struct describe_field_t<SgVarRefExp,bool,&SgVarRefExp::p_type_elaboration_required> {
  using parent = SgVarRefExp;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarRefExp::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarRefExp, bool SgVarRefExp::*, &SgVarRefExp::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgVarRefExp,bool,&SgVarRefExp::p_global_qualification_required> {
  using parent = SgVarRefExp;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVarRefExp::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVarRefExp, bool SgVarRefExp::*, &SgVarRefExp::p_global_qualification_required>;
};
template <> struct describe_node_t<SgVarRefExp> {
  using node = SgVarRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"VarRefExp"};
  static constexpr unsigned long variant{838};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgVarRefExp,SgVariableSymbol*,&SgVarRefExp::p_symbol>, describe_field_t<SgVarRefExp,SgExpression*,&SgVarRefExp::p_originalExpressionTree>, describe_field_t<SgVarRefExp,int,&SgVarRefExp::p_name_qualification_length>, describe_field_t<SgVarRefExp,bool,&SgVarRefExp::p_type_elaboration_required>, describe_field_t<SgVarRefExp,bool,&SgVarRefExp::p_global_qualification_required>>;
};
template <> struct node_from_variant_t<838> { using type = SgVarRefExp; };

// Class: VariableDeclaration
template <> struct describe_field_t<SgVariableDeclaration,SgDeclarationStatement*,&SgVariableDeclaration::p_baseTypeDefiningDeclaration> {
  using parent = SgVariableDeclaration;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"baseTypeDefiningDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_baseTypeDefiningDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, SgDeclarationStatement* SgVariableDeclaration::*, &SgVariableDeclaration::p_baseTypeDefiningDeclaration>;
};
template <> struct describe_field_t<SgVariableDeclaration,SgInitializedNamePtrList,&SgVariableDeclaration::p_variables> {
  using parent = SgVariableDeclaration;
  using field_type = SgInitializedNamePtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"variables"};
  static constexpr char const * const typestr{"SgInitializedNamePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_variables};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, SgInitializedNamePtrList SgVariableDeclaration::*, &SgVariableDeclaration::p_variables>;
};
template <> struct describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_variableDeclarationContainsBaseTypeDefiningDeclaration> {
  using parent = SgVariableDeclaration;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"variableDeclarationContainsBaseTypeDefiningDeclaration"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_variableDeclarationContainsBaseTypeDefiningDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, bool SgVariableDeclaration::*, &SgVariableDeclaration::p_variableDeclarationContainsBaseTypeDefiningDeclaration>;
};
template <> struct describe_field_t<SgVariableDeclaration,SgDeclarationStatement::template_specialization_enum,&SgVariableDeclaration::p_specialization> {
  using parent = SgVariableDeclaration;
  using field_type = SgDeclarationStatement::template_specialization_enum;
  static constexpr size_t position{3};
  static constexpr char const * const name{"specialization"};
  static constexpr char const * const typestr{"SgDeclarationStatement::template_specialization_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_specialization};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, SgDeclarationStatement::template_specialization_enum SgVariableDeclaration::*, &SgVariableDeclaration::p_specialization>;
};
template <> struct describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_requiresGlobalNameQualificationOnType> {
  using parent = SgVariableDeclaration;
  using field_type = bool;
  static constexpr size_t position{4};
  static constexpr char const * const name{"requiresGlobalNameQualificationOnType"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_requiresGlobalNameQualificationOnType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, bool SgVariableDeclaration::*, &SgVariableDeclaration::p_requiresGlobalNameQualificationOnType>;
};
template <> struct describe_field_t<SgVariableDeclaration,std::string,&SgVariableDeclaration::p_gnu_extension_section> {
  using parent = SgVariableDeclaration;
  using field_type = std::string;
  static constexpr size_t position{5};
  static constexpr char const * const name{"gnu_extension_section"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_gnu_extension_section};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, std::string SgVariableDeclaration::*, &SgVariableDeclaration::p_gnu_extension_section>;
};
template <> struct describe_field_t<SgVariableDeclaration,std::string,&SgVariableDeclaration::p_gnu_extension_alias> {
  using parent = SgVariableDeclaration;
  using field_type = std::string;
  static constexpr size_t position{6};
  static constexpr char const * const name{"gnu_extension_alias"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_gnu_extension_alias};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, std::string SgVariableDeclaration::*, &SgVariableDeclaration::p_gnu_extension_alias>;
};
template <> struct describe_field_t<SgVariableDeclaration,unsigned short,&SgVariableDeclaration::p_gnu_extension_initialization_priority> {
  using parent = SgVariableDeclaration;
  using field_type = unsigned short;
  static constexpr size_t position{7};
  static constexpr char const * const name{"gnu_extension_initialization_priority"};
  static constexpr char const * const typestr{"unsigned short"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_gnu_extension_initialization_priority};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, unsigned short SgVariableDeclaration::*, &SgVariableDeclaration::p_gnu_extension_initialization_priority>;
};
template <> struct describe_field_t<SgVariableDeclaration,SgDeclarationStatement::gnu_extension_visability_attribute_enum,&SgVariableDeclaration::p_gnu_extension_visability> {
  using parent = SgVariableDeclaration;
  using field_type = SgDeclarationStatement::gnu_extension_visability_attribute_enum;
  static constexpr size_t position{8};
  static constexpr char const * const name{"gnu_extension_visability"};
  static constexpr char const * const typestr{"SgDeclarationStatement::gnu_extension_visability_attribute_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_gnu_extension_visability};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, SgDeclarationStatement::gnu_extension_visability_attribute_enum SgVariableDeclaration::*, &SgVariableDeclaration::p_gnu_extension_visability>;
};
template <> struct describe_field_t<SgVariableDeclaration,SgVariableDeclaration::gnu_extension_declaration_attributes_enum,&SgVariableDeclaration::p_gnu_extension_declaration_attribute> {
  using parent = SgVariableDeclaration;
  using field_type = SgVariableDeclaration::gnu_extension_declaration_attributes_enum;
  static constexpr size_t position{9};
  static constexpr char const * const name{"gnu_extension_declaration_attribute"};
  static constexpr char const * const typestr{"SgVariableDeclaration::gnu_extension_declaration_attributes_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_gnu_extension_declaration_attribute};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, SgVariableDeclaration::gnu_extension_declaration_attributes_enum SgVariableDeclaration::*, &SgVariableDeclaration::p_gnu_extension_declaration_attribute>;
};
template <> struct describe_field_t<SgVariableDeclaration,int,&SgVariableDeclaration::p_name_qualification_length> {
  using parent = SgVariableDeclaration;
  using field_type = int;
  static constexpr size_t position{10};
  static constexpr char const * const name{"name_qualification_length"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_name_qualification_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, int SgVariableDeclaration::*, &SgVariableDeclaration::p_name_qualification_length>;
};
template <> struct describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_type_elaboration_required> {
  using parent = SgVariableDeclaration;
  using field_type = bool;
  static constexpr size_t position{11};
  static constexpr char const * const name{"type_elaboration_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_type_elaboration_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, bool SgVariableDeclaration::*, &SgVariableDeclaration::p_type_elaboration_required>;
};
template <> struct describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_global_qualification_required> {
  using parent = SgVariableDeclaration;
  using field_type = bool;
  static constexpr size_t position{12};
  static constexpr char const * const name{"global_qualification_required"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_global_qualification_required};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, bool SgVariableDeclaration::*, &SgVariableDeclaration::p_global_qualification_required>;
};
template <> struct describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_isAssociatedWithDeclarationList> {
  using parent = SgVariableDeclaration;
  using field_type = bool;
  static constexpr size_t position{13};
  static constexpr char const * const name{"isAssociatedWithDeclarationList"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_isAssociatedWithDeclarationList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, bool SgVariableDeclaration::*, &SgVariableDeclaration::p_isAssociatedWithDeclarationList>;
};
template <> struct describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_isFirstDeclarationOfDeclarationList> {
  using parent = SgVariableDeclaration;
  using field_type = bool;
  static constexpr size_t position{14};
  static constexpr char const * const name{"isFirstDeclarationOfDeclarationList"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_isFirstDeclarationOfDeclarationList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, bool SgVariableDeclaration::*, &SgVariableDeclaration::p_isFirstDeclarationOfDeclarationList>;
};
template <> struct describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_is_thread_local> {
  using parent = SgVariableDeclaration;
  using field_type = bool;
  static constexpr size_t position{15};
  static constexpr char const * const name{"is_thread_local"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_is_thread_local};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, bool SgVariableDeclaration::*, &SgVariableDeclaration::p_is_thread_local>;
};
template <> struct describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_is_constexpr> {
  using parent = SgVariableDeclaration;
  using field_type = bool;
  static constexpr size_t position{16};
  static constexpr char const * const name{"is_constexpr"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_is_constexpr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, bool SgVariableDeclaration::*, &SgVariableDeclaration::p_is_constexpr>;
};
template <> struct describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_builtFromUseOnly> {
  using parent = SgVariableDeclaration;
  using field_type = bool;
  static constexpr size_t position{17};
  static constexpr char const * const name{"builtFromUseOnly"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableDeclaration::p_builtFromUseOnly};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDeclaration, bool SgVariableDeclaration::*, &SgVariableDeclaration::p_builtFromUseOnly>;
};
template <> struct describe_node_t<SgVariableDeclaration> {
  using node = SgVariableDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"VariableDeclaration"};
  static constexpr unsigned long variant{839};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateVariableDeclaration, SgTemplateVariableInstantiation>;
  using fields_t = mp::List<describe_field_t<SgVariableDeclaration,SgDeclarationStatement*,&SgVariableDeclaration::p_baseTypeDefiningDeclaration>, describe_field_t<SgVariableDeclaration,SgInitializedNamePtrList,&SgVariableDeclaration::p_variables>, describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_variableDeclarationContainsBaseTypeDefiningDeclaration>, describe_field_t<SgVariableDeclaration,SgDeclarationStatement::template_specialization_enum,&SgVariableDeclaration::p_specialization>, describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_requiresGlobalNameQualificationOnType>, describe_field_t<SgVariableDeclaration,std::string,&SgVariableDeclaration::p_gnu_extension_section>, describe_field_t<SgVariableDeclaration,std::string,&SgVariableDeclaration::p_gnu_extension_alias>, describe_field_t<SgVariableDeclaration,unsigned short,&SgVariableDeclaration::p_gnu_extension_initialization_priority>, describe_field_t<SgVariableDeclaration,SgDeclarationStatement::gnu_extension_visability_attribute_enum,&SgVariableDeclaration::p_gnu_extension_visability>, describe_field_t<SgVariableDeclaration,SgVariableDeclaration::gnu_extension_declaration_attributes_enum,&SgVariableDeclaration::p_gnu_extension_declaration_attribute>, describe_field_t<SgVariableDeclaration,int,&SgVariableDeclaration::p_name_qualification_length>, describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_type_elaboration_required>, describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_global_qualification_required>, describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_isAssociatedWithDeclarationList>, describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_isFirstDeclarationOfDeclarationList>, describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_is_thread_local>, describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_is_constexpr>, describe_field_t<SgVariableDeclaration,bool,&SgVariableDeclaration::p_builtFromUseOnly>>;
};
template <> struct node_from_variant_t<839> { using type = SgVariableDeclaration; };

// Class: VariableDefinition
template <> struct describe_field_t<SgVariableDefinition,SgInitializedName*,&SgVariableDefinition::p_vardefn> {
  using parent = SgVariableDefinition;
  using field_type = SgInitializedName*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"vardefn"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVariableDefinition::p_vardefn};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDefinition, SgInitializedName* SgVariableDefinition::*, &SgVariableDefinition::p_vardefn>;
};
template <> struct describe_field_t<SgVariableDefinition,SgExpression*,&SgVariableDefinition::p_bitfield> {
  using parent = SgVariableDefinition;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"bitfield"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgVariableDefinition::p_bitfield};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableDefinition, SgExpression* SgVariableDefinition::*, &SgVariableDefinition::p_bitfield>;
};
template <> struct describe_node_t<SgVariableDefinition> {
  using node = SgVariableDefinition;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"VariableDefinition"};
  static constexpr unsigned long variant{840};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgVariableDefinition,SgInitializedName*,&SgVariableDefinition::p_vardefn>, describe_field_t<SgVariableDefinition,SgExpression*,&SgVariableDefinition::p_bitfield>>;
};
template <> struct node_from_variant_t<840> { using type = SgVariableDefinition; };

// Class: VariableSymbol
template <> struct describe_field_t<SgVariableSymbol,SgInitializedName*,&SgVariableSymbol::p_declaration> {
  using parent = SgVariableSymbol;
  using field_type = SgInitializedName*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgInitializedName*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgVariableSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgVariableSymbol, SgInitializedName* SgVariableSymbol::*, &SgVariableSymbol::p_declaration>;
};
template <> struct describe_node_t<SgVariableSymbol> {
  using node = SgVariableSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"VariableSymbol"};
  static constexpr unsigned long variant{841};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgTemplateVariableSymbol>;
  using fields_t = mp::List<describe_field_t<SgVariableSymbol,SgInitializedName*,&SgVariableSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<841> { using type = SgVariableSymbol; };

// Class: VariantExpression
template <> struct describe_node_t<SgVariantExpression> {
  using node = SgVariantExpression;
  using base = SgExpression;
  static constexpr char const * const name{"VariantExpression"};
  static constexpr unsigned long variant{842};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<842> { using type = SgVariantExpression; };

// Class: VariantStatement
template <> struct describe_node_t<SgVariantStatement> {
  using node = SgVariantStatement;
  using base = SgStatement;
  static constexpr char const * const name{"VariantStatement"};
  static constexpr unsigned long variant{843};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<843> { using type = SgVariantStatement; };

// Class: VoidVal
template <> struct describe_node_t<SgVoidVal> {
  using node = SgVoidVal;
  using base = SgValueExp;
  static constexpr char const * const name{"VoidVal"};
  static constexpr unsigned long variant{844};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<844> { using type = SgVoidVal; };

// Class: WaitStatement
template <> struct describe_node_t<SgWaitStatement> {
  using node = SgWaitStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"WaitStatement"};
  static constexpr unsigned long variant{845};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<845> { using type = SgWaitStatement; };

// Class: WarningDirectiveStatement
template <> struct describe_node_t<SgWarningDirectiveStatement> {
  using node = SgWarningDirectiveStatement;
  using base = SgC_PreprocessorDirectiveStatement;
  static constexpr char const * const name{"WarningDirectiveStatement"};
  static constexpr unsigned long variant{846};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<846> { using type = SgWarningDirectiveStatement; };

// Class: WithStatement
template <> struct describe_field_t<SgWithStatement,SgExpression*,&SgWithStatement::p_expression> {
  using parent = SgWithStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWithStatement::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWithStatement, SgExpression* SgWithStatement::*, &SgWithStatement::p_expression>;
};
template <> struct describe_field_t<SgWithStatement,SgStatement*,&SgWithStatement::p_body> {
  using parent = SgWithStatement;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWithStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWithStatement, SgStatement* SgWithStatement::*, &SgWithStatement::p_body>;
};
template <> struct describe_node_t<SgWithStatement> {
  using node = SgWithStatement;
  using base = SgStatement;
  static constexpr char const * const name{"WithStatement"};
  static constexpr unsigned long variant{847};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgWithStatement,SgExpression*,&SgWithStatement::p_expression>, describe_field_t<SgWithStatement,SgStatement*,&SgWithStatement::p_body>>;
};
template <> struct node_from_variant_t<847> { using type = SgWithStatement; };

// Class: WcharVal
template <> struct describe_field_t<SgWcharVal,unsigned long,&SgWcharVal::p_valueUL> {
  using parent = SgWcharVal;
  using field_type = unsigned long;
  static constexpr size_t position{0};
  static constexpr char const * const name{"valueUL"};
  static constexpr char const * const typestr{"unsigned long"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgWcharVal::p_valueUL};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWcharVal, unsigned long SgWcharVal::*, &SgWcharVal::p_valueUL>;
};
template <> struct describe_field_t<SgWcharVal,std::string,&SgWcharVal::p_valueString> {
  using parent = SgWcharVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgWcharVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWcharVal, std::string SgWcharVal::*, &SgWcharVal::p_valueString>;
};
template <> struct describe_node_t<SgWcharVal> {
  using node = SgWcharVal;
  using base = SgValueExp;
  static constexpr char const * const name{"WcharVal"};
  static constexpr unsigned long variant{848};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgWcharVal,unsigned long,&SgWcharVal::p_valueUL>, describe_field_t<SgWcharVal,std::string,&SgWcharVal::p_valueString>>;
};
template <> struct node_from_variant_t<848> { using type = SgWcharVal; };

// Class: WhereStatement
template <> struct describe_field_t<SgWhereStatement,SgExpression*,&SgWhereStatement::p_condition> {
  using parent = SgWhereStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"condition"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWhereStatement::p_condition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhereStatement, SgExpression* SgWhereStatement::*, &SgWhereStatement::p_condition>;
};
template <> struct describe_field_t<SgWhereStatement,SgBasicBlock*,&SgWhereStatement::p_body> {
  using parent = SgWhereStatement;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWhereStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhereStatement, SgBasicBlock* SgWhereStatement::*, &SgWhereStatement::p_body>;
};
template <> struct describe_field_t<SgWhereStatement,SgElseWhereStatement*,&SgWhereStatement::p_elsewhere> {
  using parent = SgWhereStatement;
  using field_type = SgElseWhereStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"elsewhere"};
  static constexpr char const * const typestr{"SgElseWhereStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWhereStatement::p_elsewhere};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhereStatement, SgElseWhereStatement* SgWhereStatement::*, &SgWhereStatement::p_elsewhere>;
};
template <> struct describe_field_t<SgWhereStatement,SgLabelRefExp*,&SgWhereStatement::p_end_numeric_label> {
  using parent = SgWhereStatement;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgWhereStatement::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhereStatement, SgLabelRefExp* SgWhereStatement::*, &SgWhereStatement::p_end_numeric_label>;
};
template <> struct describe_field_t<SgWhereStatement,std::string,&SgWhereStatement::p_string_label> {
  using parent = SgWhereStatement;
  using field_type = std::string;
  static constexpr size_t position{4};
  static constexpr char const * const name{"string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgWhereStatement::p_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhereStatement, std::string SgWhereStatement::*, &SgWhereStatement::p_string_label>;
};
template <> struct describe_field_t<SgWhereStatement,bool,&SgWhereStatement::p_has_end_statement> {
  using parent = SgWhereStatement;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"has_end_statement"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgWhereStatement::p_has_end_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhereStatement, bool SgWhereStatement::*, &SgWhereStatement::p_has_end_statement>;
};
template <> struct describe_node_t<SgWhereStatement> {
  using node = SgWhereStatement;
  using base = SgStatement;
  static constexpr char const * const name{"WhereStatement"};
  static constexpr unsigned long variant{849};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgWhereStatement,SgExpression*,&SgWhereStatement::p_condition>, describe_field_t<SgWhereStatement,SgBasicBlock*,&SgWhereStatement::p_body>, describe_field_t<SgWhereStatement,SgElseWhereStatement*,&SgWhereStatement::p_elsewhere>, describe_field_t<SgWhereStatement,SgLabelRefExp*,&SgWhereStatement::p_end_numeric_label>, describe_field_t<SgWhereStatement,std::string,&SgWhereStatement::p_string_label>, describe_field_t<SgWhereStatement,bool,&SgWhereStatement::p_has_end_statement>>;
};
template <> struct node_from_variant_t<849> { using type = SgWhereStatement; };

// Class: WhileStmt
template <> struct describe_field_t<SgWhileStmt,SgStatement*,&SgWhileStmt::p_condition> {
  using parent = SgWhileStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"condition"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWhileStmt::p_condition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhileStmt, SgStatement* SgWhileStmt::*, &SgWhileStmt::p_condition>;
};
template <> struct describe_field_t<SgWhileStmt,SgStatement*,&SgWhileStmt::p_body> {
  using parent = SgWhileStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWhileStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhileStmt, SgStatement* SgWhileStmt::*, &SgWhileStmt::p_body>;
};
template <> struct describe_field_t<SgWhileStmt,SgStatement*,&SgWhileStmt::p_else_body> {
  using parent = SgWhileStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"else_body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWhileStmt::p_else_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhileStmt, SgStatement* SgWhileStmt::*, &SgWhileStmt::p_else_body>;
};
template <> struct describe_field_t<SgWhileStmt,SgLabelRefExp*,&SgWhileStmt::p_end_numeric_label> {
  using parent = SgWhileStmt;
  using field_type = SgLabelRefExp*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"end_numeric_label"};
  static constexpr char const * const typestr{"SgLabelRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgWhileStmt::p_end_numeric_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhileStmt, SgLabelRefExp* SgWhileStmt::*, &SgWhileStmt::p_end_numeric_label>;
};
template <> struct describe_field_t<SgWhileStmt,std::string,&SgWhileStmt::p_string_label> {
  using parent = SgWhileStmt;
  using field_type = std::string;
  static constexpr size_t position{4};
  static constexpr char const * const name{"string_label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgWhileStmt::p_string_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhileStmt, std::string SgWhileStmt::*, &SgWhileStmt::p_string_label>;
};
template <> struct describe_field_t<SgWhileStmt,bool,&SgWhileStmt::p_has_end_statement> {
  using parent = SgWhileStmt;
  using field_type = bool;
  static constexpr size_t position{5};
  static constexpr char const * const name{"has_end_statement"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgWhileStmt::p_has_end_statement};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhileStmt, bool SgWhileStmt::*, &SgWhileStmt::p_has_end_statement>;
};
template <> struct describe_node_t<SgWhileStmt> {
  using node = SgWhileStmt;
  using base = SgScopeStatement;
  static constexpr char const * const name{"WhileStmt"};
  static constexpr unsigned long variant{850};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgWhileStmt,SgStatement*,&SgWhileStmt::p_condition>, describe_field_t<SgWhileStmt,SgStatement*,&SgWhileStmt::p_body>, describe_field_t<SgWhileStmt,SgStatement*,&SgWhileStmt::p_else_body>, describe_field_t<SgWhileStmt,SgLabelRefExp*,&SgWhileStmt::p_end_numeric_label>, describe_field_t<SgWhileStmt,std::string,&SgWhileStmt::p_string_label>, describe_field_t<SgWhileStmt,bool,&SgWhileStmt::p_has_end_statement>>;
};
template <> struct node_from_variant_t<850> { using type = SgWhileStmt; };

// Class: WriteStatement
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_format> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"format"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_format};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_format>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_namelist> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"namelist"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_namelist};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_namelist>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_advance> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"advance"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_advance};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_advance>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_asynchronous> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"asynchronous"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_asynchronous};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_asynchronous>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_blank> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"blank"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_blank};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_blank>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_decimal> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{5};
  static constexpr char const * const name{"decimal"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_decimal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_decimal>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_delim> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"delim"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_delim};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_delim>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_end> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{7};
  static constexpr char const * const name{"end"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_end};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_end>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_eor> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{8};
  static constexpr char const * const name{"eor"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_eor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_eor>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_id> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"id"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_id};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_id>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_pad> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{10};
  static constexpr char const * const name{"pad"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_pad};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_pad>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_pos> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"pos"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_pos};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_pos>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_rec> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{12};
  static constexpr char const * const name{"rec"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_rec};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_rec>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_round> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"round"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_round};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_round>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_sign> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{14};
  static constexpr char const * const name{"sign"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_sign};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_sign>;
};
template <> struct describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_size> {
  using parent = SgWriteStatement;
  using field_type = SgExpression*;
  static constexpr size_t position{15};
  static constexpr char const * const name{"size"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWriteStatement::p_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWriteStatement, SgExpression* SgWriteStatement::*, &SgWriteStatement::p_size>;
};
template <> struct describe_node_t<SgWriteStatement> {
  using node = SgWriteStatement;
  using base = SgIOStatement;
  static constexpr char const * const name{"WriteStatement"};
  static constexpr unsigned long variant{851};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_format>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_namelist>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_advance>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_asynchronous>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_blank>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_decimal>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_delim>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_end>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_eor>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_id>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_pad>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_pos>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_rec>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_round>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_sign>, describe_field_t<SgWriteStatement,SgExpression*,&SgWriteStatement::p_size>>;
};
template <> struct node_from_variant_t<851> { using type = SgWriteStatement; };

// Class: XorAssignOp
template <> struct describe_node_t<SgXorAssignOp> {
  using node = SgXorAssignOp;
  using base = SgCompoundAssignOp;
  static constexpr char const * const name{"XorAssignOp"};
  static constexpr unsigned long variant{852};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<852> { using type = SgXorAssignOp; };

// Class: YieldExpression
template <> struct describe_field_t<SgYieldExpression,SgExpression*,&SgYieldExpression::p_value> {
  using parent = SgYieldExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgYieldExpression::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgYieldExpression, SgExpression* SgYieldExpression::*, &SgYieldExpression::p_value>;
};
template <> struct describe_node_t<SgYieldExpression> {
  using node = SgYieldExpression;
  using base = SgExpression;
  static constexpr char const * const name{"YieldExpression"};
  static constexpr unsigned long variant{853};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgYieldExpression,SgExpression*,&SgYieldExpression::p_value>>;
};
template <> struct node_from_variant_t<853> { using type = SgYieldExpression; };

// Class: _File_Info
template <> struct describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_file_id> {
  using parent = Sg_File_Info;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"file_id"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&Sg_File_Info::p_file_id};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<Sg_File_Info, int Sg_File_Info::*, &Sg_File_Info::p_file_id>;
};
template <> struct describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_line> {
  using parent = Sg_File_Info;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"line"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&Sg_File_Info::p_line};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<Sg_File_Info, int Sg_File_Info::*, &Sg_File_Info::p_line>;
};
template <> struct describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_col> {
  using parent = Sg_File_Info;
  using field_type = int;
  static constexpr size_t position{2};
  static constexpr char const * const name{"col"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&Sg_File_Info::p_col};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<Sg_File_Info, int Sg_File_Info::*, &Sg_File_Info::p_col>;
};
template <> struct describe_field_t<Sg_File_Info,unsigned int,&Sg_File_Info::p_classificationBitField> {
  using parent = Sg_File_Info;
  using field_type = unsigned int;
  static constexpr size_t position{3};
  static constexpr char const * const name{"classificationBitField"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&Sg_File_Info::p_classificationBitField};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<Sg_File_Info, unsigned int Sg_File_Info::*, &Sg_File_Info::p_classificationBitField>;
};
template <> struct describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_physical_file_id> {
  using parent = Sg_File_Info;
  using field_type = int;
  static constexpr size_t position{4};
  static constexpr char const * const name{"physical_file_id"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&Sg_File_Info::p_physical_file_id};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<Sg_File_Info, int Sg_File_Info::*, &Sg_File_Info::p_physical_file_id>;
};
template <> struct describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_physical_line> {
  using parent = Sg_File_Info;
  using field_type = int;
  static constexpr size_t position{5};
  static constexpr char const * const name{"physical_line"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&Sg_File_Info::p_physical_line};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<Sg_File_Info, int Sg_File_Info::*, &Sg_File_Info::p_physical_line>;
};
template <> struct describe_field_t<Sg_File_Info,unsigned int,&Sg_File_Info::p_source_sequence_number> {
  using parent = Sg_File_Info;
  using field_type = unsigned int;
  static constexpr size_t position{6};
  static constexpr char const * const name{"source_sequence_number"};
  static constexpr char const * const typestr{"unsigned int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&Sg_File_Info::p_source_sequence_number};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<Sg_File_Info, unsigned int Sg_File_Info::*, &Sg_File_Info::p_source_sequence_number>;
};
template <> struct describe_field_t<Sg_File_Info,SgFileIdList,&Sg_File_Info::p_fileIDsToUnparse> {
  using parent = Sg_File_Info;
  using field_type = SgFileIdList;
  static constexpr size_t position{7};
  static constexpr char const * const name{"fileIDsToUnparse"};
  static constexpr char const * const typestr{"SgFileIdList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&Sg_File_Info::p_fileIDsToUnparse};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<Sg_File_Info, SgFileIdList Sg_File_Info::*, &Sg_File_Info::p_fileIDsToUnparse>;
};
template <> struct describe_field_t<Sg_File_Info,SgFileLineNumberList,&Sg_File_Info::p_fileLineNumbersToUnparse> {
  using parent = Sg_File_Info;
  using field_type = SgFileLineNumberList;
  static constexpr size_t position{8};
  static constexpr char const * const name{"fileLineNumbersToUnparse"};
  static constexpr char const * const typestr{"SgFileLineNumberList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&Sg_File_Info::p_fileLineNumbersToUnparse};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<Sg_File_Info, SgFileLineNumberList Sg_File_Info::*, &Sg_File_Info::p_fileLineNumbersToUnparse>;
};
template <> struct describe_node_t<Sg_File_Info> {
  using node = Sg_File_Info;
  using base = SgSupport;
  static constexpr char const * const name{"_File_Info"};
  static constexpr unsigned long variant{854};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_file_id>, describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_line>, describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_col>, describe_field_t<Sg_File_Info,unsigned int,&Sg_File_Info::p_classificationBitField>, describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_physical_file_id>, describe_field_t<Sg_File_Info,int,&Sg_File_Info::p_physical_line>, describe_field_t<Sg_File_Info,unsigned int,&Sg_File_Info::p_source_sequence_number>, describe_field_t<Sg_File_Info,SgFileIdList,&Sg_File_Info::p_fileIDsToUnparse>, describe_field_t<Sg_File_Info,SgFileLineNumberList,&Sg_File_Info::p_fileLineNumbersToUnparse>>;
};
template <> struct node_from_variant_t<854> { using type = Sg_File_Info; };

// Class: TypeCAFTeam
template <> struct describe_node_t<SgTypeCAFTeam> {
  using node = SgTypeCAFTeam;
  using base = SgType;
  static constexpr char const * const name{"TypeCAFTeam"};
  static constexpr unsigned long variant{855};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<855> { using type = SgTypeCAFTeam; };

// Class: CAFWithTeamStatement
template <> struct describe_field_t<SgCAFWithTeamStatement,SgVarRefExp*,&SgCAFWithTeamStatement::p_teamId> {
  using parent = SgCAFWithTeamStatement;
  using field_type = SgVarRefExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"teamId"};
  static constexpr char const * const typestr{"SgVarRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCAFWithTeamStatement::p_teamId};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCAFWithTeamStatement, SgVarRefExp* SgCAFWithTeamStatement::*, &SgCAFWithTeamStatement::p_teamId>;
};
template <> struct describe_field_t<SgCAFWithTeamStatement,SgBasicBlock*,&SgCAFWithTeamStatement::p_body> {
  using parent = SgCAFWithTeamStatement;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCAFWithTeamStatement::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCAFWithTeamStatement, SgBasicBlock* SgCAFWithTeamStatement::*, &SgCAFWithTeamStatement::p_body>;
};
template <> struct describe_field_t<SgCAFWithTeamStatement,bool,&SgCAFWithTeamStatement::p_endHasTeamId> {
  using parent = SgCAFWithTeamStatement;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"endHasTeamId"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCAFWithTeamStatement::p_endHasTeamId};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCAFWithTeamStatement, bool SgCAFWithTeamStatement::*, &SgCAFWithTeamStatement::p_endHasTeamId>;
};
template <> struct describe_node_t<SgCAFWithTeamStatement> {
  using node = SgCAFWithTeamStatement;
  using base = SgScopeStatement;
  static constexpr char const * const name{"CAFWithTeamStatement"};
  static constexpr unsigned long variant{856};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCAFWithTeamStatement,SgVarRefExp*,&SgCAFWithTeamStatement::p_teamId>, describe_field_t<SgCAFWithTeamStatement,SgBasicBlock*,&SgCAFWithTeamStatement::p_body>, describe_field_t<SgCAFWithTeamStatement,bool,&SgCAFWithTeamStatement::p_endHasTeamId>>;
};
template <> struct node_from_variant_t<856> { using type = SgCAFWithTeamStatement; };

// Class: CAFCoExpression
template <> struct describe_field_t<SgCAFCoExpression,SgVarRefExp*,&SgCAFCoExpression::p_teamId> {
  using parent = SgCAFCoExpression;
  using field_type = SgVarRefExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"teamId"};
  static constexpr char const * const typestr{"SgVarRefExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCAFCoExpression::p_teamId};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCAFCoExpression, SgVarRefExp* SgCAFCoExpression::*, &SgCAFCoExpression::p_teamId>;
};
template <> struct describe_field_t<SgCAFCoExpression,SgExpression*,&SgCAFCoExpression::p_teamRank> {
  using parent = SgCAFCoExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"teamRank"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCAFCoExpression::p_teamRank};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCAFCoExpression, SgExpression* SgCAFCoExpression::*, &SgCAFCoExpression::p_teamRank>;
};
template <> struct describe_field_t<SgCAFCoExpression,SgExpression*,&SgCAFCoExpression::p_referData> {
  using parent = SgCAFCoExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"referData"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCAFCoExpression::p_referData};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCAFCoExpression, SgExpression* SgCAFCoExpression::*, &SgCAFCoExpression::p_referData>;
};
template <> struct describe_node_t<SgCAFCoExpression> {
  using node = SgCAFCoExpression;
  using base = SgExpression;
  static constexpr char const * const name{"CAFCoExpression"};
  static constexpr unsigned long variant{857};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgCAFCoExpression,SgVarRefExp*,&SgCAFCoExpression::p_teamId>, describe_field_t<SgCAFCoExpression,SgExpression*,&SgCAFCoExpression::p_teamRank>, describe_field_t<SgCAFCoExpression,SgExpression*,&SgCAFCoExpression::p_referData>>;
};
template <> struct node_from_variant_t<857> { using type = SgCAFCoExpression; };

// Class: CallExpression
template <> struct describe_field_t<SgCallExpression,SgExpression*,&SgCallExpression::p_function> {
  using parent = SgCallExpression;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"function"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCallExpression::p_function};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCallExpression, SgExpression* SgCallExpression::*, &SgCallExpression::p_function>;
};
template <> struct describe_field_t<SgCallExpression,SgExprListExp*,&SgCallExpression::p_args> {
  using parent = SgCallExpression;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"args"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgCallExpression::p_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCallExpression, SgExprListExp* SgCallExpression::*, &SgCallExpression::p_args>;
};
template <> struct describe_field_t<SgCallExpression,SgType*,&SgCallExpression::p_expression_type> {
  using parent = SgCallExpression;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgCallExpression::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgCallExpression, SgType* SgCallExpression::*, &SgCallExpression::p_expression_type>;
};
template <> struct describe_node_t<SgCallExpression> {
  using node = SgCallExpression;
  using base = SgExpression;
  static constexpr char const * const name{"CallExpression"};
  static constexpr unsigned long variant{858};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgFunctionCallExp>;
  using fields_t = mp::List<describe_field_t<SgCallExpression,SgExpression*,&SgCallExpression::p_function>, describe_field_t<SgCallExpression,SgExprListExp*,&SgCallExpression::p_args>, describe_field_t<SgCallExpression,SgType*,&SgCallExpression::p_expression_type>>;
};
template <> struct node_from_variant_t<858> { using type = SgCallExpression; };

// Class: TypeCrayPointer
template <> struct describe_node_t<SgTypeCrayPointer> {
  using node = SgTypeCrayPointer;
  using base = SgType;
  static constexpr char const * const name{"TypeCrayPointer"};
  static constexpr unsigned long variant{859};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<859> { using type = SgTypeCrayPointer; };

// Class: JavaImportStatement
template <> struct describe_field_t<SgJavaImportStatement,SgName,&SgJavaImportStatement::p_path> {
  using parent = SgJavaImportStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"path"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaImportStatement::p_path};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaImportStatement, SgName SgJavaImportStatement::*, &SgJavaImportStatement::p_path>;
};
template <> struct describe_field_t<SgJavaImportStatement,bool,&SgJavaImportStatement::p_containsWildCard> {
  using parent = SgJavaImportStatement;
  using field_type = bool;
  static constexpr size_t position{1};
  static constexpr char const * const name{"containsWildCard"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaImportStatement::p_containsWildCard};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaImportStatement, bool SgJavaImportStatement::*, &SgJavaImportStatement::p_containsWildCard>;
};
template <> struct describe_node_t<SgJavaImportStatement> {
  using node = SgJavaImportStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"JavaImportStatement"};
  static constexpr unsigned long variant{860};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaImportStatement,SgName,&SgJavaImportStatement::p_path>, describe_field_t<SgJavaImportStatement,bool,&SgJavaImportStatement::p_containsWildCard>>;
};
template <> struct node_from_variant_t<860> { using type = SgJavaImportStatement; };

// Class: JavaPackageDeclaration
template <> struct describe_node_t<SgJavaPackageDeclaration> {
  using node = SgJavaPackageDeclaration;
  using base = SgClassDeclaration;
  static constexpr char const * const name{"JavaPackageDeclaration"};
  static constexpr unsigned long variant{861};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<861> { using type = SgJavaPackageDeclaration; };

// Class: JavaPackageStatement
template <> struct describe_field_t<SgJavaPackageStatement,SgName,&SgJavaPackageStatement::p_name> {
  using parent = SgJavaPackageStatement;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaPackageStatement::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaPackageStatement, SgName SgJavaPackageStatement::*, &SgJavaPackageStatement::p_name>;
};
template <> struct describe_node_t<SgJavaPackageStatement> {
  using node = SgJavaPackageStatement;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"JavaPackageStatement"};
  static constexpr unsigned long variant{862};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaPackageStatement,SgName,&SgJavaPackageStatement::p_name>>;
};
template <> struct node_from_variant_t<862> { using type = SgJavaPackageStatement; };

// Class: JavaImportStatementList
template <> struct describe_field_t<SgJavaImportStatementList,SgJavaImportStatementPtrList,&SgJavaImportStatementList::p_java_import_list> {
  using parent = SgJavaImportStatementList;
  using field_type = SgJavaImportStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"java_import_list"};
  static constexpr char const * const typestr{"SgJavaImportStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaImportStatementList::p_java_import_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaImportStatementList, SgJavaImportStatementPtrList SgJavaImportStatementList::*, &SgJavaImportStatementList::p_java_import_list>;
};
template <> struct describe_node_t<SgJavaImportStatementList> {
  using node = SgJavaImportStatementList;
  using base = SgSupport;
  static constexpr char const * const name{"JavaImportStatementList"};
  static constexpr unsigned long variant{863};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaImportStatementList,SgJavaImportStatementPtrList,&SgJavaImportStatementList::p_java_import_list>>;
};
template <> struct node_from_variant_t<863> { using type = SgJavaImportStatementList; };

// Class: JavaClassDeclarationList
template <> struct describe_field_t<SgJavaClassDeclarationList,SgClassDeclarationPtrList,&SgJavaClassDeclarationList::p_java_class_list> {
  using parent = SgJavaClassDeclarationList;
  using field_type = SgClassDeclarationPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"java_class_list"};
  static constexpr char const * const typestr{"SgClassDeclarationPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaClassDeclarationList::p_java_class_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaClassDeclarationList, SgClassDeclarationPtrList SgJavaClassDeclarationList::*, &SgJavaClassDeclarationList::p_java_class_list>;
};
template <> struct describe_node_t<SgJavaClassDeclarationList> {
  using node = SgJavaClassDeclarationList;
  using base = SgSupport;
  static constexpr char const * const name{"JavaClassDeclarationList"};
  static constexpr unsigned long variant{864};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaClassDeclarationList,SgClassDeclarationPtrList,&SgJavaClassDeclarationList::p_java_class_list>>;
};
template <> struct node_from_variant_t<864> { using type = SgJavaClassDeclarationList; };

// Class: JavaMemberValuePair
template <> struct describe_field_t<SgJavaMemberValuePair,SgName,&SgJavaMemberValuePair::p_name> {
  using parent = SgJavaMemberValuePair;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaMemberValuePair::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaMemberValuePair, SgName SgJavaMemberValuePair::*, &SgJavaMemberValuePair::p_name>;
};
template <> struct describe_field_t<SgJavaMemberValuePair,SgExpression*,&SgJavaMemberValuePair::p_value> {
  using parent = SgJavaMemberValuePair;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaMemberValuePair::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaMemberValuePair, SgExpression* SgJavaMemberValuePair::*, &SgJavaMemberValuePair::p_value>;
};
template <> struct describe_node_t<SgJavaMemberValuePair> {
  using node = SgJavaMemberValuePair;
  using base = SgLocatedNodeSupport;
  static constexpr char const * const name{"JavaMemberValuePair"};
  static constexpr unsigned long variant{865};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaMemberValuePair,SgName,&SgJavaMemberValuePair::p_name>, describe_field_t<SgJavaMemberValuePair,SgExpression*,&SgJavaMemberValuePair::p_value>>;
};
template <> struct node_from_variant_t<865> { using type = SgJavaMemberValuePair; };

// Class: JavaAnnotation
template <> struct describe_field_t<SgJavaAnnotation,SgType*,&SgJavaAnnotation::p_expression_type> {
  using parent = SgJavaAnnotation;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaAnnotation::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaAnnotation, SgType* SgJavaAnnotation::*, &SgJavaAnnotation::p_expression_type>;
};
template <> struct describe_node_t<SgJavaAnnotation> {
  using node = SgJavaAnnotation;
  using base = SgExpression;
  static constexpr char const * const name{"JavaAnnotation"};
  static constexpr unsigned long variant{866};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgJavaMarkerAnnotation, SgJavaSingleMemberAnnotation, SgJavaNormalAnnotation>;
  using fields_t = mp::List<describe_field_t<SgJavaAnnotation,SgType*,&SgJavaAnnotation::p_expression_type>>;
};
template <> struct node_from_variant_t<866> { using type = SgJavaAnnotation; };

// Class: JavaMarkerAnnotation
template <> struct describe_node_t<SgJavaMarkerAnnotation> {
  using node = SgJavaMarkerAnnotation;
  using base = SgJavaAnnotation;
  static constexpr char const * const name{"JavaMarkerAnnotation"};
  static constexpr unsigned long variant{867};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<867> { using type = SgJavaMarkerAnnotation; };

// Class: JavaSingleMemberAnnotation
template <> struct describe_field_t<SgJavaSingleMemberAnnotation,SgExpression*,&SgJavaSingleMemberAnnotation::p_value> {
  using parent = SgJavaSingleMemberAnnotation;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaSingleMemberAnnotation::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaSingleMemberAnnotation, SgExpression* SgJavaSingleMemberAnnotation::*, &SgJavaSingleMemberAnnotation::p_value>;
};
template <> struct describe_node_t<SgJavaSingleMemberAnnotation> {
  using node = SgJavaSingleMemberAnnotation;
  using base = SgJavaAnnotation;
  static constexpr char const * const name{"JavaSingleMemberAnnotation"};
  static constexpr unsigned long variant{868};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaSingleMemberAnnotation,SgExpression*,&SgJavaSingleMemberAnnotation::p_value>>;
};
template <> struct node_from_variant_t<868> { using type = SgJavaSingleMemberAnnotation; };

// Class: JavaNormalAnnotation
template <> struct describe_field_t<SgJavaNormalAnnotation,SgJavaMemberValuePairPtrList,&SgJavaNormalAnnotation::p_value_pair_list> {
  using parent = SgJavaNormalAnnotation;
  using field_type = SgJavaMemberValuePairPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value_pair_list"};
  static constexpr char const * const typestr{"SgJavaMemberValuePairPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgJavaNormalAnnotation::p_value_pair_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaNormalAnnotation, SgJavaMemberValuePairPtrList SgJavaNormalAnnotation::*, &SgJavaNormalAnnotation::p_value_pair_list>;
};
template <> struct describe_node_t<SgJavaNormalAnnotation> {
  using node = SgJavaNormalAnnotation;
  using base = SgJavaAnnotation;
  static constexpr char const * const name{"JavaNormalAnnotation"};
  static constexpr unsigned long variant{869};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaNormalAnnotation,SgJavaMemberValuePairPtrList,&SgJavaNormalAnnotation::p_value_pair_list>>;
};
template <> struct node_from_variant_t<869> { using type = SgJavaNormalAnnotation; };

// Class: JavaTypeExpression
template <> struct describe_field_t<SgJavaTypeExpression,SgType*,&SgJavaTypeExpression::p_type> {
  using parent = SgJavaTypeExpression;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaTypeExpression::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaTypeExpression, SgType* SgJavaTypeExpression::*, &SgJavaTypeExpression::p_type>;
};
template <> struct describe_node_t<SgJavaTypeExpression> {
  using node = SgJavaTypeExpression;
  using base = SgExpression;
  static constexpr char const * const name{"JavaTypeExpression"};
  static constexpr unsigned long variant{870};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaTypeExpression,SgType*,&SgJavaTypeExpression::p_type>>;
};
template <> struct node_from_variant_t<870> { using type = SgJavaTypeExpression; };

// Class: JavaQualifiedType
template <> struct describe_field_t<SgJavaQualifiedType,SgNamedType *,&SgJavaQualifiedType::p_parent_type> {
  using parent = SgJavaQualifiedType;
  using field_type = SgNamedType *;
  static constexpr size_t position{0};
  static constexpr char const * const name{"parent_type"};
  static constexpr char const * const typestr{"SgNamedType *"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaQualifiedType::p_parent_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaQualifiedType, SgNamedType * SgJavaQualifiedType::*, &SgJavaQualifiedType::p_parent_type>;
};
template <> struct describe_field_t<SgJavaQualifiedType,SgNamedType *,&SgJavaQualifiedType::p_type> {
  using parent = SgJavaQualifiedType;
  using field_type = SgNamedType *;
  static constexpr size_t position{1};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgNamedType *"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaQualifiedType::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaQualifiedType, SgNamedType * SgJavaQualifiedType::*, &SgJavaQualifiedType::p_type>;
};
template <> struct describe_node_t<SgJavaQualifiedType> {
  using node = SgJavaQualifiedType;
  using base = SgNamedType;
  static constexpr char const * const name{"JavaQualifiedType"};
  static constexpr unsigned long variant{871};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaQualifiedType,SgNamedType *,&SgJavaQualifiedType::p_parent_type>, describe_field_t<SgJavaQualifiedType,SgNamedType *,&SgJavaQualifiedType::p_type>>;
};
template <> struct node_from_variant_t<871> { using type = SgJavaQualifiedType; };

// Class: ClassExp
template <> struct describe_field_t<SgClassExp,SgClassSymbol*,&SgClassExp::p_class_symbol> {
  using parent = SgClassExp;
  using field_type = SgClassSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"class_symbol"};
  static constexpr char const * const typestr{"SgClassSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassExp::p_class_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassExp, SgClassSymbol* SgClassExp::*, &SgClassExp::p_class_symbol>;
};
template <> struct describe_field_t<SgClassExp,int,&SgClassExp::p_pobj_class> {
  using parent = SgClassExp;
  using field_type = int;
  static constexpr size_t position{1};
  static constexpr char const * const name{"pobj_class"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgClassExp::p_pobj_class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgClassExp, int SgClassExp::*, &SgClassExp::p_pobj_class>;
};
template <> struct describe_node_t<SgClassExp> {
  using node = SgClassExp;
  using base = SgExpression;
  static constexpr char const * const name{"ClassExp"};
  static constexpr unsigned long variant{872};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgClassExp,SgClassSymbol*,&SgClassExp::p_class_symbol>, describe_field_t<SgClassExp,int,&SgClassExp::p_pobj_class>>;
};
template <> struct node_from_variant_t<872> { using type = SgClassExp; };

// Class: JavaUnionType
template <> struct describe_field_t<SgJavaUnionType,SgTypePtrList,&SgJavaUnionType::p_type_list> {
  using parent = SgJavaUnionType;
  using field_type = SgTypePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"type_list"};
  static constexpr char const * const typestr{"SgTypePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJavaUnionType::p_type_list};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJavaUnionType, SgTypePtrList SgJavaUnionType::*, &SgJavaUnionType::p_type_list>;
};
template <> struct describe_node_t<SgJavaUnionType> {
  using node = SgJavaUnionType;
  using base = SgType;
  static constexpr char const * const name{"JavaUnionType"};
  static constexpr unsigned long variant{873};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJavaUnionType,SgTypePtrList,&SgJavaUnionType::p_type_list>>;
};
template <> struct node_from_variant_t<873> { using type = SgJavaUnionType; };

// Class: JavaParameterType
template <> struct describe_node_t<SgJavaParameterType> {
  using node = SgJavaParameterType;
  using base = SgClassType;
  static constexpr char const * const name{"JavaParameterType"};
  static constexpr unsigned long variant{874};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<874> { using type = SgJavaParameterType; };

// Class: AsyncStmt
template <> struct describe_field_t<SgAsyncStmt,SgStatement*,&SgAsyncStmt::p_body> {
  using parent = SgAsyncStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsyncStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsyncStmt, SgStatement* SgAsyncStmt::*, &SgAsyncStmt::p_body>;
};
template <> struct describe_node_t<SgAsyncStmt> {
  using node = SgAsyncStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AsyncStmt"};
  static constexpr unsigned long variant{875};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsyncStmt,SgStatement*,&SgAsyncStmt::p_body>>;
};
template <> struct node_from_variant_t<875> { using type = SgAsyncStmt; };

// Class: FinishStmt
template <> struct describe_field_t<SgFinishStmt,SgStatement*,&SgFinishStmt::p_body> {
  using parent = SgFinishStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFinishStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFinishStmt, SgStatement* SgFinishStmt::*, &SgFinishStmt::p_body>;
};
template <> struct describe_node_t<SgFinishStmt> {
  using node = SgFinishStmt;
  using base = SgStatement;
  static constexpr char const * const name{"FinishStmt"};
  static constexpr unsigned long variant{876};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFinishStmt,SgStatement*,&SgFinishStmt::p_body>>;
};
template <> struct node_from_variant_t<876> { using type = SgFinishStmt; };

// Class: AtStmt
template <> struct describe_field_t<SgAtStmt,SgExpression*,&SgAtStmt::p_expression> {
  using parent = SgAtStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAtStmt::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAtStmt, SgExpression* SgAtStmt::*, &SgAtStmt::p_expression>;
};
template <> struct describe_field_t<SgAtStmt,SgStatement*,&SgAtStmt::p_body> {
  using parent = SgAtStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAtStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAtStmt, SgStatement* SgAtStmt::*, &SgAtStmt::p_body>;
};
template <> struct describe_node_t<SgAtStmt> {
  using node = SgAtStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AtStmt"};
  static constexpr unsigned long variant{877};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAtStmt,SgExpression*,&SgAtStmt::p_expression>, describe_field_t<SgAtStmt,SgStatement*,&SgAtStmt::p_body>>;
};
template <> struct node_from_variant_t<877> { using type = SgAtStmt; };

// Class: AtomicStmt
template <> struct describe_field_t<SgAtomicStmt,SgStatement*,&SgAtomicStmt::p_body> {
  using parent = SgAtomicStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAtomicStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAtomicStmt, SgStatement* SgAtomicStmt::*, &SgAtomicStmt::p_body>;
};
template <> struct describe_node_t<SgAtomicStmt> {
  using node = SgAtomicStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AtomicStmt"};
  static constexpr unsigned long variant{878};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAtomicStmt,SgStatement*,&SgAtomicStmt::p_body>>;
};
template <> struct node_from_variant_t<878> { using type = SgAtomicStmt; };

// Class: WhenStmt
template <> struct describe_field_t<SgWhenStmt,SgExpression*,&SgWhenStmt::p_expression> {
  using parent = SgWhenStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWhenStmt::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhenStmt, SgExpression* SgWhenStmt::*, &SgWhenStmt::p_expression>;
};
template <> struct describe_field_t<SgWhenStmt,SgStatement*,&SgWhenStmt::p_body> {
  using parent = SgWhenStmt;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgWhenStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgWhenStmt, SgStatement* SgWhenStmt::*, &SgWhenStmt::p_body>;
};
template <> struct describe_node_t<SgWhenStmt> {
  using node = SgWhenStmt;
  using base = SgStatement;
  static constexpr char const * const name{"WhenStmt"};
  static constexpr unsigned long variant{880};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgWhenStmt,SgExpression*,&SgWhenStmt::p_expression>, describe_field_t<SgWhenStmt,SgStatement*,&SgWhenStmt::p_body>>;
};
template <> struct node_from_variant_t<880> { using type = SgWhenStmt; };

// Class: AtExp
template <> struct describe_field_t<SgAtExp,SgExpression*,&SgAtExp::p_expression> {
  using parent = SgAtExp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAtExp::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAtExp, SgExpression* SgAtExp::*, &SgAtExp::p_expression>;
};
template <> struct describe_field_t<SgAtExp,SgStatement*,&SgAtExp::p_body> {
  using parent = SgAtExp;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAtExp::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAtExp, SgStatement* SgAtExp::*, &SgAtExp::p_body>;
};
template <> struct describe_node_t<SgAtExp> {
  using node = SgAtExp;
  using base = SgExpression;
  static constexpr char const * const name{"AtExp"};
  static constexpr unsigned long variant{881};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAtExp,SgExpression*,&SgAtExp::p_expression>, describe_field_t<SgAtExp,SgStatement*,&SgAtExp::p_body>>;
};
template <> struct node_from_variant_t<881> { using type = SgAtExp; };

// Class: FinishExp
template <> struct describe_field_t<SgFinishExp,SgExpression*,&SgFinishExp::p_expression> {
  using parent = SgFinishExp;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFinishExp::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFinishExp, SgExpression* SgFinishExp::*, &SgFinishExp::p_expression>;
};
template <> struct describe_field_t<SgFinishExp,SgStatement*,&SgFinishExp::p_body> {
  using parent = SgFinishExp;
  using field_type = SgStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgFinishExp::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgFinishExp, SgStatement* SgFinishExp::*, &SgFinishExp::p_body>;
};
template <> struct describe_node_t<SgFinishExp> {
  using node = SgFinishExp;
  using base = SgExpression;
  static constexpr char const * const name{"FinishExp"};
  static constexpr unsigned long variant{882};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgFinishExp,SgExpression*,&SgFinishExp::p_expression>, describe_field_t<SgFinishExp,SgStatement*,&SgFinishExp::p_body>>;
};
template <> struct node_from_variant_t<882> { using type = SgFinishExp; };

// Class: HereExp
template <> struct describe_field_t<SgHereExp,SgType*,&SgHereExp::p_expression_type> {
  using parent = SgHereExp;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"expression_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgHereExp::p_expression_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgHereExp, SgType* SgHereExp::*, &SgHereExp::p_expression_type>;
};
template <> struct describe_field_t<SgHereExp,SgExpression*,&SgHereExp::p_expression> {
  using parent = SgHereExp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"expression"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgHereExp::p_expression};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgHereExp, SgExpression* SgHereExp::*, &SgHereExp::p_expression>;
};
template <> struct describe_node_t<SgHereExp> {
  using node = SgHereExp;
  using base = SgExpression;
  static constexpr char const * const name{"HereExp"};
  static constexpr unsigned long variant{883};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgHereExp,SgType*,&SgHereExp::p_expression_type>, describe_field_t<SgHereExp,SgExpression*,&SgHereExp::p_expression>>;
};
template <> struct node_from_variant_t<883> { using type = SgHereExp; };

// Class: DotDotExp
template <> struct describe_node_t<SgDotDotExp> {
  using node = SgDotDotExp;
  using base = SgBinaryOp;
  static constexpr char const * const name{"DotDotExp"};
  static constexpr unsigned long variant{884};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<884> { using type = SgDotDotExp; };

// Class: AsmNullInstruction
template <> struct describe_node_t<SgAsmNullInstruction> {
  using node = SgAsmNullInstruction;
  using base = SgAsmInstruction;
  static constexpr char const * const name{"AsmNullInstruction"};
  static constexpr unsigned long variant{885};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<885> { using type = SgAsmNullInstruction; };

// Class: AdaComponentClause
template <> struct describe_field_t<SgAdaComponentClause,SgVarRefExp*,&SgAdaComponentClause::p_component> {
  using parent = SgAdaComponentClause;
  using field_type = SgVarRefExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"component"};
  static constexpr char const * const typestr{"SgVarRefExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaComponentClause::p_component};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaComponentClause, SgVarRefExp* SgAdaComponentClause::*, &SgAdaComponentClause::p_component>;
};
template <> struct describe_field_t<SgAdaComponentClause,SgExpression*,&SgAdaComponentClause::p_offset> {
  using parent = SgAdaComponentClause;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"offset"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaComponentClause::p_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaComponentClause, SgExpression* SgAdaComponentClause::*, &SgAdaComponentClause::p_offset>;
};
template <> struct describe_field_t<SgAdaComponentClause,SgRangeExp*,&SgAdaComponentClause::p_range> {
  using parent = SgAdaComponentClause;
  using field_type = SgRangeExp*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"range"};
  static constexpr char const * const typestr{"SgRangeExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaComponentClause::p_range};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaComponentClause, SgRangeExp* SgAdaComponentClause::*, &SgAdaComponentClause::p_range>;
};
template <> struct describe_node_t<SgAdaComponentClause> {
  using node = SgAdaComponentClause;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaComponentClause"};
  static constexpr unsigned long variant{886};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaComponentClause,SgVarRefExp*,&SgAdaComponentClause::p_component>, describe_field_t<SgAdaComponentClause,SgExpression*,&SgAdaComponentClause::p_offset>, describe_field_t<SgAdaComponentClause,SgRangeExp*,&SgAdaComponentClause::p_range>>;
};
template <> struct node_from_variant_t<886> { using type = SgAdaComponentClause; };

// Class: AdaIndexConstraint
template <> struct describe_field_t<SgAdaIndexConstraint,SgExpressionPtrList,&SgAdaIndexConstraint::p_indexRanges> {
  using parent = SgAdaIndexConstraint;
  using field_type = SgExpressionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"indexRanges"};
  static constexpr char const * const typestr{"SgExpressionPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaIndexConstraint::p_indexRanges};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaIndexConstraint, SgExpressionPtrList SgAdaIndexConstraint::*, &SgAdaIndexConstraint::p_indexRanges>;
};
template <> struct describe_node_t<SgAdaIndexConstraint> {
  using node = SgAdaIndexConstraint;
  using base = SgAdaTypeConstraint;
  static constexpr char const * const name{"AdaIndexConstraint"};
  static constexpr unsigned long variant{887};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaIndexConstraint,SgExpressionPtrList,&SgAdaIndexConstraint::p_indexRanges>>;
};
template <> struct node_from_variant_t<887> { using type = SgAdaIndexConstraint; };

// Class: AdaModularType
template <> struct describe_field_t<SgAdaModularType,SgExpression*,&SgAdaModularType::p_modexpr> {
  using parent = SgAdaModularType;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"modexpr"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaModularType::p_modexpr};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaModularType, SgExpression* SgAdaModularType::*, &SgAdaModularType::p_modexpr>;
};
template <> struct describe_node_t<SgAdaModularType> {
  using node = SgAdaModularType;
  using base = SgType;
  static constexpr char const * const name{"AdaModularType"};
  static constexpr unsigned long variant{888};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaModularType,SgExpression*,&SgAdaModularType::p_modexpr>>;
};
template <> struct node_from_variant_t<888> { using type = SgAdaModularType; };

// Class: AdaRepresentationClause
template <> struct describe_field_t<SgAdaRepresentationClause,SgType*,&SgAdaRepresentationClause::p_recordType> {
  using parent = SgAdaRepresentationClause;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"recordType"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaRepresentationClause::p_recordType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaRepresentationClause, SgType* SgAdaRepresentationClause::*, &SgAdaRepresentationClause::p_recordType>;
};
template <> struct describe_field_t<SgAdaRepresentationClause,SgExpression*,&SgAdaRepresentationClause::p_alignment> {
  using parent = SgAdaRepresentationClause;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"alignment"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaRepresentationClause::p_alignment};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaRepresentationClause, SgExpression* SgAdaRepresentationClause::*, &SgAdaRepresentationClause::p_alignment>;
};
template <> struct describe_field_t<SgAdaRepresentationClause,SgBasicBlock*,&SgAdaRepresentationClause::p_components> {
  using parent = SgAdaRepresentationClause;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"components"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaRepresentationClause::p_components};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaRepresentationClause, SgBasicBlock* SgAdaRepresentationClause::*, &SgAdaRepresentationClause::p_components>;
};
template <> struct describe_node_t<SgAdaRepresentationClause> {
  using node = SgAdaRepresentationClause;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaRepresentationClause"};
  static constexpr unsigned long variant{889};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaRepresentationClause,SgType*,&SgAdaRepresentationClause::p_recordType>, describe_field_t<SgAdaRepresentationClause,SgExpression*,&SgAdaRepresentationClause::p_alignment>, describe_field_t<SgAdaRepresentationClause,SgBasicBlock*,&SgAdaRepresentationClause::p_components>>;
};
template <> struct node_from_variant_t<889> { using type = SgAdaRepresentationClause; };

// Class: AdaFunctionRenamingDecl
template <> struct describe_field_t<SgAdaFunctionRenamingDecl,SgExpression*,&SgAdaFunctionRenamingDecl::p_renamed_function> {
  using parent = SgAdaFunctionRenamingDecl;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"renamed_function"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaFunctionRenamingDecl::p_renamed_function};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFunctionRenamingDecl, SgExpression* SgAdaFunctionRenamingDecl::*, &SgAdaFunctionRenamingDecl::p_renamed_function>;
};
template <> struct describe_node_t<SgAdaFunctionRenamingDecl> {
  using node = SgAdaFunctionRenamingDecl;
  using base = SgFunctionDeclaration;
  static constexpr char const * const name{"AdaFunctionRenamingDecl"};
  static constexpr unsigned long variant{890};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaFunctionRenamingDecl,SgExpression*,&SgAdaFunctionRenamingDecl::p_renamed_function>>;
};
template <> struct node_from_variant_t<890> { using type = SgAdaFunctionRenamingDecl; };

// Class: AdaSelectStmt
template <> struct describe_field_t<SgAdaSelectStmt,SgAdaSelectAlternativeStmt*,&SgAdaSelectStmt::p_select_path> {
  using parent = SgAdaSelectStmt;
  using field_type = SgAdaSelectAlternativeStmt*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"select_path"};
  static constexpr char const * const typestr{"SgAdaSelectAlternativeStmt*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSelectStmt::p_select_path};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSelectStmt, SgAdaSelectAlternativeStmt* SgAdaSelectStmt::*, &SgAdaSelectStmt::p_select_path>;
};
template <> struct describe_field_t<SgAdaSelectStmt,SgAdaSelectAlternativeStmt*,&SgAdaSelectStmt::p_or_path> {
  using parent = SgAdaSelectStmt;
  using field_type = SgAdaSelectAlternativeStmt*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"or_path"};
  static constexpr char const * const typestr{"SgAdaSelectAlternativeStmt*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSelectStmt::p_or_path};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSelectStmt, SgAdaSelectAlternativeStmt* SgAdaSelectStmt::*, &SgAdaSelectStmt::p_or_path>;
};
template <> struct describe_field_t<SgAdaSelectStmt,SgBasicBlock*,&SgAdaSelectStmt::p_else_path> {
  using parent = SgAdaSelectStmt;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"else_path"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSelectStmt::p_else_path};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSelectStmt, SgBasicBlock* SgAdaSelectStmt::*, &SgAdaSelectStmt::p_else_path>;
};
template <> struct describe_field_t<SgAdaSelectStmt,SgBasicBlock*,&SgAdaSelectStmt::p_abort_path> {
  using parent = SgAdaSelectStmt;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"abort_path"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSelectStmt::p_abort_path};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSelectStmt, SgBasicBlock* SgAdaSelectStmt::*, &SgAdaSelectStmt::p_abort_path>;
};
template <> struct describe_field_t<SgAdaSelectStmt,SgAdaSelectStmt::select_type_enum,&SgAdaSelectStmt::p_select_type> {
  using parent = SgAdaSelectStmt;
  using field_type = SgAdaSelectStmt::select_type_enum;
  static constexpr size_t position{4};
  static constexpr char const * const name{"select_type"};
  static constexpr char const * const typestr{"SgAdaSelectStmt::select_type_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaSelectStmt::p_select_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSelectStmt, SgAdaSelectStmt::select_type_enum SgAdaSelectStmt::*, &SgAdaSelectStmt::p_select_type>;
};
template <> struct describe_node_t<SgAdaSelectStmt> {
  using node = SgAdaSelectStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AdaSelectStmt"};
  static constexpr unsigned long variant{891};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaSelectStmt,SgAdaSelectAlternativeStmt*,&SgAdaSelectStmt::p_select_path>, describe_field_t<SgAdaSelectStmt,SgAdaSelectAlternativeStmt*,&SgAdaSelectStmt::p_or_path>, describe_field_t<SgAdaSelectStmt,SgBasicBlock*,&SgAdaSelectStmt::p_else_path>, describe_field_t<SgAdaSelectStmt,SgBasicBlock*,&SgAdaSelectStmt::p_abort_path>, describe_field_t<SgAdaSelectStmt,SgAdaSelectStmt::select_type_enum,&SgAdaSelectStmt::p_select_type>>;
};
template <> struct node_from_variant_t<891> { using type = SgAdaSelectStmt; };

// Class: AdaSelectAlternativeStmt
template <> struct describe_field_t<SgAdaSelectAlternativeStmt,SgBasicBlock*,&SgAdaSelectAlternativeStmt::p_body> {
  using parent = SgAdaSelectAlternativeStmt;
  using field_type = SgBasicBlock*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgBasicBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSelectAlternativeStmt::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSelectAlternativeStmt, SgBasicBlock* SgAdaSelectAlternativeStmt::*, &SgAdaSelectAlternativeStmt::p_body>;
};
template <> struct describe_field_t<SgAdaSelectAlternativeStmt,SgExpression*,&SgAdaSelectAlternativeStmt::p_guard> {
  using parent = SgAdaSelectAlternativeStmt;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"guard"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSelectAlternativeStmt::p_guard};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSelectAlternativeStmt, SgExpression* SgAdaSelectAlternativeStmt::*, &SgAdaSelectAlternativeStmt::p_guard>;
};
template <> struct describe_field_t<SgAdaSelectAlternativeStmt,SgAdaSelectAlternativeStmt*,&SgAdaSelectAlternativeStmt::p_next> {
  using parent = SgAdaSelectAlternativeStmt;
  using field_type = SgAdaSelectAlternativeStmt*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"next"};
  static constexpr char const * const typestr{"SgAdaSelectAlternativeStmt*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSelectAlternativeStmt::p_next};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSelectAlternativeStmt, SgAdaSelectAlternativeStmt* SgAdaSelectAlternativeStmt::*, &SgAdaSelectAlternativeStmt::p_next>;
};
template <> struct describe_node_t<SgAdaSelectAlternativeStmt> {
  using node = SgAdaSelectAlternativeStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AdaSelectAlternativeStmt"};
  static constexpr unsigned long variant{892};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaSelectAlternativeStmt,SgBasicBlock*,&SgAdaSelectAlternativeStmt::p_body>, describe_field_t<SgAdaSelectAlternativeStmt,SgExpression*,&SgAdaSelectAlternativeStmt::p_guard>, describe_field_t<SgAdaSelectAlternativeStmt,SgAdaSelectAlternativeStmt*,&SgAdaSelectAlternativeStmt::p_next>>;
};
template <> struct node_from_variant_t<892> { using type = SgAdaSelectAlternativeStmt; };

// Class: AdaTerminateStmt
template <> struct describe_node_t<SgAdaTerminateStmt> {
  using node = SgAdaTerminateStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AdaTerminateStmt"};
  static constexpr unsigned long variant{893};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<893> { using type = SgAdaTerminateStmt; };

// Class: AsmAarch32Coprocessor
template <> struct describe_node_t<SgAsmAarch32Coprocessor> {
  using node = SgAsmAarch32Coprocessor;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmAarch32Coprocessor"};
  static constexpr unsigned long variant{895};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<895> { using type = SgAsmAarch32Coprocessor; };

// Class: AdaAttributeClause
template <> struct describe_field_t<SgAdaAttributeClause,SgAdaAttributeExp*,&SgAdaAttributeClause::p_attribute> {
  using parent = SgAdaAttributeClause;
  using field_type = SgAdaAttributeExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"attribute"};
  static constexpr char const * const typestr{"SgAdaAttributeExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAttributeClause::p_attribute};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAttributeClause, SgAdaAttributeExp* SgAdaAttributeClause::*, &SgAdaAttributeClause::p_attribute>;
};
template <> struct describe_field_t<SgAdaAttributeClause,SgExpression*,&SgAdaAttributeClause::p_size> {
  using parent = SgAdaAttributeClause;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"size"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAttributeClause::p_size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAttributeClause, SgExpression* SgAdaAttributeClause::*, &SgAdaAttributeClause::p_size>;
};
template <> struct describe_node_t<SgAdaAttributeClause> {
  using node = SgAdaAttributeClause;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaAttributeClause"};
  static constexpr unsigned long variant{896};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaAttributeClause,SgAdaAttributeExp*,&SgAdaAttributeClause::p_attribute>, describe_field_t<SgAdaAttributeClause,SgExpression*,&SgAdaAttributeClause::p_size>>;
};
template <> struct node_from_variant_t<896> { using type = SgAdaAttributeClause; };

// Class: AsmBinaryConcat
template <> struct describe_node_t<SgAsmBinaryConcat> {
  using node = SgAsmBinaryConcat;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryConcat"};
  static constexpr unsigned long variant{897};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<897> { using type = SgAsmBinaryConcat; };

// Class: AsmByteOrder
template <> struct describe_node_t<SgAsmByteOrder> {
  using node = SgAsmByteOrder;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmByteOrder"};
  static constexpr unsigned long variant{898};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<898> { using type = SgAsmByteOrder; };

// Class: AdaDerivedType
template <> struct describe_field_t<SgAdaDerivedType,SgType*,&SgAdaDerivedType::p_base_type> {
  using parent = SgAdaDerivedType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaDerivedType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDerivedType, SgType* SgAdaDerivedType::*, &SgAdaDerivedType::p_base_type>;
};
template <> struct describe_node_t<SgAdaDerivedType> {
  using node = SgAdaDerivedType;
  using base = SgType;
  static constexpr char const * const name{"AdaDerivedType"};
  static constexpr unsigned long variant{899};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaDerivedType,SgType*,&SgAdaDerivedType::p_base_type>>;
};
template <> struct node_from_variant_t<899> { using type = SgAdaDerivedType; };

// Class: AdaAttributeExp
template <> struct describe_field_t<SgAdaAttributeExp,SgName,&SgAdaAttributeExp::p_attribute> {
  using parent = SgAdaAttributeExp;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"attribute"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaAttributeExp::p_attribute};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAttributeExp, SgName SgAdaAttributeExp::*, &SgAdaAttributeExp::p_attribute>;
};
template <> struct describe_field_t<SgAdaAttributeExp,SgExpression*,&SgAdaAttributeExp::p_object> {
  using parent = SgAdaAttributeExp;
  using field_type = SgExpression*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"object"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAttributeExp::p_object};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAttributeExp, SgExpression* SgAdaAttributeExp::*, &SgAdaAttributeExp::p_object>;
};
template <> struct describe_field_t<SgAdaAttributeExp,SgExprListExp*,&SgAdaAttributeExp::p_args> {
  using parent = SgAdaAttributeExp;
  using field_type = SgExprListExp*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"args"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAttributeExp::p_args};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAttributeExp, SgExprListExp* SgAdaAttributeExp::*, &SgAdaAttributeExp::p_args>;
};
template <> struct describe_field_t<SgAdaAttributeExp,SgType*,&SgAdaAttributeExp::p_attrType> {
  using parent = SgAdaAttributeExp;
  using field_type = SgType*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"attrType"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaAttributeExp::p_attrType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAttributeExp, SgType* SgAdaAttributeExp::*, &SgAdaAttributeExp::p_attrType>;
};
template <> struct describe_node_t<SgAdaAttributeExp> {
  using node = SgAdaAttributeExp;
  using base = SgExpression;
  static constexpr char const * const name{"AdaAttributeExp"};
  static constexpr unsigned long variant{900};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaAttributeExp,SgName,&SgAdaAttributeExp::p_attribute>, describe_field_t<SgAdaAttributeExp,SgExpression*,&SgAdaAttributeExp::p_object>, describe_field_t<SgAdaAttributeExp,SgExprListExp*,&SgAdaAttributeExp::p_args>, describe_field_t<SgAdaAttributeExp,SgType*,&SgAdaAttributeExp::p_attrType>>;
};
template <> struct node_from_variant_t<900> { using type = SgAdaAttributeExp; };

// Class: AdaEnumRepresentationClause
template <> struct describe_field_t<SgAdaEnumRepresentationClause,SgType*,&SgAdaEnumRepresentationClause::p_enumType> {
  using parent = SgAdaEnumRepresentationClause;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"enumType"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaEnumRepresentationClause::p_enumType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaEnumRepresentationClause, SgType* SgAdaEnumRepresentationClause::*, &SgAdaEnumRepresentationClause::p_enumType>;
};
template <> struct describe_field_t<SgAdaEnumRepresentationClause,SgExprListExp*,&SgAdaEnumRepresentationClause::p_components> {
  using parent = SgAdaEnumRepresentationClause;
  using field_type = SgExprListExp*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"components"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaEnumRepresentationClause::p_components};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaEnumRepresentationClause, SgExprListExp* SgAdaEnumRepresentationClause::*, &SgAdaEnumRepresentationClause::p_components>;
};
template <> struct describe_node_t<SgAdaEnumRepresentationClause> {
  using node = SgAdaEnumRepresentationClause;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaEnumRepresentationClause"};
  static constexpr unsigned long variant{901};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaEnumRepresentationClause,SgType*,&SgAdaEnumRepresentationClause::p_enumType>, describe_field_t<SgAdaEnumRepresentationClause,SgExprListExp*,&SgAdaEnumRepresentationClause::p_components>>;
};
template <> struct node_from_variant_t<901> { using type = SgAdaEnumRepresentationClause; };

// Class: AsmBinaryPreupdate
template <> struct describe_node_t<SgAsmBinaryPreupdate> {
  using node = SgAsmBinaryPreupdate;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryPreupdate"};
  static constexpr unsigned long variant{902};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<902> { using type = SgAsmBinaryPreupdate; };

// Class: AsmBinaryPostupdate
template <> struct describe_node_t<SgAsmBinaryPostupdate> {
  using node = SgAsmBinaryPostupdate;
  using base = SgAsmBinaryExpression;
  static constexpr char const * const name{"AsmBinaryPostupdate"};
  static constexpr unsigned long variant{903};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<903> { using type = SgAsmBinaryPostupdate; };

// Class: AdaOthersExp
template <> struct describe_node_t<SgAdaOthersExp> {
  using node = SgAdaOthersExp;
  using base = SgExpression;
  static constexpr char const * const name{"AdaOthersExp"};
  static constexpr unsigned long variant{904};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<904> { using type = SgAdaOthersExp; };

// Class: AdaRenamingSymbol
template <> struct describe_field_t<SgAdaRenamingSymbol,SgAdaRenamingDecl*,&SgAdaRenamingSymbol::p_declaration> {
  using parent = SgAdaRenamingSymbol;
  using field_type = SgAdaRenamingDecl*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgAdaRenamingDecl*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaRenamingSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaRenamingSymbol, SgAdaRenamingDecl* SgAdaRenamingSymbol::*, &SgAdaRenamingSymbol::p_declaration>;
};
template <> struct describe_node_t<SgAdaRenamingSymbol> {
  using node = SgAdaRenamingSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AdaRenamingSymbol"};
  static constexpr unsigned long variant{905};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaRenamingSymbol,SgAdaRenamingDecl*,&SgAdaRenamingSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<905> { using type = SgAdaRenamingSymbol; };

// Class: AdaRenamingRefExp
template <> struct describe_field_t<SgAdaRenamingRefExp,SgAdaRenamingSymbol*,&SgAdaRenamingRefExp::p_symbol> {
  using parent = SgAdaRenamingRefExp;
  using field_type = SgAdaRenamingSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgAdaRenamingSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaRenamingRefExp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaRenamingRefExp, SgAdaRenamingSymbol* SgAdaRenamingRefExp::*, &SgAdaRenamingRefExp::p_symbol>;
};
template <> struct describe_node_t<SgAdaRenamingRefExp> {
  using node = SgAdaRenamingRefExp;
  using base = SgExpression;
  static constexpr char const * const name{"AdaRenamingRefExp"};
  static constexpr unsigned long variant{906};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaRenamingRefExp,SgAdaRenamingSymbol*,&SgAdaRenamingRefExp::p_symbol>>;
};
template <> struct node_from_variant_t<906> { using type = SgAdaRenamingRefExp; };

// Class: AdaGenericDecl
template <> struct describe_field_t<SgAdaGenericDecl,SgName,&SgAdaGenericDecl::p_name> {
  using parent = SgAdaGenericDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaGenericDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericDecl, SgName SgAdaGenericDecl::*, &SgAdaGenericDecl::p_name>;
};
template <> struct describe_field_t<SgAdaGenericDecl,SgAdaGenericDefn*,&SgAdaGenericDecl::p_definition> {
  using parent = SgAdaGenericDecl;
  using field_type = SgAdaGenericDefn*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgAdaGenericDefn*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaGenericDecl::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericDecl, SgAdaGenericDefn* SgAdaGenericDecl::*, &SgAdaGenericDecl::p_definition>;
};
template <> struct describe_field_t<SgAdaGenericDecl,SgDeclarationStatement*,&SgAdaGenericDecl::p_declaration> {
  using parent = SgAdaGenericDecl;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaGenericDecl::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericDecl, SgDeclarationStatement* SgAdaGenericDecl::*, &SgAdaGenericDecl::p_declaration>;
};
template <> struct describe_field_t<SgAdaGenericDecl,SgScopeStatement*,&SgAdaGenericDecl::p_scope> {
  using parent = SgAdaGenericDecl;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaGenericDecl::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericDecl, SgScopeStatement* SgAdaGenericDecl::*, &SgAdaGenericDecl::p_scope>;
};
template <> struct describe_node_t<SgAdaGenericDecl> {
  using node = SgAdaGenericDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaGenericDecl"};
  static constexpr unsigned long variant{907};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaGenericDecl,SgName,&SgAdaGenericDecl::p_name>, describe_field_t<SgAdaGenericDecl,SgAdaGenericDefn*,&SgAdaGenericDecl::p_definition>, describe_field_t<SgAdaGenericDecl,SgDeclarationStatement*,&SgAdaGenericDecl::p_declaration>, describe_field_t<SgAdaGenericDecl,SgScopeStatement*,&SgAdaGenericDecl::p_scope>>;
};
template <> struct node_from_variant_t<907> { using type = SgAdaGenericDecl; };

// Class: AdaGenericDefn
template <> struct describe_field_t<SgAdaGenericDefn,SgDeclarationStatementPtrList,&SgAdaGenericDefn::p_declarations> {
  using parent = SgAdaGenericDefn;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declarations"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaGenericDefn::p_declarations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericDefn, SgDeclarationStatementPtrList SgAdaGenericDefn::*, &SgAdaGenericDefn::p_declarations>;
};
template <> struct describe_node_t<SgAdaGenericDefn> {
  using node = SgAdaGenericDefn;
  using base = SgScopeStatement;
  static constexpr char const * const name{"AdaGenericDefn"};
  static constexpr unsigned long variant{908};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaGenericDefn,SgDeclarationStatementPtrList,&SgAdaGenericDefn::p_declarations>>;
};
template <> struct node_from_variant_t<908> { using type = SgAdaGenericDefn; };

// Class: AdaFormalType
template <> struct describe_field_t<SgAdaFormalType,bool,&SgAdaFormalType::p_is_private> {
  using parent = SgAdaFormalType;
  using field_type = bool;
  static constexpr size_t position{0};
  static constexpr char const * const name{"is_private"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFormalType::p_is_private};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalType, bool SgAdaFormalType::*, &SgAdaFormalType::p_is_private>;
};
template <> struct describe_field_t<SgAdaFormalType,SgType*,&SgAdaFormalType::p_formal_type> {
  using parent = SgAdaFormalType;
  using field_type = SgType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"formal_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFormalType::p_formal_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalType, SgType* SgAdaFormalType::*, &SgAdaFormalType::p_formal_type>;
};
template <> struct describe_node_t<SgAdaFormalType> {
  using node = SgAdaFormalType;
  using base = SgNamedType;
  static constexpr char const * const name{"AdaFormalType"};
  static constexpr unsigned long variant{909};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaFormalType,bool,&SgAdaFormalType::p_is_private>, describe_field_t<SgAdaFormalType,SgType*,&SgAdaFormalType::p_formal_type>>;
};
template <> struct node_from_variant_t<909> { using type = SgAdaFormalType; };

// Class: AdaGenericSymbol
template <> struct describe_field_t<SgAdaGenericSymbol,SgDeclarationStatement*,&SgAdaGenericSymbol::p_declaration> {
  using parent = SgAdaGenericSymbol;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaGenericSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericSymbol, SgDeclarationStatement* SgAdaGenericSymbol::*, &SgAdaGenericSymbol::p_declaration>;
};
template <> struct describe_node_t<SgAdaGenericSymbol> {
  using node = SgAdaGenericSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AdaGenericSymbol"};
  static constexpr unsigned long variant{910};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaGenericSymbol,SgDeclarationStatement*,&SgAdaGenericSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<910> { using type = SgAdaGenericSymbol; };

// Class: AdaFormalTypeDecl
template <> struct describe_field_t<SgAdaFormalTypeDecl,SgName,&SgAdaFormalTypeDecl::p_name> {
  using parent = SgAdaFormalTypeDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFormalTypeDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalTypeDecl, SgName SgAdaFormalTypeDecl::*, &SgAdaFormalTypeDecl::p_name>;
};
template <> struct describe_field_t<SgAdaFormalTypeDecl,SgAdaFormalType*,&SgAdaFormalTypeDecl::p_type> {
  using parent = SgAdaFormalTypeDecl;
  using field_type = SgAdaFormalType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAdaFormalType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFormalTypeDecl::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalTypeDecl, SgAdaFormalType* SgAdaFormalTypeDecl::*, &SgAdaFormalTypeDecl::p_type>;
};
template <> struct describe_field_t<SgAdaFormalTypeDecl,SgAdaParameterList*,&SgAdaFormalTypeDecl::p_discriminants> {
  using parent = SgAdaFormalTypeDecl;
  using field_type = SgAdaParameterList*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"discriminants"};
  static constexpr char const * const typestr{"SgAdaParameterList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaFormalTypeDecl::p_discriminants};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalTypeDecl, SgAdaParameterList* SgAdaFormalTypeDecl::*, &SgAdaFormalTypeDecl::p_discriminants>;
};
template <> struct describe_node_t<SgAdaFormalTypeDecl> {
  using node = SgAdaFormalTypeDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaFormalTypeDecl"};
  static constexpr unsigned long variant{911};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaFormalTypeDecl,SgName,&SgAdaFormalTypeDecl::p_name>, describe_field_t<SgAdaFormalTypeDecl,SgAdaFormalType*,&SgAdaFormalTypeDecl::p_type>, describe_field_t<SgAdaFormalTypeDecl,SgAdaParameterList*,&SgAdaFormalTypeDecl::p_discriminants>>;
};
template <> struct node_from_variant_t<911> { using type = SgAdaFormalTypeDecl; };

// Class: AdaUnitRefExp
template <> struct describe_field_t<SgAdaUnitRefExp,SgSymbol*,&SgAdaUnitRefExp::p_symbol> {
  using parent = SgAdaUnitRefExp;
  using field_type = SgSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaUnitRefExp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaUnitRefExp, SgSymbol* SgAdaUnitRefExp::*, &SgAdaUnitRefExp::p_symbol>;
};
template <> struct describe_node_t<SgAdaUnitRefExp> {
  using node = SgAdaUnitRefExp;
  using base = SgExpression;
  static constexpr char const * const name{"AdaUnitRefExp"};
  static constexpr unsigned long variant{912};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaUnitRefExp,SgSymbol*,&SgAdaUnitRefExp::p_symbol>>;
};
template <> struct node_from_variant_t<912> { using type = SgAdaUnitRefExp; };

// Class: AdaDiscriminatedTypeDecl
template <> struct describe_field_t<SgAdaDiscriminatedTypeDecl,SgDeclarationScope*,&SgAdaDiscriminatedTypeDecl::p_discriminantScope> {
  using parent = SgAdaDiscriminatedTypeDecl;
  using field_type = SgDeclarationScope*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"discriminantScope"};
  static constexpr char const * const typestr{"SgDeclarationScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaDiscriminatedTypeDecl::p_discriminantScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDiscriminatedTypeDecl, SgDeclarationScope* SgAdaDiscriminatedTypeDecl::*, &SgAdaDiscriminatedTypeDecl::p_discriminantScope>;
};
template <> struct describe_field_t<SgAdaDiscriminatedTypeDecl,SgAdaParameterList*,&SgAdaDiscriminatedTypeDecl::p_discriminants> {
  using parent = SgAdaDiscriminatedTypeDecl;
  using field_type = SgAdaParameterList*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"discriminants"};
  static constexpr char const * const typestr{"SgAdaParameterList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaDiscriminatedTypeDecl::p_discriminants};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDiscriminatedTypeDecl, SgAdaParameterList* SgAdaDiscriminatedTypeDecl::*, &SgAdaDiscriminatedTypeDecl::p_discriminants>;
};
template <> struct describe_field_t<SgAdaDiscriminatedTypeDecl,SgDeclarationStatement*,&SgAdaDiscriminatedTypeDecl::p_discriminatedDecl> {
  using parent = SgAdaDiscriminatedTypeDecl;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"discriminatedDecl"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaDiscriminatedTypeDecl::p_discriminatedDecl};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDiscriminatedTypeDecl, SgDeclarationStatement* SgAdaDiscriminatedTypeDecl::*, &SgAdaDiscriminatedTypeDecl::p_discriminatedDecl>;
};
template <> struct describe_field_t<SgAdaDiscriminatedTypeDecl,SgAdaDiscriminatedType*,&SgAdaDiscriminatedTypeDecl::p_type> {
  using parent = SgAdaDiscriminatedTypeDecl;
  using field_type = SgAdaDiscriminatedType*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAdaDiscriminatedType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaDiscriminatedTypeDecl::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDiscriminatedTypeDecl, SgAdaDiscriminatedType* SgAdaDiscriminatedTypeDecl::*, &SgAdaDiscriminatedTypeDecl::p_type>;
};
template <> struct describe_field_t<SgAdaDiscriminatedTypeDecl,SgScopeStatement*,&SgAdaDiscriminatedTypeDecl::p_scope> {
  using parent = SgAdaDiscriminatedTypeDecl;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaDiscriminatedTypeDecl::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDiscriminatedTypeDecl, SgScopeStatement* SgAdaDiscriminatedTypeDecl::*, &SgAdaDiscriminatedTypeDecl::p_scope>;
};
template <> struct describe_node_t<SgAdaDiscriminatedTypeDecl> {
  using node = SgAdaDiscriminatedTypeDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaDiscriminatedTypeDecl"};
  static constexpr unsigned long variant{913};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaDiscriminatedTypeDecl,SgDeclarationScope*,&SgAdaDiscriminatedTypeDecl::p_discriminantScope>, describe_field_t<SgAdaDiscriminatedTypeDecl,SgAdaParameterList*,&SgAdaDiscriminatedTypeDecl::p_discriminants>, describe_field_t<SgAdaDiscriminatedTypeDecl,SgDeclarationStatement*,&SgAdaDiscriminatedTypeDecl::p_discriminatedDecl>, describe_field_t<SgAdaDiscriminatedTypeDecl,SgAdaDiscriminatedType*,&SgAdaDiscriminatedTypeDecl::p_type>, describe_field_t<SgAdaDiscriminatedTypeDecl,SgScopeStatement*,&SgAdaDiscriminatedTypeDecl::p_scope>>;
};
template <> struct node_from_variant_t<913> { using type = SgAdaDiscriminatedTypeDecl; };

// Class: AdaDiscriminatedType
template <> struct describe_node_t<SgAdaDiscriminatedType> {
  using node = SgAdaDiscriminatedType;
  using base = SgNamedType;
  static constexpr char const * const name{"AdaDiscriminatedType"};
  static constexpr unsigned long variant{914};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<914> { using type = SgAdaDiscriminatedType; };

// Class: AdaDiscriminantConstraint
template <> struct describe_field_t<SgAdaDiscriminantConstraint,SgExpressionPtrList,&SgAdaDiscriminantConstraint::p_discriminants> {
  using parent = SgAdaDiscriminantConstraint;
  using field_type = SgExpressionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"discriminants"};
  static constexpr char const * const typestr{"SgExpressionPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaDiscriminantConstraint::p_discriminants};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDiscriminantConstraint, SgExpressionPtrList SgAdaDiscriminantConstraint::*, &SgAdaDiscriminantConstraint::p_discriminants>;
};
template <> struct describe_node_t<SgAdaDiscriminantConstraint> {
  using node = SgAdaDiscriminantConstraint;
  using base = SgAdaTypeConstraint;
  static constexpr char const * const name{"AdaDiscriminantConstraint"};
  static constexpr unsigned long variant{915};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaDiscriminantConstraint,SgExpressionPtrList,&SgAdaDiscriminantConstraint::p_discriminants>>;
};
template <> struct node_from_variant_t<915> { using type = SgAdaDiscriminantConstraint; };

// Class: AdaGenericInstanceDecl
template <> struct describe_field_t<SgAdaGenericInstanceDecl,SgName,&SgAdaGenericInstanceDecl::p_name> {
  using parent = SgAdaGenericInstanceDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaGenericInstanceDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericInstanceDecl, SgName SgAdaGenericInstanceDecl::*, &SgAdaGenericInstanceDecl::p_name>;
};
template <> struct describe_field_t<SgAdaGenericInstanceDecl,SgDeclarationStatement*,&SgAdaGenericInstanceDecl::p_genericDeclaration> {
  using parent = SgAdaGenericInstanceDecl;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"genericDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaGenericInstanceDecl::p_genericDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericInstanceDecl, SgDeclarationStatement* SgAdaGenericInstanceDecl::*, &SgAdaGenericInstanceDecl::p_genericDeclaration>;
};
template <> struct describe_field_t<SgAdaGenericInstanceDecl,SgScopeStatement*,&SgAdaGenericInstanceDecl::p_instantiatedScope> {
  using parent = SgAdaGenericInstanceDecl;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"instantiatedScope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaGenericInstanceDecl::p_instantiatedScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericInstanceDecl, SgScopeStatement* SgAdaGenericInstanceDecl::*, &SgAdaGenericInstanceDecl::p_instantiatedScope>;
};
template <> struct describe_field_t<SgAdaGenericInstanceDecl,SgExprListExp*,&SgAdaGenericInstanceDecl::p_actual_parameters> {
  using parent = SgAdaGenericInstanceDecl;
  using field_type = SgExprListExp*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"actual_parameters"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaGenericInstanceDecl::p_actual_parameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericInstanceDecl, SgExprListExp* SgAdaGenericInstanceDecl::*, &SgAdaGenericInstanceDecl::p_actual_parameters>;
};
template <> struct describe_field_t<SgAdaGenericInstanceDecl,SgScopeStatement*,&SgAdaGenericInstanceDecl::p_scope> {
  using parent = SgAdaGenericInstanceDecl;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaGenericInstanceDecl::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericInstanceDecl, SgScopeStatement* SgAdaGenericInstanceDecl::*, &SgAdaGenericInstanceDecl::p_scope>;
};
template <> struct describe_node_t<SgAdaGenericInstanceDecl> {
  using node = SgAdaGenericInstanceDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaGenericInstanceDecl"};
  static constexpr unsigned long variant{916};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaGenericInstanceDecl,SgName,&SgAdaGenericInstanceDecl::p_name>, describe_field_t<SgAdaGenericInstanceDecl,SgDeclarationStatement*,&SgAdaGenericInstanceDecl::p_genericDeclaration>, describe_field_t<SgAdaGenericInstanceDecl,SgScopeStatement*,&SgAdaGenericInstanceDecl::p_instantiatedScope>, describe_field_t<SgAdaGenericInstanceDecl,SgExprListExp*,&SgAdaGenericInstanceDecl::p_actual_parameters>, describe_field_t<SgAdaGenericInstanceDecl,SgScopeStatement*,&SgAdaGenericInstanceDecl::p_scope>>;
};
template <> struct node_from_variant_t<916> { using type = SgAdaGenericInstanceDecl; };

// Class: AdaUnscopedBlock
template <> struct describe_field_t<SgAdaUnscopedBlock,SgStatementPtrList,&SgAdaUnscopedBlock::p_statements> {
  using parent = SgAdaUnscopedBlock;
  using field_type = SgStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"statements"};
  static constexpr char const * const typestr{"SgStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaUnscopedBlock::p_statements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaUnscopedBlock, SgStatementPtrList SgAdaUnscopedBlock::*, &SgAdaUnscopedBlock::p_statements>;
};
template <> struct describe_node_t<SgAdaUnscopedBlock> {
  using node = SgAdaUnscopedBlock;
  using base = SgStatement;
  static constexpr char const * const name{"AdaUnscopedBlock"};
  static constexpr unsigned long variant{917};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaUnscopedBlock,SgStatementPtrList,&SgAdaUnscopedBlock::p_statements>>;
};
template <> struct node_from_variant_t<917> { using type = SgAdaUnscopedBlock; };

// Class: AdaInheritedFunctionSymbol
template <> struct describe_field_t<SgAdaInheritedFunctionSymbol,SgFunctionType*,&SgAdaInheritedFunctionSymbol::p_derivedFunctionType> {
  using parent = SgAdaInheritedFunctionSymbol;
  using field_type = SgFunctionType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"derivedFunctionType"};
  static constexpr char const * const typestr{"SgFunctionType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaInheritedFunctionSymbol::p_derivedFunctionType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaInheritedFunctionSymbol, SgFunctionType* SgAdaInheritedFunctionSymbol::*, &SgAdaInheritedFunctionSymbol::p_derivedFunctionType>;
};
template <> struct describe_field_t<SgAdaInheritedFunctionSymbol,SgNamedType*,&SgAdaInheritedFunctionSymbol::p_associatedDerivedType> {
  using parent = SgAdaInheritedFunctionSymbol;
  using field_type = SgNamedType*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"associatedDerivedType"};
  static constexpr char const * const typestr{"SgNamedType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaInheritedFunctionSymbol::p_associatedDerivedType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaInheritedFunctionSymbol, SgNamedType* SgAdaInheritedFunctionSymbol::*, &SgAdaInheritedFunctionSymbol::p_associatedDerivedType>;
};
template <> struct describe_field_t<SgAdaInheritedFunctionSymbol,SgFunctionSymbol*,&SgAdaInheritedFunctionSymbol::p_publiclyVisibleFunctionSymbol> {
  using parent = SgAdaInheritedFunctionSymbol;
  using field_type = SgFunctionSymbol*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"publiclyVisibleFunctionSymbol"};
  static constexpr char const * const typestr{"SgFunctionSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaInheritedFunctionSymbol::p_publiclyVisibleFunctionSymbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaInheritedFunctionSymbol, SgFunctionSymbol* SgAdaInheritedFunctionSymbol::*, &SgAdaInheritedFunctionSymbol::p_publiclyVisibleFunctionSymbol>;
};
template <> struct describe_node_t<SgAdaInheritedFunctionSymbol> {
  using node = SgAdaInheritedFunctionSymbol;
  using base = SgFunctionSymbol;
  static constexpr char const * const name{"AdaInheritedFunctionSymbol"};
  static constexpr unsigned long variant{918};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaInheritedFunctionSymbol,SgFunctionType*,&SgAdaInheritedFunctionSymbol::p_derivedFunctionType>, describe_field_t<SgAdaInheritedFunctionSymbol,SgNamedType*,&SgAdaInheritedFunctionSymbol::p_associatedDerivedType>, describe_field_t<SgAdaInheritedFunctionSymbol,SgFunctionSymbol*,&SgAdaInheritedFunctionSymbol::p_publiclyVisibleFunctionSymbol>>;
};
template <> struct node_from_variant_t<918> { using type = SgAdaInheritedFunctionSymbol; };

// Class: AdaProtectedBody
template <> struct describe_field_t<SgAdaProtectedBody,SgAdaProtectedSpec*,&SgAdaProtectedBody::p_spec> {
  using parent = SgAdaProtectedBody;
  using field_type = SgAdaProtectedSpec*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"spec"};
  static constexpr char const * const typestr{"SgAdaProtectedSpec*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedBody::p_spec};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedBody, SgAdaProtectedSpec* SgAdaProtectedBody::*, &SgAdaProtectedBody::p_spec>;
};
template <> struct describe_field_t<SgAdaProtectedBody,SgStatementPtrList,&SgAdaProtectedBody::p_statements> {
  using parent = SgAdaProtectedBody;
  using field_type = SgStatementPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"statements"};
  static constexpr char const * const typestr{"SgStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaProtectedBody::p_statements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedBody, SgStatementPtrList SgAdaProtectedBody::*, &SgAdaProtectedBody::p_statements>;
};
template <> struct describe_node_t<SgAdaProtectedBody> {
  using node = SgAdaProtectedBody;
  using base = SgScopeStatement;
  static constexpr char const * const name{"AdaProtectedBody"};
  static constexpr unsigned long variant{919};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaProtectedBody,SgAdaProtectedSpec*,&SgAdaProtectedBody::p_spec>, describe_field_t<SgAdaProtectedBody,SgStatementPtrList,&SgAdaProtectedBody::p_statements>>;
};
template <> struct node_from_variant_t<919> { using type = SgAdaProtectedBody; };

// Class: AdaProtectedBodyDecl
template <> struct describe_field_t<SgAdaProtectedBodyDecl,SgName,&SgAdaProtectedBodyDecl::p_name> {
  using parent = SgAdaProtectedBodyDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedBodyDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedBodyDecl, SgName SgAdaProtectedBodyDecl::*, &SgAdaProtectedBodyDecl::p_name>;
};
template <> struct describe_field_t<SgAdaProtectedBodyDecl,SgDeclarationStatement*,&SgAdaProtectedBodyDecl::p_specificationDeclaration> {
  using parent = SgAdaProtectedBodyDecl;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"specificationDeclaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedBodyDecl::p_specificationDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedBodyDecl, SgDeclarationStatement* SgAdaProtectedBodyDecl::*, &SgAdaProtectedBodyDecl::p_specificationDeclaration>;
};
template <> struct describe_field_t<SgAdaProtectedBodyDecl,SgAdaProtectedBody*,&SgAdaProtectedBodyDecl::p_definition> {
  using parent = SgAdaProtectedBodyDecl;
  using field_type = SgAdaProtectedBody*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgAdaProtectedBody*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaProtectedBodyDecl::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedBodyDecl, SgAdaProtectedBody* SgAdaProtectedBodyDecl::*, &SgAdaProtectedBodyDecl::p_definition>;
};
template <> struct describe_node_t<SgAdaProtectedBodyDecl> {
  using node = SgAdaProtectedBodyDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaProtectedBodyDecl"};
  static constexpr unsigned long variant{920};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaProtectedBodyDecl,SgName,&SgAdaProtectedBodyDecl::p_name>, describe_field_t<SgAdaProtectedBodyDecl,SgDeclarationStatement*,&SgAdaProtectedBodyDecl::p_specificationDeclaration>, describe_field_t<SgAdaProtectedBodyDecl,SgAdaProtectedBody*,&SgAdaProtectedBodyDecl::p_definition>>;
};
template <> struct node_from_variant_t<920> { using type = SgAdaProtectedBodyDecl; };

// Class: AdaProtectedSpec
template <> struct describe_field_t<SgAdaProtectedSpec,SgAdaProtectedBody*,&SgAdaProtectedSpec::p_body> {
  using parent = SgAdaProtectedSpec;
  using field_type = SgAdaProtectedBody*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAdaProtectedBody*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedSpec::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedSpec, SgAdaProtectedBody* SgAdaProtectedSpec::*, &SgAdaProtectedSpec::p_body>;
};
template <> struct describe_field_t<SgAdaProtectedSpec,SgDeclarationStatementPtrList,&SgAdaProtectedSpec::p_declarations> {
  using parent = SgAdaProtectedSpec;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"declarations"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaProtectedSpec::p_declarations};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedSpec, SgDeclarationStatementPtrList SgAdaProtectedSpec::*, &SgAdaProtectedSpec::p_declarations>;
};
template <> struct describe_field_t<SgAdaProtectedSpec,bool,&SgAdaProtectedSpec::p_hasPrivate> {
  using parent = SgAdaProtectedSpec;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"hasPrivate"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedSpec::p_hasPrivate};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedSpec, bool SgAdaProtectedSpec::*, &SgAdaProtectedSpec::p_hasPrivate>;
};
template <> struct describe_node_t<SgAdaProtectedSpec> {
  using node = SgAdaProtectedSpec;
  using base = SgScopeStatement;
  static constexpr char const * const name{"AdaProtectedSpec"};
  static constexpr unsigned long variant{921};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaProtectedSpec,SgAdaProtectedBody*,&SgAdaProtectedSpec::p_body>, describe_field_t<SgAdaProtectedSpec,SgDeclarationStatementPtrList,&SgAdaProtectedSpec::p_declarations>, describe_field_t<SgAdaProtectedSpec,bool,&SgAdaProtectedSpec::p_hasPrivate>>;
};
template <> struct node_from_variant_t<921> { using type = SgAdaProtectedSpec; };

// Class: AdaProtectedSpecDecl
template <> struct describe_field_t<SgAdaProtectedSpecDecl,SgName,&SgAdaProtectedSpecDecl::p_name> {
  using parent = SgAdaProtectedSpecDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedSpecDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedSpecDecl, SgName SgAdaProtectedSpecDecl::*, &SgAdaProtectedSpecDecl::p_name>;
};
template <> struct describe_field_t<SgAdaProtectedSpecDecl,SgAdaProtectedSpec*,&SgAdaProtectedSpecDecl::p_definition> {
  using parent = SgAdaProtectedSpecDecl;
  using field_type = SgAdaProtectedSpec*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgAdaProtectedSpec*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaProtectedSpecDecl::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedSpecDecl, SgAdaProtectedSpec* SgAdaProtectedSpecDecl::*, &SgAdaProtectedSpecDecl::p_definition>;
};
template <> struct describe_field_t<SgAdaProtectedSpecDecl,SgAdaProtectedType*,&SgAdaProtectedSpecDecl::p_type> {
  using parent = SgAdaProtectedSpecDecl;
  using field_type = SgAdaProtectedType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAdaProtectedType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedSpecDecl::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedSpecDecl, SgAdaProtectedType* SgAdaProtectedSpecDecl::*, &SgAdaProtectedSpecDecl::p_type>;
};
template <> struct describe_node_t<SgAdaProtectedSpecDecl> {
  using node = SgAdaProtectedSpecDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaProtectedSpecDecl"};
  static constexpr unsigned long variant{922};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaProtectedSpecDecl,SgName,&SgAdaProtectedSpecDecl::p_name>, describe_field_t<SgAdaProtectedSpecDecl,SgAdaProtectedSpec*,&SgAdaProtectedSpecDecl::p_definition>, describe_field_t<SgAdaProtectedSpecDecl,SgAdaProtectedType*,&SgAdaProtectedSpecDecl::p_type>>;
};
template <> struct node_from_variant_t<922> { using type = SgAdaProtectedSpecDecl; };

// Class: AdaProtectedSymbol
template <> struct describe_field_t<SgAdaProtectedSymbol,SgDeclarationStatement*,&SgAdaProtectedSymbol::p_declaration> {
  using parent = SgAdaProtectedSymbol;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaProtectedSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedSymbol, SgDeclarationStatement* SgAdaProtectedSymbol::*, &SgAdaProtectedSymbol::p_declaration>;
};
template <> struct describe_node_t<SgAdaProtectedSymbol> {
  using node = SgAdaProtectedSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AdaProtectedSymbol"};
  static constexpr unsigned long variant{923};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaProtectedSymbol,SgDeclarationStatement*,&SgAdaProtectedSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<923> { using type = SgAdaProtectedSymbol; };

// Class: AdaProtectedRefExp
template <> struct describe_field_t<SgAdaProtectedRefExp,SgAdaProtectedSymbol*,&SgAdaProtectedRefExp::p_symbol> {
  using parent = SgAdaProtectedRefExp;
  using field_type = SgAdaProtectedSymbol*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"symbol"};
  static constexpr char const * const typestr{"SgAdaProtectedSymbol*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedRefExp::p_symbol};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedRefExp, SgAdaProtectedSymbol* SgAdaProtectedRefExp::*, &SgAdaProtectedRefExp::p_symbol>;
};
template <> struct describe_node_t<SgAdaProtectedRefExp> {
  using node = SgAdaProtectedRefExp;
  using base = SgExpression;
  static constexpr char const * const name{"AdaProtectedRefExp"};
  static constexpr unsigned long variant{924};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaProtectedRefExp,SgAdaProtectedSymbol*,&SgAdaProtectedRefExp::p_symbol>>;
};
template <> struct node_from_variant_t<924> { using type = SgAdaProtectedRefExp; };

// Class: AdaProtectedType
template <> struct describe_node_t<SgAdaProtectedType> {
  using node = SgAdaProtectedType;
  using base = SgNamedType;
  static constexpr char const * const name{"AdaProtectedType"};
  static constexpr unsigned long variant{925};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<925> { using type = SgAdaProtectedType; };

// Class: AdaProtectedTypeDecl
template <> struct describe_field_t<SgAdaProtectedTypeDecl,SgName,&SgAdaProtectedTypeDecl::p_name> {
  using parent = SgAdaProtectedTypeDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedTypeDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedTypeDecl, SgName SgAdaProtectedTypeDecl::*, &SgAdaProtectedTypeDecl::p_name>;
};
template <> struct describe_field_t<SgAdaProtectedTypeDecl,SgAdaProtectedSpec*,&SgAdaProtectedTypeDecl::p_definition> {
  using parent = SgAdaProtectedTypeDecl;
  using field_type = SgAdaProtectedSpec*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"definition"};
  static constexpr char const * const typestr{"SgAdaProtectedSpec*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaProtectedTypeDecl::p_definition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedTypeDecl, SgAdaProtectedSpec* SgAdaProtectedTypeDecl::*, &SgAdaProtectedTypeDecl::p_definition>;
};
template <> struct describe_field_t<SgAdaProtectedTypeDecl,SgAdaProtectedType*,&SgAdaProtectedTypeDecl::p_type> {
  using parent = SgAdaProtectedTypeDecl;
  using field_type = SgAdaProtectedType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"type"};
  static constexpr char const * const typestr{"SgAdaProtectedType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedTypeDecl::p_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedTypeDecl, SgAdaProtectedType* SgAdaProtectedTypeDecl::*, &SgAdaProtectedTypeDecl::p_type>;
};
template <> struct describe_field_t<SgAdaProtectedTypeDecl,SgScopeStatement*,&SgAdaProtectedTypeDecl::p_scope> {
  using parent = SgAdaProtectedTypeDecl;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"scope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaProtectedTypeDecl::p_scope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaProtectedTypeDecl, SgScopeStatement* SgAdaProtectedTypeDecl::*, &SgAdaProtectedTypeDecl::p_scope>;
};
template <> struct describe_node_t<SgAdaProtectedTypeDecl> {
  using node = SgAdaProtectedTypeDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaProtectedTypeDecl"};
  static constexpr unsigned long variant{926};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaProtectedTypeDecl,SgName,&SgAdaProtectedTypeDecl::p_name>, describe_field_t<SgAdaProtectedTypeDecl,SgAdaProtectedSpec*,&SgAdaProtectedTypeDecl::p_definition>, describe_field_t<SgAdaProtectedTypeDecl,SgAdaProtectedType*,&SgAdaProtectedTypeDecl::p_type>, describe_field_t<SgAdaProtectedTypeDecl,SgScopeStatement*,&SgAdaProtectedTypeDecl::p_scope>>;
};
template <> struct node_from_variant_t<926> { using type = SgAdaProtectedTypeDecl; };

// Class: AdaDigitsConstraint
template <> struct describe_field_t<SgAdaDigitsConstraint,SgExpression*,&SgAdaDigitsConstraint::p_digits> {
  using parent = SgAdaDigitsConstraint;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"digits"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaDigitsConstraint::p_digits};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDigitsConstraint, SgExpression* SgAdaDigitsConstraint::*, &SgAdaDigitsConstraint::p_digits>;
};
template <> struct describe_field_t<SgAdaDigitsConstraint,SgAdaTypeConstraint*,&SgAdaDigitsConstraint::p_subConstraint> {
  using parent = SgAdaDigitsConstraint;
  using field_type = SgAdaTypeConstraint*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"subConstraint"};
  static constexpr char const * const typestr{"SgAdaTypeConstraint*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaDigitsConstraint::p_subConstraint};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDigitsConstraint, SgAdaTypeConstraint* SgAdaDigitsConstraint::*, &SgAdaDigitsConstraint::p_subConstraint>;
};
template <> struct describe_node_t<SgAdaDigitsConstraint> {
  using node = SgAdaDigitsConstraint;
  using base = SgAdaTypeConstraint;
  static constexpr char const * const name{"AdaDigitsConstraint"};
  static constexpr unsigned long variant{927};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaDigitsConstraint,SgExpression*,&SgAdaDigitsConstraint::p_digits>, describe_field_t<SgAdaDigitsConstraint,SgAdaTypeConstraint*,&SgAdaDigitsConstraint::p_subConstraint>>;
};
template <> struct node_from_variant_t<927> { using type = SgAdaDigitsConstraint; };

// Class: AdaAncestorInitializer
template <> struct describe_field_t<SgAdaAncestorInitializer,SgExpression*,&SgAdaAncestorInitializer::p_ancestor> {
  using parent = SgAdaAncestorInitializer;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"ancestor"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaAncestorInitializer::p_ancestor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaAncestorInitializer, SgExpression* SgAdaAncestorInitializer::*, &SgAdaAncestorInitializer::p_ancestor>;
};
template <> struct describe_node_t<SgAdaAncestorInitializer> {
  using node = SgAdaAncestorInitializer;
  using base = SgInitializer;
  static constexpr char const * const name{"AdaAncestorInitializer"};
  static constexpr unsigned long variant{928};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaAncestorInitializer,SgExpression*,&SgAdaAncestorInitializer::p_ancestor>>;
};
template <> struct node_from_variant_t<928> { using type = SgAdaAncestorInitializer; };

// Class: AdaDeltaConstraint
template <> struct describe_field_t<SgAdaDeltaConstraint,SgExpression*,&SgAdaDeltaConstraint::p_delta> {
  using parent = SgAdaDeltaConstraint;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"delta"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaDeltaConstraint::p_delta};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDeltaConstraint, SgExpression* SgAdaDeltaConstraint::*, &SgAdaDeltaConstraint::p_delta>;
};
template <> struct describe_field_t<SgAdaDeltaConstraint,SgAdaTypeConstraint*,&SgAdaDeltaConstraint::p_subConstraint> {
  using parent = SgAdaDeltaConstraint;
  using field_type = SgAdaTypeConstraint*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"subConstraint"};
  static constexpr char const * const typestr{"SgAdaTypeConstraint*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaDeltaConstraint::p_subConstraint};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDeltaConstraint, SgAdaTypeConstraint* SgAdaDeltaConstraint::*, &SgAdaDeltaConstraint::p_subConstraint>;
};
template <> struct describe_field_t<SgAdaDeltaConstraint,bool,&SgAdaDeltaConstraint::p_isDecimal> {
  using parent = SgAdaDeltaConstraint;
  using field_type = bool;
  static constexpr size_t position{2};
  static constexpr char const * const name{"isDecimal"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaDeltaConstraint::p_isDecimal};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaDeltaConstraint, bool SgAdaDeltaConstraint::*, &SgAdaDeltaConstraint::p_isDecimal>;
};
template <> struct describe_node_t<SgAdaDeltaConstraint> {
  using node = SgAdaDeltaConstraint;
  using base = SgAdaTypeConstraint;
  static constexpr char const * const name{"AdaDeltaConstraint"};
  static constexpr unsigned long variant{929};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaDeltaConstraint,SgExpression*,&SgAdaDeltaConstraint::p_delta>, describe_field_t<SgAdaDeltaConstraint,SgAdaTypeConstraint*,&SgAdaDeltaConstraint::p_subConstraint>, describe_field_t<SgAdaDeltaConstraint,bool,&SgAdaDeltaConstraint::p_isDecimal>>;
};
template <> struct node_from_variant_t<929> { using type = SgAdaDeltaConstraint; };

// Class: AdaSubroutineType
template <> struct describe_field_t<SgAdaSubroutineType,SgFunctionParameterList*,&SgAdaSubroutineType::p_parameterList> {
  using parent = SgAdaSubroutineType;
  using field_type = SgFunctionParameterList*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"parameterList"};
  static constexpr char const * const typestr{"SgFunctionParameterList*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSubroutineType::p_parameterList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSubroutineType, SgFunctionParameterList* SgAdaSubroutineType::*, &SgAdaSubroutineType::p_parameterList>;
};
template <> struct describe_field_t<SgAdaSubroutineType,SgFunctionParameterScope*,&SgAdaSubroutineType::p_functionParameterScope> {
  using parent = SgAdaSubroutineType;
  using field_type = SgFunctionParameterScope*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"functionParameterScope"};
  static constexpr char const * const typestr{"SgFunctionParameterScope*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaSubroutineType::p_functionParameterScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSubroutineType, SgFunctionParameterScope* SgAdaSubroutineType::*, &SgAdaSubroutineType::p_functionParameterScope>;
};
template <> struct describe_field_t<SgAdaSubroutineType,SgType*,&SgAdaSubroutineType::p_return_type> {
  using parent = SgAdaSubroutineType;
  using field_type = SgType*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"return_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaSubroutineType::p_return_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSubroutineType, SgType* SgAdaSubroutineType::*, &SgAdaSubroutineType::p_return_type>;
};
template <> struct describe_field_t<SgAdaSubroutineType,bool,&SgAdaSubroutineType::p_is_protected> {
  using parent = SgAdaSubroutineType;
  using field_type = bool;
  static constexpr size_t position{3};
  static constexpr char const * const name{"is_protected"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaSubroutineType::p_is_protected};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaSubroutineType, bool SgAdaSubroutineType::*, &SgAdaSubroutineType::p_is_protected>;
};
template <> struct describe_node_t<SgAdaSubroutineType> {
  using node = SgAdaSubroutineType;
  using base = SgType;
  static constexpr char const * const name{"AdaSubroutineType"};
  static constexpr unsigned long variant{930};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaSubroutineType,SgFunctionParameterList*,&SgAdaSubroutineType::p_parameterList>, describe_field_t<SgAdaSubroutineType,SgFunctionParameterScope*,&SgAdaSubroutineType::p_functionParameterScope>, describe_field_t<SgAdaSubroutineType,SgType*,&SgAdaSubroutineType::p_return_type>, describe_field_t<SgAdaSubroutineType,bool,&SgAdaSubroutineType::p_is_protected>>;
};
template <> struct node_from_variant_t<930> { using type = SgAdaSubroutineType; };

// Class: AdaGenericInstanceSymbol
template <> struct describe_field_t<SgAdaGenericInstanceSymbol,SgAdaGenericInstanceDecl*,&SgAdaGenericInstanceSymbol::p_declaration> {
  using parent = SgAdaGenericInstanceSymbol;
  using field_type = SgAdaGenericInstanceDecl*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgAdaGenericInstanceDecl*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaGenericInstanceSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaGenericInstanceSymbol, SgAdaGenericInstanceDecl* SgAdaGenericInstanceSymbol::*, &SgAdaGenericInstanceSymbol::p_declaration>;
};
template <> struct describe_node_t<SgAdaGenericInstanceSymbol> {
  using node = SgAdaGenericInstanceSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AdaGenericInstanceSymbol"};
  static constexpr unsigned long variant{931};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaGenericInstanceSymbol,SgAdaGenericInstanceDecl*,&SgAdaGenericInstanceSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<931> { using type = SgAdaGenericInstanceSymbol; };

// Class: AdaFormalPackageDecl
template <> struct describe_field_t<SgAdaFormalPackageDecl,SgName,&SgAdaFormalPackageDecl::p_name> {
  using parent = SgAdaFormalPackageDecl;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFormalPackageDecl::p_name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalPackageDecl, SgName SgAdaFormalPackageDecl::*, &SgAdaFormalPackageDecl::p_name>;
};
template <> struct describe_field_t<SgAdaFormalPackageDecl,SgDeclarationStatement*,&SgAdaFormalPackageDecl::p_declaration> {
  using parent = SgAdaFormalPackageDecl;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFormalPackageDecl::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalPackageDecl, SgDeclarationStatement* SgAdaFormalPackageDecl::*, &SgAdaFormalPackageDecl::p_declaration>;
};
template <> struct describe_field_t<SgAdaFormalPackageDecl,SgExprListExp*,&SgAdaFormalPackageDecl::p_actual_parameters> {
  using parent = SgAdaFormalPackageDecl;
  using field_type = SgExprListExp*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"actual_parameters"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFormalPackageDecl::p_actual_parameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalPackageDecl, SgExprListExp* SgAdaFormalPackageDecl::*, &SgAdaFormalPackageDecl::p_actual_parameters>;
};
template <> struct describe_field_t<SgAdaFormalPackageDecl,SgDeclarationStatement*,&SgAdaFormalPackageDecl::p_prototype> {
  using parent = SgAdaFormalPackageDecl;
  using field_type = SgDeclarationStatement*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"prototype"};
  static constexpr char const * const typestr{"SgDeclarationStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFormalPackageDecl::p_prototype};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalPackageDecl, SgDeclarationStatement* SgAdaFormalPackageDecl::*, &SgAdaFormalPackageDecl::p_prototype>;
};
template <> struct describe_field_t<SgAdaFormalPackageDecl,SgScopeStatement*,&SgAdaFormalPackageDecl::p_prototypeScope> {
  using parent = SgAdaFormalPackageDecl;
  using field_type = SgScopeStatement*;
  static constexpr size_t position{4};
  static constexpr char const * const name{"prototypeScope"};
  static constexpr char const * const typestr{"SgScopeStatement*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAdaFormalPackageDecl::p_prototypeScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalPackageDecl, SgScopeStatement* SgAdaFormalPackageDecl::*, &SgAdaFormalPackageDecl::p_prototypeScope>;
};
template <> struct describe_node_t<SgAdaFormalPackageDecl> {
  using node = SgAdaFormalPackageDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaFormalPackageDecl"};
  static constexpr unsigned long variant{932};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaFormalPackageDecl,SgName,&SgAdaFormalPackageDecl::p_name>, describe_field_t<SgAdaFormalPackageDecl,SgDeclarationStatement*,&SgAdaFormalPackageDecl::p_declaration>, describe_field_t<SgAdaFormalPackageDecl,SgExprListExp*,&SgAdaFormalPackageDecl::p_actual_parameters>, describe_field_t<SgAdaFormalPackageDecl,SgDeclarationStatement*,&SgAdaFormalPackageDecl::p_prototype>, describe_field_t<SgAdaFormalPackageDecl,SgScopeStatement*,&SgAdaFormalPackageDecl::p_prototypeScope>>;
};
template <> struct node_from_variant_t<932> { using type = SgAdaFormalPackageDecl; };

// Class: AdaFormalPackageSymbol
template <> struct describe_field_t<SgAdaFormalPackageSymbol,SgAdaFormalPackageDecl*,&SgAdaFormalPackageSymbol::p_declaration> {
  using parent = SgAdaFormalPackageSymbol;
  using field_type = SgAdaFormalPackageDecl*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"declaration"};
  static constexpr char const * const typestr{"SgAdaFormalPackageDecl*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaFormalPackageSymbol::p_declaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaFormalPackageSymbol, SgAdaFormalPackageDecl* SgAdaFormalPackageSymbol::*, &SgAdaFormalPackageSymbol::p_declaration>;
};
template <> struct describe_node_t<SgAdaFormalPackageSymbol> {
  using node = SgAdaFormalPackageSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"AdaFormalPackageSymbol"};
  static constexpr unsigned long variant{933};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaFormalPackageSymbol,SgAdaFormalPackageDecl*,&SgAdaFormalPackageSymbol::p_declaration>>;
};
template <> struct node_from_variant_t<933> { using type = SgAdaFormalPackageSymbol; };

// Class: AsmJvmAttributeTable
template <> struct describe_field_t<SgAsmJvmAttributeTable,SgAsmJvmAttributePtrList,&SgAsmJvmAttributeTable::p_attributes> {
  using parent = SgAsmJvmAttributeTable;
  using field_type = SgAsmJvmAttributePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"attributes"};
  static constexpr char const * const typestr{"SgAsmJvmAttributePtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmJvmAttributeTable::p_attributes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmAttributeTable, SgAsmJvmAttributePtrList SgAsmJvmAttributeTable::*, &SgAsmJvmAttributeTable::p_attributes>;
};
template <> struct describe_node_t<SgAsmJvmAttributeTable> {
  using node = SgAsmJvmAttributeTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmJvmAttributeTable"};
  static constexpr unsigned long variant{934};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmAttributeTable,SgAsmJvmAttributePtrList,&SgAsmJvmAttributeTable::p_attributes>>;
};
template <> struct node_from_variant_t<934> { using type = SgAsmJvmAttributeTable; };

// Class: AsmJvmMethodTable
template <> struct describe_field_t<SgAsmJvmMethodTable,SgAsmJvmMethodPtrList,&SgAsmJvmMethodTable::p_methods> {
  using parent = SgAsmJvmMethodTable;
  using field_type = SgAsmJvmMethodPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"methods"};
  static constexpr char const * const typestr{"SgAsmJvmMethodPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmJvmMethodTable::p_methods};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmMethodTable, SgAsmJvmMethodPtrList SgAsmJvmMethodTable::*, &SgAsmJvmMethodTable::p_methods>;
};
template <> struct describe_node_t<SgAsmJvmMethodTable> {
  using node = SgAsmJvmMethodTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmJvmMethodTable"};
  static constexpr unsigned long variant{935};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmMethodTable,SgAsmJvmMethodPtrList,&SgAsmJvmMethodTable::p_methods>>;
};
template <> struct node_from_variant_t<935> { using type = SgAsmJvmMethodTable; };

// Class: AsmJvmField
template <> struct describe_field_t<SgAsmJvmField,uint16_t,&SgAsmJvmField::p_access_flags> {
  using parent = SgAsmJvmField;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"access_flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmField::p_access_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmField, uint16_t SgAsmJvmField::*, &SgAsmJvmField::p_access_flags>;
};
template <> struct describe_field_t<SgAsmJvmField,uint16_t,&SgAsmJvmField::p_name_index> {
  using parent = SgAsmJvmField;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"name_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmField::p_name_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmField, uint16_t SgAsmJvmField::*, &SgAsmJvmField::p_name_index>;
};
template <> struct describe_field_t<SgAsmJvmField,uint16_t,&SgAsmJvmField::p_descriptor_index> {
  using parent = SgAsmJvmField;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"descriptor_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmField::p_descriptor_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmField, uint16_t SgAsmJvmField::*, &SgAsmJvmField::p_descriptor_index>;
};
template <> struct describe_field_t<SgAsmJvmField,SgAsmJvmAttributeTable*,&SgAsmJvmField::p_attribute_table> {
  using parent = SgAsmJvmField;
  using field_type = SgAsmJvmAttributeTable*;
  static constexpr size_t position{3};
  static constexpr char const * const name{"attribute_table"};
  static constexpr char const * const typestr{"SgAsmJvmAttributeTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmJvmField::p_attribute_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmField, SgAsmJvmAttributeTable* SgAsmJvmField::*, &SgAsmJvmField::p_attribute_table>;
};
template <> struct describe_node_t<SgAsmJvmField> {
  using node = SgAsmJvmField;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmField"};
  static constexpr unsigned long variant{936};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmField,uint16_t,&SgAsmJvmField::p_access_flags>, describe_field_t<SgAsmJvmField,uint16_t,&SgAsmJvmField::p_name_index>, describe_field_t<SgAsmJvmField,uint16_t,&SgAsmJvmField::p_descriptor_index>, describe_field_t<SgAsmJvmField,SgAsmJvmAttributeTable*,&SgAsmJvmField::p_attribute_table>>;
};
template <> struct node_from_variant_t<936> { using type = SgAsmJvmField; };

// Class: AsmJvmFieldTable
template <> struct describe_field_t<SgAsmJvmFieldTable,SgAsmJvmFieldPtrList,&SgAsmJvmFieldTable::p_fields> {
  using parent = SgAsmJvmFieldTable;
  using field_type = SgAsmJvmFieldPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"fields"};
  static constexpr char const * const typestr{"SgAsmJvmFieldPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmJvmFieldTable::p_fields};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmFieldTable, SgAsmJvmFieldPtrList SgAsmJvmFieldTable::*, &SgAsmJvmFieldTable::p_fields>;
};
template <> struct describe_node_t<SgAsmJvmFieldTable> {
  using node = SgAsmJvmFieldTable;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmJvmFieldTable"};
  static constexpr unsigned long variant{937};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmFieldTable,SgAsmJvmFieldPtrList,&SgAsmJvmFieldTable::p_fields>>;
};
template <> struct node_from_variant_t<937> { using type = SgAsmJvmFieldTable; };

// Class: AsmJvmExceptionHandler
template <> struct describe_field_t<SgAsmJvmExceptionHandler,uint16_t,&SgAsmJvmExceptionHandler::p_start_pc> {
  using parent = SgAsmJvmExceptionHandler;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"start_pc"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmExceptionHandler::p_start_pc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmExceptionHandler, uint16_t SgAsmJvmExceptionHandler::*, &SgAsmJvmExceptionHandler::p_start_pc>;
};
template <> struct describe_field_t<SgAsmJvmExceptionHandler,uint16_t,&SgAsmJvmExceptionHandler::p_end_pc> {
  using parent = SgAsmJvmExceptionHandler;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"end_pc"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmExceptionHandler::p_end_pc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmExceptionHandler, uint16_t SgAsmJvmExceptionHandler::*, &SgAsmJvmExceptionHandler::p_end_pc>;
};
template <> struct describe_field_t<SgAsmJvmExceptionHandler,uint16_t,&SgAsmJvmExceptionHandler::p_handler_pc> {
  using parent = SgAsmJvmExceptionHandler;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"handler_pc"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmExceptionHandler::p_handler_pc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmExceptionHandler, uint16_t SgAsmJvmExceptionHandler::*, &SgAsmJvmExceptionHandler::p_handler_pc>;
};
template <> struct describe_field_t<SgAsmJvmExceptionHandler,uint16_t,&SgAsmJvmExceptionHandler::p_catch_type> {
  using parent = SgAsmJvmExceptionHandler;
  using field_type = uint16_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"catch_type"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmExceptionHandler::p_catch_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmExceptionHandler, uint16_t SgAsmJvmExceptionHandler::*, &SgAsmJvmExceptionHandler::p_catch_type>;
};
template <> struct describe_node_t<SgAsmJvmExceptionHandler> {
  using node = SgAsmJvmExceptionHandler;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmExceptionHandler"};
  static constexpr unsigned long variant{938};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmExceptionHandler,uint16_t,&SgAsmJvmExceptionHandler::p_start_pc>, describe_field_t<SgAsmJvmExceptionHandler,uint16_t,&SgAsmJvmExceptionHandler::p_end_pc>, describe_field_t<SgAsmJvmExceptionHandler,uint16_t,&SgAsmJvmExceptionHandler::p_handler_pc>, describe_field_t<SgAsmJvmExceptionHandler,uint16_t,&SgAsmJvmExceptionHandler::p_catch_type>>;
};
template <> struct node_from_variant_t<938> { using type = SgAsmJvmExceptionHandler; };

// Class: AsmJvmExceptionTable
template <> struct describe_field_t<SgAsmJvmExceptionTable,SgAsmJvmExceptionHandlerPtrList,&SgAsmJvmExceptionTable::p_handlers> {
  using parent = SgAsmJvmExceptionTable;
  using field_type = SgAsmJvmExceptionHandlerPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"handlers"};
  static constexpr char const * const typestr{"SgAsmJvmExceptionHandlerPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmExceptionTable::p_handlers};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmExceptionTable, SgAsmJvmExceptionHandlerPtrList SgAsmJvmExceptionTable::*, &SgAsmJvmExceptionTable::p_handlers>;
};
template <> struct describe_node_t<SgAsmJvmExceptionTable> {
  using node = SgAsmJvmExceptionTable;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmExceptionTable"};
  static constexpr unsigned long variant{939};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmExceptionTable,SgAsmJvmExceptionHandlerPtrList,&SgAsmJvmExceptionTable::p_handlers>>;
};
template <> struct node_from_variant_t<939> { using type = SgAsmJvmExceptionTable; };

// Class: AsmJvmClass
template <> struct describe_node_t<SgAsmJvmClass> {
  using node = SgAsmJvmClass;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmClass"};
  static constexpr unsigned long variant{940};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<940> { using type = SgAsmJvmClass; };

// Class: AsmJvmLineNumberEntry
template <> struct describe_field_t<SgAsmJvmLineNumberEntry,uint16_t,&SgAsmJvmLineNumberEntry::p_start_pc> {
  using parent = SgAsmJvmLineNumberEntry;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"start_pc"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLineNumberEntry::p_start_pc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLineNumberEntry, uint16_t SgAsmJvmLineNumberEntry::*, &SgAsmJvmLineNumberEntry::p_start_pc>;
};
template <> struct describe_field_t<SgAsmJvmLineNumberEntry,uint16_t,&SgAsmJvmLineNumberEntry::p_line_number> {
  using parent = SgAsmJvmLineNumberEntry;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"line_number"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLineNumberEntry::p_line_number};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLineNumberEntry, uint16_t SgAsmJvmLineNumberEntry::*, &SgAsmJvmLineNumberEntry::p_line_number>;
};
template <> struct describe_node_t<SgAsmJvmLineNumberEntry> {
  using node = SgAsmJvmLineNumberEntry;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmLineNumberEntry"};
  static constexpr unsigned long variant{941};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmLineNumberEntry,uint16_t,&SgAsmJvmLineNumberEntry::p_start_pc>, describe_field_t<SgAsmJvmLineNumberEntry,uint16_t,&SgAsmJvmLineNumberEntry::p_line_number>>;
};
template <> struct node_from_variant_t<941> { using type = SgAsmJvmLineNumberEntry; };

// Class: AsmJvmLineNumberTable
template <> struct describe_field_t<SgAsmJvmLineNumberTable,SgAsmJvmLineNumberEntryPtrList,&SgAsmJvmLineNumberTable::p_line_number_table> {
  using parent = SgAsmJvmLineNumberTable;
  using field_type = SgAsmJvmLineNumberEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"line_number_table"};
  static constexpr char const * const typestr{"SgAsmJvmLineNumberEntryPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLineNumberTable::p_line_number_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLineNumberTable, SgAsmJvmLineNumberEntryPtrList SgAsmJvmLineNumberTable::*, &SgAsmJvmLineNumberTable::p_line_number_table>;
};
template <> struct describe_node_t<SgAsmJvmLineNumberTable> {
  using node = SgAsmJvmLineNumberTable;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmLineNumberTable"};
  static constexpr unsigned long variant{942};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmLineNumberTable,SgAsmJvmLineNumberEntryPtrList,&SgAsmJvmLineNumberTable::p_line_number_table>>;
};
template <> struct node_from_variant_t<942> { using type = SgAsmJvmLineNumberTable; };

// Class: AsmJvmInnerClassesEntry
template <> struct describe_field_t<SgAsmJvmInnerClassesEntry,uint16_t,&SgAsmJvmInnerClassesEntry::p_inner_class_info_index> {
  using parent = SgAsmJvmInnerClassesEntry;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"inner_class_info_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmInnerClassesEntry::p_inner_class_info_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmInnerClassesEntry, uint16_t SgAsmJvmInnerClassesEntry::*, &SgAsmJvmInnerClassesEntry::p_inner_class_info_index>;
};
template <> struct describe_field_t<SgAsmJvmInnerClassesEntry,uint16_t,&SgAsmJvmInnerClassesEntry::p_outer_class_info_index> {
  using parent = SgAsmJvmInnerClassesEntry;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"outer_class_info_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmInnerClassesEntry::p_outer_class_info_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmInnerClassesEntry, uint16_t SgAsmJvmInnerClassesEntry::*, &SgAsmJvmInnerClassesEntry::p_outer_class_info_index>;
};
template <> struct describe_field_t<SgAsmJvmInnerClassesEntry,uint16_t,&SgAsmJvmInnerClassesEntry::p_inner_name_index> {
  using parent = SgAsmJvmInnerClassesEntry;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"inner_name_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmInnerClassesEntry::p_inner_name_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmInnerClassesEntry, uint16_t SgAsmJvmInnerClassesEntry::*, &SgAsmJvmInnerClassesEntry::p_inner_name_index>;
};
template <> struct describe_field_t<SgAsmJvmInnerClassesEntry,uint16_t,&SgAsmJvmInnerClassesEntry::p_inner_class_access_flags> {
  using parent = SgAsmJvmInnerClassesEntry;
  using field_type = uint16_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"inner_class_access_flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmInnerClassesEntry::p_inner_class_access_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmInnerClassesEntry, uint16_t SgAsmJvmInnerClassesEntry::*, &SgAsmJvmInnerClassesEntry::p_inner_class_access_flags>;
};
template <> struct describe_node_t<SgAsmJvmInnerClassesEntry> {
  using node = SgAsmJvmInnerClassesEntry;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmInnerClassesEntry"};
  static constexpr unsigned long variant{943};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmInnerClassesEntry,uint16_t,&SgAsmJvmInnerClassesEntry::p_inner_class_info_index>, describe_field_t<SgAsmJvmInnerClassesEntry,uint16_t,&SgAsmJvmInnerClassesEntry::p_outer_class_info_index>, describe_field_t<SgAsmJvmInnerClassesEntry,uint16_t,&SgAsmJvmInnerClassesEntry::p_inner_name_index>, describe_field_t<SgAsmJvmInnerClassesEntry,uint16_t,&SgAsmJvmInnerClassesEntry::p_inner_class_access_flags>>;
};
template <> struct node_from_variant_t<943> { using type = SgAsmJvmInnerClassesEntry; };

// Class: AsmJvmInnerClasses
template <> struct describe_field_t<SgAsmJvmInnerClasses,SgAsmJvmInnerClassesEntryPtrList,&SgAsmJvmInnerClasses::p_classes> {
  using parent = SgAsmJvmInnerClasses;
  using field_type = SgAsmJvmInnerClassesEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"classes"};
  static constexpr char const * const typestr{"SgAsmJvmInnerClassesEntryPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmInnerClasses::p_classes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmInnerClasses, SgAsmJvmInnerClassesEntryPtrList SgAsmJvmInnerClasses::*, &SgAsmJvmInnerClasses::p_classes>;
};
template <> struct describe_node_t<SgAsmJvmInnerClasses> {
  using node = SgAsmJvmInnerClasses;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmInnerClasses"};
  static constexpr unsigned long variant{944};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmInnerClasses,SgAsmJvmInnerClassesEntryPtrList,&SgAsmJvmInnerClasses::p_classes>>;
};
template <> struct node_from_variant_t<944> { using type = SgAsmJvmInnerClasses; };

// Class: AsmCilInstruction
template <> struct describe_field_t<SgAsmCilInstruction,Rose::BinaryAnalysis::CilInstructionKind,&SgAsmCilInstruction::p_kind> {
  using parent = SgAsmCilInstruction;
  using field_type = Rose::BinaryAnalysis::CilInstructionKind;
  static constexpr size_t position{0};
  static constexpr char const * const name{"kind"};
  static constexpr char const * const typestr{"Rose::BinaryAnalysis::CilInstructionKind"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilInstruction::p_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilInstruction, Rose::BinaryAnalysis::CilInstructionKind SgAsmCilInstruction::*, &SgAsmCilInstruction::p_kind>;
};
template <> struct describe_node_t<SgAsmCilInstruction> {
  using node = SgAsmCilInstruction;
  using base = SgAsmInstruction;
  static constexpr char const * const name{"AsmCilInstruction"};
  static constexpr unsigned long variant{945};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilInstruction,Rose::BinaryAnalysis::CilInstructionKind,&SgAsmCilInstruction::p_kind>>;
};
template <> struct node_from_variant_t<945> { using type = SgAsmCilInstruction; };

// Class: AsmStackExpression
template <> struct describe_field_t<SgAsmStackExpression,int,&SgAsmStackExpression::p_stackPosition> {
  using parent = SgAsmStackExpression;
  using field_type = int;
  static constexpr size_t position{0};
  static constexpr char const * const name{"stackPosition"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmStackExpression::p_stackPosition};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmStackExpression, int SgAsmStackExpression::*, &SgAsmStackExpression::p_stackPosition>;
};
template <> struct describe_node_t<SgAsmStackExpression> {
  using node = SgAsmStackExpression;
  using base = SgAsmExpression;
  static constexpr char const * const name{"AsmStackExpression"};
  static constexpr unsigned long variant{946};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmStackExpression,int,&SgAsmStackExpression::p_stackPosition>>;
};
template <> struct node_from_variant_t<946> { using type = SgAsmStackExpression; };

// Class: AsmJvmEnclosingMethod
template <> struct describe_field_t<SgAsmJvmEnclosingMethod,uint16_t,&SgAsmJvmEnclosingMethod::p_class_index> {
  using parent = SgAsmJvmEnclosingMethod;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"class_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmEnclosingMethod::p_class_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmEnclosingMethod, uint16_t SgAsmJvmEnclosingMethod::*, &SgAsmJvmEnclosingMethod::p_class_index>;
};
template <> struct describe_field_t<SgAsmJvmEnclosingMethod,uint16_t,&SgAsmJvmEnclosingMethod::p_method_index> {
  using parent = SgAsmJvmEnclosingMethod;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"method_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmEnclosingMethod::p_method_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmEnclosingMethod, uint16_t SgAsmJvmEnclosingMethod::*, &SgAsmJvmEnclosingMethod::p_method_index>;
};
template <> struct describe_node_t<SgAsmJvmEnclosingMethod> {
  using node = SgAsmJvmEnclosingMethod;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmEnclosingMethod"};
  static constexpr unsigned long variant{947};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmEnclosingMethod,uint16_t,&SgAsmJvmEnclosingMethod::p_class_index>, describe_field_t<SgAsmJvmEnclosingMethod,uint16_t,&SgAsmJvmEnclosingMethod::p_method_index>>;
};
template <> struct node_from_variant_t<947> { using type = SgAsmJvmEnclosingMethod; };

// Class: AdaNullConstraint
template <> struct describe_node_t<SgAdaNullConstraint> {
  using node = SgAdaNullConstraint;
  using base = SgAdaTypeConstraint;
  static constexpr char const * const name{"AdaNullConstraint"};
  static constexpr unsigned long variant{948};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<948> { using type = SgAdaNullConstraint; };

// Class: AsmJvmModuleMainClass
template <> struct describe_field_t<SgAsmJvmModuleMainClass,uint16_t,&SgAsmJvmModuleMainClass::p_main_class_index> {
  using parent = SgAsmJvmModuleMainClass;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"main_class_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmModuleMainClass::p_main_class_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmModuleMainClass, uint16_t SgAsmJvmModuleMainClass::*, &SgAsmJvmModuleMainClass::p_main_class_index>;
};
template <> struct describe_node_t<SgAsmJvmModuleMainClass> {
  using node = SgAsmJvmModuleMainClass;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmModuleMainClass"};
  static constexpr unsigned long variant{949};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmModuleMainClass,uint16_t,&SgAsmJvmModuleMainClass::p_main_class_index>>;
};
template <> struct node_from_variant_t<949> { using type = SgAsmJvmModuleMainClass; };

// Class: AsmInstructionList
template <> struct describe_field_t<SgAsmInstructionList,SgAsmInstructionPtrList,&SgAsmInstructionList::p_instructions> {
  using parent = SgAsmInstructionList;
  using field_type = SgAsmInstructionPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"instructions"};
  static constexpr char const * const typestr{"SgAsmInstructionPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmInstructionList::p_instructions};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmInstructionList, SgAsmInstructionPtrList SgAsmInstructionList::*, &SgAsmInstructionList::p_instructions>;
};
template <> struct describe_node_t<SgAsmInstructionList> {
  using node = SgAsmInstructionList;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmInstructionList"};
  static constexpr unsigned long variant{950};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmInstructionList,SgAsmInstructionPtrList,&SgAsmInstructionList::p_instructions>>;
};
template <> struct node_from_variant_t<950> { using type = SgAsmInstructionList; };

// Class: AsmCilNode
template <> struct describe_node_t<SgAsmCilNode> {
  using node = SgAsmCilNode;
  using base = SgAsmNode;
  static constexpr char const * const name{"AsmCilNode"};
  static constexpr unsigned long variant{951};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmCilDataStream, SgAsmCilExceptionData, SgAsmCilMetadata, SgAsmCilMetadataRoot, SgAsmCilMethodData>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<951> { using type = SgAsmCilNode; };

// Class: AsmCilAssembly
template <> struct describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_HashAlgId> {
  using parent = SgAsmCilAssembly;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"HashAlgId"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssembly::p_HashAlgId};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssembly, uint32_t SgAsmCilAssembly::*, &SgAsmCilAssembly::p_HashAlgId>;
};
template <> struct describe_field_t<SgAsmCilAssembly,uint16_t,&SgAsmCilAssembly::p_MajorVersion> {
  using parent = SgAsmCilAssembly;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"MajorVersion"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssembly::p_MajorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssembly, uint16_t SgAsmCilAssembly::*, &SgAsmCilAssembly::p_MajorVersion>;
};
template <> struct describe_field_t<SgAsmCilAssembly,uint16_t,&SgAsmCilAssembly::p_MinorVersion> {
  using parent = SgAsmCilAssembly;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"MinorVersion"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssembly::p_MinorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssembly, uint16_t SgAsmCilAssembly::*, &SgAsmCilAssembly::p_MinorVersion>;
};
template <> struct describe_field_t<SgAsmCilAssembly,uint16_t,&SgAsmCilAssembly::p_BuildNumber> {
  using parent = SgAsmCilAssembly;
  using field_type = uint16_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"BuildNumber"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssembly::p_BuildNumber};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssembly, uint16_t SgAsmCilAssembly::*, &SgAsmCilAssembly::p_BuildNumber>;
};
template <> struct describe_field_t<SgAsmCilAssembly,uint16_t,&SgAsmCilAssembly::p_RevisionNumber> {
  using parent = SgAsmCilAssembly;
  using field_type = uint16_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"RevisionNumber"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssembly::p_RevisionNumber};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssembly, uint16_t SgAsmCilAssembly::*, &SgAsmCilAssembly::p_RevisionNumber>;
};
template <> struct describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_Flags> {
  using parent = SgAsmCilAssembly;
  using field_type = uint32_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssembly::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssembly, uint32_t SgAsmCilAssembly::*, &SgAsmCilAssembly::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_PublicKey> {
  using parent = SgAsmCilAssembly;
  using field_type = uint32_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"PublicKey"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssembly::p_PublicKey};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssembly, uint32_t SgAsmCilAssembly::*, &SgAsmCilAssembly::p_PublicKey>;
};
template <> struct describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_Name> {
  using parent = SgAsmCilAssembly;
  using field_type = uint32_t;
  static constexpr size_t position{7};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssembly::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssembly, uint32_t SgAsmCilAssembly::*, &SgAsmCilAssembly::p_Name>;
};
template <> struct describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_Culture> {
  using parent = SgAsmCilAssembly;
  using field_type = uint32_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"Culture"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssembly::p_Culture};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssembly, uint32_t SgAsmCilAssembly::*, &SgAsmCilAssembly::p_Culture>;
};
template <> struct describe_node_t<SgAsmCilAssembly> {
  using node = SgAsmCilAssembly;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssembly"};
  static constexpr unsigned long variant{952};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_HashAlgId>, describe_field_t<SgAsmCilAssembly,uint16_t,&SgAsmCilAssembly::p_MajorVersion>, describe_field_t<SgAsmCilAssembly,uint16_t,&SgAsmCilAssembly::p_MinorVersion>, describe_field_t<SgAsmCilAssembly,uint16_t,&SgAsmCilAssembly::p_BuildNumber>, describe_field_t<SgAsmCilAssembly,uint16_t,&SgAsmCilAssembly::p_RevisionNumber>, describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_Flags>, describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_PublicKey>, describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_Name>, describe_field_t<SgAsmCilAssembly,uint32_t,&SgAsmCilAssembly::p_Culture>>;
};
template <> struct node_from_variant_t<952> { using type = SgAsmCilAssembly; };

// Class: AsmCilAssemblyOS
template <> struct describe_field_t<SgAsmCilAssemblyOS,uint32_t,&SgAsmCilAssemblyOS::p_OSPlatformID> {
  using parent = SgAsmCilAssemblyOS;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"OSPlatformID"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyOS::p_OSPlatformID};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyOS, uint32_t SgAsmCilAssemblyOS::*, &SgAsmCilAssemblyOS::p_OSPlatformID>;
};
template <> struct describe_field_t<SgAsmCilAssemblyOS,uint32_t,&SgAsmCilAssemblyOS::p_OSMajorVersion> {
  using parent = SgAsmCilAssemblyOS;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"OSMajorVersion"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyOS::p_OSMajorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyOS, uint32_t SgAsmCilAssemblyOS::*, &SgAsmCilAssemblyOS::p_OSMajorVersion>;
};
template <> struct describe_field_t<SgAsmCilAssemblyOS,uint32_t,&SgAsmCilAssemblyOS::p_OSMinorVersion> {
  using parent = SgAsmCilAssemblyOS;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"OSMinorVersion"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyOS::p_OSMinorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyOS, uint32_t SgAsmCilAssemblyOS::*, &SgAsmCilAssemblyOS::p_OSMinorVersion>;
};
template <> struct describe_node_t<SgAsmCilAssemblyOS> {
  using node = SgAsmCilAssemblyOS;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyOS"};
  static constexpr unsigned long variant{953};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyOS,uint32_t,&SgAsmCilAssemblyOS::p_OSPlatformID>, describe_field_t<SgAsmCilAssemblyOS,uint32_t,&SgAsmCilAssemblyOS::p_OSMajorVersion>, describe_field_t<SgAsmCilAssemblyOS,uint32_t,&SgAsmCilAssemblyOS::p_OSMinorVersion>>;
};
template <> struct node_from_variant_t<953> { using type = SgAsmCilAssemblyOS; };

// Class: AsmCilAssemblyProcessor
template <> struct describe_field_t<SgAsmCilAssemblyProcessor,uint32_t,&SgAsmCilAssemblyProcessor::p_Processor> {
  using parent = SgAsmCilAssemblyProcessor;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Processor"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyProcessor::p_Processor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyProcessor, uint32_t SgAsmCilAssemblyProcessor::*, &SgAsmCilAssemblyProcessor::p_Processor>;
};
template <> struct describe_node_t<SgAsmCilAssemblyProcessor> {
  using node = SgAsmCilAssemblyProcessor;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyProcessor"};
  static constexpr unsigned long variant{954};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyProcessor,uint32_t,&SgAsmCilAssemblyProcessor::p_Processor>>;
};
template <> struct node_from_variant_t<954> { using type = SgAsmCilAssemblyProcessor; };

// Class: AsmCilAssemblyRef
template <> struct describe_field_t<SgAsmCilAssemblyRef,uint16_t,&SgAsmCilAssemblyRef::p_MajorVersion> {
  using parent = SgAsmCilAssemblyRef;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"MajorVersion"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRef::p_MajorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRef, uint16_t SgAsmCilAssemblyRef::*, &SgAsmCilAssemblyRef::p_MajorVersion>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRef,uint16_t,&SgAsmCilAssemblyRef::p_MinorVersion> {
  using parent = SgAsmCilAssemblyRef;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"MinorVersion"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRef::p_MinorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRef, uint16_t SgAsmCilAssemblyRef::*, &SgAsmCilAssemblyRef::p_MinorVersion>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRef,uint16_t,&SgAsmCilAssemblyRef::p_BuildNumber> {
  using parent = SgAsmCilAssemblyRef;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"BuildNumber"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRef::p_BuildNumber};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRef, uint16_t SgAsmCilAssemblyRef::*, &SgAsmCilAssemblyRef::p_BuildNumber>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRef,uint16_t,&SgAsmCilAssemblyRef::p_RevisionNumber> {
  using parent = SgAsmCilAssemblyRef;
  using field_type = uint16_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"RevisionNumber"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRef::p_RevisionNumber};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRef, uint16_t SgAsmCilAssemblyRef::*, &SgAsmCilAssemblyRef::p_RevisionNumber>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_Flags> {
  using parent = SgAsmCilAssemblyRef;
  using field_type = uint32_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRef::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRef, uint32_t SgAsmCilAssemblyRef::*, &SgAsmCilAssemblyRef::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_PublicKeyOrToken> {
  using parent = SgAsmCilAssemblyRef;
  using field_type = uint32_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"PublicKeyOrToken"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRef::p_PublicKeyOrToken};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRef, uint32_t SgAsmCilAssemblyRef::*, &SgAsmCilAssemblyRef::p_PublicKeyOrToken>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_Name> {
  using parent = SgAsmCilAssemblyRef;
  using field_type = uint32_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRef::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRef, uint32_t SgAsmCilAssemblyRef::*, &SgAsmCilAssemblyRef::p_Name>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_Culture> {
  using parent = SgAsmCilAssemblyRef;
  using field_type = uint32_t;
  static constexpr size_t position{7};
  static constexpr char const * const name{"Culture"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRef::p_Culture};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRef, uint32_t SgAsmCilAssemblyRef::*, &SgAsmCilAssemblyRef::p_Culture>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_HashValue> {
  using parent = SgAsmCilAssemblyRef;
  using field_type = uint32_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"HashValue"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRef::p_HashValue};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRef, uint32_t SgAsmCilAssemblyRef::*, &SgAsmCilAssemblyRef::p_HashValue>;
};
template <> struct describe_node_t<SgAsmCilAssemblyRef> {
  using node = SgAsmCilAssemblyRef;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyRef"};
  static constexpr unsigned long variant{955};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyRef,uint16_t,&SgAsmCilAssemblyRef::p_MajorVersion>, describe_field_t<SgAsmCilAssemblyRef,uint16_t,&SgAsmCilAssemblyRef::p_MinorVersion>, describe_field_t<SgAsmCilAssemblyRef,uint16_t,&SgAsmCilAssemblyRef::p_BuildNumber>, describe_field_t<SgAsmCilAssemblyRef,uint16_t,&SgAsmCilAssemblyRef::p_RevisionNumber>, describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_Flags>, describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_PublicKeyOrToken>, describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_Name>, describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_Culture>, describe_field_t<SgAsmCilAssemblyRef,uint32_t,&SgAsmCilAssemblyRef::p_HashValue>>;
};
template <> struct node_from_variant_t<955> { using type = SgAsmCilAssemblyRef; };

// Class: AsmCilAssemblyRefOS
template <> struct describe_field_t<SgAsmCilAssemblyRefOS,uint32_t,&SgAsmCilAssemblyRefOS::p_OSPlatformID> {
  using parent = SgAsmCilAssemblyRefOS;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"OSPlatformID"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRefOS::p_OSPlatformID};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRefOS, uint32_t SgAsmCilAssemblyRefOS::*, &SgAsmCilAssemblyRefOS::p_OSPlatformID>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRefOS,uint32_t,&SgAsmCilAssemblyRefOS::p_OSMajorVersion> {
  using parent = SgAsmCilAssemblyRefOS;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"OSMajorVersion"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRefOS::p_OSMajorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRefOS, uint32_t SgAsmCilAssemblyRefOS::*, &SgAsmCilAssemblyRefOS::p_OSMajorVersion>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRefOS,uint32_t,&SgAsmCilAssemblyRefOS::p_OSMinorVersion> {
  using parent = SgAsmCilAssemblyRefOS;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"OSMinorVersion"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRefOS::p_OSMinorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRefOS, uint32_t SgAsmCilAssemblyRefOS::*, &SgAsmCilAssemblyRefOS::p_OSMinorVersion>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRefOS,uint32_t,&SgAsmCilAssemblyRefOS::p_AssemblyRefOS> {
  using parent = SgAsmCilAssemblyRefOS;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"AssemblyRefOS"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRefOS::p_AssemblyRefOS};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRefOS, uint32_t SgAsmCilAssemblyRefOS::*, &SgAsmCilAssemblyRefOS::p_AssemblyRefOS>;
};
template <> struct describe_node_t<SgAsmCilAssemblyRefOS> {
  using node = SgAsmCilAssemblyRefOS;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyRefOS"};
  static constexpr unsigned long variant{956};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyRefOS,uint32_t,&SgAsmCilAssemblyRefOS::p_OSPlatformID>, describe_field_t<SgAsmCilAssemblyRefOS,uint32_t,&SgAsmCilAssemblyRefOS::p_OSMajorVersion>, describe_field_t<SgAsmCilAssemblyRefOS,uint32_t,&SgAsmCilAssemblyRefOS::p_OSMinorVersion>, describe_field_t<SgAsmCilAssemblyRefOS,uint32_t,&SgAsmCilAssemblyRefOS::p_AssemblyRefOS>>;
};
template <> struct node_from_variant_t<956> { using type = SgAsmCilAssemblyRefOS; };

// Class: AsmCilAssemblyRefProcessor
template <> struct describe_field_t<SgAsmCilAssemblyRefProcessor,uint32_t,&SgAsmCilAssemblyRefProcessor::p_Processor> {
  using parent = SgAsmCilAssemblyRefProcessor;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Processor"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRefProcessor::p_Processor};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRefProcessor, uint32_t SgAsmCilAssemblyRefProcessor::*, &SgAsmCilAssemblyRefProcessor::p_Processor>;
};
template <> struct describe_field_t<SgAsmCilAssemblyRefProcessor,uint32_t,&SgAsmCilAssemblyRefProcessor::p_AssemblyRef> {
  using parent = SgAsmCilAssemblyRefProcessor;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"AssemblyRef"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRefProcessor::p_AssemblyRef};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRefProcessor, uint32_t SgAsmCilAssemblyRefProcessor::*, &SgAsmCilAssemblyRefProcessor::p_AssemblyRef>;
};
template <> struct describe_node_t<SgAsmCilAssemblyRefProcessor> {
  using node = SgAsmCilAssemblyRefProcessor;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyRefProcessor"};
  static constexpr unsigned long variant{957};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyRefProcessor,uint32_t,&SgAsmCilAssemblyRefProcessor::p_Processor>, describe_field_t<SgAsmCilAssemblyRefProcessor,uint32_t,&SgAsmCilAssemblyRefProcessor::p_AssemblyRef>>;
};
template <> struct node_from_variant_t<957> { using type = SgAsmCilAssemblyRefProcessor; };

// Class: AsmCilClassLayout
template <> struct describe_field_t<SgAsmCilClassLayout,uint16_t,&SgAsmCilClassLayout::p_PackingSize> {
  using parent = SgAsmCilClassLayout;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"PackingSize"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilClassLayout::p_PackingSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilClassLayout, uint16_t SgAsmCilClassLayout::*, &SgAsmCilClassLayout::p_PackingSize>;
};
template <> struct describe_field_t<SgAsmCilClassLayout,uint32_t,&SgAsmCilClassLayout::p_ClassSize> {
  using parent = SgAsmCilClassLayout;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"ClassSize"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilClassLayout::p_ClassSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilClassLayout, uint32_t SgAsmCilClassLayout::*, &SgAsmCilClassLayout::p_ClassSize>;
};
template <> struct describe_field_t<SgAsmCilClassLayout,uint32_t,&SgAsmCilClassLayout::p_Parent> {
  using parent = SgAsmCilClassLayout;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Parent"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilClassLayout::p_Parent};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilClassLayout, uint32_t SgAsmCilClassLayout::*, &SgAsmCilClassLayout::p_Parent>;
};
template <> struct describe_node_t<SgAsmCilClassLayout> {
  using node = SgAsmCilClassLayout;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilClassLayout"};
  static constexpr unsigned long variant{958};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilClassLayout,uint16_t,&SgAsmCilClassLayout::p_PackingSize>, describe_field_t<SgAsmCilClassLayout,uint32_t,&SgAsmCilClassLayout::p_ClassSize>, describe_field_t<SgAsmCilClassLayout,uint32_t,&SgAsmCilClassLayout::p_Parent>>;
};
template <> struct node_from_variant_t<958> { using type = SgAsmCilClassLayout; };

// Class: AsmCilConstant
template <> struct describe_field_t<SgAsmCilConstant,uint8_t,&SgAsmCilConstant::p_Type> {
  using parent = SgAsmCilConstant;
  using field_type = uint8_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Type"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilConstant::p_Type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilConstant, uint8_t SgAsmCilConstant::*, &SgAsmCilConstant::p_Type>;
};
template <> struct describe_field_t<SgAsmCilConstant,uint8_t,&SgAsmCilConstant::p_Padding> {
  using parent = SgAsmCilConstant;
  using field_type = uint8_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Padding"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilConstant::p_Padding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilConstant, uint8_t SgAsmCilConstant::*, &SgAsmCilConstant::p_Padding>;
};
template <> struct describe_field_t<SgAsmCilConstant,uint32_t,&SgAsmCilConstant::p_Parent> {
  using parent = SgAsmCilConstant;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Parent"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilConstant::p_Parent};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilConstant, uint32_t SgAsmCilConstant::*, &SgAsmCilConstant::p_Parent>;
};
template <> struct describe_field_t<SgAsmCilConstant,uint32_t,&SgAsmCilConstant::p_Value> {
  using parent = SgAsmCilConstant;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"Value"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilConstant::p_Value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilConstant, uint32_t SgAsmCilConstant::*, &SgAsmCilConstant::p_Value>;
};
template <> struct describe_node_t<SgAsmCilConstant> {
  using node = SgAsmCilConstant;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilConstant"};
  static constexpr unsigned long variant{959};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilConstant,uint8_t,&SgAsmCilConstant::p_Type>, describe_field_t<SgAsmCilConstant,uint8_t,&SgAsmCilConstant::p_Padding>, describe_field_t<SgAsmCilConstant,uint32_t,&SgAsmCilConstant::p_Parent>, describe_field_t<SgAsmCilConstant,uint32_t,&SgAsmCilConstant::p_Value>>;
};
template <> struct node_from_variant_t<959> { using type = SgAsmCilConstant; };

// Class: AsmCilCustomAttribute
template <> struct describe_field_t<SgAsmCilCustomAttribute,uint32_t,&SgAsmCilCustomAttribute::p_Parent> {
  using parent = SgAsmCilCustomAttribute;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Parent"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilCustomAttribute::p_Parent};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilCustomAttribute, uint32_t SgAsmCilCustomAttribute::*, &SgAsmCilCustomAttribute::p_Parent>;
};
template <> struct describe_field_t<SgAsmCilCustomAttribute,uint32_t,&SgAsmCilCustomAttribute::p_Type> {
  using parent = SgAsmCilCustomAttribute;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Type"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilCustomAttribute::p_Type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilCustomAttribute, uint32_t SgAsmCilCustomAttribute::*, &SgAsmCilCustomAttribute::p_Type>;
};
template <> struct describe_field_t<SgAsmCilCustomAttribute,uint32_t,&SgAsmCilCustomAttribute::p_Value> {
  using parent = SgAsmCilCustomAttribute;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Value"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilCustomAttribute::p_Value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilCustomAttribute, uint32_t SgAsmCilCustomAttribute::*, &SgAsmCilCustomAttribute::p_Value>;
};
template <> struct describe_node_t<SgAsmCilCustomAttribute> {
  using node = SgAsmCilCustomAttribute;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilCustomAttribute"};
  static constexpr unsigned long variant{960};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilCustomAttribute,uint32_t,&SgAsmCilCustomAttribute::p_Parent>, describe_field_t<SgAsmCilCustomAttribute,uint32_t,&SgAsmCilCustomAttribute::p_Type>, describe_field_t<SgAsmCilCustomAttribute,uint32_t,&SgAsmCilCustomAttribute::p_Value>>;
};
template <> struct node_from_variant_t<960> { using type = SgAsmCilCustomAttribute; };

// Class: AsmCilDeclSecurity
template <> struct describe_field_t<SgAsmCilDeclSecurity,uint16_t,&SgAsmCilDeclSecurity::p_Action> {
  using parent = SgAsmCilDeclSecurity;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Action"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilDeclSecurity::p_Action};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilDeclSecurity, uint16_t SgAsmCilDeclSecurity::*, &SgAsmCilDeclSecurity::p_Action>;
};
template <> struct describe_field_t<SgAsmCilDeclSecurity,uint32_t,&SgAsmCilDeclSecurity::p_Parent> {
  using parent = SgAsmCilDeclSecurity;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Parent"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilDeclSecurity::p_Parent};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilDeclSecurity, uint32_t SgAsmCilDeclSecurity::*, &SgAsmCilDeclSecurity::p_Parent>;
};
template <> struct describe_field_t<SgAsmCilDeclSecurity,uint32_t,&SgAsmCilDeclSecurity::p_PermissionSet> {
  using parent = SgAsmCilDeclSecurity;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"PermissionSet"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilDeclSecurity::p_PermissionSet};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilDeclSecurity, uint32_t SgAsmCilDeclSecurity::*, &SgAsmCilDeclSecurity::p_PermissionSet>;
};
template <> struct describe_node_t<SgAsmCilDeclSecurity> {
  using node = SgAsmCilDeclSecurity;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilDeclSecurity"};
  static constexpr unsigned long variant{961};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilDeclSecurity,uint16_t,&SgAsmCilDeclSecurity::p_Action>, describe_field_t<SgAsmCilDeclSecurity,uint32_t,&SgAsmCilDeclSecurity::p_Parent>, describe_field_t<SgAsmCilDeclSecurity,uint32_t,&SgAsmCilDeclSecurity::p_PermissionSet>>;
};
template <> struct node_from_variant_t<961> { using type = SgAsmCilDeclSecurity; };

// Class: AsmCilEvent
template <> struct describe_field_t<SgAsmCilEvent,uint16_t,&SgAsmCilEvent::p_EventFlags> {
  using parent = SgAsmCilEvent;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"EventFlags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilEvent::p_EventFlags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilEvent, uint16_t SgAsmCilEvent::*, &SgAsmCilEvent::p_EventFlags>;
};
template <> struct describe_field_t<SgAsmCilEvent,uint32_t,&SgAsmCilEvent::p_Name> {
  using parent = SgAsmCilEvent;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilEvent::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilEvent, uint32_t SgAsmCilEvent::*, &SgAsmCilEvent::p_Name>;
};
template <> struct describe_field_t<SgAsmCilEvent,uint32_t,&SgAsmCilEvent::p_EventType> {
  using parent = SgAsmCilEvent;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"EventType"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilEvent::p_EventType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilEvent, uint32_t SgAsmCilEvent::*, &SgAsmCilEvent::p_EventType>;
};
template <> struct describe_node_t<SgAsmCilEvent> {
  using node = SgAsmCilEvent;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilEvent"};
  static constexpr unsigned long variant{962};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilEvent,uint16_t,&SgAsmCilEvent::p_EventFlags>, describe_field_t<SgAsmCilEvent,uint32_t,&SgAsmCilEvent::p_Name>, describe_field_t<SgAsmCilEvent,uint32_t,&SgAsmCilEvent::p_EventType>>;
};
template <> struct node_from_variant_t<962> { using type = SgAsmCilEvent; };

// Class: AsmCilEventMap
template <> struct describe_field_t<SgAsmCilEventMap,uint32_t,&SgAsmCilEventMap::p_Parent> {
  using parent = SgAsmCilEventMap;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Parent"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilEventMap::p_Parent};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilEventMap, uint32_t SgAsmCilEventMap::*, &SgAsmCilEventMap::p_Parent>;
};
template <> struct describe_field_t<SgAsmCilEventMap,uint32_t,&SgAsmCilEventMap::p_EventList> {
  using parent = SgAsmCilEventMap;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"EventList"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilEventMap::p_EventList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilEventMap, uint32_t SgAsmCilEventMap::*, &SgAsmCilEventMap::p_EventList>;
};
template <> struct describe_node_t<SgAsmCilEventMap> {
  using node = SgAsmCilEventMap;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilEventMap"};
  static constexpr unsigned long variant{963};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilEventMap,uint32_t,&SgAsmCilEventMap::p_Parent>, describe_field_t<SgAsmCilEventMap,uint32_t,&SgAsmCilEventMap::p_EventList>>;
};
template <> struct node_from_variant_t<963> { using type = SgAsmCilEventMap; };

// Class: AsmCilExportedType
template <> struct describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_EventFlags> {
  using parent = SgAsmCilExportedType;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"EventFlags"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExportedType::p_EventFlags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExportedType, uint32_t SgAsmCilExportedType::*, &SgAsmCilExportedType::p_EventFlags>;
};
template <> struct describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_TypeDefIdName> {
  using parent = SgAsmCilExportedType;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"TypeDefIdName"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExportedType::p_TypeDefIdName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExportedType, uint32_t SgAsmCilExportedType::*, &SgAsmCilExportedType::p_TypeDefIdName>;
};
template <> struct describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_TypeName> {
  using parent = SgAsmCilExportedType;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"TypeName"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExportedType::p_TypeName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExportedType, uint32_t SgAsmCilExportedType::*, &SgAsmCilExportedType::p_TypeName>;
};
template <> struct describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_TypeNamespace> {
  using parent = SgAsmCilExportedType;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"TypeNamespace"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExportedType::p_TypeNamespace};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExportedType, uint32_t SgAsmCilExportedType::*, &SgAsmCilExportedType::p_TypeNamespace>;
};
template <> struct describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_Implementation> {
  using parent = SgAsmCilExportedType;
  using field_type = uint32_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"Implementation"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExportedType::p_Implementation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExportedType, uint32_t SgAsmCilExportedType::*, &SgAsmCilExportedType::p_Implementation>;
};
template <> struct describe_node_t<SgAsmCilExportedType> {
  using node = SgAsmCilExportedType;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilExportedType"};
  static constexpr unsigned long variant{964};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_EventFlags>, describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_TypeDefIdName>, describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_TypeName>, describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_TypeNamespace>, describe_field_t<SgAsmCilExportedType,uint32_t,&SgAsmCilExportedType::p_Implementation>>;
};
template <> struct node_from_variant_t<964> { using type = SgAsmCilExportedType; };

// Class: AsmCilField
template <> struct describe_field_t<SgAsmCilField,uint16_t,&SgAsmCilField::p_Flags> {
  using parent = SgAsmCilField;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilField::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilField, uint16_t SgAsmCilField::*, &SgAsmCilField::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilField,uint32_t,&SgAsmCilField::p_Name> {
  using parent = SgAsmCilField;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilField::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilField, uint32_t SgAsmCilField::*, &SgAsmCilField::p_Name>;
};
template <> struct describe_field_t<SgAsmCilField,uint32_t,&SgAsmCilField::p_Signature> {
  using parent = SgAsmCilField;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Signature"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilField::p_Signature};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilField, uint32_t SgAsmCilField::*, &SgAsmCilField::p_Signature>;
};
template <> struct describe_node_t<SgAsmCilField> {
  using node = SgAsmCilField;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilField"};
  static constexpr unsigned long variant{965};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilField,uint16_t,&SgAsmCilField::p_Flags>, describe_field_t<SgAsmCilField,uint32_t,&SgAsmCilField::p_Name>, describe_field_t<SgAsmCilField,uint32_t,&SgAsmCilField::p_Signature>>;
};
template <> struct node_from_variant_t<965> { using type = SgAsmCilField; };

// Class: AsmCilFieldLayout
template <> struct describe_field_t<SgAsmCilFieldLayout,uint32_t,&SgAsmCilFieldLayout::p_Offset> {
  using parent = SgAsmCilFieldLayout;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Offset"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilFieldLayout::p_Offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldLayout, uint32_t SgAsmCilFieldLayout::*, &SgAsmCilFieldLayout::p_Offset>;
};
template <> struct describe_field_t<SgAsmCilFieldLayout,uint32_t,&SgAsmCilFieldLayout::p_Field> {
  using parent = SgAsmCilFieldLayout;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Field"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilFieldLayout::p_Field};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldLayout, uint32_t SgAsmCilFieldLayout::*, &SgAsmCilFieldLayout::p_Field>;
};
template <> struct describe_node_t<SgAsmCilFieldLayout> {
  using node = SgAsmCilFieldLayout;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilFieldLayout"};
  static constexpr unsigned long variant{966};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilFieldLayout,uint32_t,&SgAsmCilFieldLayout::p_Offset>, describe_field_t<SgAsmCilFieldLayout,uint32_t,&SgAsmCilFieldLayout::p_Field>>;
};
template <> struct node_from_variant_t<966> { using type = SgAsmCilFieldLayout; };

// Class: AsmCilFieldMarshal
template <> struct describe_field_t<SgAsmCilFieldMarshal,uint32_t,&SgAsmCilFieldMarshal::p_Parent> {
  using parent = SgAsmCilFieldMarshal;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Parent"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilFieldMarshal::p_Parent};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldMarshal, uint32_t SgAsmCilFieldMarshal::*, &SgAsmCilFieldMarshal::p_Parent>;
};
template <> struct describe_field_t<SgAsmCilFieldMarshal,uint32_t,&SgAsmCilFieldMarshal::p_NativeType> {
  using parent = SgAsmCilFieldMarshal;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"NativeType"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilFieldMarshal::p_NativeType};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldMarshal, uint32_t SgAsmCilFieldMarshal::*, &SgAsmCilFieldMarshal::p_NativeType>;
};
template <> struct describe_node_t<SgAsmCilFieldMarshal> {
  using node = SgAsmCilFieldMarshal;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilFieldMarshal"};
  static constexpr unsigned long variant{967};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilFieldMarshal,uint32_t,&SgAsmCilFieldMarshal::p_Parent>, describe_field_t<SgAsmCilFieldMarshal,uint32_t,&SgAsmCilFieldMarshal::p_NativeType>>;
};
template <> struct node_from_variant_t<967> { using type = SgAsmCilFieldMarshal; };

// Class: AsmCilFieldRVA
template <> struct describe_field_t<SgAsmCilFieldRVA,uint32_t,&SgAsmCilFieldRVA::p_RVA> {
  using parent = SgAsmCilFieldRVA;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"RVA"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilFieldRVA::p_RVA};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldRVA, uint32_t SgAsmCilFieldRVA::*, &SgAsmCilFieldRVA::p_RVA>;
};
template <> struct describe_field_t<SgAsmCilFieldRVA,uint32_t,&SgAsmCilFieldRVA::p_Field> {
  using parent = SgAsmCilFieldRVA;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Field"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilFieldRVA::p_Field};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldRVA, uint32_t SgAsmCilFieldRVA::*, &SgAsmCilFieldRVA::p_Field>;
};
template <> struct describe_node_t<SgAsmCilFieldRVA> {
  using node = SgAsmCilFieldRVA;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilFieldRVA"};
  static constexpr unsigned long variant{968};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilFieldRVA,uint32_t,&SgAsmCilFieldRVA::p_RVA>, describe_field_t<SgAsmCilFieldRVA,uint32_t,&SgAsmCilFieldRVA::p_Field>>;
};
template <> struct node_from_variant_t<968> { using type = SgAsmCilFieldRVA; };

// Class: AsmCilFile
template <> struct describe_field_t<SgAsmCilFile,uint32_t,&SgAsmCilFile::p_Flags> {
  using parent = SgAsmCilFile;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilFile::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFile, uint32_t SgAsmCilFile::*, &SgAsmCilFile::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilFile,uint32_t,&SgAsmCilFile::p_Name> {
  using parent = SgAsmCilFile;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilFile::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFile, uint32_t SgAsmCilFile::*, &SgAsmCilFile::p_Name>;
};
template <> struct describe_field_t<SgAsmCilFile,uint32_t,&SgAsmCilFile::p_HashValue> {
  using parent = SgAsmCilFile;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"HashValue"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilFile::p_HashValue};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFile, uint32_t SgAsmCilFile::*, &SgAsmCilFile::p_HashValue>;
};
template <> struct describe_node_t<SgAsmCilFile> {
  using node = SgAsmCilFile;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilFile"};
  static constexpr unsigned long variant{969};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilFile,uint32_t,&SgAsmCilFile::p_Flags>, describe_field_t<SgAsmCilFile,uint32_t,&SgAsmCilFile::p_Name>, describe_field_t<SgAsmCilFile,uint32_t,&SgAsmCilFile::p_HashValue>>;
};
template <> struct node_from_variant_t<969> { using type = SgAsmCilFile; };

// Class: AsmCilGenericParam
template <> struct describe_field_t<SgAsmCilGenericParam,uint16_t,&SgAsmCilGenericParam::p_Number> {
  using parent = SgAsmCilGenericParam;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Number"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilGenericParam::p_Number};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilGenericParam, uint16_t SgAsmCilGenericParam::*, &SgAsmCilGenericParam::p_Number>;
};
template <> struct describe_field_t<SgAsmCilGenericParam,uint16_t,&SgAsmCilGenericParam::p_Flags> {
  using parent = SgAsmCilGenericParam;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilGenericParam::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilGenericParam, uint16_t SgAsmCilGenericParam::*, &SgAsmCilGenericParam::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilGenericParam,uint32_t,&SgAsmCilGenericParam::p_Owner> {
  using parent = SgAsmCilGenericParam;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Owner"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilGenericParam::p_Owner};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilGenericParam, uint32_t SgAsmCilGenericParam::*, &SgAsmCilGenericParam::p_Owner>;
};
template <> struct describe_field_t<SgAsmCilGenericParam,uint32_t,&SgAsmCilGenericParam::p_Name> {
  using parent = SgAsmCilGenericParam;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilGenericParam::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilGenericParam, uint32_t SgAsmCilGenericParam::*, &SgAsmCilGenericParam::p_Name>;
};
template <> struct describe_node_t<SgAsmCilGenericParam> {
  using node = SgAsmCilGenericParam;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilGenericParam"};
  static constexpr unsigned long variant{970};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilGenericParam,uint16_t,&SgAsmCilGenericParam::p_Number>, describe_field_t<SgAsmCilGenericParam,uint16_t,&SgAsmCilGenericParam::p_Flags>, describe_field_t<SgAsmCilGenericParam,uint32_t,&SgAsmCilGenericParam::p_Owner>, describe_field_t<SgAsmCilGenericParam,uint32_t,&SgAsmCilGenericParam::p_Name>>;
};
template <> struct node_from_variant_t<970> { using type = SgAsmCilGenericParam; };

// Class: AsmCilGenericParamConstraint
template <> struct describe_field_t<SgAsmCilGenericParamConstraint,uint32_t,&SgAsmCilGenericParamConstraint::p_Owner> {
  using parent = SgAsmCilGenericParamConstraint;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Owner"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilGenericParamConstraint::p_Owner};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilGenericParamConstraint, uint32_t SgAsmCilGenericParamConstraint::*, &SgAsmCilGenericParamConstraint::p_Owner>;
};
template <> struct describe_field_t<SgAsmCilGenericParamConstraint,uint32_t,&SgAsmCilGenericParamConstraint::p_Constraint> {
  using parent = SgAsmCilGenericParamConstraint;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Constraint"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilGenericParamConstraint::p_Constraint};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilGenericParamConstraint, uint32_t SgAsmCilGenericParamConstraint::*, &SgAsmCilGenericParamConstraint::p_Constraint>;
};
template <> struct describe_node_t<SgAsmCilGenericParamConstraint> {
  using node = SgAsmCilGenericParamConstraint;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilGenericParamConstraint"};
  static constexpr unsigned long variant{971};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilGenericParamConstraint,uint32_t,&SgAsmCilGenericParamConstraint::p_Owner>, describe_field_t<SgAsmCilGenericParamConstraint,uint32_t,&SgAsmCilGenericParamConstraint::p_Constraint>>;
};
template <> struct node_from_variant_t<971> { using type = SgAsmCilGenericParamConstraint; };

// Class: AsmCilImplMap
template <> struct describe_field_t<SgAsmCilImplMap,uint16_t,&SgAsmCilImplMap::p_MappingFlags> {
  using parent = SgAsmCilImplMap;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"MappingFlags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilImplMap::p_MappingFlags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilImplMap, uint16_t SgAsmCilImplMap::*, &SgAsmCilImplMap::p_MappingFlags>;
};
template <> struct describe_field_t<SgAsmCilImplMap,uint32_t,&SgAsmCilImplMap::p_MemberForwarded> {
  using parent = SgAsmCilImplMap;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"MemberForwarded"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilImplMap::p_MemberForwarded};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilImplMap, uint32_t SgAsmCilImplMap::*, &SgAsmCilImplMap::p_MemberForwarded>;
};
template <> struct describe_field_t<SgAsmCilImplMap,uint32_t,&SgAsmCilImplMap::p_ImportName> {
  using parent = SgAsmCilImplMap;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"ImportName"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilImplMap::p_ImportName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilImplMap, uint32_t SgAsmCilImplMap::*, &SgAsmCilImplMap::p_ImportName>;
};
template <> struct describe_field_t<SgAsmCilImplMap,uint32_t,&SgAsmCilImplMap::p_ImportScope> {
  using parent = SgAsmCilImplMap;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"ImportScope"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilImplMap::p_ImportScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilImplMap, uint32_t SgAsmCilImplMap::*, &SgAsmCilImplMap::p_ImportScope>;
};
template <> struct describe_node_t<SgAsmCilImplMap> {
  using node = SgAsmCilImplMap;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilImplMap"};
  static constexpr unsigned long variant{972};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilImplMap,uint16_t,&SgAsmCilImplMap::p_MappingFlags>, describe_field_t<SgAsmCilImplMap,uint32_t,&SgAsmCilImplMap::p_MemberForwarded>, describe_field_t<SgAsmCilImplMap,uint32_t,&SgAsmCilImplMap::p_ImportName>, describe_field_t<SgAsmCilImplMap,uint32_t,&SgAsmCilImplMap::p_ImportScope>>;
};
template <> struct node_from_variant_t<972> { using type = SgAsmCilImplMap; };

// Class: AsmCilInterfaceImpl
template <> struct describe_field_t<SgAsmCilInterfaceImpl,uint32_t,&SgAsmCilInterfaceImpl::p_Class> {
  using parent = SgAsmCilInterfaceImpl;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Class"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilInterfaceImpl::p_Class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilInterfaceImpl, uint32_t SgAsmCilInterfaceImpl::*, &SgAsmCilInterfaceImpl::p_Class>;
};
template <> struct describe_field_t<SgAsmCilInterfaceImpl,uint32_t,&SgAsmCilInterfaceImpl::p_Interface> {
  using parent = SgAsmCilInterfaceImpl;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Interface"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilInterfaceImpl::p_Interface};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilInterfaceImpl, uint32_t SgAsmCilInterfaceImpl::*, &SgAsmCilInterfaceImpl::p_Interface>;
};
template <> struct describe_node_t<SgAsmCilInterfaceImpl> {
  using node = SgAsmCilInterfaceImpl;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilInterfaceImpl"};
  static constexpr unsigned long variant{973};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilInterfaceImpl,uint32_t,&SgAsmCilInterfaceImpl::p_Class>, describe_field_t<SgAsmCilInterfaceImpl,uint32_t,&SgAsmCilInterfaceImpl::p_Interface>>;
};
template <> struct node_from_variant_t<973> { using type = SgAsmCilInterfaceImpl; };

// Class: AsmCilManifestResource
template <> struct describe_field_t<SgAsmCilManifestResource,uint32_t,&SgAsmCilManifestResource::p_Offset> {
  using parent = SgAsmCilManifestResource;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Offset"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilManifestResource::p_Offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilManifestResource, uint32_t SgAsmCilManifestResource::*, &SgAsmCilManifestResource::p_Offset>;
};
template <> struct describe_field_t<SgAsmCilManifestResource,uint32_t,&SgAsmCilManifestResource::p_Flags> {
  using parent = SgAsmCilManifestResource;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilManifestResource::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilManifestResource, uint32_t SgAsmCilManifestResource::*, &SgAsmCilManifestResource::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilManifestResource,uint32_t,&SgAsmCilManifestResource::p_Name> {
  using parent = SgAsmCilManifestResource;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilManifestResource::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilManifestResource, uint32_t SgAsmCilManifestResource::*, &SgAsmCilManifestResource::p_Name>;
};
template <> struct describe_field_t<SgAsmCilManifestResource,uint32_t,&SgAsmCilManifestResource::p_Implementation> {
  using parent = SgAsmCilManifestResource;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"Implementation"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilManifestResource::p_Implementation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilManifestResource, uint32_t SgAsmCilManifestResource::*, &SgAsmCilManifestResource::p_Implementation>;
};
template <> struct describe_node_t<SgAsmCilManifestResource> {
  using node = SgAsmCilManifestResource;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilManifestResource"};
  static constexpr unsigned long variant{974};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilManifestResource,uint32_t,&SgAsmCilManifestResource::p_Offset>, describe_field_t<SgAsmCilManifestResource,uint32_t,&SgAsmCilManifestResource::p_Flags>, describe_field_t<SgAsmCilManifestResource,uint32_t,&SgAsmCilManifestResource::p_Name>, describe_field_t<SgAsmCilManifestResource,uint32_t,&SgAsmCilManifestResource::p_Implementation>>;
};
template <> struct node_from_variant_t<974> { using type = SgAsmCilManifestResource; };

// Class: AsmCilMemberRef
template <> struct describe_field_t<SgAsmCilMemberRef,uint32_t,&SgAsmCilMemberRef::p_Class> {
  using parent = SgAsmCilMemberRef;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Class"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMemberRef::p_Class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMemberRef, uint32_t SgAsmCilMemberRef::*, &SgAsmCilMemberRef::p_Class>;
};
template <> struct describe_field_t<SgAsmCilMemberRef,uint32_t,&SgAsmCilMemberRef::p_Name> {
  using parent = SgAsmCilMemberRef;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMemberRef::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMemberRef, uint32_t SgAsmCilMemberRef::*, &SgAsmCilMemberRef::p_Name>;
};
template <> struct describe_field_t<SgAsmCilMemberRef,uint32_t,&SgAsmCilMemberRef::p_Signature> {
  using parent = SgAsmCilMemberRef;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Signature"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMemberRef::p_Signature};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMemberRef, uint32_t SgAsmCilMemberRef::*, &SgAsmCilMemberRef::p_Signature>;
};
template <> struct describe_node_t<SgAsmCilMemberRef> {
  using node = SgAsmCilMemberRef;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMemberRef"};
  static constexpr unsigned long variant{975};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMemberRef,uint32_t,&SgAsmCilMemberRef::p_Class>, describe_field_t<SgAsmCilMemberRef,uint32_t,&SgAsmCilMemberRef::p_Name>, describe_field_t<SgAsmCilMemberRef,uint32_t,&SgAsmCilMemberRef::p_Signature>>;
};
template <> struct node_from_variant_t<975> { using type = SgAsmCilMemberRef; };

// Class: AsmCilMethodDef
template <> struct describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_RVA> {
  using parent = SgAsmCilMethodDef;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"RVA"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_RVA};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, uint32_t SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_RVA>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,uint16_t,&SgAsmCilMethodDef::p_ImplFlags> {
  using parent = SgAsmCilMethodDef;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"ImplFlags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_ImplFlags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, uint16_t SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_ImplFlags>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,uint16_t,&SgAsmCilMethodDef::p_Flags> {
  using parent = SgAsmCilMethodDef;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, uint16_t SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_Name> {
  using parent = SgAsmCilMethodDef;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, uint32_t SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_Name>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_Signature> {
  using parent = SgAsmCilMethodDef;
  using field_type = uint32_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"Signature"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_Signature};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, uint32_t SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_Signature>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_ParamList> {
  using parent = SgAsmCilMethodDef;
  using field_type = uint32_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"ParamList"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_ParamList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, uint32_t SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_ParamList>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,SgAsmBlock*,&SgAsmCilMethodDef::p_body> {
  using parent = SgAsmCilMethodDef;
  using field_type = SgAsmBlock*;
  static constexpr size_t position{6};
  static constexpr char const * const name{"body"};
  static constexpr char const * const typestr{"SgAsmBlock*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_body};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, SgAsmBlock* SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_body>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,bool,&SgAsmCilMethodDef::p_initLocals> {
  using parent = SgAsmCilMethodDef;
  using field_type = bool;
  static constexpr size_t position{7};
  static constexpr char const * const name{"initLocals"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_initLocals};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, bool SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_initLocals>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_stackSize> {
  using parent = SgAsmCilMethodDef;
  using field_type = uint32_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"stackSize"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_stackSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, uint32_t SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_stackSize>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,bool,&SgAsmCilMethodDef::p_hasMoreSections> {
  using parent = SgAsmCilMethodDef;
  using field_type = bool;
  static constexpr size_t position{9};
  static constexpr char const * const name{"hasMoreSections"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_hasMoreSections};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, bool SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_hasMoreSections>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_localVarSigTok> {
  using parent = SgAsmCilMethodDef;
  using field_type = uint32_t;
  static constexpr size_t position{10};
  static constexpr char const * const name{"localVarSigTok"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_localVarSigTok};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, uint32_t SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_localVarSigTok>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,std::vector<SgAsmCilMethodData*>,&SgAsmCilMethodDef::p_methodData> {
  using parent = SgAsmCilMethodDef;
  using field_type = std::vector<SgAsmCilMethodData*>;
  static constexpr size_t position{11};
  static constexpr char const * const name{"methodData"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilMethodData*>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_methodData};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, std::vector<SgAsmCilMethodData*> SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_methodData>;
};
template <> struct describe_field_t<SgAsmCilMethodDef,int,&SgAsmCilMethodDef::p_bodyState> {
  using parent = SgAsmCilMethodDef;
  using field_type = int;
  static constexpr size_t position{12};
  static constexpr char const * const name{"bodyState"};
  static constexpr char const * const typestr{"int"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDef::p_bodyState};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDef, int SgAsmCilMethodDef::*, &SgAsmCilMethodDef::p_bodyState>;
};
template <> struct describe_node_t<SgAsmCilMethodDef> {
  using node = SgAsmCilMethodDef;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMethodDef"};
  static constexpr unsigned long variant{976};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_RVA>, describe_field_t<SgAsmCilMethodDef,uint16_t,&SgAsmCilMethodDef::p_ImplFlags>, describe_field_t<SgAsmCilMethodDef,uint16_t,&SgAsmCilMethodDef::p_Flags>, describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_Name>, describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_Signature>, describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_ParamList>, describe_field_t<SgAsmCilMethodDef,SgAsmBlock*,&SgAsmCilMethodDef::p_body>, describe_field_t<SgAsmCilMethodDef,bool,&SgAsmCilMethodDef::p_initLocals>, describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_stackSize>, describe_field_t<SgAsmCilMethodDef,bool,&SgAsmCilMethodDef::p_hasMoreSections>, describe_field_t<SgAsmCilMethodDef,uint32_t,&SgAsmCilMethodDef::p_localVarSigTok>, describe_field_t<SgAsmCilMethodDef,std::vector<SgAsmCilMethodData*>,&SgAsmCilMethodDef::p_methodData>, describe_field_t<SgAsmCilMethodDef,int,&SgAsmCilMethodDef::p_bodyState>>;
};
template <> struct node_from_variant_t<976> { using type = SgAsmCilMethodDef; };

// Class: AsmCilMethodImpl
template <> struct describe_field_t<SgAsmCilMethodImpl,uint32_t,&SgAsmCilMethodImpl::p_Class> {
  using parent = SgAsmCilMethodImpl;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Class"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodImpl::p_Class};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodImpl, uint32_t SgAsmCilMethodImpl::*, &SgAsmCilMethodImpl::p_Class>;
};
template <> struct describe_field_t<SgAsmCilMethodImpl,uint32_t,&SgAsmCilMethodImpl::p_MethodBody> {
  using parent = SgAsmCilMethodImpl;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"MethodBody"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodImpl::p_MethodBody};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodImpl, uint32_t SgAsmCilMethodImpl::*, &SgAsmCilMethodImpl::p_MethodBody>;
};
template <> struct describe_field_t<SgAsmCilMethodImpl,uint32_t,&SgAsmCilMethodImpl::p_MethodDeclaration> {
  using parent = SgAsmCilMethodImpl;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"MethodDeclaration"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodImpl::p_MethodDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodImpl, uint32_t SgAsmCilMethodImpl::*, &SgAsmCilMethodImpl::p_MethodDeclaration>;
};
template <> struct describe_node_t<SgAsmCilMethodImpl> {
  using node = SgAsmCilMethodImpl;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMethodImpl"};
  static constexpr unsigned long variant{977};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMethodImpl,uint32_t,&SgAsmCilMethodImpl::p_Class>, describe_field_t<SgAsmCilMethodImpl,uint32_t,&SgAsmCilMethodImpl::p_MethodBody>, describe_field_t<SgAsmCilMethodImpl,uint32_t,&SgAsmCilMethodImpl::p_MethodDeclaration>>;
};
template <> struct node_from_variant_t<977> { using type = SgAsmCilMethodImpl; };

// Class: AsmCilMethodSemantics
template <> struct describe_field_t<SgAsmCilMethodSemantics,uint16_t,&SgAsmCilMethodSemantics::p_Semantics> {
  using parent = SgAsmCilMethodSemantics;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Semantics"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodSemantics::p_Semantics};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodSemantics, uint16_t SgAsmCilMethodSemantics::*, &SgAsmCilMethodSemantics::p_Semantics>;
};
template <> struct describe_field_t<SgAsmCilMethodSemantics,uint32_t,&SgAsmCilMethodSemantics::p_Method> {
  using parent = SgAsmCilMethodSemantics;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Method"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodSemantics::p_Method};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodSemantics, uint32_t SgAsmCilMethodSemantics::*, &SgAsmCilMethodSemantics::p_Method>;
};
template <> struct describe_field_t<SgAsmCilMethodSemantics,uint32_t,&SgAsmCilMethodSemantics::p_Association> {
  using parent = SgAsmCilMethodSemantics;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Association"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodSemantics::p_Association};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodSemantics, uint32_t SgAsmCilMethodSemantics::*, &SgAsmCilMethodSemantics::p_Association>;
};
template <> struct describe_node_t<SgAsmCilMethodSemantics> {
  using node = SgAsmCilMethodSemantics;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMethodSemantics"};
  static constexpr unsigned long variant{978};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMethodSemantics,uint16_t,&SgAsmCilMethodSemantics::p_Semantics>, describe_field_t<SgAsmCilMethodSemantics,uint32_t,&SgAsmCilMethodSemantics::p_Method>, describe_field_t<SgAsmCilMethodSemantics,uint32_t,&SgAsmCilMethodSemantics::p_Association>>;
};
template <> struct node_from_variant_t<978> { using type = SgAsmCilMethodSemantics; };

// Class: AsmCilMethodSpec
template <> struct describe_field_t<SgAsmCilMethodSpec,uint32_t,&SgAsmCilMethodSpec::p_Method> {
  using parent = SgAsmCilMethodSpec;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Method"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodSpec::p_Method};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodSpec, uint32_t SgAsmCilMethodSpec::*, &SgAsmCilMethodSpec::p_Method>;
};
template <> struct describe_field_t<SgAsmCilMethodSpec,uint32_t,&SgAsmCilMethodSpec::p_Instantiation> {
  using parent = SgAsmCilMethodSpec;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Instantiation"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodSpec::p_Instantiation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodSpec, uint32_t SgAsmCilMethodSpec::*, &SgAsmCilMethodSpec::p_Instantiation>;
};
template <> struct describe_node_t<SgAsmCilMethodSpec> {
  using node = SgAsmCilMethodSpec;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMethodSpec"};
  static constexpr unsigned long variant{979};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMethodSpec,uint32_t,&SgAsmCilMethodSpec::p_Method>, describe_field_t<SgAsmCilMethodSpec,uint32_t,&SgAsmCilMethodSpec::p_Instantiation>>;
};
template <> struct node_from_variant_t<979> { using type = SgAsmCilMethodSpec; };

// Class: AsmCilModule
template <> struct describe_field_t<SgAsmCilModule,uint16_t,&SgAsmCilModule::p_Generation> {
  using parent = SgAsmCilModule;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Generation"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilModule::p_Generation};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilModule, uint16_t SgAsmCilModule::*, &SgAsmCilModule::p_Generation>;
};
template <> struct describe_field_t<SgAsmCilModule,uint32_t,&SgAsmCilModule::p_Name> {
  using parent = SgAsmCilModule;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilModule::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilModule, uint32_t SgAsmCilModule::*, &SgAsmCilModule::p_Name>;
};
template <> struct describe_field_t<SgAsmCilModule,uint32_t,&SgAsmCilModule::p_Mvid> {
  using parent = SgAsmCilModule;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Mvid"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilModule::p_Mvid};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilModule, uint32_t SgAsmCilModule::*, &SgAsmCilModule::p_Mvid>;
};
template <> struct describe_field_t<SgAsmCilModule,uint32_t,&SgAsmCilModule::p_Encld> {
  using parent = SgAsmCilModule;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"Encld"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilModule::p_Encld};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilModule, uint32_t SgAsmCilModule::*, &SgAsmCilModule::p_Encld>;
};
template <> struct describe_field_t<SgAsmCilModule,uint32_t,&SgAsmCilModule::p_EncBaseId> {
  using parent = SgAsmCilModule;
  using field_type = uint32_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"EncBaseId"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilModule::p_EncBaseId};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilModule, uint32_t SgAsmCilModule::*, &SgAsmCilModule::p_EncBaseId>;
};
template <> struct describe_node_t<SgAsmCilModule> {
  using node = SgAsmCilModule;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilModule"};
  static constexpr unsigned long variant{980};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilModule,uint16_t,&SgAsmCilModule::p_Generation>, describe_field_t<SgAsmCilModule,uint32_t,&SgAsmCilModule::p_Name>, describe_field_t<SgAsmCilModule,uint32_t,&SgAsmCilModule::p_Mvid>, describe_field_t<SgAsmCilModule,uint32_t,&SgAsmCilModule::p_Encld>, describe_field_t<SgAsmCilModule,uint32_t,&SgAsmCilModule::p_EncBaseId>>;
};
template <> struct node_from_variant_t<980> { using type = SgAsmCilModule; };

// Class: AsmCilModuleRef
template <> struct describe_field_t<SgAsmCilModuleRef,uint32_t,&SgAsmCilModuleRef::p_Name> {
  using parent = SgAsmCilModuleRef;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilModuleRef::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilModuleRef, uint32_t SgAsmCilModuleRef::*, &SgAsmCilModuleRef::p_Name>;
};
template <> struct describe_node_t<SgAsmCilModuleRef> {
  using node = SgAsmCilModuleRef;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilModuleRef"};
  static constexpr unsigned long variant{981};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilModuleRef,uint32_t,&SgAsmCilModuleRef::p_Name>>;
};
template <> struct node_from_variant_t<981> { using type = SgAsmCilModuleRef; };

// Class: AsmCilNestedClass
template <> struct describe_field_t<SgAsmCilNestedClass,uint32_t,&SgAsmCilNestedClass::p_NestedClass> {
  using parent = SgAsmCilNestedClass;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"NestedClass"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilNestedClass::p_NestedClass};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilNestedClass, uint32_t SgAsmCilNestedClass::*, &SgAsmCilNestedClass::p_NestedClass>;
};
template <> struct describe_field_t<SgAsmCilNestedClass,uint32_t,&SgAsmCilNestedClass::p_EnclosingClass> {
  using parent = SgAsmCilNestedClass;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"EnclosingClass"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilNestedClass::p_EnclosingClass};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilNestedClass, uint32_t SgAsmCilNestedClass::*, &SgAsmCilNestedClass::p_EnclosingClass>;
};
template <> struct describe_node_t<SgAsmCilNestedClass> {
  using node = SgAsmCilNestedClass;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilNestedClass"};
  static constexpr unsigned long variant{982};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilNestedClass,uint32_t,&SgAsmCilNestedClass::p_NestedClass>, describe_field_t<SgAsmCilNestedClass,uint32_t,&SgAsmCilNestedClass::p_EnclosingClass>>;
};
template <> struct node_from_variant_t<982> { using type = SgAsmCilNestedClass; };

// Class: AsmCilParam
template <> struct describe_field_t<SgAsmCilParam,uint16_t,&SgAsmCilParam::p_Flags> {
  using parent = SgAsmCilParam;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilParam::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilParam, uint16_t SgAsmCilParam::*, &SgAsmCilParam::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilParam,uint16_t,&SgAsmCilParam::p_Sequence> {
  using parent = SgAsmCilParam;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Sequence"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilParam::p_Sequence};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilParam, uint16_t SgAsmCilParam::*, &SgAsmCilParam::p_Sequence>;
};
template <> struct describe_field_t<SgAsmCilParam,uint32_t,&SgAsmCilParam::p_Name> {
  using parent = SgAsmCilParam;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilParam::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilParam, uint32_t SgAsmCilParam::*, &SgAsmCilParam::p_Name>;
};
template <> struct describe_node_t<SgAsmCilParam> {
  using node = SgAsmCilParam;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilParam"};
  static constexpr unsigned long variant{983};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilParam,uint16_t,&SgAsmCilParam::p_Flags>, describe_field_t<SgAsmCilParam,uint16_t,&SgAsmCilParam::p_Sequence>, describe_field_t<SgAsmCilParam,uint32_t,&SgAsmCilParam::p_Name>>;
};
template <> struct node_from_variant_t<983> { using type = SgAsmCilParam; };

// Class: AsmCilProperty
template <> struct describe_field_t<SgAsmCilProperty,uint16_t,&SgAsmCilProperty::p_Flags> {
  using parent = SgAsmCilProperty;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilProperty::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilProperty, uint16_t SgAsmCilProperty::*, &SgAsmCilProperty::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilProperty,uint32_t,&SgAsmCilProperty::p_Name> {
  using parent = SgAsmCilProperty;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilProperty::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilProperty, uint32_t SgAsmCilProperty::*, &SgAsmCilProperty::p_Name>;
};
template <> struct describe_field_t<SgAsmCilProperty,uint32_t,&SgAsmCilProperty::p_Type> {
  using parent = SgAsmCilProperty;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Type"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilProperty::p_Type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilProperty, uint32_t SgAsmCilProperty::*, &SgAsmCilProperty::p_Type>;
};
template <> struct describe_node_t<SgAsmCilProperty> {
  using node = SgAsmCilProperty;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilProperty"};
  static constexpr unsigned long variant{984};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilProperty,uint16_t,&SgAsmCilProperty::p_Flags>, describe_field_t<SgAsmCilProperty,uint32_t,&SgAsmCilProperty::p_Name>, describe_field_t<SgAsmCilProperty,uint32_t,&SgAsmCilProperty::p_Type>>;
};
template <> struct node_from_variant_t<984> { using type = SgAsmCilProperty; };

// Class: AsmCilPropertyMap
template <> struct describe_field_t<SgAsmCilPropertyMap,uint32_t,&SgAsmCilPropertyMap::p_Parent> {
  using parent = SgAsmCilPropertyMap;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Parent"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilPropertyMap::p_Parent};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilPropertyMap, uint32_t SgAsmCilPropertyMap::*, &SgAsmCilPropertyMap::p_Parent>;
};
template <> struct describe_field_t<SgAsmCilPropertyMap,uint32_t,&SgAsmCilPropertyMap::p_PropertyList> {
  using parent = SgAsmCilPropertyMap;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"PropertyList"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilPropertyMap::p_PropertyList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilPropertyMap, uint32_t SgAsmCilPropertyMap::*, &SgAsmCilPropertyMap::p_PropertyList>;
};
template <> struct describe_node_t<SgAsmCilPropertyMap> {
  using node = SgAsmCilPropertyMap;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilPropertyMap"};
  static constexpr unsigned long variant{985};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilPropertyMap,uint32_t,&SgAsmCilPropertyMap::p_Parent>, describe_field_t<SgAsmCilPropertyMap,uint32_t,&SgAsmCilPropertyMap::p_PropertyList>>;
};
template <> struct node_from_variant_t<985> { using type = SgAsmCilPropertyMap; };

// Class: AsmCilStandAloneSig
template <> struct describe_field_t<SgAsmCilStandAloneSig,uint32_t,&SgAsmCilStandAloneSig::p_Signature> {
  using parent = SgAsmCilStandAloneSig;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Signature"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilStandAloneSig::p_Signature};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilStandAloneSig, uint32_t SgAsmCilStandAloneSig::*, &SgAsmCilStandAloneSig::p_Signature>;
};
template <> struct describe_node_t<SgAsmCilStandAloneSig> {
  using node = SgAsmCilStandAloneSig;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilStandAloneSig"};
  static constexpr unsigned long variant{986};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilStandAloneSig,uint32_t,&SgAsmCilStandAloneSig::p_Signature>>;
};
template <> struct node_from_variant_t<986> { using type = SgAsmCilStandAloneSig; };

// Class: AsmCilTypeDef
template <> struct describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_Flags> {
  using parent = SgAsmCilTypeDef;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeDef::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeDef, uint32_t SgAsmCilTypeDef::*, &SgAsmCilTypeDef::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_TypeName> {
  using parent = SgAsmCilTypeDef;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"TypeName"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeDef::p_TypeName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeDef, uint32_t SgAsmCilTypeDef::*, &SgAsmCilTypeDef::p_TypeName>;
};
template <> struct describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_TypeNamespace> {
  using parent = SgAsmCilTypeDef;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"TypeNamespace"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeDef::p_TypeNamespace};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeDef, uint32_t SgAsmCilTypeDef::*, &SgAsmCilTypeDef::p_TypeNamespace>;
};
template <> struct describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_Extends> {
  using parent = SgAsmCilTypeDef;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"Extends"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeDef::p_Extends};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeDef, uint32_t SgAsmCilTypeDef::*, &SgAsmCilTypeDef::p_Extends>;
};
template <> struct describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_FieldList> {
  using parent = SgAsmCilTypeDef;
  using field_type = uint32_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"FieldList"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeDef::p_FieldList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeDef, uint32_t SgAsmCilTypeDef::*, &SgAsmCilTypeDef::p_FieldList>;
};
template <> struct describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_MethodList> {
  using parent = SgAsmCilTypeDef;
  using field_type = uint32_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"MethodList"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeDef::p_MethodList};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeDef, uint32_t SgAsmCilTypeDef::*, &SgAsmCilTypeDef::p_MethodList>;
};
template <> struct describe_node_t<SgAsmCilTypeDef> {
  using node = SgAsmCilTypeDef;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilTypeDef"};
  static constexpr unsigned long variant{987};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_Flags>, describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_TypeName>, describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_TypeNamespace>, describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_Extends>, describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_FieldList>, describe_field_t<SgAsmCilTypeDef,uint32_t,&SgAsmCilTypeDef::p_MethodList>>;
};
template <> struct node_from_variant_t<987> { using type = SgAsmCilTypeDef; };

// Class: AsmCilTypeRef
template <> struct describe_field_t<SgAsmCilTypeRef,uint16_t,&SgAsmCilTypeRef::p_ResolutionScope> {
  using parent = SgAsmCilTypeRef;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"ResolutionScope"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeRef::p_ResolutionScope};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeRef, uint16_t SgAsmCilTypeRef::*, &SgAsmCilTypeRef::p_ResolutionScope>;
};
template <> struct describe_field_t<SgAsmCilTypeRef,uint32_t,&SgAsmCilTypeRef::p_TypeName> {
  using parent = SgAsmCilTypeRef;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"TypeName"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeRef::p_TypeName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeRef, uint32_t SgAsmCilTypeRef::*, &SgAsmCilTypeRef::p_TypeName>;
};
template <> struct describe_field_t<SgAsmCilTypeRef,uint32_t,&SgAsmCilTypeRef::p_TypeNamespace> {
  using parent = SgAsmCilTypeRef;
  using field_type = uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"TypeNamespace"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeRef::p_TypeNamespace};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeRef, uint32_t SgAsmCilTypeRef::*, &SgAsmCilTypeRef::p_TypeNamespace>;
};
template <> struct describe_node_t<SgAsmCilTypeRef> {
  using node = SgAsmCilTypeRef;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilTypeRef"};
  static constexpr unsigned long variant{988};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilTypeRef,uint16_t,&SgAsmCilTypeRef::p_ResolutionScope>, describe_field_t<SgAsmCilTypeRef,uint32_t,&SgAsmCilTypeRef::p_TypeName>, describe_field_t<SgAsmCilTypeRef,uint32_t,&SgAsmCilTypeRef::p_TypeNamespace>>;
};
template <> struct node_from_variant_t<988> { using type = SgAsmCilTypeRef; };

// Class: AsmCilTypeSpec
template <> struct describe_field_t<SgAsmCilTypeSpec,uint32_t,&SgAsmCilTypeSpec::p_Signature> {
  using parent = SgAsmCilTypeSpec;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Signature"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilTypeSpec::p_Signature};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeSpec, uint32_t SgAsmCilTypeSpec::*, &SgAsmCilTypeSpec::p_Signature>;
};
template <> struct describe_node_t<SgAsmCilTypeSpec> {
  using node = SgAsmCilTypeSpec;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilTypeSpec"};
  static constexpr unsigned long variant{989};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilTypeSpec,uint32_t,&SgAsmCilTypeSpec::p_Signature>>;
};
template <> struct node_from_variant_t<989> { using type = SgAsmCilTypeSpec; };

// Class: AdaParameterList
template <> struct describe_field_t<SgAdaParameterList,SgDeclarationStatementPtrList,&SgAdaParameterList::p_parameters> {
  using parent = SgAdaParameterList;
  using field_type = SgDeclarationStatementPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"parameters"};
  static constexpr char const * const typestr{"SgDeclarationStatementPtrList"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaParameterList::p_parameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaParameterList, SgDeclarationStatementPtrList SgAdaParameterList::*, &SgAdaParameterList::p_parameters>;
};
template <> struct describe_node_t<SgAdaParameterList> {
  using node = SgAdaParameterList;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaParameterList"};
  static constexpr unsigned long variant{990};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaParameterList,SgDeclarationStatementPtrList,&SgAdaParameterList::p_parameters>>;
};
template <> struct node_from_variant_t<990> { using type = SgAdaParameterList; };

// Class: AsmCilMetadata
template <> struct describe_node_t<SgAsmCilMetadata> {
  using node = SgAsmCilMetadata;
  using base = SgAsmCilNode;
  static constexpr char const * const name{"AsmCilMetadata"};
  static constexpr unsigned long variant{991};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmCilAssembly, SgAsmCilAssemblyOS, SgAsmCilAssemblyOSTable, SgAsmCilAssemblyProcessor, SgAsmCilAssemblyProcessorTable, SgAsmCilAssemblyRef, SgAsmCilAssemblyRefOS, SgAsmCilAssemblyRefOSTable, SgAsmCilAssemblyRefProcessor, SgAsmCilAssemblyRefProcessorTable, SgAsmCilAssemblyRefTable, SgAsmCilAssemblyTable, SgAsmCilClassLayout, SgAsmCilClassLayoutTable, SgAsmCilConstant, SgAsmCilConstantTable, SgAsmCilCustomAttribute, SgAsmCilCustomAttributeTable, SgAsmCilDeclSecurity, SgAsmCilDeclSecurityTable, SgAsmCilEvent, SgAsmCilEventMap, SgAsmCilEventMapTable, SgAsmCilEventTable, SgAsmCilExportedType, SgAsmCilExportedTypeTable, SgAsmCilField, SgAsmCilFieldLayout, SgAsmCilFieldLayoutTable, SgAsmCilFieldMarshal, SgAsmCilFieldMarshalTable, SgAsmCilFieldRVA, SgAsmCilFieldRVATable, SgAsmCilFieldTable, SgAsmCilFile, SgAsmCilFileTable, SgAsmCilGenericParamConstraint, SgAsmCilGenericParamConstraintTable, SgAsmCilGenericParam, SgAsmCilGenericParamTable, SgAsmCilImplMap, SgAsmCilImplMapTable, SgAsmCilInterfaceImpl, SgAsmCilInterfaceImplTable, SgAsmCilManifestResource, SgAsmCilManifestResourceTable, SgAsmCilMemberRef, SgAsmCilMemberRefTable, SgAsmCilMethodDef, SgAsmCilMethodDefTable, SgAsmCilMethodImpl, SgAsmCilMethodImplTable, SgAsmCilMethodSemantics, SgAsmCilMethodSemanticsTable, SgAsmCilMethodSpec, SgAsmCilMethodSpecTable, SgAsmCilModule, SgAsmCilModuleRef, SgAsmCilModuleRefTable, SgAsmCilModuleTable, SgAsmCilNestedClass, SgAsmCilNestedClassTable, SgAsmCilParam, SgAsmCilParamTable, SgAsmCilProperty, SgAsmCilPropertyMap, SgAsmCilPropertyMapTable, SgAsmCilPropertyTable, SgAsmCilStandAloneSig, SgAsmCilStandAloneSigTable, SgAsmCilTypeDef, SgAsmCilTypeDefTable, SgAsmCilTypeRef, SgAsmCilTypeRefTable, SgAsmCilTypeSpec, SgAsmCilTypeSpecTable>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<991> { using type = SgAsmCilMetadata; };

// Class: AsmCilMetadataRoot
template <> struct describe_field_t<SgAsmCilMetadataRoot,uint32_t,&SgAsmCilMetadataRoot::p_Signature> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Signature"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_Signature};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, uint32_t SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_Signature>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,uint16_t,&SgAsmCilMetadataRoot::p_MajorVersion> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"MajorVersion"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_MajorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, uint16_t SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_MajorVersion>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,uint16_t,&SgAsmCilMetadataRoot::p_MinorVersion> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"MinorVersion"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_MinorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, uint16_t SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_MinorVersion>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,uint32_t,&SgAsmCilMetadataRoot::p_Reserved0> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"Reserved0"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_Reserved0};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, uint32_t SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_Reserved0>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,uint32_t,&SgAsmCilMetadataRoot::p_Length> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = uint32_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"Length"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_Length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, uint32_t SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_Length>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,std::string,&SgAsmCilMetadataRoot::p_Version> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = std::string;
  static constexpr size_t position{5};
  static constexpr char const * const name{"Version"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_Version};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, std::string SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_Version>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,uint32_t,&SgAsmCilMetadataRoot::p_VersionPadding> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = uint32_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"VersionPadding"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_VersionPadding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, uint32_t SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_VersionPadding>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,uint16_t,&SgAsmCilMetadataRoot::p_Flags> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = uint16_t;
  static constexpr size_t position{7};
  static constexpr char const * const name{"Flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_Flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, uint16_t SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_Flags>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,uint16_t,&SgAsmCilMetadataRoot::p_NumberOfStreams> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = uint16_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"NumberOfStreams"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_NumberOfStreams};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, uint16_t SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_NumberOfStreams>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,std::vector<SgAsmCilDataStream*>,&SgAsmCilMetadataRoot::p_Streams> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = std::vector<SgAsmCilDataStream*>;
  static constexpr size_t position{9};
  static constexpr char const * const name{"Streams"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilDataStream*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_Streams};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, std::vector<SgAsmCilDataStream*> SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_Streams>;
};
template <> struct describe_field_t<SgAsmCilMetadataRoot,bool,&SgAsmCilMetadataRoot::p_ErrorFree> {
  using parent = SgAsmCilMetadataRoot;
  using field_type = bool;
  static constexpr size_t position{10};
  static constexpr char const * const name{"ErrorFree"};
  static constexpr char const * const typestr{"bool"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataRoot::p_ErrorFree};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataRoot, bool SgAsmCilMetadataRoot::*, &SgAsmCilMetadataRoot::p_ErrorFree>;
};
template <> struct describe_node_t<SgAsmCilMetadataRoot> {
  using node = SgAsmCilMetadataRoot;
  using base = SgAsmCilNode;
  static constexpr char const * const name{"AsmCilMetadataRoot"};
  static constexpr unsigned long variant{992};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMetadataRoot,uint32_t,&SgAsmCilMetadataRoot::p_Signature>, describe_field_t<SgAsmCilMetadataRoot,uint16_t,&SgAsmCilMetadataRoot::p_MajorVersion>, describe_field_t<SgAsmCilMetadataRoot,uint16_t,&SgAsmCilMetadataRoot::p_MinorVersion>, describe_field_t<SgAsmCilMetadataRoot,uint32_t,&SgAsmCilMetadataRoot::p_Reserved0>, describe_field_t<SgAsmCilMetadataRoot,uint32_t,&SgAsmCilMetadataRoot::p_Length>, describe_field_t<SgAsmCilMetadataRoot,std::string,&SgAsmCilMetadataRoot::p_Version>, describe_field_t<SgAsmCilMetadataRoot,uint32_t,&SgAsmCilMetadataRoot::p_VersionPadding>, describe_field_t<SgAsmCilMetadataRoot,uint16_t,&SgAsmCilMetadataRoot::p_Flags>, describe_field_t<SgAsmCilMetadataRoot,uint16_t,&SgAsmCilMetadataRoot::p_NumberOfStreams>, describe_field_t<SgAsmCilMetadataRoot,std::vector<SgAsmCilDataStream*>,&SgAsmCilMetadataRoot::p_Streams>, describe_field_t<SgAsmCilMetadataRoot,bool,&SgAsmCilMetadataRoot::p_ErrorFree>>;
};
template <> struct node_from_variant_t<992> { using type = SgAsmCilMetadataRoot; };

// Class: AsmCilDataStream
template <> struct describe_field_t<SgAsmCilDataStream,uint32_t,&SgAsmCilDataStream::p_Offset> {
  using parent = SgAsmCilDataStream;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Offset"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilDataStream::p_Offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilDataStream, uint32_t SgAsmCilDataStream::*, &SgAsmCilDataStream::p_Offset>;
};
template <> struct describe_field_t<SgAsmCilDataStream,uint32_t,&SgAsmCilDataStream::p_Size> {
  using parent = SgAsmCilDataStream;
  using field_type = uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"Size"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilDataStream::p_Size};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilDataStream, uint32_t SgAsmCilDataStream::*, &SgAsmCilDataStream::p_Size>;
};
template <> struct describe_field_t<SgAsmCilDataStream,std::string,&SgAsmCilDataStream::p_Name> {
  using parent = SgAsmCilDataStream;
  using field_type = std::string;
  static constexpr size_t position{2};
  static constexpr char const * const name{"Name"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilDataStream::p_Name};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilDataStream, std::string SgAsmCilDataStream::*, &SgAsmCilDataStream::p_Name>;
};
template <> struct describe_field_t<SgAsmCilDataStream,uint32_t,&SgAsmCilDataStream::p_NamePadding> {
  using parent = SgAsmCilDataStream;
  using field_type = uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"NamePadding"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilDataStream::p_NamePadding};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilDataStream, uint32_t SgAsmCilDataStream::*, &SgAsmCilDataStream::p_NamePadding>;
};
template <> struct describe_node_t<SgAsmCilDataStream> {
  using node = SgAsmCilDataStream;
  using base = SgAsmCilNode;
  static constexpr char const * const name{"AsmCilDataStream"};
  static constexpr unsigned long variant{993};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgAsmCilErrorHeap, SgAsmCilMetadataHeap, SgAsmCilUint32Heap, SgAsmCilUint8Heap>;
  using fields_t = mp::List<describe_field_t<SgAsmCilDataStream,uint32_t,&SgAsmCilDataStream::p_Offset>, describe_field_t<SgAsmCilDataStream,uint32_t,&SgAsmCilDataStream::p_Size>, describe_field_t<SgAsmCilDataStream,std::string,&SgAsmCilDataStream::p_Name>, describe_field_t<SgAsmCilDataStream,uint32_t,&SgAsmCilDataStream::p_NamePadding>>;
};
template <> struct node_from_variant_t<993> { using type = SgAsmCilDataStream; };

// Class: AsmCilMetadataHeap
template <> struct describe_field_t<SgAsmCilMetadataHeap,uint32_t,&SgAsmCilMetadataHeap::p_ReservedAlwaysZero> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"ReservedAlwaysZero"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ReservedAlwaysZero};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, uint32_t SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ReservedAlwaysZero>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,uint8_t,&SgAsmCilMetadataHeap::p_MajorVersion> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = uint8_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"MajorVersion"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_MajorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, uint8_t SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_MajorVersion>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,uint8_t,&SgAsmCilMetadataHeap::p_MinorVersion> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = uint8_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"MinorVersion"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_MinorVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, uint8_t SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_MinorVersion>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,uint8_t,&SgAsmCilMetadataHeap::p_HeapSizes> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = uint8_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"HeapSizes"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_HeapSizes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, uint8_t SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_HeapSizes>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,uint8_t,&SgAsmCilMetadataHeap::p_ReservedAlwaysOne> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = uint8_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"ReservedAlwaysOne"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ReservedAlwaysOne};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, uint8_t SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ReservedAlwaysOne>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,uint64_t,&SgAsmCilMetadataHeap::p_Valid> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = uint64_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"Valid"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_Valid};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, uint64_t SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_Valid>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,uint64_t,&SgAsmCilMetadataHeap::p_Sorted> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = uint64_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"Sorted"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_Sorted};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, uint64_t SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_Sorted>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,std::vector<uint32_t>,&SgAsmCilMetadataHeap::p_NumberOfRows> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = std::vector<uint32_t>;
  static constexpr size_t position{7};
  static constexpr char const * const name{"NumberOfRows"};
  static constexpr char const * const typestr{"std::vector<uint32_t>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_NumberOfRows};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, std::vector<uint32_t> SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_NumberOfRows>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,uint64_t,&SgAsmCilMetadataHeap::p_DataSizeFlags> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = uint64_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"DataSizeFlags"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_DataSizeFlags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, uint64_t SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_DataSizeFlags>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyTable*,&SgAsmCilMetadataHeap::p_AssemblyTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilAssemblyTable*;
  static constexpr size_t position{9};
  static constexpr char const * const name{"AssemblyTable"};
  static constexpr char const * const typestr{"SgAsmCilAssemblyTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_AssemblyTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilAssemblyTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_AssemblyTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyOSTable*,&SgAsmCilMetadataHeap::p_AssemblyOSTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilAssemblyOSTable*;
  static constexpr size_t position{10};
  static constexpr char const * const name{"AssemblyOSTable"};
  static constexpr char const * const typestr{"SgAsmCilAssemblyOSTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_AssemblyOSTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilAssemblyOSTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_AssemblyOSTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyProcessorTable*,&SgAsmCilMetadataHeap::p_AssemblyProcessorTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilAssemblyProcessorTable*;
  static constexpr size_t position{11};
  static constexpr char const * const name{"AssemblyProcessorTable"};
  static constexpr char const * const typestr{"SgAsmCilAssemblyProcessorTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_AssemblyProcessorTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilAssemblyProcessorTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_AssemblyProcessorTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyRefTable*,&SgAsmCilMetadataHeap::p_AssemblyRefTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilAssemblyRefTable*;
  static constexpr size_t position{12};
  static constexpr char const * const name{"AssemblyRefTable"};
  static constexpr char const * const typestr{"SgAsmCilAssemblyRefTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_AssemblyRefTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilAssemblyRefTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_AssemblyRefTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyRefOSTable*,&SgAsmCilMetadataHeap::p_AssemblyRefOSTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilAssemblyRefOSTable*;
  static constexpr size_t position{13};
  static constexpr char const * const name{"AssemblyRefOSTable"};
  static constexpr char const * const typestr{"SgAsmCilAssemblyRefOSTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_AssemblyRefOSTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilAssemblyRefOSTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_AssemblyRefOSTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyRefProcessorTable*,&SgAsmCilMetadataHeap::p_AssemblyRefProcessorTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilAssemblyRefProcessorTable*;
  static constexpr size_t position{14};
  static constexpr char const * const name{"AssemblyRefProcessorTable"};
  static constexpr char const * const typestr{"SgAsmCilAssemblyRefProcessorTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_AssemblyRefProcessorTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilAssemblyRefProcessorTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_AssemblyRefProcessorTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilClassLayoutTable*,&SgAsmCilMetadataHeap::p_ClassLayoutTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilClassLayoutTable*;
  static constexpr size_t position{15};
  static constexpr char const * const name{"ClassLayoutTable"};
  static constexpr char const * const typestr{"SgAsmCilClassLayoutTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ClassLayoutTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilClassLayoutTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ClassLayoutTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilConstantTable*,&SgAsmCilMetadataHeap::p_ConstantTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilConstantTable*;
  static constexpr size_t position{16};
  static constexpr char const * const name{"ConstantTable"};
  static constexpr char const * const typestr{"SgAsmCilConstantTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ConstantTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilConstantTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ConstantTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilCustomAttributeTable*,&SgAsmCilMetadataHeap::p_CustomAttributeTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilCustomAttributeTable*;
  static constexpr size_t position{17};
  static constexpr char const * const name{"CustomAttributeTable"};
  static constexpr char const * const typestr{"SgAsmCilCustomAttributeTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_CustomAttributeTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilCustomAttributeTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_CustomAttributeTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilDeclSecurityTable*,&SgAsmCilMetadataHeap::p_DeclSecurityTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilDeclSecurityTable*;
  static constexpr size_t position{18};
  static constexpr char const * const name{"DeclSecurityTable"};
  static constexpr char const * const typestr{"SgAsmCilDeclSecurityTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_DeclSecurityTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilDeclSecurityTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_DeclSecurityTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilEventTable*,&SgAsmCilMetadataHeap::p_EventTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilEventTable*;
  static constexpr size_t position{19};
  static constexpr char const * const name{"EventTable"};
  static constexpr char const * const typestr{"SgAsmCilEventTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_EventTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilEventTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_EventTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilEventMapTable*,&SgAsmCilMetadataHeap::p_EventMapTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilEventMapTable*;
  static constexpr size_t position{20};
  static constexpr char const * const name{"EventMapTable"};
  static constexpr char const * const typestr{"SgAsmCilEventMapTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_EventMapTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilEventMapTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_EventMapTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilExportedTypeTable*,&SgAsmCilMetadataHeap::p_ExportedTypeTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilExportedTypeTable*;
  static constexpr size_t position{21};
  static constexpr char const * const name{"ExportedTypeTable"};
  static constexpr char const * const typestr{"SgAsmCilExportedTypeTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ExportedTypeTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilExportedTypeTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ExportedTypeTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFieldTable*,&SgAsmCilMetadataHeap::p_FieldTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilFieldTable*;
  static constexpr size_t position{22};
  static constexpr char const * const name{"FieldTable"};
  static constexpr char const * const typestr{"SgAsmCilFieldTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_FieldTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilFieldTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_FieldTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFieldLayoutTable*,&SgAsmCilMetadataHeap::p_FieldLayoutTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilFieldLayoutTable*;
  static constexpr size_t position{23};
  static constexpr char const * const name{"FieldLayoutTable"};
  static constexpr char const * const typestr{"SgAsmCilFieldLayoutTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_FieldLayoutTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilFieldLayoutTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_FieldLayoutTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFieldMarshalTable*,&SgAsmCilMetadataHeap::p_FieldMarshalTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilFieldMarshalTable*;
  static constexpr size_t position{24};
  static constexpr char const * const name{"FieldMarshalTable"};
  static constexpr char const * const typestr{"SgAsmCilFieldMarshalTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_FieldMarshalTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilFieldMarshalTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_FieldMarshalTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFieldRVATable*,&SgAsmCilMetadataHeap::p_FieldRVATable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilFieldRVATable*;
  static constexpr size_t position{25};
  static constexpr char const * const name{"FieldRVATable"};
  static constexpr char const * const typestr{"SgAsmCilFieldRVATable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_FieldRVATable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilFieldRVATable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_FieldRVATable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFileTable*,&SgAsmCilMetadataHeap::p_FileTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilFileTable*;
  static constexpr size_t position{26};
  static constexpr char const * const name{"FileTable"};
  static constexpr char const * const typestr{"SgAsmCilFileTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_FileTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilFileTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_FileTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilGenericParamTable*,&SgAsmCilMetadataHeap::p_GenericParamTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilGenericParamTable*;
  static constexpr size_t position{27};
  static constexpr char const * const name{"GenericParamTable"};
  static constexpr char const * const typestr{"SgAsmCilGenericParamTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_GenericParamTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilGenericParamTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_GenericParamTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilGenericParamConstraintTable*,&SgAsmCilMetadataHeap::p_GenericParamConstraintTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilGenericParamConstraintTable*;
  static constexpr size_t position{28};
  static constexpr char const * const name{"GenericParamConstraintTable"};
  static constexpr char const * const typestr{"SgAsmCilGenericParamConstraintTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_GenericParamConstraintTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilGenericParamConstraintTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_GenericParamConstraintTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilImplMapTable*,&SgAsmCilMetadataHeap::p_ImplMapTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilImplMapTable*;
  static constexpr size_t position{29};
  static constexpr char const * const name{"ImplMapTable"};
  static constexpr char const * const typestr{"SgAsmCilImplMapTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ImplMapTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilImplMapTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ImplMapTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilInterfaceImplTable*,&SgAsmCilMetadataHeap::p_InterfaceImplTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilInterfaceImplTable*;
  static constexpr size_t position{30};
  static constexpr char const * const name{"InterfaceImplTable"};
  static constexpr char const * const typestr{"SgAsmCilInterfaceImplTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_InterfaceImplTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilInterfaceImplTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_InterfaceImplTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilManifestResourceTable*,&SgAsmCilMetadataHeap::p_ManifestResourceTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilManifestResourceTable*;
  static constexpr size_t position{31};
  static constexpr char const * const name{"ManifestResourceTable"};
  static constexpr char const * const typestr{"SgAsmCilManifestResourceTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ManifestResourceTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilManifestResourceTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ManifestResourceTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMemberRefTable*,&SgAsmCilMetadataHeap::p_MemberRefTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilMemberRefTable*;
  static constexpr size_t position{32};
  static constexpr char const * const name{"MemberRefTable"};
  static constexpr char const * const typestr{"SgAsmCilMemberRefTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_MemberRefTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilMemberRefTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_MemberRefTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMethodDefTable*,&SgAsmCilMetadataHeap::p_MethodDefTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilMethodDefTable*;
  static constexpr size_t position{33};
  static constexpr char const * const name{"MethodDefTable"};
  static constexpr char const * const typestr{"SgAsmCilMethodDefTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_MethodDefTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilMethodDefTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_MethodDefTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMethodImplTable*,&SgAsmCilMetadataHeap::p_MethodImplTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilMethodImplTable*;
  static constexpr size_t position{34};
  static constexpr char const * const name{"MethodImplTable"};
  static constexpr char const * const typestr{"SgAsmCilMethodImplTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_MethodImplTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilMethodImplTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_MethodImplTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMethodSemanticsTable*,&SgAsmCilMetadataHeap::p_MethodSemanticsTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilMethodSemanticsTable*;
  static constexpr size_t position{35};
  static constexpr char const * const name{"MethodSemanticsTable"};
  static constexpr char const * const typestr{"SgAsmCilMethodSemanticsTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_MethodSemanticsTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilMethodSemanticsTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_MethodSemanticsTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMethodSpecTable*,&SgAsmCilMetadataHeap::p_MethodSpecTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilMethodSpecTable*;
  static constexpr size_t position{36};
  static constexpr char const * const name{"MethodSpecTable"};
  static constexpr char const * const typestr{"SgAsmCilMethodSpecTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_MethodSpecTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilMethodSpecTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_MethodSpecTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilModuleTable*,&SgAsmCilMetadataHeap::p_ModuleTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilModuleTable*;
  static constexpr size_t position{37};
  static constexpr char const * const name{"ModuleTable"};
  static constexpr char const * const typestr{"SgAsmCilModuleTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ModuleTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilModuleTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ModuleTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilModuleRefTable*,&SgAsmCilMetadataHeap::p_ModuleRefTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilModuleRefTable*;
  static constexpr size_t position{38};
  static constexpr char const * const name{"ModuleRefTable"};
  static constexpr char const * const typestr{"SgAsmCilModuleRefTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ModuleRefTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilModuleRefTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ModuleRefTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilNestedClassTable*,&SgAsmCilMetadataHeap::p_NestedClassTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilNestedClassTable*;
  static constexpr size_t position{39};
  static constexpr char const * const name{"NestedClassTable"};
  static constexpr char const * const typestr{"SgAsmCilNestedClassTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_NestedClassTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilNestedClassTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_NestedClassTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilParamTable*,&SgAsmCilMetadataHeap::p_ParamTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilParamTable*;
  static constexpr size_t position{40};
  static constexpr char const * const name{"ParamTable"};
  static constexpr char const * const typestr{"SgAsmCilParamTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_ParamTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilParamTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_ParamTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilPropertyTable*,&SgAsmCilMetadataHeap::p_PropertyTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilPropertyTable*;
  static constexpr size_t position{41};
  static constexpr char const * const name{"PropertyTable"};
  static constexpr char const * const typestr{"SgAsmCilPropertyTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_PropertyTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilPropertyTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_PropertyTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilPropertyMapTable*,&SgAsmCilMetadataHeap::p_PropertyMapTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilPropertyMapTable*;
  static constexpr size_t position{42};
  static constexpr char const * const name{"PropertyMapTable"};
  static constexpr char const * const typestr{"SgAsmCilPropertyMapTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_PropertyMapTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilPropertyMapTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_PropertyMapTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilStandAloneSigTable*,&SgAsmCilMetadataHeap::p_StandAloneSigTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilStandAloneSigTable*;
  static constexpr size_t position{43};
  static constexpr char const * const name{"StandAloneSigTable"};
  static constexpr char const * const typestr{"SgAsmCilStandAloneSigTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_StandAloneSigTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilStandAloneSigTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_StandAloneSigTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilTypeDefTable*,&SgAsmCilMetadataHeap::p_TypeDefTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilTypeDefTable*;
  static constexpr size_t position{44};
  static constexpr char const * const name{"TypeDefTable"};
  static constexpr char const * const typestr{"SgAsmCilTypeDefTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_TypeDefTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilTypeDefTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_TypeDefTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilTypeRefTable*,&SgAsmCilMetadataHeap::p_TypeRefTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilTypeRefTable*;
  static constexpr size_t position{45};
  static constexpr char const * const name{"TypeRefTable"};
  static constexpr char const * const typestr{"SgAsmCilTypeRefTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_TypeRefTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilTypeRefTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_TypeRefTable>;
};
template <> struct describe_field_t<SgAsmCilMetadataHeap,SgAsmCilTypeSpecTable*,&SgAsmCilMetadataHeap::p_TypeSpecTable> {
  using parent = SgAsmCilMetadataHeap;
  using field_type = SgAsmCilTypeSpecTable*;
  static constexpr size_t position{46};
  static constexpr char const * const name{"TypeSpecTable"};
  static constexpr char const * const typestr{"SgAsmCilTypeSpecTable*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMetadataHeap::p_TypeSpecTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMetadataHeap, SgAsmCilTypeSpecTable* SgAsmCilMetadataHeap::*, &SgAsmCilMetadataHeap::p_TypeSpecTable>;
};
template <> struct describe_node_t<SgAsmCilMetadataHeap> {
  using node = SgAsmCilMetadataHeap;
  using base = SgAsmCilDataStream;
  static constexpr char const * const name{"AsmCilMetadataHeap"};
  static constexpr unsigned long variant{994};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMetadataHeap,uint32_t,&SgAsmCilMetadataHeap::p_ReservedAlwaysZero>, describe_field_t<SgAsmCilMetadataHeap,uint8_t,&SgAsmCilMetadataHeap::p_MajorVersion>, describe_field_t<SgAsmCilMetadataHeap,uint8_t,&SgAsmCilMetadataHeap::p_MinorVersion>, describe_field_t<SgAsmCilMetadataHeap,uint8_t,&SgAsmCilMetadataHeap::p_HeapSizes>, describe_field_t<SgAsmCilMetadataHeap,uint8_t,&SgAsmCilMetadataHeap::p_ReservedAlwaysOne>, describe_field_t<SgAsmCilMetadataHeap,uint64_t,&SgAsmCilMetadataHeap::p_Valid>, describe_field_t<SgAsmCilMetadataHeap,uint64_t,&SgAsmCilMetadataHeap::p_Sorted>, describe_field_t<SgAsmCilMetadataHeap,std::vector<uint32_t>,&SgAsmCilMetadataHeap::p_NumberOfRows>, describe_field_t<SgAsmCilMetadataHeap,uint64_t,&SgAsmCilMetadataHeap::p_DataSizeFlags>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyTable*,&SgAsmCilMetadataHeap::p_AssemblyTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyOSTable*,&SgAsmCilMetadataHeap::p_AssemblyOSTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyProcessorTable*,&SgAsmCilMetadataHeap::p_AssemblyProcessorTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyRefTable*,&SgAsmCilMetadataHeap::p_AssemblyRefTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyRefOSTable*,&SgAsmCilMetadataHeap::p_AssemblyRefOSTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilAssemblyRefProcessorTable*,&SgAsmCilMetadataHeap::p_AssemblyRefProcessorTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilClassLayoutTable*,&SgAsmCilMetadataHeap::p_ClassLayoutTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilConstantTable*,&SgAsmCilMetadataHeap::p_ConstantTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilCustomAttributeTable*,&SgAsmCilMetadataHeap::p_CustomAttributeTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilDeclSecurityTable*,&SgAsmCilMetadataHeap::p_DeclSecurityTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilEventTable*,&SgAsmCilMetadataHeap::p_EventTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilEventMapTable*,&SgAsmCilMetadataHeap::p_EventMapTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilExportedTypeTable*,&SgAsmCilMetadataHeap::p_ExportedTypeTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFieldTable*,&SgAsmCilMetadataHeap::p_FieldTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFieldLayoutTable*,&SgAsmCilMetadataHeap::p_FieldLayoutTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFieldMarshalTable*,&SgAsmCilMetadataHeap::p_FieldMarshalTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFieldRVATable*,&SgAsmCilMetadataHeap::p_FieldRVATable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilFileTable*,&SgAsmCilMetadataHeap::p_FileTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilGenericParamTable*,&SgAsmCilMetadataHeap::p_GenericParamTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilGenericParamConstraintTable*,&SgAsmCilMetadataHeap::p_GenericParamConstraintTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilImplMapTable*,&SgAsmCilMetadataHeap::p_ImplMapTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilInterfaceImplTable*,&SgAsmCilMetadataHeap::p_InterfaceImplTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilManifestResourceTable*,&SgAsmCilMetadataHeap::p_ManifestResourceTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMemberRefTable*,&SgAsmCilMetadataHeap::p_MemberRefTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMethodDefTable*,&SgAsmCilMetadataHeap::p_MethodDefTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMethodImplTable*,&SgAsmCilMetadataHeap::p_MethodImplTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMethodSemanticsTable*,&SgAsmCilMetadataHeap::p_MethodSemanticsTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilMethodSpecTable*,&SgAsmCilMetadataHeap::p_MethodSpecTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilModuleTable*,&SgAsmCilMetadataHeap::p_ModuleTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilModuleRefTable*,&SgAsmCilMetadataHeap::p_ModuleRefTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilNestedClassTable*,&SgAsmCilMetadataHeap::p_NestedClassTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilParamTable*,&SgAsmCilMetadataHeap::p_ParamTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilPropertyTable*,&SgAsmCilMetadataHeap::p_PropertyTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilPropertyMapTable*,&SgAsmCilMetadataHeap::p_PropertyMapTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilStandAloneSigTable*,&SgAsmCilMetadataHeap::p_StandAloneSigTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilTypeDefTable*,&SgAsmCilMetadataHeap::p_TypeDefTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilTypeRefTable*,&SgAsmCilMetadataHeap::p_TypeRefTable>, describe_field_t<SgAsmCilMetadataHeap,SgAsmCilTypeSpecTable*,&SgAsmCilMetadataHeap::p_TypeSpecTable>>;
};
template <> struct node_from_variant_t<994> { using type = SgAsmCilMetadataHeap; };

// Class: AsmCilUint8Heap
template <> struct describe_field_t<SgAsmCilUint8Heap,std::vector<uint8_t>,&SgAsmCilUint8Heap::p_Stream> {
  using parent = SgAsmCilUint8Heap;
  using field_type = std::vector<uint8_t>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Stream"};
  static constexpr char const * const typestr{"std::vector<uint8_t>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilUint8Heap::p_Stream};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilUint8Heap, std::vector<uint8_t> SgAsmCilUint8Heap::*, &SgAsmCilUint8Heap::p_Stream>;
};
template <> struct describe_node_t<SgAsmCilUint8Heap> {
  using node = SgAsmCilUint8Heap;
  using base = SgAsmCilDataStream;
  static constexpr char const * const name{"AsmCilUint8Heap"};
  static constexpr unsigned long variant{995};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilUint8Heap,std::vector<uint8_t>,&SgAsmCilUint8Heap::p_Stream>>;
};
template <> struct node_from_variant_t<995> { using type = SgAsmCilUint8Heap; };

// Class: AsmCilUint32Heap
template <> struct describe_field_t<SgAsmCilUint32Heap,std::vector<uint32_t>,&SgAsmCilUint32Heap::p_Stream> {
  using parent = SgAsmCilUint32Heap;
  using field_type = std::vector<uint32_t>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"Stream"};
  static constexpr char const * const typestr{"std::vector<uint32_t>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilUint32Heap::p_Stream};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilUint32Heap, std::vector<uint32_t> SgAsmCilUint32Heap::*, &SgAsmCilUint32Heap::p_Stream>;
};
template <> struct describe_node_t<SgAsmCilUint32Heap> {
  using node = SgAsmCilUint32Heap;
  using base = SgAsmCilDataStream;
  static constexpr char const * const name{"AsmCilUint32Heap"};
  static constexpr unsigned long variant{996};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilUint32Heap,std::vector<uint32_t>,&SgAsmCilUint32Heap::p_Stream>>;
};
template <> struct node_from_variant_t<996> { using type = SgAsmCilUint32Heap; };

// Class: AsmCliHeader
template <> struct describe_field_t<SgAsmCliHeader,uint32_t,&SgAsmCliHeader::p_cb> {
  using parent = SgAsmCliHeader;
  using field_type = uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"cb"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_cb};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint32_t SgAsmCliHeader::*, &SgAsmCliHeader::p_cb>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint16_t,&SgAsmCliHeader::p_majorRuntimeVersion> {
  using parent = SgAsmCliHeader;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"majorRuntimeVersion"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_majorRuntimeVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint16_t SgAsmCliHeader::*, &SgAsmCliHeader::p_majorRuntimeVersion>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint16_t,&SgAsmCliHeader::p_minorRuntimeVersion> {
  using parent = SgAsmCliHeader;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"minorRuntimeVersion"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_minorRuntimeVersion};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint16_t SgAsmCliHeader::*, &SgAsmCliHeader::p_minorRuntimeVersion>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_metaData> {
  using parent = SgAsmCliHeader;
  using field_type = uint64_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"metaData"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_metaData};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint64_t SgAsmCliHeader::*, &SgAsmCliHeader::p_metaData>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint32_t,&SgAsmCliHeader::p_flags> {
  using parent = SgAsmCliHeader;
  using field_type = uint32_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint32_t SgAsmCliHeader::*, &SgAsmCliHeader::p_flags>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint32_t,&SgAsmCliHeader::p_entryPointToken> {
  using parent = SgAsmCliHeader;
  using field_type = uint32_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"entryPointToken"};
  static constexpr char const * const typestr{"uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_entryPointToken};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint32_t SgAsmCliHeader::*, &SgAsmCliHeader::p_entryPointToken>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_resources> {
  using parent = SgAsmCliHeader;
  using field_type = uint64_t;
  static constexpr size_t position{6};
  static constexpr char const * const name{"resources"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_resources};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint64_t SgAsmCliHeader::*, &SgAsmCliHeader::p_resources>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_strongNameSignature> {
  using parent = SgAsmCliHeader;
  using field_type = uint64_t;
  static constexpr size_t position{7};
  static constexpr char const * const name{"strongNameSignature"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_strongNameSignature};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint64_t SgAsmCliHeader::*, &SgAsmCliHeader::p_strongNameSignature>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_codeManagerTable> {
  using parent = SgAsmCliHeader;
  using field_type = uint64_t;
  static constexpr size_t position{8};
  static constexpr char const * const name{"codeManagerTable"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_codeManagerTable};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint64_t SgAsmCliHeader::*, &SgAsmCliHeader::p_codeManagerTable>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_vTableFixups> {
  using parent = SgAsmCliHeader;
  using field_type = uint64_t;
  static constexpr size_t position{9};
  static constexpr char const * const name{"vTableFixups"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_vTableFixups};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint64_t SgAsmCliHeader::*, &SgAsmCliHeader::p_vTableFixups>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_exportAddressTableJumps> {
  using parent = SgAsmCliHeader;
  using field_type = uint64_t;
  static constexpr size_t position{10};
  static constexpr char const * const name{"exportAddressTableJumps"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_exportAddressTableJumps};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint64_t SgAsmCliHeader::*, &SgAsmCliHeader::p_exportAddressTableJumps>;
};
template <> struct describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_managedNativeHeader> {
  using parent = SgAsmCliHeader;
  using field_type = uint64_t;
  static constexpr size_t position{11};
  static constexpr char const * const name{"managedNativeHeader"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_managedNativeHeader};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, uint64_t SgAsmCliHeader::*, &SgAsmCliHeader::p_managedNativeHeader>;
};
template <> struct describe_field_t<SgAsmCliHeader,SgAsmCilMetadataRoot*,&SgAsmCliHeader::p_metadataRoot> {
  using parent = SgAsmCliHeader;
  using field_type = SgAsmCilMetadataRoot*;
  static constexpr size_t position{12};
  static constexpr char const * const name{"metadataRoot"};
  static constexpr char const * const typestr{"SgAsmCilMetadataRoot*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCliHeader::p_metadataRoot};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCliHeader, SgAsmCilMetadataRoot* SgAsmCliHeader::*, &SgAsmCliHeader::p_metadataRoot>;
};
template <> struct describe_node_t<SgAsmCliHeader> {
  using node = SgAsmCliHeader;
  using base = SgAsmGenericSection;
  static constexpr char const * const name{"AsmCliHeader"};
  static constexpr unsigned long variant{997};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCliHeader,uint32_t,&SgAsmCliHeader::p_cb>, describe_field_t<SgAsmCliHeader,uint16_t,&SgAsmCliHeader::p_majorRuntimeVersion>, describe_field_t<SgAsmCliHeader,uint16_t,&SgAsmCliHeader::p_minorRuntimeVersion>, describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_metaData>, describe_field_t<SgAsmCliHeader,uint32_t,&SgAsmCliHeader::p_flags>, describe_field_t<SgAsmCliHeader,uint32_t,&SgAsmCliHeader::p_entryPointToken>, describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_resources>, describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_strongNameSignature>, describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_codeManagerTable>, describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_vTableFixups>, describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_exportAddressTableJumps>, describe_field_t<SgAsmCliHeader,uint64_t,&SgAsmCliHeader::p_managedNativeHeader>, describe_field_t<SgAsmCliHeader,SgAsmCilMetadataRoot*,&SgAsmCliHeader::p_metadataRoot>>;
};
template <> struct node_from_variant_t<997> { using type = SgAsmCliHeader; };

// Class: AdaVariantDecl
template <> struct describe_field_t<SgAdaVariantDecl,SgExpression*,&SgAdaVariantDecl::p_discriminant> {
  using parent = SgAdaVariantDecl;
  using field_type = SgExpression*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"discriminant"};
  static constexpr char const * const typestr{"SgExpression*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaVariantDecl::p_discriminant};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaVariantDecl, SgExpression* SgAdaVariantDecl::*, &SgAdaVariantDecl::p_discriminant>;
};
template <> struct describe_field_t<SgAdaVariantDecl,SgAdaUnscopedBlock*,&SgAdaVariantDecl::p_variants> {
  using parent = SgAdaVariantDecl;
  using field_type = SgAdaUnscopedBlock*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"variants"};
  static constexpr char const * const typestr{"SgAdaUnscopedBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaVariantDecl::p_variants};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaVariantDecl, SgAdaUnscopedBlock* SgAdaVariantDecl::*, &SgAdaVariantDecl::p_variants>;
};
template <> struct describe_node_t<SgAdaVariantDecl> {
  using node = SgAdaVariantDecl;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"AdaVariantDecl"};
  static constexpr unsigned long variant{998};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaVariantDecl,SgExpression*,&SgAdaVariantDecl::p_discriminant>, describe_field_t<SgAdaVariantDecl,SgAdaUnscopedBlock*,&SgAdaVariantDecl::p_variants>>;
};
template <> struct node_from_variant_t<998> { using type = SgAdaVariantDecl; };

// Class: AdaVariantWhenStmt
template <> struct describe_field_t<SgAdaVariantWhenStmt,SgExprListExp*,&SgAdaVariantWhenStmt::p_choices> {
  using parent = SgAdaVariantWhenStmt;
  using field_type = SgExprListExp*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"choices"};
  static constexpr char const * const typestr{"SgExprListExp*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaVariantWhenStmt::p_choices};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaVariantWhenStmt, SgExprListExp* SgAdaVariantWhenStmt::*, &SgAdaVariantWhenStmt::p_choices>;
};
template <> struct describe_field_t<SgAdaVariantWhenStmt,SgAdaUnscopedBlock*,&SgAdaVariantWhenStmt::p_components> {
  using parent = SgAdaVariantWhenStmt;
  using field_type = SgAdaUnscopedBlock*;
  static constexpr size_t position{1};
  static constexpr char const * const name{"components"};
  static constexpr char const * const typestr{"SgAdaUnscopedBlock*"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAdaVariantWhenStmt::p_components};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAdaVariantWhenStmt, SgAdaUnscopedBlock* SgAdaVariantWhenStmt::*, &SgAdaVariantWhenStmt::p_components>;
};
template <> struct describe_node_t<SgAdaVariantWhenStmt> {
  using node = SgAdaVariantWhenStmt;
  using base = SgStatement;
  static constexpr char const * const name{"AdaVariantWhenStmt"};
  static constexpr unsigned long variant{999};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAdaVariantWhenStmt,SgExprListExp*,&SgAdaVariantWhenStmt::p_choices>, describe_field_t<SgAdaVariantWhenStmt,SgAdaUnscopedBlock*,&SgAdaVariantWhenStmt::p_components>>;
};
template <> struct node_from_variant_t<999> { using type = SgAdaVariantWhenStmt; };

// Class: AsmCilAssemblyTable
template <> struct describe_field_t<SgAsmCilAssemblyTable,std::vector<SgAsmCilAssembly*>,&SgAsmCilAssemblyTable::p_elements> {
  using parent = SgAsmCilAssemblyTable;
  using field_type = std::vector<SgAsmCilAssembly*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilAssembly*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyTable, std::vector<SgAsmCilAssembly*> SgAsmCilAssemblyTable::*, &SgAsmCilAssemblyTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilAssemblyTable> {
  using node = SgAsmCilAssemblyTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyTable"};
  static constexpr unsigned long variant{1000};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyTable,std::vector<SgAsmCilAssembly*>,&SgAsmCilAssemblyTable::p_elements>>;
};
template <> struct node_from_variant_t<1000> { using type = SgAsmCilAssemblyTable; };

// Class: AsmCilAssemblyOSTable
template <> struct describe_field_t<SgAsmCilAssemblyOSTable,std::vector<SgAsmCilAssemblyOS*>,&SgAsmCilAssemblyOSTable::p_elements> {
  using parent = SgAsmCilAssemblyOSTable;
  using field_type = std::vector<SgAsmCilAssemblyOS*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilAssemblyOS*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyOSTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyOSTable, std::vector<SgAsmCilAssemblyOS*> SgAsmCilAssemblyOSTable::*, &SgAsmCilAssemblyOSTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilAssemblyOSTable> {
  using node = SgAsmCilAssemblyOSTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyOSTable"};
  static constexpr unsigned long variant{1001};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyOSTable,std::vector<SgAsmCilAssemblyOS*>,&SgAsmCilAssemblyOSTable::p_elements>>;
};
template <> struct node_from_variant_t<1001> { using type = SgAsmCilAssemblyOSTable; };

// Class: AsmCilAssemblyProcessorTable
template <> struct describe_field_t<SgAsmCilAssemblyProcessorTable,std::vector<SgAsmCilAssemblyProcessor*>,&SgAsmCilAssemblyProcessorTable::p_elements> {
  using parent = SgAsmCilAssemblyProcessorTable;
  using field_type = std::vector<SgAsmCilAssemblyProcessor*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilAssemblyProcessor*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyProcessorTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyProcessorTable, std::vector<SgAsmCilAssemblyProcessor*> SgAsmCilAssemblyProcessorTable::*, &SgAsmCilAssemblyProcessorTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilAssemblyProcessorTable> {
  using node = SgAsmCilAssemblyProcessorTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyProcessorTable"};
  static constexpr unsigned long variant{1002};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyProcessorTable,std::vector<SgAsmCilAssemblyProcessor*>,&SgAsmCilAssemblyProcessorTable::p_elements>>;
};
template <> struct node_from_variant_t<1002> { using type = SgAsmCilAssemblyProcessorTable; };

// Class: AsmCilAssemblyRefTable
template <> struct describe_field_t<SgAsmCilAssemblyRefTable,std::vector<SgAsmCilAssemblyRef*>,&SgAsmCilAssemblyRefTable::p_elements> {
  using parent = SgAsmCilAssemblyRefTable;
  using field_type = std::vector<SgAsmCilAssemblyRef*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilAssemblyRef*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRefTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRefTable, std::vector<SgAsmCilAssemblyRef*> SgAsmCilAssemblyRefTable::*, &SgAsmCilAssemblyRefTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilAssemblyRefTable> {
  using node = SgAsmCilAssemblyRefTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyRefTable"};
  static constexpr unsigned long variant{1003};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyRefTable,std::vector<SgAsmCilAssemblyRef*>,&SgAsmCilAssemblyRefTable::p_elements>>;
};
template <> struct node_from_variant_t<1003> { using type = SgAsmCilAssemblyRefTable; };

// Class: AsmCilAssemblyRefOSTable
template <> struct describe_field_t<SgAsmCilAssemblyRefOSTable,std::vector<SgAsmCilAssemblyRefOS*>,&SgAsmCilAssemblyRefOSTable::p_elements> {
  using parent = SgAsmCilAssemblyRefOSTable;
  using field_type = std::vector<SgAsmCilAssemblyRefOS*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilAssemblyRefOS*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRefOSTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRefOSTable, std::vector<SgAsmCilAssemblyRefOS*> SgAsmCilAssemblyRefOSTable::*, &SgAsmCilAssemblyRefOSTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilAssemblyRefOSTable> {
  using node = SgAsmCilAssemblyRefOSTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyRefOSTable"};
  static constexpr unsigned long variant{1004};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyRefOSTable,std::vector<SgAsmCilAssemblyRefOS*>,&SgAsmCilAssemblyRefOSTable::p_elements>>;
};
template <> struct node_from_variant_t<1004> { using type = SgAsmCilAssemblyRefOSTable; };

// Class: AsmCilAssemblyRefProcessorTable
template <> struct describe_field_t<SgAsmCilAssemblyRefProcessorTable,std::vector<SgAsmCilAssemblyRefProcessor*>,&SgAsmCilAssemblyRefProcessorTable::p_elements> {
  using parent = SgAsmCilAssemblyRefProcessorTable;
  using field_type = std::vector<SgAsmCilAssemblyRefProcessor*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilAssemblyRefProcessor*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilAssemblyRefProcessorTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilAssemblyRefProcessorTable, std::vector<SgAsmCilAssemblyRefProcessor*> SgAsmCilAssemblyRefProcessorTable::*, &SgAsmCilAssemblyRefProcessorTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilAssemblyRefProcessorTable> {
  using node = SgAsmCilAssemblyRefProcessorTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilAssemblyRefProcessorTable"};
  static constexpr unsigned long variant{1005};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilAssemblyRefProcessorTable,std::vector<SgAsmCilAssemblyRefProcessor*>,&SgAsmCilAssemblyRefProcessorTable::p_elements>>;
};
template <> struct node_from_variant_t<1005> { using type = SgAsmCilAssemblyRefProcessorTable; };

// Class: AsmCilClassLayoutTable
template <> struct describe_field_t<SgAsmCilClassLayoutTable,std::vector<SgAsmCilClassLayout*>,&SgAsmCilClassLayoutTable::p_elements> {
  using parent = SgAsmCilClassLayoutTable;
  using field_type = std::vector<SgAsmCilClassLayout*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilClassLayout*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilClassLayoutTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilClassLayoutTable, std::vector<SgAsmCilClassLayout*> SgAsmCilClassLayoutTable::*, &SgAsmCilClassLayoutTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilClassLayoutTable> {
  using node = SgAsmCilClassLayoutTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilClassLayoutTable"};
  static constexpr unsigned long variant{1006};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilClassLayoutTable,std::vector<SgAsmCilClassLayout*>,&SgAsmCilClassLayoutTable::p_elements>>;
};
template <> struct node_from_variant_t<1006> { using type = SgAsmCilClassLayoutTable; };

// Class: AsmCilConstantTable
template <> struct describe_field_t<SgAsmCilConstantTable,std::vector<SgAsmCilConstant*>,&SgAsmCilConstantTable::p_elements> {
  using parent = SgAsmCilConstantTable;
  using field_type = std::vector<SgAsmCilConstant*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilConstant*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilConstantTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilConstantTable, std::vector<SgAsmCilConstant*> SgAsmCilConstantTable::*, &SgAsmCilConstantTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilConstantTable> {
  using node = SgAsmCilConstantTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilConstantTable"};
  static constexpr unsigned long variant{1007};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilConstantTable,std::vector<SgAsmCilConstant*>,&SgAsmCilConstantTable::p_elements>>;
};
template <> struct node_from_variant_t<1007> { using type = SgAsmCilConstantTable; };

// Class: AsmCilCustomAttributeTable
template <> struct describe_field_t<SgAsmCilCustomAttributeTable,std::vector<SgAsmCilCustomAttribute*>,&SgAsmCilCustomAttributeTable::p_elements> {
  using parent = SgAsmCilCustomAttributeTable;
  using field_type = std::vector<SgAsmCilCustomAttribute*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilCustomAttribute*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilCustomAttributeTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilCustomAttributeTable, std::vector<SgAsmCilCustomAttribute*> SgAsmCilCustomAttributeTable::*, &SgAsmCilCustomAttributeTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilCustomAttributeTable> {
  using node = SgAsmCilCustomAttributeTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilCustomAttributeTable"};
  static constexpr unsigned long variant{1008};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilCustomAttributeTable,std::vector<SgAsmCilCustomAttribute*>,&SgAsmCilCustomAttributeTable::p_elements>>;
};
template <> struct node_from_variant_t<1008> { using type = SgAsmCilCustomAttributeTable; };

// Class: AsmCilDeclSecurityTable
template <> struct describe_field_t<SgAsmCilDeclSecurityTable,std::vector<SgAsmCilDeclSecurity*>,&SgAsmCilDeclSecurityTable::p_elements> {
  using parent = SgAsmCilDeclSecurityTable;
  using field_type = std::vector<SgAsmCilDeclSecurity*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilDeclSecurity*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilDeclSecurityTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilDeclSecurityTable, std::vector<SgAsmCilDeclSecurity*> SgAsmCilDeclSecurityTable::*, &SgAsmCilDeclSecurityTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilDeclSecurityTable> {
  using node = SgAsmCilDeclSecurityTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilDeclSecurityTable"};
  static constexpr unsigned long variant{1009};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilDeclSecurityTable,std::vector<SgAsmCilDeclSecurity*>,&SgAsmCilDeclSecurityTable::p_elements>>;
};
template <> struct node_from_variant_t<1009> { using type = SgAsmCilDeclSecurityTable; };

// Class: AsmCilEventTable
template <> struct describe_field_t<SgAsmCilEventTable,std::vector<SgAsmCilEvent*>,&SgAsmCilEventTable::p_elements> {
  using parent = SgAsmCilEventTable;
  using field_type = std::vector<SgAsmCilEvent*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilEvent*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilEventTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilEventTable, std::vector<SgAsmCilEvent*> SgAsmCilEventTable::*, &SgAsmCilEventTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilEventTable> {
  using node = SgAsmCilEventTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilEventTable"};
  static constexpr unsigned long variant{1010};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilEventTable,std::vector<SgAsmCilEvent*>,&SgAsmCilEventTable::p_elements>>;
};
template <> struct node_from_variant_t<1010> { using type = SgAsmCilEventTable; };

// Class: AsmCilEventMapTable
template <> struct describe_field_t<SgAsmCilEventMapTable,std::vector<SgAsmCilEventMap*>,&SgAsmCilEventMapTable::p_elements> {
  using parent = SgAsmCilEventMapTable;
  using field_type = std::vector<SgAsmCilEventMap*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilEventMap*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilEventMapTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilEventMapTable, std::vector<SgAsmCilEventMap*> SgAsmCilEventMapTable::*, &SgAsmCilEventMapTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilEventMapTable> {
  using node = SgAsmCilEventMapTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilEventMapTable"};
  static constexpr unsigned long variant{1011};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilEventMapTable,std::vector<SgAsmCilEventMap*>,&SgAsmCilEventMapTable::p_elements>>;
};
template <> struct node_from_variant_t<1011> { using type = SgAsmCilEventMapTable; };

// Class: AsmCilExportedTypeTable
template <> struct describe_field_t<SgAsmCilExportedTypeTable,std::vector<SgAsmCilExportedType*>,&SgAsmCilExportedTypeTable::p_elements> {
  using parent = SgAsmCilExportedTypeTable;
  using field_type = std::vector<SgAsmCilExportedType*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilExportedType*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilExportedTypeTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExportedTypeTable, std::vector<SgAsmCilExportedType*> SgAsmCilExportedTypeTable::*, &SgAsmCilExportedTypeTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilExportedTypeTable> {
  using node = SgAsmCilExportedTypeTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilExportedTypeTable"};
  static constexpr unsigned long variant{1012};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilExportedTypeTable,std::vector<SgAsmCilExportedType*>,&SgAsmCilExportedTypeTable::p_elements>>;
};
template <> struct node_from_variant_t<1012> { using type = SgAsmCilExportedTypeTable; };

// Class: AsmCilFieldTable
template <> struct describe_field_t<SgAsmCilFieldTable,std::vector<SgAsmCilField*>,&SgAsmCilFieldTable::p_elements> {
  using parent = SgAsmCilFieldTable;
  using field_type = std::vector<SgAsmCilField*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilField*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilFieldTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldTable, std::vector<SgAsmCilField*> SgAsmCilFieldTable::*, &SgAsmCilFieldTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilFieldTable> {
  using node = SgAsmCilFieldTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilFieldTable"};
  static constexpr unsigned long variant{1013};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilFieldTable,std::vector<SgAsmCilField*>,&SgAsmCilFieldTable::p_elements>>;
};
template <> struct node_from_variant_t<1013> { using type = SgAsmCilFieldTable; };

// Class: AsmCilFieldLayoutTable
template <> struct describe_field_t<SgAsmCilFieldLayoutTable,std::vector<SgAsmCilFieldLayout*>,&SgAsmCilFieldLayoutTable::p_elements> {
  using parent = SgAsmCilFieldLayoutTable;
  using field_type = std::vector<SgAsmCilFieldLayout*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilFieldLayout*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilFieldLayoutTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldLayoutTable, std::vector<SgAsmCilFieldLayout*> SgAsmCilFieldLayoutTable::*, &SgAsmCilFieldLayoutTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilFieldLayoutTable> {
  using node = SgAsmCilFieldLayoutTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilFieldLayoutTable"};
  static constexpr unsigned long variant{1014};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilFieldLayoutTable,std::vector<SgAsmCilFieldLayout*>,&SgAsmCilFieldLayoutTable::p_elements>>;
};
template <> struct node_from_variant_t<1014> { using type = SgAsmCilFieldLayoutTable; };

// Class: AsmCilFieldMarshalTable
template <> struct describe_field_t<SgAsmCilFieldMarshalTable,std::vector<SgAsmCilFieldMarshal*>,&SgAsmCilFieldMarshalTable::p_elements> {
  using parent = SgAsmCilFieldMarshalTable;
  using field_type = std::vector<SgAsmCilFieldMarshal*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilFieldMarshal*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilFieldMarshalTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldMarshalTable, std::vector<SgAsmCilFieldMarshal*> SgAsmCilFieldMarshalTable::*, &SgAsmCilFieldMarshalTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilFieldMarshalTable> {
  using node = SgAsmCilFieldMarshalTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilFieldMarshalTable"};
  static constexpr unsigned long variant{1015};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilFieldMarshalTable,std::vector<SgAsmCilFieldMarshal*>,&SgAsmCilFieldMarshalTable::p_elements>>;
};
template <> struct node_from_variant_t<1015> { using type = SgAsmCilFieldMarshalTable; };

// Class: AsmCilFieldRVATable
template <> struct describe_field_t<SgAsmCilFieldRVATable,std::vector<SgAsmCilFieldRVA*>,&SgAsmCilFieldRVATable::p_elements> {
  using parent = SgAsmCilFieldRVATable;
  using field_type = std::vector<SgAsmCilFieldRVA*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilFieldRVA*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilFieldRVATable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFieldRVATable, std::vector<SgAsmCilFieldRVA*> SgAsmCilFieldRVATable::*, &SgAsmCilFieldRVATable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilFieldRVATable> {
  using node = SgAsmCilFieldRVATable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilFieldRVATable"};
  static constexpr unsigned long variant{1016};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilFieldRVATable,std::vector<SgAsmCilFieldRVA*>,&SgAsmCilFieldRVATable::p_elements>>;
};
template <> struct node_from_variant_t<1016> { using type = SgAsmCilFieldRVATable; };

// Class: AsmCilFileTable
template <> struct describe_field_t<SgAsmCilFileTable,std::vector<SgAsmCilFile*>,&SgAsmCilFileTable::p_elements> {
  using parent = SgAsmCilFileTable;
  using field_type = std::vector<SgAsmCilFile*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilFile*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilFileTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilFileTable, std::vector<SgAsmCilFile*> SgAsmCilFileTable::*, &SgAsmCilFileTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilFileTable> {
  using node = SgAsmCilFileTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilFileTable"};
  static constexpr unsigned long variant{1017};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilFileTable,std::vector<SgAsmCilFile*>,&SgAsmCilFileTable::p_elements>>;
};
template <> struct node_from_variant_t<1017> { using type = SgAsmCilFileTable; };

// Class: AsmCilGenericParamTable
template <> struct describe_field_t<SgAsmCilGenericParamTable,std::vector<SgAsmCilGenericParam*>,&SgAsmCilGenericParamTable::p_elements> {
  using parent = SgAsmCilGenericParamTable;
  using field_type = std::vector<SgAsmCilGenericParam*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilGenericParam*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilGenericParamTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilGenericParamTable, std::vector<SgAsmCilGenericParam*> SgAsmCilGenericParamTable::*, &SgAsmCilGenericParamTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilGenericParamTable> {
  using node = SgAsmCilGenericParamTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilGenericParamTable"};
  static constexpr unsigned long variant{1018};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilGenericParamTable,std::vector<SgAsmCilGenericParam*>,&SgAsmCilGenericParamTable::p_elements>>;
};
template <> struct node_from_variant_t<1018> { using type = SgAsmCilGenericParamTable; };

// Class: AsmCilGenericParamConstraintTable
template <> struct describe_field_t<SgAsmCilGenericParamConstraintTable,std::vector<SgAsmCilGenericParamConstraint*>,&SgAsmCilGenericParamConstraintTable::p_elements> {
  using parent = SgAsmCilGenericParamConstraintTable;
  using field_type = std::vector<SgAsmCilGenericParamConstraint*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilGenericParamConstraint*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilGenericParamConstraintTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilGenericParamConstraintTable, std::vector<SgAsmCilGenericParamConstraint*> SgAsmCilGenericParamConstraintTable::*, &SgAsmCilGenericParamConstraintTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilGenericParamConstraintTable> {
  using node = SgAsmCilGenericParamConstraintTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilGenericParamConstraintTable"};
  static constexpr unsigned long variant{1019};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilGenericParamConstraintTable,std::vector<SgAsmCilGenericParamConstraint*>,&SgAsmCilGenericParamConstraintTable::p_elements>>;
};
template <> struct node_from_variant_t<1019> { using type = SgAsmCilGenericParamConstraintTable; };

// Class: AsmCilImplMapTable
template <> struct describe_field_t<SgAsmCilImplMapTable,std::vector<SgAsmCilImplMap*>,&SgAsmCilImplMapTable::p_elements> {
  using parent = SgAsmCilImplMapTable;
  using field_type = std::vector<SgAsmCilImplMap*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilImplMap*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilImplMapTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilImplMapTable, std::vector<SgAsmCilImplMap*> SgAsmCilImplMapTable::*, &SgAsmCilImplMapTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilImplMapTable> {
  using node = SgAsmCilImplMapTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilImplMapTable"};
  static constexpr unsigned long variant{1020};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilImplMapTable,std::vector<SgAsmCilImplMap*>,&SgAsmCilImplMapTable::p_elements>>;
};
template <> struct node_from_variant_t<1020> { using type = SgAsmCilImplMapTable; };

// Class: AsmCilInterfaceImplTable
template <> struct describe_field_t<SgAsmCilInterfaceImplTable,std::vector<SgAsmCilInterfaceImpl*>,&SgAsmCilInterfaceImplTable::p_elements> {
  using parent = SgAsmCilInterfaceImplTable;
  using field_type = std::vector<SgAsmCilInterfaceImpl*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilInterfaceImpl*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilInterfaceImplTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilInterfaceImplTable, std::vector<SgAsmCilInterfaceImpl*> SgAsmCilInterfaceImplTable::*, &SgAsmCilInterfaceImplTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilInterfaceImplTable> {
  using node = SgAsmCilInterfaceImplTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilInterfaceImplTable"};
  static constexpr unsigned long variant{1021};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilInterfaceImplTable,std::vector<SgAsmCilInterfaceImpl*>,&SgAsmCilInterfaceImplTable::p_elements>>;
};
template <> struct node_from_variant_t<1021> { using type = SgAsmCilInterfaceImplTable; };

// Class: AsmCilManifestResourceTable
template <> struct describe_field_t<SgAsmCilManifestResourceTable,std::vector<SgAsmCilManifestResource*>,&SgAsmCilManifestResourceTable::p_elements> {
  using parent = SgAsmCilManifestResourceTable;
  using field_type = std::vector<SgAsmCilManifestResource*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilManifestResource*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilManifestResourceTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilManifestResourceTable, std::vector<SgAsmCilManifestResource*> SgAsmCilManifestResourceTable::*, &SgAsmCilManifestResourceTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilManifestResourceTable> {
  using node = SgAsmCilManifestResourceTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilManifestResourceTable"};
  static constexpr unsigned long variant{1022};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilManifestResourceTable,std::vector<SgAsmCilManifestResource*>,&SgAsmCilManifestResourceTable::p_elements>>;
};
template <> struct node_from_variant_t<1022> { using type = SgAsmCilManifestResourceTable; };

// Class: AsmCilMemberRefTable
template <> struct describe_field_t<SgAsmCilMemberRefTable,std::vector<SgAsmCilMemberRef*>,&SgAsmCilMemberRefTable::p_elements> {
  using parent = SgAsmCilMemberRefTable;
  using field_type = std::vector<SgAsmCilMemberRef*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilMemberRef*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMemberRefTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMemberRefTable, std::vector<SgAsmCilMemberRef*> SgAsmCilMemberRefTable::*, &SgAsmCilMemberRefTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilMemberRefTable> {
  using node = SgAsmCilMemberRefTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMemberRefTable"};
  static constexpr unsigned long variant{1023};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMemberRefTable,std::vector<SgAsmCilMemberRef*>,&SgAsmCilMemberRefTable::p_elements>>;
};
template <> struct node_from_variant_t<1023> { using type = SgAsmCilMemberRefTable; };

// Class: AsmCilMethodDefTable
template <> struct describe_field_t<SgAsmCilMethodDefTable,std::vector<SgAsmCilMethodDef*>,&SgAsmCilMethodDefTable::p_elements> {
  using parent = SgAsmCilMethodDefTable;
  using field_type = std::vector<SgAsmCilMethodDef*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilMethodDef*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMethodDefTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodDefTable, std::vector<SgAsmCilMethodDef*> SgAsmCilMethodDefTable::*, &SgAsmCilMethodDefTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilMethodDefTable> {
  using node = SgAsmCilMethodDefTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMethodDefTable"};
  static constexpr unsigned long variant{1024};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMethodDefTable,std::vector<SgAsmCilMethodDef*>,&SgAsmCilMethodDefTable::p_elements>>;
};
template <> struct node_from_variant_t<1024> { using type = SgAsmCilMethodDefTable; };

// Class: AsmCilMethodImplTable
template <> struct describe_field_t<SgAsmCilMethodImplTable,std::vector<SgAsmCilMethodImpl*>,&SgAsmCilMethodImplTable::p_elements> {
  using parent = SgAsmCilMethodImplTable;
  using field_type = std::vector<SgAsmCilMethodImpl*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilMethodImpl*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMethodImplTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodImplTable, std::vector<SgAsmCilMethodImpl*> SgAsmCilMethodImplTable::*, &SgAsmCilMethodImplTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilMethodImplTable> {
  using node = SgAsmCilMethodImplTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMethodImplTable"};
  static constexpr unsigned long variant{1025};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMethodImplTable,std::vector<SgAsmCilMethodImpl*>,&SgAsmCilMethodImplTable::p_elements>>;
};
template <> struct node_from_variant_t<1025> { using type = SgAsmCilMethodImplTable; };

// Class: AsmCilMethodSemanticsTable
template <> struct describe_field_t<SgAsmCilMethodSemanticsTable,std::vector<SgAsmCilMethodSemantics*>,&SgAsmCilMethodSemanticsTable::p_elements> {
  using parent = SgAsmCilMethodSemanticsTable;
  using field_type = std::vector<SgAsmCilMethodSemantics*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilMethodSemantics*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMethodSemanticsTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodSemanticsTable, std::vector<SgAsmCilMethodSemantics*> SgAsmCilMethodSemanticsTable::*, &SgAsmCilMethodSemanticsTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilMethodSemanticsTable> {
  using node = SgAsmCilMethodSemanticsTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMethodSemanticsTable"};
  static constexpr unsigned long variant{1026};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMethodSemanticsTable,std::vector<SgAsmCilMethodSemantics*>,&SgAsmCilMethodSemanticsTable::p_elements>>;
};
template <> struct node_from_variant_t<1026> { using type = SgAsmCilMethodSemanticsTable; };

// Class: AsmCilMethodSpecTable
template <> struct describe_field_t<SgAsmCilMethodSpecTable,std::vector<SgAsmCilMethodSpec*>,&SgAsmCilMethodSpecTable::p_elements> {
  using parent = SgAsmCilMethodSpecTable;
  using field_type = std::vector<SgAsmCilMethodSpec*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilMethodSpec*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilMethodSpecTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodSpecTable, std::vector<SgAsmCilMethodSpec*> SgAsmCilMethodSpecTable::*, &SgAsmCilMethodSpecTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilMethodSpecTable> {
  using node = SgAsmCilMethodSpecTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilMethodSpecTable"};
  static constexpr unsigned long variant{1027};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMethodSpecTable,std::vector<SgAsmCilMethodSpec*>,&SgAsmCilMethodSpecTable::p_elements>>;
};
template <> struct node_from_variant_t<1027> { using type = SgAsmCilMethodSpecTable; };

// Class: AsmCilModuleTable
template <> struct describe_field_t<SgAsmCilModuleTable,std::vector<SgAsmCilModule*>,&SgAsmCilModuleTable::p_elements> {
  using parent = SgAsmCilModuleTable;
  using field_type = std::vector<SgAsmCilModule*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilModule*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilModuleTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilModuleTable, std::vector<SgAsmCilModule*> SgAsmCilModuleTable::*, &SgAsmCilModuleTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilModuleTable> {
  using node = SgAsmCilModuleTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilModuleTable"};
  static constexpr unsigned long variant{1028};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilModuleTable,std::vector<SgAsmCilModule*>,&SgAsmCilModuleTable::p_elements>>;
};
template <> struct node_from_variant_t<1028> { using type = SgAsmCilModuleTable; };

// Class: AsmCilModuleRefTable
template <> struct describe_field_t<SgAsmCilModuleRefTable,std::vector<SgAsmCilModuleRef*>,&SgAsmCilModuleRefTable::p_elements> {
  using parent = SgAsmCilModuleRefTable;
  using field_type = std::vector<SgAsmCilModuleRef*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilModuleRef*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilModuleRefTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilModuleRefTable, std::vector<SgAsmCilModuleRef*> SgAsmCilModuleRefTable::*, &SgAsmCilModuleRefTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilModuleRefTable> {
  using node = SgAsmCilModuleRefTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilModuleRefTable"};
  static constexpr unsigned long variant{1029};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilModuleRefTable,std::vector<SgAsmCilModuleRef*>,&SgAsmCilModuleRefTable::p_elements>>;
};
template <> struct node_from_variant_t<1029> { using type = SgAsmCilModuleRefTable; };

// Class: AsmCilNestedClassTable
template <> struct describe_field_t<SgAsmCilNestedClassTable,std::vector<SgAsmCilNestedClass*>,&SgAsmCilNestedClassTable::p_elements> {
  using parent = SgAsmCilNestedClassTable;
  using field_type = std::vector<SgAsmCilNestedClass*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilNestedClass*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilNestedClassTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilNestedClassTable, std::vector<SgAsmCilNestedClass*> SgAsmCilNestedClassTable::*, &SgAsmCilNestedClassTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilNestedClassTable> {
  using node = SgAsmCilNestedClassTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilNestedClassTable"};
  static constexpr unsigned long variant{1030};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilNestedClassTable,std::vector<SgAsmCilNestedClass*>,&SgAsmCilNestedClassTable::p_elements>>;
};
template <> struct node_from_variant_t<1030> { using type = SgAsmCilNestedClassTable; };

// Class: AsmCilParamTable
template <> struct describe_field_t<SgAsmCilParamTable,std::vector<SgAsmCilParam*>,&SgAsmCilParamTable::p_elements> {
  using parent = SgAsmCilParamTable;
  using field_type = std::vector<SgAsmCilParam*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilParam*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilParamTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilParamTable, std::vector<SgAsmCilParam*> SgAsmCilParamTable::*, &SgAsmCilParamTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilParamTable> {
  using node = SgAsmCilParamTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilParamTable"};
  static constexpr unsigned long variant{1031};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilParamTable,std::vector<SgAsmCilParam*>,&SgAsmCilParamTable::p_elements>>;
};
template <> struct node_from_variant_t<1031> { using type = SgAsmCilParamTable; };

// Class: AsmCilPropertyTable
template <> struct describe_field_t<SgAsmCilPropertyTable,std::vector<SgAsmCilProperty*>,&SgAsmCilPropertyTable::p_elements> {
  using parent = SgAsmCilPropertyTable;
  using field_type = std::vector<SgAsmCilProperty*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilProperty*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilPropertyTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilPropertyTable, std::vector<SgAsmCilProperty*> SgAsmCilPropertyTable::*, &SgAsmCilPropertyTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilPropertyTable> {
  using node = SgAsmCilPropertyTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilPropertyTable"};
  static constexpr unsigned long variant{1032};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilPropertyTable,std::vector<SgAsmCilProperty*>,&SgAsmCilPropertyTable::p_elements>>;
};
template <> struct node_from_variant_t<1032> { using type = SgAsmCilPropertyTable; };

// Class: AsmCilPropertyMapTable
template <> struct describe_field_t<SgAsmCilPropertyMapTable,std::vector<SgAsmCilPropertyMap*>,&SgAsmCilPropertyMapTable::p_elements> {
  using parent = SgAsmCilPropertyMapTable;
  using field_type = std::vector<SgAsmCilPropertyMap*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilPropertyMap*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilPropertyMapTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilPropertyMapTable, std::vector<SgAsmCilPropertyMap*> SgAsmCilPropertyMapTable::*, &SgAsmCilPropertyMapTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilPropertyMapTable> {
  using node = SgAsmCilPropertyMapTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilPropertyMapTable"};
  static constexpr unsigned long variant{1033};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilPropertyMapTable,std::vector<SgAsmCilPropertyMap*>,&SgAsmCilPropertyMapTable::p_elements>>;
};
template <> struct node_from_variant_t<1033> { using type = SgAsmCilPropertyMapTable; };

// Class: AsmCilStandAloneSigTable
template <> struct describe_field_t<SgAsmCilStandAloneSigTable,std::vector<SgAsmCilStandAloneSig*>,&SgAsmCilStandAloneSigTable::p_elements> {
  using parent = SgAsmCilStandAloneSigTable;
  using field_type = std::vector<SgAsmCilStandAloneSig*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilStandAloneSig*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilStandAloneSigTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilStandAloneSigTable, std::vector<SgAsmCilStandAloneSig*> SgAsmCilStandAloneSigTable::*, &SgAsmCilStandAloneSigTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilStandAloneSigTable> {
  using node = SgAsmCilStandAloneSigTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilStandAloneSigTable"};
  static constexpr unsigned long variant{1034};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilStandAloneSigTable,std::vector<SgAsmCilStandAloneSig*>,&SgAsmCilStandAloneSigTable::p_elements>>;
};
template <> struct node_from_variant_t<1034> { using type = SgAsmCilStandAloneSigTable; };

// Class: AsmCilTypeDefTable
template <> struct describe_field_t<SgAsmCilTypeDefTable,std::vector<SgAsmCilTypeDef*>,&SgAsmCilTypeDefTable::p_elements> {
  using parent = SgAsmCilTypeDefTable;
  using field_type = std::vector<SgAsmCilTypeDef*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilTypeDef*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilTypeDefTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeDefTable, std::vector<SgAsmCilTypeDef*> SgAsmCilTypeDefTable::*, &SgAsmCilTypeDefTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilTypeDefTable> {
  using node = SgAsmCilTypeDefTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilTypeDefTable"};
  static constexpr unsigned long variant{1035};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilTypeDefTable,std::vector<SgAsmCilTypeDef*>,&SgAsmCilTypeDefTable::p_elements>>;
};
template <> struct node_from_variant_t<1035> { using type = SgAsmCilTypeDefTable; };

// Class: AsmCilTypeRefTable
template <> struct describe_field_t<SgAsmCilTypeRefTable,std::vector<SgAsmCilTypeRef*>,&SgAsmCilTypeRefTable::p_elements> {
  using parent = SgAsmCilTypeRefTable;
  using field_type = std::vector<SgAsmCilTypeRef*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilTypeRef*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilTypeRefTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeRefTable, std::vector<SgAsmCilTypeRef*> SgAsmCilTypeRefTable::*, &SgAsmCilTypeRefTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilTypeRefTable> {
  using node = SgAsmCilTypeRefTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilTypeRefTable"};
  static constexpr unsigned long variant{1036};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilTypeRefTable,std::vector<SgAsmCilTypeRef*>,&SgAsmCilTypeRefTable::p_elements>>;
};
template <> struct node_from_variant_t<1036> { using type = SgAsmCilTypeRefTable; };

// Class: AsmCilTypeSpecTable
template <> struct describe_field_t<SgAsmCilTypeSpecTable,std::vector<SgAsmCilTypeSpec*>,&SgAsmCilTypeSpecTable::p_elements> {
  using parent = SgAsmCilTypeSpecTable;
  using field_type = std::vector<SgAsmCilTypeSpec*>;
  static constexpr size_t position{0};
  static constexpr char const * const name{"elements"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilTypeSpec*>"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmCilTypeSpecTable::p_elements};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilTypeSpecTable, std::vector<SgAsmCilTypeSpec*> SgAsmCilTypeSpecTable::*, &SgAsmCilTypeSpecTable::p_elements>;
};
template <> struct describe_node_t<SgAsmCilTypeSpecTable> {
  using node = SgAsmCilTypeSpecTable;
  using base = SgAsmCilMetadata;
  static constexpr char const * const name{"AsmCilTypeSpecTable"};
  static constexpr unsigned long variant{1037};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilTypeSpecTable,std::vector<SgAsmCilTypeSpec*>,&SgAsmCilTypeSpecTable::p_elements>>;
};
template <> struct node_from_variant_t<1037> { using type = SgAsmCilTypeSpecTable; };

// Class: JvmComposite
template <> struct describe_node_t<SgJvmComposite> {
  using node = SgJvmComposite;
  using base = SgBinaryComposite;
  static constexpr char const * const name{"JvmComposite"};
  static constexpr unsigned long variant{1038};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<1038> { using type = SgJvmComposite; };

// Class: FortranContinueStmt
template <> struct describe_node_t<SgFortranContinueStmt> {
  using node = SgFortranContinueStmt;
  using base = SgStatement;
  static constexpr char const * const name{"FortranContinueStmt"};
  static constexpr unsigned long variant{1039};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<1039> { using type = SgFortranContinueStmt; };

// Class: AsmJvmStackMapTable
template <> struct describe_field_t<SgAsmJvmStackMapTable,SgAsmJvmStackMapFramePtrList,&SgAsmJvmStackMapTable::p_entries> {
  using parent = SgAsmJvmStackMapTable;
  using field_type = SgAsmJvmStackMapFramePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"entries"};
  static constexpr char const * const typestr{"SgAsmJvmStackMapFramePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmStackMapTable::p_entries};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmStackMapTable, SgAsmJvmStackMapFramePtrList SgAsmJvmStackMapTable::*, &SgAsmJvmStackMapTable::p_entries>;
};
template <> struct describe_node_t<SgAsmJvmStackMapTable> {
  using node = SgAsmJvmStackMapTable;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmStackMapTable"};
  static constexpr unsigned long variant{1040};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmStackMapTable,SgAsmJvmStackMapFramePtrList,&SgAsmJvmStackMapTable::p_entries>>;
};
template <> struct node_from_variant_t<1040> { using type = SgAsmJvmStackMapTable; };

// Class: AsmJvmStackMapFrame
template <> struct describe_field_t<SgAsmJvmStackMapFrame,SgAsmJvmStackMapVerificationTypePtrList,&SgAsmJvmStackMapFrame::p_stack> {
  using parent = SgAsmJvmStackMapFrame;
  using field_type = SgAsmJvmStackMapVerificationTypePtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"stack"};
  static constexpr char const * const typestr{"SgAsmJvmStackMapVerificationTypePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmStackMapFrame::p_stack};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmStackMapFrame, SgAsmJvmStackMapVerificationTypePtrList SgAsmJvmStackMapFrame::*, &SgAsmJvmStackMapFrame::p_stack>;
};
template <> struct describe_field_t<SgAsmJvmStackMapFrame,SgAsmJvmStackMapVerificationTypePtrList,&SgAsmJvmStackMapFrame::p_locals> {
  using parent = SgAsmJvmStackMapFrame;
  using field_type = SgAsmJvmStackMapVerificationTypePtrList;
  static constexpr size_t position{1};
  static constexpr char const * const name{"locals"};
  static constexpr char const * const typestr{"SgAsmJvmStackMapVerificationTypePtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmStackMapFrame::p_locals};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmStackMapFrame, SgAsmJvmStackMapVerificationTypePtrList SgAsmJvmStackMapFrame::*, &SgAsmJvmStackMapFrame::p_locals>;
};
template <> struct describe_field_t<SgAsmJvmStackMapFrame,uint8_t,&SgAsmJvmStackMapFrame::p_frame_type> {
  using parent = SgAsmJvmStackMapFrame;
  using field_type = uint8_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"frame_type"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmStackMapFrame::p_frame_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmStackMapFrame, uint8_t SgAsmJvmStackMapFrame::*, &SgAsmJvmStackMapFrame::p_frame_type>;
};
template <> struct describe_field_t<SgAsmJvmStackMapFrame,uint16_t,&SgAsmJvmStackMapFrame::p_offset_delta> {
  using parent = SgAsmJvmStackMapFrame;
  using field_type = uint16_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"offset_delta"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmStackMapFrame::p_offset_delta};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmStackMapFrame, uint16_t SgAsmJvmStackMapFrame::*, &SgAsmJvmStackMapFrame::p_offset_delta>;
};
template <> struct describe_node_t<SgAsmJvmStackMapFrame> {
  using node = SgAsmJvmStackMapFrame;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmStackMapFrame"};
  static constexpr unsigned long variant{1041};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmStackMapFrame,SgAsmJvmStackMapVerificationTypePtrList,&SgAsmJvmStackMapFrame::p_stack>, describe_field_t<SgAsmJvmStackMapFrame,SgAsmJvmStackMapVerificationTypePtrList,&SgAsmJvmStackMapFrame::p_locals>, describe_field_t<SgAsmJvmStackMapFrame,uint8_t,&SgAsmJvmStackMapFrame::p_frame_type>, describe_field_t<SgAsmJvmStackMapFrame,uint16_t,&SgAsmJvmStackMapFrame::p_offset_delta>>;
};
template <> struct node_from_variant_t<1041> { using type = SgAsmJvmStackMapFrame; };

// Class: AsmJvmStackMapVerificationType
template <> struct describe_field_t<SgAsmJvmStackMapVerificationType,uint8_t,&SgAsmJvmStackMapVerificationType::p_tag> {
  using parent = SgAsmJvmStackMapVerificationType;
  using field_type = uint8_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"tag"};
  static constexpr char const * const typestr{"uint8_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmStackMapVerificationType::p_tag};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmStackMapVerificationType, uint8_t SgAsmJvmStackMapVerificationType::*, &SgAsmJvmStackMapVerificationType::p_tag>;
};
template <> struct describe_field_t<SgAsmJvmStackMapVerificationType,uint16_t,&SgAsmJvmStackMapVerificationType::p_cpool_index> {
  using parent = SgAsmJvmStackMapVerificationType;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"cpool_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmStackMapVerificationType::p_cpool_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmStackMapVerificationType, uint16_t SgAsmJvmStackMapVerificationType::*, &SgAsmJvmStackMapVerificationType::p_cpool_index>;
};
template <> struct describe_field_t<SgAsmJvmStackMapVerificationType,uint16_t,&SgAsmJvmStackMapVerificationType::p_offset> {
  using parent = SgAsmJvmStackMapVerificationType;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"offset"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmStackMapVerificationType::p_offset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmStackMapVerificationType, uint16_t SgAsmJvmStackMapVerificationType::*, &SgAsmJvmStackMapVerificationType::p_offset>;
};
template <> struct describe_node_t<SgAsmJvmStackMapVerificationType> {
  using node = SgAsmJvmStackMapVerificationType;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmStackMapVerificationType"};
  static constexpr unsigned long variant{1042};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmStackMapVerificationType,uint8_t,&SgAsmJvmStackMapVerificationType::p_tag>, describe_field_t<SgAsmJvmStackMapVerificationType,uint16_t,&SgAsmJvmStackMapVerificationType::p_cpool_index>, describe_field_t<SgAsmJvmStackMapVerificationType,uint16_t,&SgAsmJvmStackMapVerificationType::p_offset>>;
};
template <> struct node_from_variant_t<1042> { using type = SgAsmJvmStackMapVerificationType; };

// Class: AsmJvmBootstrapMethod
template <> struct describe_field_t<SgAsmJvmBootstrapMethod,uint16_t,&SgAsmJvmBootstrapMethod::p_bootstrap_method_ref> {
  using parent = SgAsmJvmBootstrapMethod;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"bootstrap_method_ref"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmBootstrapMethod::p_bootstrap_method_ref};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmBootstrapMethod, uint16_t SgAsmJvmBootstrapMethod::*, &SgAsmJvmBootstrapMethod::p_bootstrap_method_ref>;
};
template <> struct describe_field_t<SgAsmJvmBootstrapMethod,SgUnsigned16List,&SgAsmJvmBootstrapMethod::p_bootstrap_arguments> {
  using parent = SgAsmJvmBootstrapMethod;
  using field_type = SgUnsigned16List;
  static constexpr size_t position{1};
  static constexpr char const * const name{"bootstrap_arguments"};
  static constexpr char const * const typestr{"SgUnsigned16List"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmBootstrapMethod::p_bootstrap_arguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmBootstrapMethod, SgUnsigned16List SgAsmJvmBootstrapMethod::*, &SgAsmJvmBootstrapMethod::p_bootstrap_arguments>;
};
template <> struct describe_node_t<SgAsmJvmBootstrapMethod> {
  using node = SgAsmJvmBootstrapMethod;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmBootstrapMethod"};
  static constexpr unsigned long variant{1043};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmBootstrapMethod,uint16_t,&SgAsmJvmBootstrapMethod::p_bootstrap_method_ref>, describe_field_t<SgAsmJvmBootstrapMethod,SgUnsigned16List,&SgAsmJvmBootstrapMethod::p_bootstrap_arguments>>;
};
template <> struct node_from_variant_t<1043> { using type = SgAsmJvmBootstrapMethod; };

// Class: AsmJvmBootstrapMethods
template <> struct describe_field_t<SgAsmJvmBootstrapMethods,SgAsmJvmBootstrapMethodPtrList,&SgAsmJvmBootstrapMethods::p_bootstrap_methods> {
  using parent = SgAsmJvmBootstrapMethods;
  using field_type = SgAsmJvmBootstrapMethodPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"bootstrap_methods"};
  static constexpr char const * const typestr{"SgAsmJvmBootstrapMethodPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmBootstrapMethods::p_bootstrap_methods};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmBootstrapMethods, SgAsmJvmBootstrapMethodPtrList SgAsmJvmBootstrapMethods::*, &SgAsmJvmBootstrapMethods::p_bootstrap_methods>;
};
template <> struct describe_node_t<SgAsmJvmBootstrapMethods> {
  using node = SgAsmJvmBootstrapMethods;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmBootstrapMethods"};
  static constexpr unsigned long variant{1044};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmBootstrapMethods,SgAsmJvmBootstrapMethodPtrList,&SgAsmJvmBootstrapMethods::p_bootstrap_methods>>;
};
template <> struct node_from_variant_t<1044> { using type = SgAsmJvmBootstrapMethods; };

// Class: AsmJvmExceptions
template <> struct describe_field_t<SgAsmJvmExceptions,SgUnsigned16List,&SgAsmJvmExceptions::p_exception_index_table> {
  using parent = SgAsmJvmExceptions;
  using field_type = SgUnsigned16List;
  static constexpr size_t position{0};
  static constexpr char const * const name{"exception_index_table"};
  static constexpr char const * const typestr{"SgUnsigned16List"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmExceptions::p_exception_index_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmExceptions, SgUnsigned16List SgAsmJvmExceptions::*, &SgAsmJvmExceptions::p_exception_index_table>;
};
template <> struct describe_node_t<SgAsmJvmExceptions> {
  using node = SgAsmJvmExceptions;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmExceptions"};
  static constexpr unsigned long variant{1045};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmExceptions,SgUnsigned16List,&SgAsmJvmExceptions::p_exception_index_table>>;
};
template <> struct node_from_variant_t<1045> { using type = SgAsmJvmExceptions; };

// Class: AsmJvmNestMembers
template <> struct describe_field_t<SgAsmJvmNestMembers,SgUnsigned16List,&SgAsmJvmNestMembers::p_classes> {
  using parent = SgAsmJvmNestMembers;
  using field_type = SgUnsigned16List;
  static constexpr size_t position{0};
  static constexpr char const * const name{"classes"};
  static constexpr char const * const typestr{"SgUnsigned16List"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmNestMembers::p_classes};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmNestMembers, SgUnsigned16List SgAsmJvmNestMembers::*, &SgAsmJvmNestMembers::p_classes>;
};
template <> struct describe_node_t<SgAsmJvmNestMembers> {
  using node = SgAsmJvmNestMembers;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmNestMembers"};
  static constexpr unsigned long variant{1046};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmNestMembers,SgUnsigned16List,&SgAsmJvmNestMembers::p_classes>>;
};
template <> struct node_from_variant_t<1046> { using type = SgAsmJvmNestMembers; };

// Class: AsmJvmNestHost
template <> struct describe_field_t<SgAsmJvmNestHost,uint16_t,&SgAsmJvmNestHost::p_host_class_index> {
  using parent = SgAsmJvmNestHost;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"host_class_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmNestHost::p_host_class_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmNestHost, uint16_t SgAsmJvmNestHost::*, &SgAsmJvmNestHost::p_host_class_index>;
};
template <> struct describe_node_t<SgAsmJvmNestHost> {
  using node = SgAsmJvmNestHost;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmNestHost"};
  static constexpr unsigned long variant{1047};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmNestHost,uint16_t,&SgAsmJvmNestHost::p_host_class_index>>;
};
template <> struct node_from_variant_t<1047> { using type = SgAsmJvmNestHost; };

// Class: JovialLabelDeclaration
template <> struct describe_field_t<SgJovialLabelDeclaration,std::string,&SgJovialLabelDeclaration::p_label> {
  using parent = SgJovialLabelDeclaration;
  using field_type = std::string;
  static constexpr size_t position{0};
  static constexpr char const * const name{"label"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialLabelDeclaration::p_label};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialLabelDeclaration, std::string SgJovialLabelDeclaration::*, &SgJovialLabelDeclaration::p_label>;
};
template <> struct describe_field_t<SgJovialLabelDeclaration,SgJovialLabelDeclaration::label_type_enum,&SgJovialLabelDeclaration::p_label_type> {
  using parent = SgJovialLabelDeclaration;
  using field_type = SgJovialLabelDeclaration::label_type_enum;
  static constexpr size_t position{1};
  static constexpr char const * const name{"label_type"};
  static constexpr char const * const typestr{"SgJovialLabelDeclaration::label_type_enum"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgJovialLabelDeclaration::p_label_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgJovialLabelDeclaration, SgJovialLabelDeclaration::label_type_enum SgJovialLabelDeclaration::*, &SgJovialLabelDeclaration::p_label_type>;
};
template <> struct describe_node_t<SgJovialLabelDeclaration> {
  using node = SgJovialLabelDeclaration;
  using base = SgDeclarationStatement;
  static constexpr char const * const name{"JovialLabelDeclaration"};
  static constexpr unsigned long variant{1048};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgJovialLabelDeclaration,std::string,&SgJovialLabelDeclaration::p_label>, describe_field_t<SgJovialLabelDeclaration,SgJovialLabelDeclaration::label_type_enum,&SgJovialLabelDeclaration::p_label_type>>;
};
template <> struct node_from_variant_t<1048> { using type = SgJovialLabelDeclaration; };

// Class: AsmJvmLocalVariableEntry
template <> struct describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_start_pc> {
  using parent = SgAsmJvmLocalVariableEntry;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"start_pc"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableEntry::p_start_pc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableEntry, uint16_t SgAsmJvmLocalVariableEntry::*, &SgAsmJvmLocalVariableEntry::p_start_pc>;
};
template <> struct describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_length> {
  using parent = SgAsmJvmLocalVariableEntry;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"length"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableEntry::p_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableEntry, uint16_t SgAsmJvmLocalVariableEntry::*, &SgAsmJvmLocalVariableEntry::p_length>;
};
template <> struct describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_name_index> {
  using parent = SgAsmJvmLocalVariableEntry;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableEntry::p_name_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableEntry, uint16_t SgAsmJvmLocalVariableEntry::*, &SgAsmJvmLocalVariableEntry::p_name_index>;
};
template <> struct describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_descriptor_index> {
  using parent = SgAsmJvmLocalVariableEntry;
  using field_type = uint16_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"descriptor_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableEntry::p_descriptor_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableEntry, uint16_t SgAsmJvmLocalVariableEntry::*, &SgAsmJvmLocalVariableEntry::p_descriptor_index>;
};
template <> struct describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_index> {
  using parent = SgAsmJvmLocalVariableEntry;
  using field_type = uint16_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableEntry::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableEntry, uint16_t SgAsmJvmLocalVariableEntry::*, &SgAsmJvmLocalVariableEntry::p_index>;
};
template <> struct describe_node_t<SgAsmJvmLocalVariableEntry> {
  using node = SgAsmJvmLocalVariableEntry;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmLocalVariableEntry"};
  static constexpr unsigned long variant{1049};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_start_pc>, describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_length>, describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_name_index>, describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_descriptor_index>, describe_field_t<SgAsmJvmLocalVariableEntry,uint16_t,&SgAsmJvmLocalVariableEntry::p_index>>;
};
template <> struct node_from_variant_t<1049> { using type = SgAsmJvmLocalVariableEntry; };

// Class: AsmJvmLocalVariableTable
template <> struct describe_field_t<SgAsmJvmLocalVariableTable,SgAsmJvmLocalVariableEntryPtrList,&SgAsmJvmLocalVariableTable::p_local_variable_table> {
  using parent = SgAsmJvmLocalVariableTable;
  using field_type = SgAsmJvmLocalVariableEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"local_variable_table"};
  static constexpr char const * const typestr{"SgAsmJvmLocalVariableEntryPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableTable::p_local_variable_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableTable, SgAsmJvmLocalVariableEntryPtrList SgAsmJvmLocalVariableTable::*, &SgAsmJvmLocalVariableTable::p_local_variable_table>;
};
template <> struct describe_node_t<SgAsmJvmLocalVariableTable> {
  using node = SgAsmJvmLocalVariableTable;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmLocalVariableTable"};
  static constexpr unsigned long variant{1050};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmLocalVariableTable,SgAsmJvmLocalVariableEntryPtrList,&SgAsmJvmLocalVariableTable::p_local_variable_table>>;
};
template <> struct node_from_variant_t<1050> { using type = SgAsmJvmLocalVariableTable; };

// Class: AsmJvmLocalVariableTypeEntry
template <> struct describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_start_pc> {
  using parent = SgAsmJvmLocalVariableTypeEntry;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"start_pc"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableTypeEntry::p_start_pc};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableTypeEntry, uint16_t SgAsmJvmLocalVariableTypeEntry::*, &SgAsmJvmLocalVariableTypeEntry::p_start_pc>;
};
template <> struct describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_length> {
  using parent = SgAsmJvmLocalVariableTypeEntry;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"length"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableTypeEntry::p_length};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableTypeEntry, uint16_t SgAsmJvmLocalVariableTypeEntry::*, &SgAsmJvmLocalVariableTypeEntry::p_length>;
};
template <> struct describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_name_index> {
  using parent = SgAsmJvmLocalVariableTypeEntry;
  using field_type = uint16_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"name_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableTypeEntry::p_name_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableTypeEntry, uint16_t SgAsmJvmLocalVariableTypeEntry::*, &SgAsmJvmLocalVariableTypeEntry::p_name_index>;
};
template <> struct describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_signature_index> {
  using parent = SgAsmJvmLocalVariableTypeEntry;
  using field_type = uint16_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"signature_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableTypeEntry::p_signature_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableTypeEntry, uint16_t SgAsmJvmLocalVariableTypeEntry::*, &SgAsmJvmLocalVariableTypeEntry::p_signature_index>;
};
template <> struct describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_index> {
  using parent = SgAsmJvmLocalVariableTypeEntry;
  using field_type = uint16_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableTypeEntry::p_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableTypeEntry, uint16_t SgAsmJvmLocalVariableTypeEntry::*, &SgAsmJvmLocalVariableTypeEntry::p_index>;
};
template <> struct describe_node_t<SgAsmJvmLocalVariableTypeEntry> {
  using node = SgAsmJvmLocalVariableTypeEntry;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmLocalVariableTypeEntry"};
  static constexpr unsigned long variant{1051};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_start_pc>, describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_length>, describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_name_index>, describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_signature_index>, describe_field_t<SgAsmJvmLocalVariableTypeEntry,uint16_t,&SgAsmJvmLocalVariableTypeEntry::p_index>>;
};
template <> struct node_from_variant_t<1051> { using type = SgAsmJvmLocalVariableTypeEntry; };

// Class: AsmJvmLocalVariableTypeTable
template <> struct describe_field_t<SgAsmJvmLocalVariableTypeTable,SgAsmJvmLocalVariableTypeEntryPtrList,&SgAsmJvmLocalVariableTypeTable::p_local_variable_type_table> {
  using parent = SgAsmJvmLocalVariableTypeTable;
  using field_type = SgAsmJvmLocalVariableTypeEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"local_variable_type_table"};
  static constexpr char const * const typestr{"SgAsmJvmLocalVariableTypeEntryPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmLocalVariableTypeTable::p_local_variable_type_table};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmLocalVariableTypeTable, SgAsmJvmLocalVariableTypeEntryPtrList SgAsmJvmLocalVariableTypeTable::*, &SgAsmJvmLocalVariableTypeTable::p_local_variable_type_table>;
};
template <> struct describe_node_t<SgAsmJvmLocalVariableTypeTable> {
  using node = SgAsmJvmLocalVariableTypeTable;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmLocalVariableTypeTable"};
  static constexpr unsigned long variant{1052};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmLocalVariableTypeTable,SgAsmJvmLocalVariableTypeEntryPtrList,&SgAsmJvmLocalVariableTypeTable::p_local_variable_type_table>>;
};
template <> struct node_from_variant_t<1052> { using type = SgAsmJvmLocalVariableTypeTable; };

// Class: AsmUserInstruction
template <> struct describe_field_t<SgAsmUserInstruction,unsigned,&SgAsmUserInstruction::p_kind> {
  using parent = SgAsmUserInstruction;
  using field_type = unsigned;
  static constexpr size_t position{0};
  static constexpr char const * const name{"kind"};
  static constexpr char const * const typestr{"unsigned"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmUserInstruction::p_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmUserInstruction, unsigned SgAsmUserInstruction::*, &SgAsmUserInstruction::p_kind>;
};
template <> struct describe_node_t<SgAsmUserInstruction> {
  using node = SgAsmUserInstruction;
  using base = SgAsmInstruction;
  static constexpr char const * const name{"AsmUserInstruction"};
  static constexpr unsigned long variant{1053};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmUserInstruction,unsigned,&SgAsmUserInstruction::p_kind>>;
};
template <> struct node_from_variant_t<1053> { using type = SgAsmUserInstruction; };

// Class: AsmJvmMethodParameters
template <> struct describe_field_t<SgAsmJvmMethodParameters,SgAsmJvmMethodParametersEntryPtrList,&SgAsmJvmMethodParameters::p_parameters> {
  using parent = SgAsmJvmMethodParameters;
  using field_type = SgAsmJvmMethodParametersEntryPtrList;
  static constexpr size_t position{0};
  static constexpr char const * const name{"parameters"};
  static constexpr char const * const typestr{"SgAsmJvmMethodParametersEntryPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmMethodParameters::p_parameters};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmMethodParameters, SgAsmJvmMethodParametersEntryPtrList SgAsmJvmMethodParameters::*, &SgAsmJvmMethodParameters::p_parameters>;
};
template <> struct describe_node_t<SgAsmJvmMethodParameters> {
  using node = SgAsmJvmMethodParameters;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmMethodParameters"};
  static constexpr unsigned long variant{1054};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmMethodParameters,SgAsmJvmMethodParametersEntryPtrList,&SgAsmJvmMethodParameters::p_parameters>>;
};
template <> struct node_from_variant_t<1054> { using type = SgAsmJvmMethodParameters; };

// Class: AsmJvmMethodParametersEntry
template <> struct describe_field_t<SgAsmJvmMethodParametersEntry,uint16_t,&SgAsmJvmMethodParametersEntry::p_name_index> {
  using parent = SgAsmJvmMethodParametersEntry;
  using field_type = uint16_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"name_index"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmMethodParametersEntry::p_name_index};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmMethodParametersEntry, uint16_t SgAsmJvmMethodParametersEntry::*, &SgAsmJvmMethodParametersEntry::p_name_index>;
};
template <> struct describe_field_t<SgAsmJvmMethodParametersEntry,uint16_t,&SgAsmJvmMethodParametersEntry::p_access_flags> {
  using parent = SgAsmJvmMethodParametersEntry;
  using field_type = uint16_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"access_flags"};
  static constexpr char const * const typestr{"uint16_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmJvmMethodParametersEntry::p_access_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmJvmMethodParametersEntry, uint16_t SgAsmJvmMethodParametersEntry::*, &SgAsmJvmMethodParametersEntry::p_access_flags>;
};
template <> struct describe_node_t<SgAsmJvmMethodParametersEntry> {
  using node = SgAsmJvmMethodParametersEntry;
  using base = SgAsmJvmNode;
  static constexpr char const * const name{"AsmJvmMethodParametersEntry"};
  static constexpr unsigned long variant{1055};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmJvmMethodParametersEntry,uint16_t,&SgAsmJvmMethodParametersEntry::p_name_index>, describe_field_t<SgAsmJvmMethodParametersEntry,uint16_t,&SgAsmJvmMethodParametersEntry::p_access_flags>>;
};
template <> struct node_from_variant_t<1055> { using type = SgAsmJvmMethodParametersEntry; };

// Class: AsmVoidType
template <> struct describe_node_t<SgAsmVoidType> {
  using node = SgAsmVoidType;
  using base = SgAsmType;
  static constexpr char const * const name{"AsmVoidType"};
  static constexpr unsigned long variant{1056};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<1056> { using type = SgAsmVoidType; };

// Class: AsmPointerType
template <> struct describe_field_t<SgAsmPointerType,SgAsmType *,&SgAsmPointerType::p_subtype> {
  using parent = SgAsmPointerType;
  using field_type = SgAsmType *;
  static constexpr size_t position{0};
  static constexpr char const * const name{"subtype"};
  static constexpr char const * const typestr{"SgAsmType *"};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgAsmPointerType::p_subtype};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmPointerType, SgAsmType * SgAsmPointerType::*, &SgAsmPointerType::p_subtype>;
};
template <> struct describe_node_t<SgAsmPointerType> {
  using node = SgAsmPointerType;
  using base = SgAsmScalarType;
  static constexpr char const * const name{"AsmPointerType"};
  static constexpr unsigned long variant{1057};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmPointerType,SgAsmType *,&SgAsmPointerType::p_subtype>>;
};
template <> struct node_from_variant_t<1057> { using type = SgAsmPointerType; };

// Class: RangeType
template <> struct describe_field_t<SgRangeType,SgType*,&SgRangeType::p_base_type> {
  using parent = SgRangeType;
  using field_type = SgType*;
  static constexpr size_t position{0};
  static constexpr char const * const name{"base_type"};
  static constexpr char const * const typestr{"SgType*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgRangeType::p_base_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgRangeType, SgType* SgRangeType::*, &SgRangeType::p_base_type>;
};
template <> struct describe_node_t<SgRangeType> {
  using node = SgRangeType;
  using base = SgType;
  static constexpr char const * const name{"RangeType"};
  static constexpr unsigned long variant{1059};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgRangeType,SgType*,&SgRangeType::p_base_type>>;
};
template <> struct node_from_variant_t<1059> { using type = SgRangeType; };

// Class: AsmCilExceptionData
template <> struct describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_flags> {
  using parent = SgAsmCilExceptionData;
  using field_type = std::uint32_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"flags"};
  static constexpr char const * const typestr{"std::uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExceptionData::p_flags};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExceptionData, std::uint32_t SgAsmCilExceptionData::*, &SgAsmCilExceptionData::p_flags>;
};
template <> struct describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_tryOffset> {
  using parent = SgAsmCilExceptionData;
  using field_type = std::uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"tryOffset"};
  static constexpr char const * const typestr{"std::uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExceptionData::p_tryOffset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExceptionData, std::uint32_t SgAsmCilExceptionData::*, &SgAsmCilExceptionData::p_tryOffset>;
};
template <> struct describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_tryLength> {
  using parent = SgAsmCilExceptionData;
  using field_type = std::uint32_t;
  static constexpr size_t position{2};
  static constexpr char const * const name{"tryLength"};
  static constexpr char const * const typestr{"std::uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExceptionData::p_tryLength};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExceptionData, std::uint32_t SgAsmCilExceptionData::*, &SgAsmCilExceptionData::p_tryLength>;
};
template <> struct describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_handlerOffset> {
  using parent = SgAsmCilExceptionData;
  using field_type = std::uint32_t;
  static constexpr size_t position{3};
  static constexpr char const * const name{"handlerOffset"};
  static constexpr char const * const typestr{"std::uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExceptionData::p_handlerOffset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExceptionData, std::uint32_t SgAsmCilExceptionData::*, &SgAsmCilExceptionData::p_handlerOffset>;
};
template <> struct describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_handlerLength> {
  using parent = SgAsmCilExceptionData;
  using field_type = std::uint32_t;
  static constexpr size_t position{4};
  static constexpr char const * const name{"handlerLength"};
  static constexpr char const * const typestr{"std::uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExceptionData::p_handlerLength};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExceptionData, std::uint32_t SgAsmCilExceptionData::*, &SgAsmCilExceptionData::p_handlerLength>;
};
template <> struct describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_classTokenOrFilterOffset> {
  using parent = SgAsmCilExceptionData;
  using field_type = std::uint32_t;
  static constexpr size_t position{5};
  static constexpr char const * const name{"classTokenOrFilterOffset"};
  static constexpr char const * const typestr{"std::uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilExceptionData::p_classTokenOrFilterOffset};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilExceptionData, std::uint32_t SgAsmCilExceptionData::*, &SgAsmCilExceptionData::p_classTokenOrFilterOffset>;
};
template <> struct describe_node_t<SgAsmCilExceptionData> {
  using node = SgAsmCilExceptionData;
  using base = SgAsmCilNode;
  static constexpr char const * const name{"AsmCilExceptionData"};
  static constexpr unsigned long variant{1060};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_flags>, describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_tryOffset>, describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_tryLength>, describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_handlerOffset>, describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_handlerLength>, describe_field_t<SgAsmCilExceptionData,std::uint32_t,&SgAsmCilExceptionData::p_classTokenOrFilterOffset>>;
};
template <> struct node_from_variant_t<1060> { using type = SgAsmCilExceptionData; };

// Class: AsmCilMethodData
template <> struct describe_field_t<SgAsmCilMethodData,uint64_t,&SgAsmCilMethodData::p_kind> {
  using parent = SgAsmCilMethodData;
  using field_type = uint64_t;
  static constexpr size_t position{0};
  static constexpr char const * const name{"kind"};
  static constexpr char const * const typestr{"uint64_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodData::p_kind};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodData, uint64_t SgAsmCilMethodData::*, &SgAsmCilMethodData::p_kind>;
};
template <> struct describe_field_t<SgAsmCilMethodData,std::uint32_t,&SgAsmCilMethodData::p_dataSize> {
  using parent = SgAsmCilMethodData;
  using field_type = std::uint32_t;
  static constexpr size_t position{1};
  static constexpr char const * const name{"dataSize"};
  static constexpr char const * const typestr{"std::uint32_t"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodData::p_dataSize};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodData, std::uint32_t SgAsmCilMethodData::*, &SgAsmCilMethodData::p_dataSize>;
};
template <> struct describe_field_t<SgAsmCilMethodData,std::vector<SgAsmCilExceptionData*>,&SgAsmCilMethodData::p_clauses> {
  using parent = SgAsmCilMethodData;
  using field_type = std::vector<SgAsmCilExceptionData*>;
  static constexpr size_t position{2};
  static constexpr char const * const name{"clauses"};
  static constexpr char const * const typestr{"std::vector<SgAsmCilExceptionData*>"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgAsmCilMethodData::p_clauses};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgAsmCilMethodData, std::vector<SgAsmCilExceptionData*> SgAsmCilMethodData::*, &SgAsmCilMethodData::p_clauses>;
};
template <> struct describe_node_t<SgAsmCilMethodData> {
  using node = SgAsmCilMethodData;
  using base = SgAsmCilNode;
  static constexpr char const * const name{"AsmCilMethodData"};
  static constexpr unsigned long variant{1061};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgAsmCilMethodData,uint64_t,&SgAsmCilMethodData::p_kind>, describe_field_t<SgAsmCilMethodData,std::uint32_t,&SgAsmCilMethodData::p_dataSize>, describe_field_t<SgAsmCilMethodData,std::vector<SgAsmCilExceptionData*>,&SgAsmCilMethodData::p_clauses>>;
};
template <> struct node_from_variant_t<1061> { using type = SgAsmCilMethodData; };

// Class: TemplateVariableInstantiation
template <> struct describe_field_t<SgTemplateVariableInstantiation,SgName,&SgTemplateVariableInstantiation::p_templateName> {
  using parent = SgTemplateVariableInstantiation;
  using field_type = SgName;
  static constexpr size_t position{0};
  static constexpr char const * const name{"templateName"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateVariableInstantiation::p_templateName};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateVariableInstantiation, SgName SgTemplateVariableInstantiation::*, &SgTemplateVariableInstantiation::p_templateName>;
};
template <> struct describe_field_t<SgTemplateVariableInstantiation,SgName,&SgTemplateVariableInstantiation::p_templateHeader> {
  using parent = SgTemplateVariableInstantiation;
  using field_type = SgName;
  static constexpr size_t position{1};
  static constexpr char const * const name{"templateHeader"};
  static constexpr char const * const typestr{"SgName"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateVariableInstantiation::p_templateHeader};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateVariableInstantiation, SgName SgTemplateVariableInstantiation::*, &SgTemplateVariableInstantiation::p_templateHeader>;
};
template <> struct describe_field_t<SgTemplateVariableInstantiation,SgTemplateVariableDeclaration*,&SgTemplateVariableInstantiation::p_templateDeclaration> {
  using parent = SgTemplateVariableInstantiation;
  using field_type = SgTemplateVariableDeclaration*;
  static constexpr size_t position{2};
  static constexpr char const * const name{"templateDeclaration"};
  static constexpr char const * const typestr{"SgTemplateVariableDeclaration*"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateVariableInstantiation::p_templateDeclaration};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateVariableInstantiation, SgTemplateVariableDeclaration* SgTemplateVariableInstantiation::*, &SgTemplateVariableInstantiation::p_templateDeclaration>;
};
template <> struct describe_field_t<SgTemplateVariableInstantiation,SgTemplateArgumentPtrList,&SgTemplateVariableInstantiation::p_templateArguments> {
  using parent = SgTemplateVariableInstantiation;
  using field_type = SgTemplateArgumentPtrList;
  static constexpr size_t position{3};
  static constexpr char const * const name{"templateArguments"};
  static constexpr char const * const typestr{"SgTemplateArgumentPtrList"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTemplateVariableInstantiation::p_templateArguments};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTemplateVariableInstantiation, SgTemplateArgumentPtrList SgTemplateVariableInstantiation::*, &SgTemplateVariableInstantiation::p_templateArguments>;
};
template <> struct describe_node_t<SgTemplateVariableInstantiation> {
  using node = SgTemplateVariableInstantiation;
  using base = SgVariableDeclaration;
  static constexpr char const * const name{"TemplateVariableInstantiation"};
  static constexpr unsigned long variant{1062};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTemplateVariableInstantiation,SgName,&SgTemplateVariableInstantiation::p_templateName>, describe_field_t<SgTemplateVariableInstantiation,SgName,&SgTemplateVariableInstantiation::p_templateHeader>, describe_field_t<SgTemplateVariableInstantiation,SgTemplateVariableDeclaration*,&SgTemplateVariableInstantiation::p_templateDeclaration>, describe_field_t<SgTemplateVariableInstantiation,SgTemplateArgumentPtrList,&SgTemplateVariableInstantiation::p_templateArguments>>;
};
template <> struct node_from_variant_t<1062> { using type = SgTemplateVariableInstantiation; };

// Class: ReferenceExp
template <> struct describe_node_t<SgReferenceExp> {
  using node = SgReferenceExp;
  using base = SgExpression;
  static constexpr char const * const name{"ReferenceExp"};
  static constexpr unsigned long variant{1063};
  static constexpr bool concrete{false};
  using subclasses_t = mp::List<SgVarRefExp, SgLabelRefExp, SgClassNameRefExp, SgNonrealRefExp, SgScopedRefExp, SgTypeRefExp, SgFunctionRefExp, SgMemberFunctionRefExp, SgTemplateFunctionRefExp, SgTemplateMemberFunctionRefExp>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<1063> { using type = SgReferenceExp; };

// Class: TypeRefExp
template <> struct describe_field_t<SgTypeRefExp,SgNamedType * ,&SgTypeRefExp::p_named_type> {
  using parent = SgTypeRefExp;
  using field_type = SgNamedType * ;
  static constexpr size_t position{0};
  static constexpr char const * const name{"named_type"};
  static constexpr char const * const typestr{"SgNamedType * "};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgTypeRefExp::p_named_type};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgTypeRefExp, SgNamedType *  SgTypeRefExp::*, &SgTypeRefExp::p_named_type>;
};
template <> struct describe_node_t<SgTypeRefExp> {
  using node = SgTypeRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"TypeRefExp"};
  static constexpr unsigned long variant{1064};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgTypeRefExp,SgNamedType * ,&SgTypeRefExp::p_named_type>>;
};
template <> struct node_from_variant_t<1064> { using type = SgTypeRefExp; };

// Class: ScopedRefExp
template <> struct describe_field_t<SgScopedRefExp,SgReferenceExp * ,&SgScopedRefExp::p_lhs> {
  using parent = SgScopedRefExp;
  using field_type = SgReferenceExp * ;
  static constexpr size_t position{0};
  static constexpr char const * const name{"lhs"};
  static constexpr char const * const typestr{"SgReferenceExp * "};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgScopedRefExp::p_lhs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgScopedRefExp, SgReferenceExp *  SgScopedRefExp::*, &SgScopedRefExp::p_lhs>;
};
template <> struct describe_field_t<SgScopedRefExp,SgReferenceExp * ,&SgScopedRefExp::p_rhs> {
  using parent = SgScopedRefExp;
  using field_type = SgReferenceExp * ;
  static constexpr size_t position{1};
  static constexpr char const * const name{"rhs"};
  static constexpr char const * const typestr{"SgReferenceExp * "};
  static constexpr bool traverse{true};
  static constexpr auto mbr_ptr{&SgScopedRefExp::p_rhs};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgScopedRefExp, SgReferenceExp *  SgScopedRefExp::*, &SgScopedRefExp::p_rhs>;
};
template <> struct describe_node_t<SgScopedRefExp> {
  using node = SgScopedRefExp;
  using base = SgReferenceExp;
  static constexpr char const * const name{"ScopedRefExp"};
  static constexpr unsigned long variant{1065};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgScopedRefExp,SgReferenceExp * ,&SgScopedRefExp::p_lhs>, describe_field_t<SgScopedRefExp,SgReferenceExp * ,&SgScopedRefExp::p_rhs>>;
};
template <> struct node_from_variant_t<1065> { using type = SgScopedRefExp; };

// Class: ScopedType
template <> struct describe_node_t<SgScopedType> {
  using node = SgScopedType;
  using base = SgNamedType;
  static constexpr char const * const name{"ScopedType"};
  static constexpr unsigned long variant{1066};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<1066> { using type = SgScopedType; };

// Class: TypeSymbol
template <> struct describe_node_t<SgTypeSymbol> {
  using node = SgTypeSymbol;
  using base = SgSymbol;
  static constexpr char const * const name{"TypeSymbol"};
  static constexpr unsigned long variant{1067};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<SgClassSymbol, SgTypedefSymbol, SgEnumSymbol>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<1067> { using type = SgTypeSymbol; };

// Class: AsmJvmSynthetic
template <> struct describe_node_t<SgAsmJvmSynthetic> {
  using node = SgAsmJvmSynthetic;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmSynthetic"};
  static constexpr unsigned long variant{1068};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<1068> { using type = SgAsmJvmSynthetic; };

// Class: AsmJvmDeprecated
template <> struct describe_node_t<SgAsmJvmDeprecated> {
  using node = SgAsmJvmDeprecated;
  using base = SgAsmJvmAttribute;
  static constexpr char const * const name{"AsmJvmDeprecated"};
  static constexpr unsigned long variant{1069};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<1069> { using type = SgAsmJvmDeprecated; };

// Class: SignedCharVal
template <> struct describe_field_t<SgSignedCharVal,signed char,&SgSignedCharVal::p_value> {
  using parent = SgSignedCharVal;
  using field_type = signed char;
  static constexpr size_t position{0};
  static constexpr char const * const name{"value"};
  static constexpr char const * const typestr{"signed char"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSignedCharVal::p_value};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSignedCharVal, signed char SgSignedCharVal::*, &SgSignedCharVal::p_value>;
};
template <> struct describe_field_t<SgSignedCharVal,std::string,&SgSignedCharVal::p_valueString> {
  using parent = SgSignedCharVal;
  using field_type = std::string;
  static constexpr size_t position{1};
  static constexpr char const * const name{"valueString"};
  static constexpr char const * const typestr{"std::string"};
  static constexpr bool traverse{false};
  static constexpr auto mbr_ptr{&SgSignedCharVal::p_valueString};
  template <template <typename NodeT, typename FieldT, FieldT fld_ptr> class Desc>
  using bind = Desc<SgSignedCharVal, std::string SgSignedCharVal::*, &SgSignedCharVal::p_valueString>;
};
template <> struct describe_node_t<SgSignedCharVal> {
  using node = SgSignedCharVal;
  using base = SgValueExp;
  static constexpr char const * const name{"SignedCharVal"};
  static constexpr unsigned long variant{1070};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<describe_field_t<SgSignedCharVal,signed char,&SgSignedCharVal::p_value>, describe_field_t<SgSignedCharVal,std::string,&SgSignedCharVal::p_valueString>>;
};
template <> struct node_from_variant_t<1070> { using type = SgSignedCharVal; };

// Class: AsmCilErrorHeap
template <> struct describe_node_t<SgAsmCilErrorHeap> {
  using node = SgAsmCilErrorHeap;
  using base = SgAsmCilDataStream;
  static constexpr char const * const name{"AsmCilErrorHeap"};
  static constexpr unsigned long variant{1071};
  static constexpr bool concrete{true};
  using subclasses_t = mp::List<>;
  using fields_t = mp::List<>;
};
template <> struct node_from_variant_t<1071> { using type = SgAsmCilErrorHeap; };

} } }
#endif /* Rose_Traits_generated_h */
